@Test public void testReplicasCheckForLedgersFoundHavingLessThanWQReplicasOfAnEntry() throws Exception {
  int numOfBookies=5;
  RegistrationManager regManager=driver.getRegistrationManager();
  MultiKeyMap<String,AvailabilityOfEntriesOfLedger> returnAvailabilityOfEntriesOfLedger=new MultiKeyMap<String,AvailabilityOfEntriesOfLedger>();
  MultiKeyMap<String,Integer> errorReturnValueForGetAvailabilityOfEntriesOfLedger=new MultiKeyMap<String,Integer>();
  List<BookieId> bookieAddresses=addAndRegisterBookies(regManager,numOfBookies);
  LedgerManagerFactory mFactory=driver.getLedgerManagerFactory();
  LedgerManager lm=mFactory.newLedgerManager();
  DigestType digestType=DigestType.DUMMY;
  byte[] password=new byte[0];
  Collections.shuffle(bookieAddresses);
  int numLedgersFoundHavingLessThanWQReplicasOfAnEntry=0;
  Map<Long,List<BookieId>> segmentEnsembles=new HashMap<Long,List<BookieId>>();
  int ensembleSize=4;
  int writeQuorumSize=3;
  int ackQuorumSize=2;
  long lastEntryId=3;
  int length=10000;
  segmentEnsembles.put(0L,bookieAddresses.subList(0,4));
  long ledgerId=1L;
  createClosedLedgerMetadata(lm,ledgerId,ensembleSize,writeQuorumSize,ackQuorumSize,segmentEnsembles,lastEntryId,length,digestType,password);
  returnAvailabilityOfEntriesOfLedger.put(bookieAddresses.get(0).toString(),Long.toString(ledgerId),new AvailabilityOfEntriesOfLedger(new long[]{0,2}));
  returnAvailabilityOfEntriesOfLedger.put(bookieAddresses.get(1).toString(),Long.toString(ledgerId),new AvailabilityOfEntriesOfLedger(new long[]{0,1,3}));
  returnAvailabilityOfEntriesOfLedger.put(bookieAddresses.get(2).toString(),Long.toString(ledgerId),new AvailabilityOfEntriesOfLedger(new long[]{0,1}));
  returnAvailabilityOfEntriesOfLedger.put(bookieAddresses.get(3).toString(),Long.toString(ledgerId),new AvailabilityOfEntriesOfLedger(new long[]{1,2,3}));
  numLedgersFoundHavingLessThanWQReplicasOfAnEntry++;
  segmentEnsembles.clear();
  segmentEnsembles.put(0L,bookieAddresses.subList(0,4));
  segmentEnsembles.put(2L,bookieAddresses.subList(1,5));
  ledgerId=2L;
  createClosedLedgerMetadata(lm,ledgerId,ensembleSize,writeQuorumSize,ackQuorumSize,segmentEnsembles,lastEntryId,length,digestType,password);
  returnAvailabilityOfEntriesOfLedger.put(bookieAddresses.get(0).toString(),Long.toString(ledgerId),new AvailabilityOfEntriesOfLedger(new long[]{}));
  returnAvailabilityOfEntriesOfLedger.put(bookieAddresses.get(1).toString(),Long.toString(ledgerId),new AvailabilityOfEntriesOfLedger(new long[]{0,1,2,3}));
  returnAvailabilityOfEntriesOfLedger.put(bookieAddresses.get(2).toString(),Long.toString(ledgerId),new AvailabilityOfEntriesOfLedger(new long[]{0,1,3}));
  returnAvailabilityOfEntriesOfLedger.put(bookieAddresses.get(3).toString(),Long.toString(ledgerId),new AvailabilityOfEntriesOfLedger(new long[]{1}));
  returnAvailabilityOfEntriesOfLedger.put(bookieAddresses.get(4).toString(),Long.toString(ledgerId),new AvailabilityOfEntriesOfLedger(new long[]{2,3}));
  numLedgersFoundHavingLessThanWQReplicasOfAnEntry++;
  segmentEnsembles.clear();
  segmentEnsembles.put(0L,bookieAddresses.subList(0,4));
  segmentEnsembles.put(2L,bookieAddresses.subList(1,5));
  ledgerId=3L;
  createNonClosedLedgerMetadata(lm,ledgerId,ensembleSize,writeQuorumSize,ackQuorumSize,segmentEnsembles,digestType,password);
  errorReturnValueForGetAvailabilityOfEntriesOfLedger.put(bookieAddresses.get(0).toString(),Long.toString(ledgerId),BKException.Code.NoSuchLedgerExistsException);
  returnAvailabilityOfEntriesOfLedger.put(bookieAddresses.get(1).toString(),Long.toString(ledgerId),new AvailabilityOfEntriesOfLedger(new long[]{0,1,2,3}));
  returnAvailabilityOfEntriesOfLedger.put(bookieAddresses.get(2).toString(),Long.toString(ledgerId),new AvailabilityOfEntriesOfLedger(new long[]{0,1,3}));
  returnAvailabilityOfEntriesOfLedger.put(bookieAddresses.get(3).toString(),Long.toString(ledgerId),new AvailabilityOfEntriesOfLedger(new long[]{1}));
  returnAvailabilityOfEntriesOfLedger.put(bookieAddresses.get(4).toString(),Long.toString(ledgerId),new AvailabilityOfEntriesOfLedger(new long[]{2,3}));
  ensembleSize=4;
  writeQuorumSize=3;
  ackQuorumSize=2;
  lastEntryId=1;
  length=1000;
  segmentEnsembles.clear();
  segmentEnsembles.put(0L,bookieAddresses.subList(0,4));
  ledgerId=4L;
  createClosedLedgerMetadata(lm,ledgerId,ensembleSize,writeQuorumSize,ackQuorumSize,segmentEnsembles,lastEntryId,length,digestType,password);
  returnAvailabilityOfEntriesOfLedger.put(bookieAddresses.get(0).toString(),Long.toString(ledgerId),new AvailabilityOfEntriesOfLedger(new long[]{0,1}));
  returnAvailabilityOfEntriesOfLedger.put(bookieAddresses.get(1).toString(),Long.toString(ledgerId),new AvailabilityOfEntriesOfLedger(new long[]{0,1,2,3}));
  returnAvailabilityOfEntriesOfLedger.put(bookieAddresses.get(2).toString(),Long.toString(ledgerId),new AvailabilityOfEntriesOfLedger(new long[]{1,3}));
  returnAvailabilityOfEntriesOfLedger.put(bookieAddresses.get(3).toString(),Long.toString(ledgerId),new AvailabilityOfEntriesOfLedger(new long[]{0}));
  numLedgersFoundHavingLessThanWQReplicasOfAnEntry++;
  ensembleSize=3;
  writeQuorumSize=3;
  ackQuorumSize=2;
  lastEntryId=1;
  length=1000;
  segmentEnsembles.clear();
  segmentEnsembles.put(0L,bookieAddresses.subList(0,3));
  ledgerId=5L;
  createClosedLedgerMetadata(lm,ledgerId,ensembleSize,writeQuorumSize,ackQuorumSize,segmentEnsembles,lastEntryId,length,digestType,password);
  returnAvailabilityOfEntriesOfLedger.put(bookieAddresses.get(0).toString(),Long.toString(ledgerId),AvailabilityOfEntriesOfLedger.EMPTY_AVAILABILITYOFENTRIESOFLEDGER);
  returnAvailabilityOfEntriesOfLedger.put(bookieAddresses.get(1).toString(),Long.toString(ledgerId),new AvailabilityOfEntriesOfLedger(new long[]{0,1}));
  errorReturnValueForGetAvailabilityOfEntriesOfLedger.put(bookieAddresses.get(2).toString(),Long.toString(ledgerId),BKException.Code.BookieHandleNotAvailableException);
  numLedgersFoundHavingLessThanWQReplicasOfAnEntry++;
  runTestScenario(returnAvailabilityOfEntriesOfLedger,errorReturnValueForGetAvailabilityOfEntriesOfLedger,0,0,numLedgersFoundHavingLessThanWQReplicasOfAnEntry);
}
