id,project,test_name,full_code,label,category
2,neo4j_neo4j,RobustJobSchedulerWrapperTest.shouldBeAbleToCancelJob,"@Test
public void shouldBeAbleToCancelJob() throws Exception {
    RobustJobSchedulerWrapper robustWrapper = new RobustJobSchedulerWrapper(actualScheduler, log);
    AtomicInteger count = new AtomicInteger();
    JobHandle jobHandle = robustWrapper.scheduleRecurring(""JobName"", 1, count::incrementAndGet);
    assertEventually(""run count"", count::get, Matchers.greaterThanOrEqualTo(100), DEFAULT_TIMEOUT_MS, MILLISECONDS);
    robustWrapper.cancelAndWaitTermination(jobHandle);
    int finalCount = count.get();
    Thread.sleep(50);
    assertEquals(finalCount, count.get());
}",concurrency,1
11,androidx_androidx,getNanoTime,"@Test
public void getNanoTime() {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
        long time = mRecyclerView.getNanoTime();
        assertNotEquals(0, time);
        assertNotEquals(time, mRecyclerView.getNanoTime());
    } else {
        assertEquals(0, mRecyclerView.getNanoTime());
    }
}",time,2
13,androidx_androidx,testTimer_withListenerAndCleanUp,"@Test
@LargeTest
public void testTimer_withListenerAndCleanUp() throws InterruptedException {
    TestTimeLimitExceededListener listenerSpy = spy(mListener);
    mWorkTimer.startTimer(WORKSPEC_ID_1, 0, listenerSpy);
    Thread.sleep(10);
    verify(listenerSpy, times(1)).onTimeLimitExceeded(WORKSPEC_ID_1);
    assertThat(mWorkTimer.getTimerMap().size(), is(0));
    assertThat(mWorkTimer.getListeners().size(), is(0));
}",async wait,0
14,neo4j_neo4j,RobustJobSchedulerWrapperTest.recurringJobWithExceptionShouldKeepRunning,"@Test
public void recurringJobWithExceptionShouldKeepRunning() throws Exception
{
    RobustJobSchedulerWrapper robustWrapper = new RobustJobSchedulerWrapper( actualScheduler, log );
    AtomicInteger count = new AtomicInteger();
    IllegalStateException e = new IllegalStateException();
    int nRuns = 100;
    JobHandle jobHandle = robustWrapper.scheduleRecurring( ""JobName"", 1, () -> {
        if ( count.get() < nRuns )
        {
            count.incrementAndGet();
            throw e;
        }
    }
    );
    assertEventually( ""run count"", count::get, Matchers.equalTo( nRuns ), DEFAULT_TIMEOUT_MS , MILLISECONDS );
    robustWrapper.cancelAndWaitTermination( jobHandle );
    verify( log, timeout( DEFAULT_TIMEOUT_MS ).times( nRuns ) ).warn( ""Uncaught exception"", e );
}",concurrency,1
16,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testFireObjectEvent,"@Test
public void testFireObjectEvent() throws Exception {
    final NamingEventCoordinator coordinator = new NamingEventCoordinator();
    final CollectingListener objectListener = new CollectingListener(1);
    coordinator.addListener(""test/path"", EventContext.OBJECT_SCOPE, objectListener);
    final CollectingListener subtreeListener = new CollectingListener(0);
    coordinator.addListener(""test"", EventContext.SUBTREE_SCOPE, subtreeListener);
    final CollectingListener oneLevelListener = new CollectingListener(0);
    coordinator.addListener(""test"", EventContext.ONELEVEL_SCOPE, oneLevelListener);
    coordinator.fireEvent(context, new CompositeName(""test/path""), null, null, NamingEvent.OBJECT_ADDED, ""bind"", EventContext.OBJECT_SCOPE);
    objectListener.latch.await(1, TimeUnit.SECONDS);
    assertEquals(1, objectListener.capturedEvents.size());
    assertTrue(oneLevelListener.capturedEvents.isEmpty());
    assertTrue(subtreeListener.capturedEvents.isEmpty());
}",test order dependency,4
29,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testCreateSubcontext,"@Test
public void testCreateSubcontext() throws Exception {
    assertTrue(namingContext.createSubcontext(new CompositeName(""test"")) instanceof NamingContext);
    assertTrue(testActionPermission(JndiPermission.ACTION_CREATE_SUBCONTEXT, namingContext, ""securitytest"") instanceof NamingContext);
}",test order dependency,4
33,apache_kafka,shouldTogglePrepareForBulkLoadDuringRestoreCalls,"@Test
public void shouldTogglePrepareForBulkLoadDuringRestoreCalls() throws Exception {
    final List<KeyValue<byte[], byte[]>> entries = new ArrayList<>();
    entries.add(new KeyValue<>(""1"".getBytes(""UTF-8""), ""a"".getBytes(""UTF-8"")));
    entries.add(new KeyValue<>(""2"".getBytes(""UTF-8""), ""b"".getBytes(""UTF-8"")));
    entries.add(new KeyValue<>(""3"".getBytes(""UTF-8""), ""c"".getBytes(""UTF-8"")));
    final AtomicReference<Exception> conditionNotMet = new AtomicReference<>();
    final AtomicInteger conditionCheckCount = new AtomicInteger();
    Thread conditionCheckThread = new Thread(new Runnable() {
        @Override
        public void run() {
            assertRocksDBTurnsOnBulkLoading(conditionCheckCount, conditionNotMet);
            assertRockDBTurnsOffBulkLoad(conditionCheckCount, conditionNotMet);
        }
    });
    subject.init(context, subject);
    conditionCheckThread.start();
    context.restore(subject.name(), entries);
    conditionCheckThread.join(2000);
    assertTrue(conditionNotMet.get() == null);
    assertTrue(conditionCheckCount.get() == 2);
}",concurrency,1
35,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testLookupContextLink,"@Test
public void testLookupContextLink() throws Exception {
    final Name name = new CompositeName(""test/value"");
    namingStore.bind(name, ""testValue"");
    final Name linkName = new CompositeName(""link"");
    namingStore.bind(linkName, new LinkRef(""./test""));
    Object result = namingContext.lookup(""link/value"");
    assertEquals(""testValue"", result);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, Arrays.asList(new JndiPermission(""test"", ""lookup""),
    new JndiPermission(""test/value"", ""lookup"")), namingContext, ""link/value"");
    assertEquals(""testValue"", result);
}",test order dependency,4
39,quarkusio_quarkus,testTimedMethod,"@Test
void testTimedMethod() throws InterruptedException {
    assertTrue(Jobs.latch01.await(5, TimeUnit.SECONDS));
    assertTrue(Jobs.latch02.await(5, TimeUnit.SECONDS));
    Timer timer1 = registry.get(""scheduled.methods"")
    .tag(""method"", ""everySecond"")
    .tag(""class"", ""io.quarkus.scheduler.test.metrics.MicrometerTimedTest$Jobs"")
    .tag(""exception"", ""none"")
    .timer();
    assertNotNull(timer1);
    assertTrue(timer1.count() > 0);
    Timer timer2 = registry.get(""foo"")
    .tag(""method"", ""anotherEverySecond"")
    .tag(""class"", ""io.quarkus.scheduler.test.metrics.MicrometerTimedTest$Jobs"")
    .tag(""exception"", ""none"")
    .timer();
    assertNotNull(timer2);
    assertTrue(timer2.count() > 0);
}",time,2
44,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testLookupEmptyName,"@Test
public void testLookupEmptyName() throws Exception {
    Object result = namingContext.lookup(new CompositeName());
    assertTrue(result instanceof NamingContext);
    result = namingContext.lookup(new CompositeName(""""));
    assertTrue(result instanceof NamingContext);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, null);
    assertTrue(result instanceof NamingContext);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, """");
    assertTrue(result instanceof NamingContext);
}",test order dependency,4
45,Tencent_Firestorm,HealthCheckCoordinatorGrpcTest.healthCheckTest,"@Test
public void healthCheckTest() throws Exception {
    RssGetShuffleAssignmentsRequest request = new RssGetShuffleAssignmentsRequest(""1"", 1, 1, 1, 1, Sets.newHashSet(SHUFFLE_SERVER_VERSION));
    Uninterruptibles.sleepUninterruptibly(3, TimeUnit.SECONDS);
    assertEquals(2, coordinatorClient.getShuffleServerList().getServersCount());
    List<ServerNode> nodes = coordinators.get(0).getClusterManager().getServerList(Sets.newHashSet(SHUFFLE_SERVER_VERSION));
    assertEquals(2, coordinatorClient.getShuffleServerList().getServersCount());
    assertEquals(2, nodes.size());
    RssGetShuffleAssignmentsResponse response = coordinatorClient.getShuffleAssignments(request);
    assertFalse(response.getPartitionToServers().isEmpty());
    for (ServerNode node : nodes) {
        assertTrue(node.isHealthy());
    }
    byte[] bytes = new byte[writeDataSize];
    new Random().nextBytes(bytes);
    try (final FileOutputStream out = new FileOutputStream(tempDataFile)) {
        out.write(bytes);
    }
    Uninterruptibles.sleepUninterruptibly(3, TimeUnit.SECONDS);
    CoordinatorTestUtils.waitForRegister(coordinatorClient, 2);
    nodes = coordinators.get(0).getClusterManager().getServerList(Sets.newHashSet(SHUFFLE_SERVER_VERSION));
    for (ServerNode node : nodes) {
        assertFalse(node.isHealthy());
    }
    assertEquals(0, nodes.size());
    response = coordinatorClient.getShuffleAssignments(request);
    assertEquals(INTERNAL_ERROR, response.getStatusCode());
    tempDataFile.delete();
    int i = 0;
    do {
        Uninterruptibles.sleepUninterruptibly(3, TimeUnit.SECONDS);
        nodes = coordinators.get(0).getClusterManager().getServerList(Sets.newHashSet(SHUFFLE_SERVER_VERSION));
        i++;
        if (i == 10) {
            fail();
        }
    } while (nodes.size() != 2 );
    for (ServerNode node : nodes) {
        assertTrue(node.isHealthy());
    }
    assertEquals(2, nodes.size());
    response = coordinatorClient.getShuffleAssignments(request);
    assertFalse(response.getPartitionToServers().isEmpty());
}",async wait,0
49,opensearch-project_OpenSearch,testReplicaThreadedThroughputDegradationAndRejection,"@Test
public void testReplicaThreadedThroughputDegradationAndRejection() throws Exception {
    Settings settings = Settings.builder().put(IndexingPressure.MAX_INDEXING_BYTES.getKey(), ""10KB"")
    .put(ShardIndexingPressureSettings.SHARD_INDEXING_PRESSURE_ENABLED.getKey(), true)
    .put(ShardIndexingPressureSettings.SHARD_INDEXING_PRESSURE_ENFORCED.getKey(), true)
    .put(ShardIndexingPressureMemoryManager.THROUGHPUT_DEGRADATION_LIMITS.getKey(), 1)
    .put(ShardIndexingPressureSettings.REQUEST_SIZE_WINDOW.getKey(), 100)
    .build();
    final int NUM_THREADS = scaledRandomIntBetween(100, 120);
    ShardIndexingPressure shardIndexingPressure = new ShardIndexingPressure(settings, clusterService);
    Index index = new Index(""IndexName"", ""UUID"");
    ShardId shardId1 = new ShardId(index, 0);
    fireConcurrentAndParallelRequestsForUniformThroughPut(NUM_THREADS, shardIndexingPressure, shardId1, 100, 100,
    OperationType.REPLICA);
    fireAllThenCompleteConcurrentRequestsWithUniformDelay(ShardIndexingPressureSettings.REQUEST_SIZE_WINDOW.get(settings),
    shardIndexingPressure, shardId1, 100, 200, OperationType.REPLICA);
    expectThrows(OpenSearchRejectedExecutionException.class,
    () -> shardIndexingPressure.markReplicaOperationStarted(shardId1, 11 * 1024, false));
    assertEquals(0, shardIndexingPressure.coldStats().getIndexingPressureShardStats(shardId1).getCurrentReplicaBytes());
    assertEquals(15, shardIndexingPressure.coldStats().getIndexingPressureShardStats(shardId1).getCurrentReplicaLimits());
}",concurrency,1
50,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testCompositeBindingOps,"@Test
public void testCompositeBindingOps() throws Exception {
    final KernelServices services = createKernelServicesBuilder(createAdditionalInitialization()).setSubsystemXml(getSubsystemXml()).build();
    final ModelNode addr = Operations.createAddress(ModelDescriptionConstants.SUBSYSTEM, NamingExtension.SUBSYSTEM_NAME, NamingSubsystemModel.BINDING, ""java:global/alookup"");
    final ModelNode addOp = Operations.createAddOperation(addr);
    addOp.get(NamingSubsystemModel.BINDING_TYPE).set(NamingSubsystemModel.LOOKUP);
    final ModelNode compositeOp = Operations.CompositeOperationBuilder.create().addStep(addOp).addStep(Operations.createWriteAttributeOperation(addr, NamingSubsystemModel.LOOKUP, ""java:global/a"")).build().getOperation();
    ModelTestUtils.checkOutcome(services.executeOperation(compositeOp));
}",test order dependency,4
54,androidx_androidx,testGenerateCleanupCallback_deletesOldFinishedWork,"@Test
public void testGenerateCleanupCallback_deletesOldFinishedWork() {
    Work work1 = new Work.Builder(TestWorker.class)
    .withInitialState(SUCCEEDED)
    .withPeriodStartTime(0L)
    .build();
    Work work2 = new Work.Builder(TestWorker.class).withPeriodStartTime(Long.MAX_VALUE).build();
    insertWorkSpecAndTags(work1);
    insertWorkSpecAndTags(work2);
    SupportSQLiteOpenHelper openHelper = mDatabase.getOpenHelper();
    SupportSQLiteDatabase db = openHelper.getWritableDatabase();
    WorkDatabase.generateCleanupCallback().onOpen(db);
    WorkSpecDao workSpecDao = mDatabase.workSpecDao();
    assertThat(workSpecDao.getWorkSpec(work1.getId()), is(nullValue()));
    assertThat(workSpecDao.getWorkSpec(work2.getId()), is(not(nullValue())));
}",time,2
57,androidx_androidx,testMenuInvalidationAfterDestroy,"@Test
public void testMenuInvalidationAfterDestroy() throws Throwable {
    final A activity = getActivity();
    getInstrumentation().runOnMainSync(new Runnable() {
        @Override
        public void run() {
            activity.reset();
            assertNull(activity.getMenu());
            activity.supportInvalidateOptionsMenu();
            getInstrumentation().callActivityOnDestroy(activity);
        }
    });
    Thread.sleep(100);
    assertNull(activity.getMenu());
}",async wait,0
58,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testBindAndRetrieveObjectFactoryFromNamingContext,"@Test
public void testBindAndRetrieveObjectFactoryFromNamingContext() throws Exception {
    final Reference reference = new Reference(""java.util.String"", TestObjectFactory.class.getName(), null);
    namingStore.bind(new CompositeName(""test""), reference);
    final Object result = namingContext.lookup(""test"");
    assertTrue(result instanceof String);
    assertEquals(""Test ParsedResult"", result);
}",test order dependency,4
61,graylog2_graylog2-server,indexCreationDateReturnsIndexCreationDateOfExistingIndexAsDateTime,"@Test
public void indexCreationDateReturnsIndexCreationDateOfExistingIndexAsDateTime() {
    final DateTime now = DateTime.now(DateTimeZone.UTC);
    final String indexName = client().createRandomIndex(""indices_it_"");
    final Optional<DateTime> indexCreationDate = indices.indexCreationDate(indexName);
    assertThat(indexCreationDate).isNotEmpty()
    .hasValueSatisfying(date -> Assertions.assertThat(date).isEqualToIgnoringMillis(now));
}",time,2
62,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testJavaContext,"@Test
public void testJavaContext() throws Exception {
    System.setProperty(Context.INITIAL_CONTEXT_FACTORY, InitialContextFactory.class.getName());
    System.setProperty(Context.URL_PKG_PREFIXES, ""org.jboss.as.naming.interfaces"");
    InitialContext initialContext = new InitialContext();
    Context context = (Context) initialContext.lookup(""java:"");
    assertTrue(context instanceof NamingContext);
}",test order dependency,4
63,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testLookupWithContinuation,"@Test
public void testLookupWithContinuation() throws Exception {
    namingStore.bind(new CompositeName(""comp/nested""), ""test"");
    final Reference reference = new Reference(String.class.getName(), new StringRefAddr(""nns"", ""comp""), TestObjectFactoryWithNameResolution.class.getName(), null);
    namingStore.bind(new CompositeName(""test""), reference);
    Object result = namingContext.lookup(new CompositeName(""test/nested""));
    assertEquals(""test"", result);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, Arrays.asList(new JndiPermission(""comp/nested"", ""lookup"")), namingContext, ""test/nested"");
    assertEquals(""test"", result);
}",test order dependency,4
65,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testInitialFactory,"@Test
public void testInitialFactory() throws Exception {
    System.setProperty(Context.INITIAL_CONTEXT_FACTORY, InitialContextFactory.class.getName());
    InitialContext initialContext = new InitialContext();
    Context context = (Context) initialContext.lookup("""");
    assertTrue(context instanceof NamingContext);
    if (!NamingManager.hasInitialContextFactoryBuilder()) {
        NamingManager.setInitialContextFactoryBuilder(new InitialContextFactoryBuilder());
    }
    initialContext = new InitialContext();
    context = (Context) initialContext.lookup("""");
    assertTrue(context instanceof NamingContext);
}",test order dependency,4
68,androidx_androidx,testUnsubscribeWithSubscriptionCallbackForMultipleSubscriptions,"@Test
public void testUnsubscribeWithSubscriptionCallbackForMultipleSubscriptions() throws Exception {
    connectMediaBrowserService();
    final List<StubSubscriptionCallback> subscriptionCallbacks = new ArrayList<>();
    final int pageSize = 1;
    for (int page = 0; page < 4; page++) {
        final StubSubscriptionCallback callback = new StubSubscriptionCallback();
        subscriptionCallbacks.add(callback);
        Bundle options = new Bundle();
        options.putInt(MediaBrowserCompat.EXTRA_PAGE, page);
        options.putInt(MediaBrowserCompat.EXTRA_PAGE_SIZE, pageSize);
        callback.reset(1);
        mMediaBrowser.subscribe(MEDIA_ID_ROOT, options, callback);
        callback.await(TIME_OUT_MS);
        assertEquals(1, callback.mChildrenLoadedWithOptionCount);
    }
    final int[] orderOfRemovingCallbacks = {2, 0, 3, 1};
    for (int i = 0; i < orderOfRemovingCallbacks.length; i++) {
        for (StubSubscriptionCallback callback : subscriptionCallbacks) {
            callback.reset(1);
        }
        mMediaBrowser.unsubscribe(MEDIA_ID_ROOT,
        subscriptionCallbacks.get(orderOfRemovingCallbacks[i]));
        callMediaBrowserServiceMethod(NOTIFY_CHILDREN_CHANGED, MEDIA_ID_ROOT,
        getApplicationContext());
        try {
            Thread.sleep(SLEEP_MS);
        } catch (InterruptedException e) {
            fail(""Unexpected InterruptedException occurred."");
        }
        for (int j = 0; j < 4; j++) {
            int childrenLoadedWithOptionsCount = subscriptionCallbacks
            .get(orderOfRemovingCallbacks[j]).mChildrenLoadedWithOptionCount;
            if (j <= i) {
                assertEquals(0, childrenLoadedWithOptionsCount);
            } else {
                assertEquals(1, childrenLoadedWithOptionsCount);
            }
        }
    }
}",async wait,0
71,androidx_androidx,testOneTimeWorkRequest_backedOff,"@Test
public void testOneTimeWorkRequest_backedOff() {
    val now = System.currentTimeMillis() ;
    when(mTaskConverter.now()).thenReturn(now) ;
    val request = OneTimeWorkRequestBuilder<TestWorker>().setInitialRunAttemptCount(1).build() ;
    val workSpec = request.workSpec ;
    val expected = workSpec.calculateNextRunTime();
    val offset = offset(expected, now) ,
    val delta = task.windowEnd - (offset + EXECUTION_WINDOW_SIZE_IN_SECONDS);
    val task = mTaskConverter.convert(request.workSpec);
    assertEquals(task.serviceName, WorkManagerGcmService::class.java.name);
    assertEquals(task.isPersisted, false);
    assertEquals(task.isUpdateCurrent, true);
    assertEquals(task.requiredNetwork, Task.NETWORK_STATE_ANY);
    assertEquals(task.requiresCharging, false);
    assertEquals(task.windowStart, offset);
    assertEquals(task.windowEnd, offset + EXECUTION_WINDOW_SIZE_IN_SECONDS);
}",time,2
74,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testBind.2,"@Test
public void testBind() throws Exception {
    final Name name = new CompositeName(""test"");
    final Object value = new Object();
    WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);
    try {
        store.bind(name, value);
    } finally {
        WritableServiceBasedNamingStore.popOwner();
    }
    assertEquals(value, store.lookup(name));
}",test order dependency,4
79,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testRejectionEAP6,"@Test
public void testRejectionsEAP6() throws Exception {
    testTransformer(""subsystem.xml"", ModelTestControllerVersion.EAP_6_4_0, ModelVersion.create(1, 3),""jboss-as-naming"");
}",test order dependency,4
82,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testLookupLink,"@Test
public void testLookupLink() throws Exception {
    final Name name = new CompositeName(""test"");
    namingStore.bind(name, ""testValue"", String.class);
    final Name linkName = new CompositeName(""link"");
    namingStore.bind(linkName, new LinkRef(""./test""));
    Object result = namingContext.lookup(linkName);
    assertEquals(""testValue"", result);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, Arrays.asList(new JndiPermission(""test"", ""lookup"")), namingContext, ""link"");
    assertEquals(""testValue"", result);
    System.setProperty(Context.INITIAL_CONTEXT_FACTORY, InitialContextFactory.class.getName());
    namingStore.rebind(linkName, new LinkRef(name));
    result = namingContext.lookup(linkName);
    assertEquals(""testValue"", result);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, Arrays.asList(new JndiPermission(""test"", ""lookup"")), namingContext, ""link"");
    assertEquals(""testValue"", result);
}",test order dependency,4
83,square_okhttp,CallTest.legalToExecuteTwiceCloning_Async,"@Test
public void legalToExecuteTwiceCloning_Async() throws Exception {
    server.enqueue(new MockResponse().setBody(""abc""));
    server.enqueue(new MockResponse().setBody(""def""));
    Request request = new Request.Builder().url(server.url(""/"")).build();
    Call call = client.newCall(request);
    call.enqueue(callback);
    Call cloned = call.clone();
    cloned.enqueue(callback);
    callback.await(request.url()).assertBody(""abc"");
    callback.await(request.url()).assertBody(""def"");
}",async wait,0
88,togglz_togglz,ZookeeperStateRepositoryTest.testZkNodeChangesUpdateFeatureState,"@Test
public void testZkNodeChangesUpdateFeatureState() throws Exception {
    setupTestWithEmptyDatastore();
    FeatureState savedFeatureState = new FeatureState(TestFeature.FEATURE);
    savedFeatureState.setStrategyId(ID);
    savedFeatureState.setParameter(PARAM_USERS, ""user1, user2, user3"");
    stateRepository.setFeatureState(savedFeatureState);
    FeatureState loadedFeatureState = stateRepository.getFeatureState(TestFeature.FEATURE);
    assertThat(reflectionEquals(savedFeatureState, loadedFeatureState), is(true));
    FeatureStateStorageWrapper externallySetStateWrapper = new FeatureStateStorageWrapper();
    FeatureState externallySetState = new FeatureState(TestFeature.FEATURE);
    ObjectMapper objectMapper = new ObjectMapper();
    final String json = objectMapper.writeValueAsString(externallySetStateWrapper);
    final CountDownLatch latch = new CountDownLatch(1);
    new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                serverClientPair.client.setData().forPath(TEST_ZNODE + ""/FEATURE"", json.getBytes(""UTF-8""));
                latch.countDown();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }).start();
    latch.await(2, TimeUnit.SECONDS);
    Thread.sleep(25);
    loadedFeatureState = stateRepository.getFeatureState(TestFeature.FEATURE);
    assertThat(reflectionEquals(externallySetState, loadedFeatureState), is(true));
}",async wait,0
89,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testLookupReference,"@Test
public void testLookupReference() throws Exception {
    final Name name = new CompositeName(""test"");
    final Reference reference = new Reference(String.class.getName(), new StringRefAddr(""blah"", ""test""), TestObjectFactory.class.getName(), null);
    namingStore.bind(name, reference);
    Object result = namingContext.lookup(name);
    assertEquals(""test"", result);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, ""test"");
    assertEquals(""test"", result);
}",test order dependency,4
100,androidx_androidx,playbackRate,"@Test
public void playbackRate() throws Exception {
    final int toleranceMs = 1000;
    Future<PlayerResult> setSurfaceFuture = mPlayer.setSurface(
    mActivity.getSurfaceHolder().getSurface());
    Future<PlayerResult> prepareFuture = mPlayer.prepare();
    assertFutureSuccess(setSurfaceFuture);
    assertFutureSuccess(prepareFuture);
    float[] rates = {0.25f, 0.5f, 1.0f, 2.0f};
    for (float playbackRate : rates) {
        Future<PlayerResult> seekFuture = mPlayer.seekTo(0, MediaPlayer.SEEK_PREVIOUS_SYNC);
        Thread.sleep(1000);
        int playTime = 4000;
        int privState = mPlayer.getPlayerState();
        Future<PlayerResult> setParamsFuture = mPlayer.setPlaybackParams(
        new PlaybackParams.Builder().setSpeed(playbackRate).build());
        assertFutureSuccess(seekFuture);
        assertFutureSuccess(setParamsFuture);
        assertEquals(""setPlaybackParams() should not change player state. ""
        + mPlayer.getPlayerState(), privState, mPlayer.getPlayerState());
        Future<PlayerResult> playFuture = mPlayer.play();
        Thread.sleep(playTime);
        PlaybackParams pbp = mPlayer.getPlaybackParams();
        assertEquals(playbackRate, pbp.getSpeed(), FLOAT_TOLERANCE);
        assertEquals(""The player should still be playing"",
        MediaPlayer.PLAYER_STATE_PLAYING, mPlayer.getPlayerState());
        long playedMediaDurationMs = mPlayer.getCurrentPosition();
        long expectedPosition = (long) (playTime * playbackRate);
        int diff = (int) Math.abs(playedMediaDurationMs - expectedPosition);
        if (diff > toleranceMs) {
            fail(""Media player had error in playback rate "" + playbackRate
            + "". expected position after playing "" + playTime
            + "" was "" + expectedPosition + "", but actually "" + playedMediaDurationMs);
        }
        assertFutureSuccess(playFuture);
        assertFutureSuccess(mPlayer.pause());
        pbp = mPlayer.getPlaybackParams();
        assertEquals(""pause() should not change the playback rate property."",
        playbackRate, pbp.getSpeed(), FLOAT_TOLERANCE);
    }
    mPlayer.reset();
}",async wait,0
104,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testListNameNotFound,"@Test
public void testListNameNotFound() throws Exception {
    try {
        namingContext.list(new CompositeName(""test""));
        fail(""Should have thrown and NameNotFoundException"");
    } catch (NameNotFoundException expected) {
    }
    try {
        testActionPermission(JndiPermission.ACTION_LIST, namingContext, ""test"");
        fail(""Should have thrown and NameNotFoundException with appropriate permissions"");
    } catch (NameNotFoundException expected) {
    }
}",test order dependency,4
115,ReactiveX_RxJava,ObservableSwitchTest.outerInnerErrorRace,"@Test
public void outerInnerErrorRace() {
    for (int i = 0; i < 500; i++) {
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final PublishSubject<Integer> ps1 = PublishSubject.create();
            final PublishSubject<Integer> ps2 = PublishSubject.create();
            ps1.switchMap(new Function<Integer, ObservableSource<Integer>>() {
                @Override
                public ObservableSource<Integer> apply(Integer v) throws Exception {
                    if (v == 1) {
                        return ps2;
                    }
                    return Observable.never();
                }
            })
            .test();
            final TestException ex1 = new TestException();
            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps1.onError(ex1);
                }
            };
            final TestException ex2 = new TestException();
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps2.onError(ex2);
                }
            };
            TestHelper.race(r1, r2);
            for (Throwable e : errors) {
                assertTrue(e.toString(), e instanceof TestException);
            }
        } finally {
            RxJavaPlugins.reset();
        }
    }
}",concurrency,1
128,neo4j_neo4j,createdWorkerThreadsShouldContainConnectorName,"@Test
public void createdWorkerThreadsShouldContainConnectorName() throws Exception
{
    AtomicInteger processNextBatchCount = new AtomicInteger();
    AtomicReference<Thread> poolThread = new AtomicReference<>();
    AtomicReference<String> poolThreadName = new AtomicReference<>();
    String id = UUID.randomUUID().toString();
    BoltConnection connection = newConnection( id );
    when( connection.processNextBatch() ).thenAnswer( inv ->
    {
        poolThread.set( Thread.currentThread() );
        poolThreadName.set( Thread.currentThread().getName() );
        processNextBatchCount.incrementAndGet();
        return true;
    } );
    boltScheduler.start();
    boltScheduler.created( connection );
    boltScheduler.enqueued( connection, Jobs.noop() );
    Predicates.await( () -> processNextBatchCount.get() > 0, 1, MINUTES );
    assertThat( poolThread.get().getName(), not( equalTo( poolThreadName.get() ) ) );
    assertThat( poolThread.get().getName(), containsString( String.format( ""[%s]"", CONNECTOR_KEY ) ) );
    assertThat( poolThread.get().getName(), not( containsString( String.format( ""[%s]"", connection.remoteAddress() ) ) ) );
}",concurrency,1
130,Kong_unirest-java,DefectTest.nullAndObjectValuesInMap,"@Test
void nullAndObjectValuesInMap() {
    Map<String, Object> queryParams = new HashMap<>();
    queryParams.put(""foo"", null);
    queryParams.put(""baz"", ""qux"");
    Unirest.get(GET).queryString(queryParams).asObject(RequestCapture.class).getBody().assertParam(""foo"", """").assertParam(""baz"", ""qux"").assertQueryString(""foo&baz=qux"");
}",unordered collections,3
132,androidx_androidx,testInterruption,"@Test
public void testInterruption() throws InterruptedException {
    OneTimeWorkRequest work = new OneTimeWorkRequest.Builder(TestWorker.class).build();
    insertWork(work);
    WorkerWrapper workerWrapper =
    createBuilder(work.getStringId())
    .withSchedulers(Collections.singletonList(mMockScheduler))
    .build();
    FutureListener listener = createAndAddFutureListener(workerWrapper);
    Executors.newSingleThreadExecutor().submit(workerWrapper);
    workerWrapper.interrupt();
    Thread.sleep(6000L);
    assertThat(listener.mResult, is(true));
}",async wait,0
136,graylog2_graylog2-server,KafkaJournalTest.serverStatusUnthrottledIfJournalUtilizationIsLowerThanThreshold,"@Test
public void serverStatusUnthrottledIfJournalUtilizationIsLowerThanThreshold() throws Exception {
    serverStatus.throttle();
    final Size segmentSize = Size.kilobytes(1L);
    final KafkaJournal journal = new KafkaJournal(journalDirectory, scheduler, segmentSize, Duration.standardSeconds(1L), Size.kilobytes(4L), Duration.standardSeconds(1L), 1000000, Duration.standardSeconds(1L), 90, new MetricRegistry(), serverStatus);
    journal.flushDirtyLogs();
    journal.cleanupLogs();
    assertThat(serverStatus.getLifecycle()).isEqualTo(RUNNING);
}",concurrency,1
143,apache_cassandra,ColumnFamilyStoreTest.testRemoveSuperColumn,"@Test
public void testRemoveSuperColumn() throws IOException, ExecutionException, InterruptedException {
    Table table = Table.open(""Table1"");
    ColumnFamilyStore store = table.getColumnFamilyStore(""Super1"");
    RowMutation rm;
    rm = new RowMutation(""Table1"", ""key1"");
    rm.add(""Super1:SC1:Column1"", ""asdf"".getBytes(), 0);
    rm.apply();
    store.forceBlockingFlush();
    rm = new RowMutation(""Table1"", ""key1"");
    rm.delete(""Super1:SC1"", 1);
    rm.apply();
    List<ColumnFamily> families = store.getColumnFamilies(""key1"", ""Super1"", new IdentityFilter());
    assert families.get(0).getAllColumns().first().getMarkedForDeleteAt() == 1;
    assert !families.get(1).getAllColumns().first().isMarkedForDelete();
    ColumnFamily resolved = ColumnFamily.resolve(families);
    assert resolved.getAllColumns().first().getMarkedForDeleteAt() == 1;
    Collection<IColumn> subColumns = resolved.getAllColumns().first().getSubColumns();
    assert subColumns.size() == 1;
    assert subColumns.iterator().next().timestamp() == 0;
    assertNull(ColumnFamilyStore.removeDeleted(resolved, Integer.MAX_VALUE));
}",async wait,0
149,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testCompositeBindingUpdate,"@Test
public void testCompositeBindingUpdate() throws Exception {
    final KernelServices services = createKernelServicesBuilder(createAdditionalInitialization()).setSubsystemXml(getSubsystemXml()).build();
    final ModelNode addr = Operations.createAddress(ModelDescriptionConstants.SUBSYSTEM, NamingExtension.SUBSYSTEM_NAME, NamingSubsystemModel.BINDING, ""java:global/a"");
    final ModelNode compositeOp = Operations.CompositeOperationBuilder.create()
    .addStep(Operations.createWriteAttributeOperation(addr, NamingSubsystemModel.BINDING_TYPE, NamingSubsystemModel.LOOKUP))
    .addStep(Operations.createWriteAttributeOperation(addr, NamingSubsystemModel.LOOKUP, ""java:global/b""))
    .build().getOperation();
    ModelTestUtils.checkOutcome(services.executeOperation(compositeOp));
}",test order dependency,4
153,androidx_androidx,testOneTimeRequest_noInitialDelay_withConstraintNetworkConnected,"@Test
public void testOneTimeRequest_noInitialDelay_withConstraintNetworkConnected() {
    val now = System.currentTimeMillis() ;
    when(mTaskConverter.now()).thenReturn(now) ;
    val constraints = Constraints.Builder().setRequiredNetworkType(NetworkType.METERED).setRequiresCharging(true).build() ;
    val request = OneTimeWorkRequestBuilder<TestWorker>()
    .setConstraints(constraints)
    .build() ;
    val task = mTaskConverter.convert(request.workSpec) ;
    val expected = request.workSpec.calculateNextRunTime() ;
    val offset = offset(expected, now) ;
    assertEquals(task.serviceName, WorkManagerGcmService::class.java.name) ;
    assertEquals(task.isPersisted, false) ;
    assertEquals(task.isUpdateCurrent, true) ;
    assertEquals(task.requiredNetwork, Task.NETWORK_STATE_CONNECTED) ;
    assertEquals(task.requiresCharging, true) ;
    assertEquals(task.windowStart, offset) ;
    assertEquals(task.windowEnd, offset + EXECUTION_WINDOW_SIZE_IN_SECONDS) ;
}",time,2
157,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testStoredContext,"@Test
public void testStoredContext() throws Exception {
    final ServiceName bindingName = ServiceName.JBOSS.append(""foo-stored"").append(""again"");
    bindObject(bindingName, new Context() {
        @Override
        public Object lookup(Name name) throws NamingException {
            if (""blah/blah2"".equals(name.toString())) {
                return new Integer(5);
            }
            return null;
        }
        @Override
        public Object lookup(String name) throws NamingException {
            return lookup(new CompositeName(name));
        }
        @Override
        public void bind(Name name, Object obj) throws NamingException {
        }
        @Override
        public void bind(String name, Object obj) throws NamingException {
        }
        @Override
        public void rebind(Name name, Object obj) throws NamingException {
        }
        @Override
        public void rebind(String name, Object obj) throws NamingException {
        }
        @Override
        public void unbind(Name name) throws NamingException {
        }
        @Override
        public void unbind(String name) throws NamingException {
        }
        @Override
        public void rename(Name oldName, Name newName) throws NamingException {
        }
        @Override
        public void rename(String oldName, String newName) throws NamingException {
        }
        @Override
        public NamingEnumeration<NameClassPair> list(Name name) throws NamingException {
            return null;
        }
        @Override
        public NamingEnumeration<NameClassPair> list(String name) throws NamingException {
            return null;
        }
        @Override
        public NamingEnumeration<Binding> listBindings(Name name) throws NamingException {
            if (!""hi/there"".equals(name.toString()))
            throw new IllegalArgumentException(""Expected hi/there"");
            return null;
        }
        @Override
        public NamingEnumeration<Binding> listBindings(String name) throws NamingException {
            return null;
        }
        @Override
        public void destroySubcontext(Name name) throws NamingException {
        }
        @Override
        public void destroySubcontext(String name) throws NamingException {
        }
        @Override
        public Context createSubcontext(Name name) throws NamingException {
            return null;
        }
        @Override
        public Context createSubcontext(String name) throws NamingException {
            return null;
        }
        @Override
        public Object lookupLink(Name name) throws NamingException {
            return null;
        }
        @Override
        public Object lookupLink(String name) throws NamingException {
            return null;
        }
        @Override
        public NameParser getNameParser(Name name) throws NamingException {
            return null;
        }
        @Override
        public NameParser getNameParser(String name) throws NamingException {
            return null;
        }
        @Override
        public Name composeName(Name name, Name prefix) throws NamingException {
            return null;
        }
        @Override
        public String composeName(String name, String prefix) throws NamingException {
            return null;
        }
        @Override
        public Object addToEnvironment(String propName, Object propVal) throws NamingException {
            return null;
        }
        @Override
        public Object removeFromEnvironment(String propName) throws NamingException {
            return null;
        }
        @Override
        public Hashtable<?, ?> getEnvironment() throws NamingException {
            return null;
        }
        @Override
        public void close() throws NamingException {
        }
        @Override
        public String getNameInNamespace() throws NamingException {
            return null;
        }
    });
    final NamingContext ctx = new NamingContext(new CompositeName(), store, null);
    final Object obj = ctx.lookup(new CompositeName(""foo-stored/again/blah/blah2""));
    ctx.listBindings(""foo-stored/again/hi/there"");
    assertNotNull(obj);
    assertEquals(new Integer(5), obj);
}",test order dependency,4
158,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testBindAndRetrieveObjectFactoryFromInitialContext,"@Test
public void testBindAndRetrieveObjectFactoryFromInitialContext() throws Exception {
    final Reference reference = new Reference(""java.util.String"", TestObjectFactory.class.getName(), null);
    namingStore.bind(new CompositeName(""test""), reference);
    final InitialContext initialContext = new InitialContext();
    final Object result = initialContext.lookup(""test"");
    assertTrue(result instanceof String);
    assertEquals(""Test ParsedResult"", result);
}",test order dependency,4
159,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testFireOneLevelEvent,"@Test
public void testFireOneLevelEvent() throws Exception {
    final NamingEventCoordinator coordinator = new NamingEventCoordinator();
    final CollectingListener objectListener = new CollectingListener(0);
    coordinator.addListener(""test/path"", EventContext.OBJECT_SCOPE, objectListener);
    final CollectingListener subtreeListener = new CollectingListener(0);
    coordinator.addListener(""test"", EventContext.SUBTREE_SCOPE, subtreeListener);
    final CollectingListener oneLevelListener = new CollectingListener(1);
    coordinator.addListener(""test"", EventContext.ONELEVEL_SCOPE, oneLevelListener);
    coordinator.fireEvent(context, new CompositeName(""test/path""), null, null, NamingEvent.OBJECT_ADDED, ""bind"", EventContext.ONELEVEL_SCOPE);
    oneLevelListener.latch.await(1, TimeUnit.SECONDS);
    assertTrue(objectListener.capturedEvents.isEmpty());
    assertTrue(subtreeListener.capturedEvents.isEmpty());
    assertEquals(1, oneLevelListener.capturedEvents.size());
}",test order dependency,4
162,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testLookupWitResolveResult,"@Test
public void testLookupWitResolveResult() throws Exception {
    namingStore.bind(new CompositeName(""test/nested""), ""test"");
    final Reference reference = new Reference(String.class.getName(), new StringRefAddr(""blahh"", ""test""), TestObjectFactoryWithNameResolution.class.getName(), null);
    namingStore.bind(new CompositeName(""comp""), reference);
    Object result = namingContext.lookup(new CompositeName(""comp/nested""));
    assertEquals(""test"", result);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, Arrays.asList(new JndiPermission(""test/nested"", ""lookup"")), namingContext, ""comp/nested"");
    assertEquals(""test"", result);
}",test order dependency,4
163,pushtorefresh_storio,NotifyAboutChangesTest.notifyAboutChangesConcurrently,"@Test
public void notifyAboutChangesConcurrently() {
    final int numberOfThreads = 100;
    final TestSubscriber<Changes> testSubscriber = new TestSubscriber<Changes>();
    final Set<String> tables = new HashSet<String>();
    final List<Changes> expectedChanges = new ArrayList<Changes>();
    for (int i = 0; i < numberOfThreads; i++) {
        final String table = ""test_table"" + i;
        tables.add(table);
        expectedChanges.add(Changes.newInstance(table));
    }
    storIOSQLite.observeChanges(LATEST).subscribe(testSubscriber);
    final CountDownLatch startAllThreadsLock = new CountDownLatch(1);
    for (int i = 0; i < numberOfThreads; i++) {
        final int finalI = i;
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    startAllThreadsLock.await();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                storIOSQLite.lowLevel().notifyAboutChanges(Changes.newInstance(""test_table"" + finalI));
            }
        }).start();
    }
    startAllThreadsLock.countDown();
    final long startTime = SystemClock.elapsedRealtime();
    while ((testSubscriber.valueCount() != tables.size()) && ((SystemClock.elapsedRealtime() - startTime) < 20000)) {
        Thread.yield();
    }
    testSubscriber.assertNoErrors();
    testSubscriber.assertValueCount(expectedChanges.size());
    assertThat(expectedChanges.containsAll(testSubscriber.values())).isTrue();
}",concurrency,1
166,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testRejectionEAP7,"@Test
public void testRejectionsEAP7() throws Exception {
    testTransformer(""subsystem.xml"", ModelTestControllerVersion.EAP_7_0_0, ModelVersion.create(2, 0), ""wildfly-naming"");
}",test order dependency,4
167,neo4j_neo4j,RaftMessageProcessingMetricTest.shouldBeAbleToUpdateAllMessageTypes,"@Test
public void shouldBeAbleToUpdateAllMessageTypes() throws Throwable
{
    int durationNanos = 5;
    for ( RaftMessages.Type type : RaftMessages.Type.values() )
    {
        metric.updateTimer( type, Duration.ofNanos( durationNanos ) );
        assertEquals( 1, metric.timer( type ).getCount() );
        assertEquals( durationNanos, metric.timer( type ).getSnapshot().getMean(), 0 );
    }
    assertEquals( RaftMessages.Type.values().length, metric.timer().getCount() );
    assertEquals( 0, metric.timer().getSnapshot().getMean(), durationNanos );
}",time,2
169,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testBindNested,"@Test
public void testBindNested() throws Exception {
    final Name name = new CompositeName(""nested/test"");
    final Object value = new Object();
    WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);
    try {
        store.bind(name, value);
    } finally {
        WritableServiceBasedNamingStore.popOwner();
    }
    assertEquals(value, store.lookup(name));
}",test order dependency,4
188,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testLookupBindingUsingNestedContext,"@Test
public void testLookupBindingUsingNestedContext() throws Exception {
    final ServiceName bindingName = ServiceName.JBOSS.append(""foo"", ""bar"", ""baz"", ""TestBean"");
    final Object value = new Object();
    bindObject(bindingName, value);
    Object context = store.lookup(new CompositeName(""foo""));
    assertNotNull(context);
    assertTrue(context instanceof Context);
    Object obj = Context.class.cast(context).lookup(new CompositeName(""bar/baz/TestBean""));
    assertNotNull(obj);
    assertEquals(value, obj);
    context = Context.class.cast(context).lookup(new CompositeName(""bar""));
    obj = Context.class.cast(context).lookup(new CompositeName(""baz/TestBean""));
    assertNotNull(obj);
    assertEquals(value, obj);
    context = Context.class.cast(context).lookup(new CompositeName(""baz""));
    obj = Context.class.cast(context).lookup(new CompositeName(""TestBean""));
    assertNotNull(obj);
    assertEquals(value, obj);
}",test order dependency,4
194,netty_netty,testAutomaticStartStop,"@Test
public void testAutomaticStartStop() throws Exception {
    final TestRunnable task = new TestRunnable(500);
    e.execute(task);
    Thread thread = e.thread;
    assertThat(thread, is(not(nullValue())));
    assertThat(thread.isAlive(), is(true));
    Thread.sleep(1500);
    assertThat(thread.isAlive(), is(false));
    assertThat(task.ran.get(), is(true));
    task.ran.set(false);
    e.execute(task);
    assertThat(e.thread, not(sameInstance(thread)));
    thread = e.thread;
    Thread.sleep(1500);
    assertThat(thread.isAlive(), is(false));
    assertThat(task.ran.get(), is(true));
}",async wait,0
196,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testBind,"@Test
public void testBind() throws Exception {
    Name name = new CompositeName(""test"");
    final Object value = new Object();
    namingContext.bind(name, value);
    assertEquals(value, namingStore.lookup(name));
    name = new CompositeName(""securitytest"");
    testActionPermission(JndiPermission.ACTION_BIND, namingContext, ""securitytest"", value);
    assertEquals(value, namingStore.lookup(name));
}",test order dependency,4
201,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testLookupBinding.2.,"@Test
public void testLookupBinding() throws Exception {
    final ServiceName bindingName = ServiceName.JBOSS.append(""foo"", ""bar"");
    final Object value = new Object();
    bindObject(bindingName, value);
    final Object obj = store.lookup(new CompositeName(""foo/bar""));
    assertNotNull(obj);
    assertEquals(value, obj);
}",test order dependency,4
203,apache_cassandra,testTimeWindows,"@Test
public void testTimeWindows()
{
    Long tstamp1 = 1451001601000L;
    Long tstamp2 = 1451088001000L;
    Long lowHour = 1451001600000L;
    assertTrue(getWindowBoundsInMillis(TimeUnit.HOURS, 1, tstamp1).left.compareTo(lowHour) == 0);
    assertTrue(getWindowBoundsInMillis(TimeUnit.MINUTES, 1, tstamp1).left.compareTo(lowHour) == 0);
    assertTrue(getWindowBoundsInMillis(TimeUnit.DAYS, 1, tstamp1).left.compareTo(lowHour) == 0 );
    assertTrue(getWindowBoundsInMillis(TimeUnit.DAYS, 2, tstamp2).left.compareTo(lowHour) == 0);
    return;
}",time,2
206,apache_kafka,testGracefulClose,"@Test
public void testGracefulClose() throws Exception {
    int maxReceiveCountAfterClose = 0;
    for (int i = 6; i <= 100 && maxReceiveCountAfterClose < 5; i++) {
        int receiveCount = 0;
        KafkaChannel channel = createConnectionWithPendingReceives(i);
        selector.poll(1000);
        assertEquals(1, selector.completedReceives().size());
        server.closeConnections();
        while (selector.disconnected().isEmpty()) {
            selector.poll(1);
            receiveCount += selector.completedReceives().size();
            assertTrue(""Too many completed receives in one poll"", selector.completedReceives().size() <= 1);
        }
        assertEquals(channel.id(), selector.disconnected().keySet().iterator().next());
        maxReceiveCountAfterClose = Math.max(maxReceiveCountAfterClose, receiveCount);
    }
    assertTrue(""Too few receives after close: "" + maxReceiveCountAfterClose, maxReceiveCountAfterClose >= 5);
}",async wait,0
210,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testBindReferenceable,"@Test
public void testBindReferenceable() throws Exception {
    Name name = new CompositeName(""test"");
    final TestObjectReferenceable referenceable = new TestObjectReferenceable(""addr"");
    namingContext.bind(name, referenceable);
    Object result = namingContext.lookup(name);
    assertEquals(referenceable.addr, result);
    name = new CompositeName(""securitytest"");
    testActionPermission(JndiPermission.ACTION_BIND, namingContext, ""securitytest"", referenceable);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, ""securitytest"");
    assertEquals(referenceable.addr, result);
}",test order dependency,4
212,square_okhttp,HttpOverHttp2Test.recoverFromCancelReusesConnection,"@Test
public void recoverFromCancelReusesConnection() throws Exception {
    CountDownLatch responseDequeuedLatch = new CountDownLatch(1);
    CountDownLatch requestCanceledLatch = new CountDownLatch(1);
    QueueDispatcher dispatcher = new QueueDispatcher() {
        @Override
        public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
            MockResponse response = super.dispatch(request);
            responseDequeuedLatch.countDown();
            requestCanceledLatch.await();
            return response;
        }
    };
    server.setDispatcher(dispatcher);
    dispatcher.enqueueResponse(new MockResponse().setBodyDelay(10, TimeUnit.SECONDS).setBody(""abc""));
    dispatcher.enqueueResponse(new MockResponse().setBody(""def""));
    client = client.newBuilder().dns(new DoubleInetAddressDns()).build();
    callAndCancel(0, responseDequeuedLatch, requestCanceledLatch);
    Call call = client.newCall(new Request.Builder().url(server.url(""/"")).build());
    Response response = call.execute();
    assertThat(response.body().string()).isEqualTo(""def"");
    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
}",async wait,0
215,neo4j_neo4j,shouldPickANewServerToWriteToOnLeaderSwitch,"@Test
public void shouldPickANewServerToWriteToOnLeaderSwitch() throws Throwable
{
    cluster = clusterRule.withNumberOfEdgeMembers( 0 ).startCluster();
    CoreClusterMember leader = cluster.awaitLeader();
    CountDownLatch startTheLeaderSwitching = new CountDownLatch( 1 );
    Thread thread = new Thread( () ->
    {
        try
        {
            startTheLeaderSwitching.await();
            CoreClusterMember theLeader = cluster.awaitLeader();
            switchLeader( theLeader );
        }
        catch ( TimeoutException | InterruptedException e )
        {
        }
    } );
    thread.start();
    Config config = Config.build().withLogging( new JULogging( Level.OFF ) ).toConfig();
    try ( Driver driver = GraphDatabase
    .driver( leader.routingURI(), AuthTokens.basic( ""neo4j"", ""neo4j"" ), config ) )
    {
        boolean success = false;
        Set<BoltServerAddress> seenAddresses = new HashSet<>();
        long deadline = System.currentTimeMillis() + (30 * 1000);
        while ( !success )
        {
            if ( System.currentTimeMillis() > deadline )
            {
                fail( ""Failed to write to the new leader in time"" );
            }
            try ( Session session = driver.session( AccessMode.WRITE ) )
            {
                startTheLeaderSwitching.countDown();
                BoltServerAddress boltServerAddress = ((RoutingNetworkSession) session).address();
                seenAddresses.add( boltServerAddress );
                session.run( ""CREATE (p:Person)"" );
                success = seenAddresses.size() >= 2;
            }
            catch ( Exception e )
            {
                Thread.sleep( 100 );
            }
        }
    }
    finally
    {
        thread.join();
    }
}",concurrency,1
217,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testFireAllEvent,"@Test
public void testFireAllEvent() throws Exception {
    final NamingEventCoordinator coordinator = new NamingEventCoordinator();
    final CollectingListener objectListener = new CollectingListener(1);
    coordinator.addListener(""test/path"", EventContext.OBJECT_SCOPE, objectListener);
    final CollectingListener subtreeListener = new CollectingListener(1);
    coordinator.addListener(""test"", EventContext.SUBTREE_SCOPE, subtreeListener);
    final CollectingListener oneLevelListener = new CollectingListener(1);
    coordinator.addListener(""test"", EventContext.ONELEVEL_SCOPE, oneLevelListener);
    coordinator.fireEvent(context, new CompositeName(""test/path""), null, null, NamingEvent.OBJECT_ADDED, ""bind"", EventContext.OBJECT_SCOPE, EventContext.ONELEVEL_SCOPE, EventContext.SUBTREE_SCOPE);
    objectListener.latch.await(1, TimeUnit.SECONDS);
    oneLevelListener.latch.await(1, TimeUnit.SECONDS);
    subtreeListener.latch.await(1, TimeUnit.SECONDS);
    assertEquals(1, objectListener.capturedEvents.size());
    assertEquals(1, subtreeListener.capturedEvents.size());
    assertEquals(1, oneLevelListener.capturedEvents.size());
}",test order dependency,4
219,graylog2_graylog2-server,KafkaJournalTest.serverStatusThrottledIfJournalUtilizationIsHigherThanThreshold,"@Test
public void serverStatusThrottledIfJournalUtilizationIsHigherThanThreshold() throws Exception {
    serverStatus.running();
    final Size segmentSize = Size.kilobytes(1L);
    final KafkaJournal journal = new KafkaJournal(journalDirectory, scheduler, segmentSize, Duration.standardSeconds(1L), Size.kilobytes(4L), Duration.standardSeconds(1L), 1000000, Duration.standardSeconds(1L), 90, new MetricRegistry(), serverStatus);
    createBulkChunks(journal, segmentSize, 4);
    journal.flushDirtyLogs();
    journal.cleanupLogs();
    assertThat(serverStatus.getLifecycle()).isEqualTo(THROTTLED);
}",concurrency,1
220,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testRebind,"@Test
public void testRebind() throws Exception {
    final Name name = new CompositeName(""test"");
    final Object value = new Object();
    namingStore.bind(name, value);
    Object newValue = new Object();
    namingContext.rebind(name, newValue);
    assertEquals(newValue, namingStore.lookup(name));
    newValue = new Object();
    testActionPermission(JndiPermission.ACTION_REBIND, namingContext, ""test"", newValue);
    assertEquals(newValue, namingStore.lookup(name));
}",test order dependency,4
221,commercetools-project-sync,InventoryEntrySyncerTest.syncWithError_ShouldCallErrorCallback,"@Test
void syncWithError_ShouldCallErrorCallback() {
    final TestLogger syncerTestLogger = TestLoggerFactory.getTestLogger(InventoryEntrySyncer.class);
    final SphereClient sourceClient = mock(SphereClient.class);
    final SphereClient targetClient = mock(SphereClient.class);
    when(sourceClient.getConfig()).thenReturn(SphereApiConfig.of(""source-project""));
    when(targetClient.getConfig()).thenReturn(SphereApiConfig.of(""target-project""));
    final List<InventoryEntry> inventoryEntries = Collections.singletonList(readObjectFromResource(""inventory-no-sku.json"", InventoryEntry.class));
    final PagedQueryResult<InventoryEntry> pagedQueryResult = mock(PagedQueryResult.class);
    when(pagedQueryResult.getResults()).thenReturn(inventoryEntries);
    when(sourceClient.execute(any(InventoryEntryQuery.class))).thenReturn(CompletableFuture.completedFuture(pagedQueryResult));
    final InventoryEntrySyncer inventoryEntrySyncer = InventoryEntrySyncer.of(sourceClient, targetClient, mock(Clock.class));
    inventoryEntrySyncer.sync(null, true).toCompletableFuture().join();
    final LoggingEvent errorLog = syncerTestLogger.getAllLoggingEvents().get(1);
    assertThat(errorLog.getMessage()).isEqualTo(""Error when trying to sync inventory entry. Existing key: <<not present>>. Update actions: []"");
    assertThat(errorLog.getThrowable().get().getMessage()).isEqualTo(""InventoryEntryDraft doesn't have a SKU. Please make sure all inventory entry drafts have SKUs."");
}",test order dependency,4
223,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testList,"@Test
public void testList() throws Exception {
    bindList();
    NamingEnumeration<NameClassPair> results = namingContext.list(new CompositeName());
    checkListResults(results);
    results = (NamingEnumeration<NameClassPair>) testActionPermission(JndiPermission.ACTION_LIST, namingContext, null);
    checkListResults(results);
}",test order dependency,4
231,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testListBindings,"@Test
public void testListBindings() throws Exception {
    bindList();
    NamingEnumeration<Binding> results = namingContext.listBindings(new CompositeName());
    checkListResults(results);
    results = (NamingEnumeration<Binding>) testActionPermission(JndiPermission.ACTION_LIST_BINDINGS, namingContext, null);
    checkListResults(results);
}",test order dependency,4
232,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testListWithContinuation,"@Test
public void testListWithContinuation() throws Exception {
    bindListWithContinuations();
    NamingEnumeration<NameClassPair> results = namingContext.list(new CompositeName(""comp""));
    checkListWithContinuationsResults(results);
    results = (NamingEnumeration<NameClassPair>) testActionPermission(JndiPermission.ACTION_LIST, Arrays.asList(
    new JndiPermission(""test"", ""list"")), namingContext, ""comp"");
    checkListWithContinuationsResults(results);
}",test order dependency,4
244,kiwiproject_dropwizard-service-utilities,SystemExecutionerTest.shouldExitBeforeGivenWaitTime_WhenWaitingThreadInterrupted,"@Test
void shouldExitBeforeGivenWaitTime_WhenWaitingThreadInterrupted() {
    var executorService = Executors.newFixedThreadPool(2);
    var executionStrategy = new ExecutionStrategies.ExitFlaggingExecutionStrategy();
    var executioner = new SystemExecutioner(executionStrategy);
    var startTime = new AtomicLong();
    var executionFuture = executorService.submit(() -> {
        LOG.info(""Calling executioner with 5 second wait"");
        startTime.set(System.nanoTime());
        executioner.exit(5, TimeUnit.SECONDS);
    });
    var killerSleepTimeMillis = 100;
    var killerFuture = executorService.submit(() -> {
        LOG.info(""Sleeping for {} milliseconds..."", killerSleepTimeMillis);
        new DefaultEnvironment().sleepQuietly(killerSleepTimeMillis, TimeUnit.MILLISECONDS);
        LOG.info(""I'm awake and will now interrupt executionThread"");
        var canceled = executionFuture.cancel(true);
        LOG.info(""executionFuture was canceled? {}"", canceled);
    });
    await().atMost(ONE_SECOND).until(() -> executionFuture.isDone() && killerFuture.isDone());
    long elapsedNanos = System.nanoTime() - startTime.get();
    assertThat(executionStrategy.didExit()).describedAs(""Execution strategy exit() should have been called"").isTrue();
    assertThat(TimeUnit.NANOSECONDS.toMillis(elapsedNanos)).describedAs(""Elapsed millis must be greater than %d"", killerSleepTimeMillis).isGreaterThan(killerSleepTimeMillis);
    executorService.shutdown();
    await().atMost(ONE_SECOND).until(executorService::isShutdown);
}",time,2
246,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testLookupNameNotFound,"@Test
public void testLookupNameNotFound() throws Exception {
    try {
        namingContext.lookup(new CompositeName(""test""));
        fail(""Should have thrown and NameNotFoundException"");
    } catch (NameNotFoundException expected) {
    }
    try {
        testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, ""test"");
        fail(""Should have thrown and NameNotFoundException with appropriate permissions"");
    } catch (NameNotFoundException expected) {
    }
}",test order dependency,4
249,spring-projects_spring-framework,validUsage,"@Test
void validUsage() throws Exception {
    assertThat(stopWatch.isRunning()).isFalse();
    stopWatch.start(name1);
    Thread.sleep(duration1);
    assertThat(stopWatch.isRunning()).isTrue();
    assertThat(stopWatch.currentTaskName()).isEqualTo(name1);
    stopWatch.stop();
    assertThat(stopWatch.isRunning()).isFalse();
    assertThat(stopWatch.getLastTaskTimeNanos())
    .as(""last task time in nanoseconds for task #2"")
    .isGreaterThanOrEqualTo(millisToNanos(duration2))
    .isLessThanOrEqualTo(millisToNanos(duration2 + fudgeFactor));
    assertThat(stopWatch.getTotalTimeMillis())
    .as(""total time in milliseconds for tasks #1 and #2"")
    .isGreaterThanOrEqualTo(duration1 + duration2 - fudgeFactor)
    .isLessThanOrEqualTo(duration1 + duration2 + fudgeFactor);
    assertThat(stopWatch.getTotalTimeSeconds())
    .as(""total time in seconds for task #2"")
    .isGreaterThanOrEqualTo((duration1 + duration2 - fudgeFactor) / 1000.0)
    .isLessThanOrEqualTo((duration1 + duration2 + fudgeFactor) / 1000.0);
    assertThat(stopWatch.getTaskCount()).isEqualTo(2);
    assertThat(stopWatch.prettyPrint()).contains(name1, name2);
    assertThat(stopWatch.getTaskInfo()).extracting(TaskInfo::getTaskName).containsExactly(name1, name2);
    assertThat(stopWatch.toString()).contains(ID, name1, name2);
    assertThat(stopWatch.getId()).isEqualTo(ID);
}",time,2
253,neo4j_neo4j,RobustJobSchedulerWrapperTest.recurringJobWithErrorShouldStop,"@Test
public void recurringJobWithErrorShouldStop() throws Exception
{
    RobustJobSchedulerWrapper robustWrapper = new RobustJobSchedulerWrapper( actualScheduler, log );
    AtomicInteger count = new AtomicInteger();
    Error e = new Error();
    JobHandle jobHandle = robustWrapper.scheduleRecurring( ""JobName"", 1, () ->{
        count.incrementAndGet();
        throw e;
    }
    );
    Thread.sleep( 50 );
    assertEventually( ""run count"", count::get, Matchers.equalTo( 1 ), DEFAULT_TIMEOUT_MS , MILLISECONDS );
    robustWrapper.cancelAndWaitTermination( jobHandle );
    verify( log, timeout( DEFAULT_TIMEOUT_MS ).times( 1 ) ).error( ""Uncaught error rethrown"", e );
}",concurrency,1
260,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testRebindReferenceable,"@Test
public void testRebindReferenceable() throws Exception {
    final Name name = new CompositeName(""test"");
    final TestObjectReferenceable referenceable = new TestObjectReferenceable(""addr"");
    namingContext.bind(name, referenceable);
    TestObjectReferenceable newReferenceable = new TestObjectReferenceable(""newAddr"");
    namingContext.rebind(name, newReferenceable);
    Object result = namingContext.lookup(name);
    assertEquals(newReferenceable.addr, result);
    newReferenceable = new TestObjectReferenceable(""yetAnotherNewAddr"");
    testActionPermission(JndiPermission.ACTION_REBIND, namingContext, ""test"", newReferenceable);
    result = namingContext.lookup(name);
    assertEquals(newReferenceable.addr, result);
}",test order dependency,4
268,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testRebind.2,"@Test
public void testRebind() throws Exception {
    final Name name = new CompositeName(""test"");
    final Object value = new Object();
    final Object newValue = new Object();
    WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);
    try {
        store.bind(name, value);
        store.rebind(name, newValue);
    } finally {
        WritableServiceBasedNamingStore.popOwner();
    }
    assertEquals(newValue, store.lookup(name));
}",test order dependency,4
269,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testUnbind,"@Test
public void testUnbind() throws Exception {
    final Name name = new CompositeName(""test"");
    final Object value = new Object();
    namingStore.bind(name, value);
    namingContext.unbind(name);
    try {
        namingStore.lookup(name);
        fail(""Should have thrown name not found"");
    } catch (NameNotFoundException expect) {}
    testActionPermission(JndiPermission.ACTION_BIND, namingContext, ""test"", value);
    testActionPermission(JndiPermission.ACTION_UNBIND, namingContext, ""test"");
    try {
        namingStore.lookup(name);
        fail(""Should have thrown name not found"");
    } catch (NameNotFoundException expect) {}
}",test order dependency,4
271,ReactiveX_RxJava,TestSchedulers.testSchedulingWithDueTime,"@Test
public void testSchedulingWithDueTime() throws InterruptedException {
    final CountDownLatch latch = new CountDownLatch(5);
    final AtomicInteger counter = new AtomicInteger();
    long start = System.currentTimeMillis();
    Schedulers.threadPoolForComputation().schedule(null, new Func2<Scheduler, String, Subscription>() {
        @Override
        public Subscription call(Scheduler scheduler, String state) {
            System.out.println(""doing work"");
            latch.countDown();
            counter.incrementAndGet();
            if (latch.getCount() == 0) {
                return Subscriptions.empty();
            } else {
                return scheduler.schedule(state, this, new Date(System.currentTimeMillis() + 50));
            }
        }
    }, new Date(System.currentTimeMillis() + 100));
    if (!latch.await(3000, TimeUnit.MILLISECONDS)) {
        fail(""didn't execute ... timed out"");
    }
    long end = System.currentTimeMillis();
    assertEquals(5, counter.get());
    if ((end - start) < 250) {
        fail(""it should have taken over 250ms since each step was scheduled 50ms in the future"");
    }
}",concurrency,1
273,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testFireMultipleLevelEvent,"@Test
public void testFireMultiLevelEvent() throws Exception {
    final NamingEventCoordinator coordinator = new NamingEventCoordinator();
    final CollectingListener subtreeListener = new CollectingListener(1);
    coordinator.addListener(""foo"", EventContext.SUBTREE_SCOPE, subtreeListener);
    final CollectingListener subtreeListenerTwo = new CollectingListener(1);
    coordinator.addListener(""foo/bar"", EventContext.SUBTREE_SCOPE, subtreeListenerTwo);
    final CollectingListener subtreeListenerThree = new CollectingListener(1);
    coordinator.addListener(""foo/bar/baz"", EventContext.SUBTREE_SCOPE, subtreeListenerThree);
    coordinator.fireEvent(context, new CompositeName(""foo/bar/baz/boo""), null, null, NamingEvent.OBJECT_ADDED, ""bind"", EventContext.OBJECT_SCOPE, EventContext.ONELEVEL_SCOPE, EventContext.SUBTREE_SCOPE);
    subtreeListener.latch.await(1, TimeUnit.SECONDS);
    subtreeListenerTwo.latch.await(1, TimeUnit.SECONDS);
    subtreeListenerThree.latch.await(1, TimeUnit.SECONDS);
    assertEquals(1, subtreeListener.capturedEvents.size());
    assertEquals(1, subtreeListenerTwo.capturedEvents.size());
    assertEquals(1, subtreeListenerThree.capturedEvents.size());
}",test order dependency,4
275,androidx_androidx,testOneTimeRequest_noInitialDelay,"@Test
public void testOneTimeRequest_noInitialDelay() {
    val request = OneTimeWorkRequestBuilder<TestWorker>().build();
    val task = mTaskConverter.convert(request.workSpec);
    assertEquals(task.serviceName, WorkManagerGcmService::class.java.name);
    assertEquals(task.isPersisted, false);
    assertEquals(task.isUpdateCurrent, true);
    assertEquals(task.requiredNetwork, Task.NETWORK_STATE_ANY);
    assertEquals(task.requiresCharging, false);
    assertEquals(task.windowStart, 0L);
    assertEquals(task.windowEnd, 0L + EXECUTION_WINDOW_SIZE_IN_SECONDS);
}",time,2
277,androidx_androidx,testGettersAfterConnected,"@Test
public void testGettersAfterConnected() throws InterruptedException {
    prepareLooper();
    final int state = MediaPlayerBase.PLAYER_STATE_PLAYING;
    final long position = 150000;
    final long bufferedPosition = 900000;
    final float speed = 0.5f;
    mPlayer.mLastPlayerState = state;
    mPlayer.mCurrentPosition = position;
    mPlayer.mBufferedPosition = bufferedPosition;
    mPlayer.mPlaybackSpeed = speed;
    long time = System.currentTimeMillis();
    MediaController2 controller = createController(mSession.getToken());
    assertEquals(state, controller.getPlayerState());
    assertEquals(bufferedPosition, controller.getBufferedPosition());
    assertEquals(speed, controller.getPlaybackSpeed());
    long elapsedTime = System.currentTimeMillis() - time;
    final long tolerance = 10;
    assertEquals(position + speed * elapsedTime, controller.getCurrentPosition(), tolerance);
}",time,2
278,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testFireSubTreeEvent,"@Test
public void testFireSubTreeEvent() throws Exception {
    final NamingEventCoordinator coordinator = new NamingEventCoordinator();
    final CollectingListener objectListener = new CollectingListener(0);
    coordinator.addListener(""test/path"", EventContext.OBJECT_SCOPE, objectListener);
    final CollectingListener subtreeListener = new CollectingListener(1);
    coordinator.addListener(""test"", EventContext.SUBTREE_SCOPE, subtreeListener);
    final CollectingListener oneLevelListener = new CollectingListener(0);
    coordinator.addListener(""test"", EventContext.ONELEVEL_SCOPE, oneLevelListener);
    coordinator.fireEvent(context, new CompositeName(""test/path""), null, null, NamingEvent.OBJECT_ADDED, ""bind"", EventContext.SUBTREE_SCOPE);
    subtreeListener.latch.await(1, TimeUnit.SECONDS);
    assertTrue(objectListener.capturedEvents.isEmpty());
    assertTrue(oneLevelListener.capturedEvents.isEmpty());
    assertEquals(1, subtreeListener.capturedEvents.size());
}",test order dependency,4
284,apache_cassandra,testWithMismatchingPending,"@Test
public void testWithMismatchingPending() throws Throwable
{
    try(Cluster cluster = init(Cluster.build(2).withConfig(config -> config.with(GOSSIP).with(NETWORK)).start()))
    {
        cluster.schemaChange(""create table "" + KEYSPACE + "".tbl (id int primary key, t int)"");
        insert(cluster.coordinator(1), 0, 100);
        cluster.forEach((node) -> node.flush(KEYSPACE));
        cluster.get(1).callOnInstance(repair(options(false)));
        insert(cluster.coordinator(1), 100, 100);
        cluster.forEach((node) -> node.flush(KEYSPACE));
        cluster.forEach((node) -> node.runOnInstance(() -> {
            ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(""tbl"");
            FBUtilities.waitOnFutures(CompactionManager.instance.submitBackground(cfs));
            cfs.disableAutoCompaction();
        }));
        cluster.get(1).callOnInstance(repair(options(false)));
        cluster.get(1).runOnInstance(() -> {
            ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(""tbl"");
            cfs.enableAutoCompaction();
            FBUtilities.waitOnFutures(CompactionManager.instance.submitBackground(cfs));
        });
        RepairResult rs = cluster.get(1).callOnInstance(repair(options(true)));
        assertTrue(rs.success);
        assertFalse(rs.wasInconsistent);
    }
}",concurrency,1
285,neo4j_neo4j,shouldBuildUpGracefullyUntilReachedMinPoolSize,"@Test
public void shouldBuildUpGracefullyUntilReachedMinPoolSize() throws InterruptedException
{
    StatefulMonitor stateMonitor = new StatefulMonitor();
    FakeClock clock = new FakeClock();
    final LinkedQueuePool<Object> pool = getLinkedQueuePool( stateMonitor, clock, 5 );
    ExecutorService executor = Executors.newCachedThreadPool();
    List<FlyweightHolder<Object>> flyweightHolders = acquireFromPool( pool, 5, executor );
    executor.shutdown();
    for ( FlyweightHolder<Object> flyweightHolder : flyweightHolders )
    {
        flyweightHolder.release();
    }
    executor.awaitTermination( 10, TimeUnit.SECONDS );
    assertEquals( -1, stateMonitor.currentPeakSize.get() );
    assertEquals( -1, stateMonitor.targetSize.get() );
    assertEquals( 0, stateMonitor.disposed.get() );
}",concurrency,1
287,apache_commons-lang,RecursiveToStringStyleTest.testPerson,"@Test
public void testPerson() {
    final Person p = new Person();
    p.name = ""John Doe"";
    p.age = 33;
    p.smoker = false;
    p.job = new Job();
    p.job.title = ""Manager"";
    final String pBaseStr = (p.getClass().getName() + ""@"") + Integer.toHexString(System.identityHashCode(p));
    final String pJobStr = (p.job.getClass().getName() + ""@"") + Integer.toHexString(System.identityHashCode(p.job));
    assertEquals(((pBaseStr + ""[name=John Doe,age=33,smoker=false,job="") + pJobStr) + ""[title=Manager]]"", new ReflectionToStringBuilder(p, new RecursiveToStringStyle()).toString());
}",unordered collections,3
289,opensearch-project_OpenSearch,testListenerFailures,"@Test
public void testListenerFailures() throws InterruptedException {
    int iters = iterations(10, 100);
    for (int i = 0; i < iters; i++) {
        try (TestIteration iteration = new TestIteration()) {
            iteration.transport.endConnectMode();
            final CountDownLatch latch = new CountDownLatch(1);
            final AtomicInteger finalFailures = new AtomicInteger();
            final AtomicReference<Throwable> finalFailure = new AtomicReference<>();
            final AtomicReference<TestResponse> response = new AtomicReference<>();
            ActionListener<TestResponse> actionListener = new ActionListener<TestResponse>();
            final AtomicInteger preSendFailures = new AtomicInteger();
            iteration.transportClientNodesService.execute((node, retryListener) -> {
                if (rarely()) {
                    preSendFailures.incrementAndGet();
                    throw new IllegalArgumentException();
                }
                iteration.transportService.sendRequest(node, ""action"", new TestRequest(),
                TransportRequestOptions.EMPTY, new TransportResponseHandler<TestResponse>() {
                }, actionListener);
                assertThat(latch.await(1, TimeUnit.SECONDS), equalTo(true));
                assertThat(preSendFailures.get() + iteration.transport.failures() + iteration.transport.successes(), lessThanOrEqualTo(1));
                if (iteration.transport.successes() == 1) {
                    assertThat(finalFailures.get(), equalTo(0));
                    assertThat(finalFailure.get(), nullValue());
                    assertThat(response.get(), notNullValue());
                } else {
                    assertThat(finalFailures.get(), equalTo(1));
                    assertThat(finalFailure.get(), notNullValue());
                    assertThat(response.get(), nullValue());
                    if (preSendFailures.get() == 0 && iteration.transport.failures() == 0) {
                        assertThat(finalFailure.get(), instanceOf(NoNodeAvailableException.class));
                    }
                }
                assertThat(iteration.transport.triedNodes().size(), lessThanOrEqualTo(iteration.listNodesCount));
                assertThat(iteration.transport.triedNodes().size(), equalTo(iteration.transport.connectTransportExceptions() + iteration.transport.failures() + iteration.transport.successes()));
            });
        }
    }
}",async wait,0
290,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testListBindingsNameNotFound,"@Test
public void testListBindingsNameNotFound() throws Exception {
    try {
        namingContext.listBindings(new CompositeName(""test""));
        fail(""Should have thrown and NameNotFoundException"");
    } catch (NameNotFoundException expected) {
    }
    try {
        testActionPermission(JndiPermission.ACTION_LIST_BINDINGS, namingContext, ""test"");
        fail(""Should have thrown and NameNotFoundException with appropriate permissions"");
    } catch (NameNotFoundException expected) {
    }
}",test order dependency,4
293,neo4j_neo4j,schema.IndexPopulationIT.shutdownDatabaseDuringIndexPopulations,"@Test
public void shutdownDatabaseDuringIndexPopulations() {
    AssertableLogProvider assertableLogProvider = new AssertableLogProvider(true);
    File storeDir = directory.directory(""shutdownDbTest"");
    Label testLabel = Label.label(""testLabel"");
    String propertyName = ""testProperty"";
    GraphDatabaseService shutDownDb = new TestGraphDatabaseFactory().setInternalLogProvider(assertableLogProvider).newEmbeddedDatabase(storeDir);
    prePopulateDatabase(shutDownDb, testLabel, propertyName);
    try (final Transaction transaction = shutDownDb.beginTx()) {
        shutDownDb.schema().indexFor(testLabel).on(propertyName).create();
        transaction.success();
    }
    shutDownDb.shutdown();
    assertableLogProvider.assertNone(AssertableLogProvider.inLog(IndexPopulationJob.class).anyError());
}",concurrency,1
297,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testRegisterURLSchemeHandler,"@Test
public void testRegisterURLSchemeHandler() throws Exception {
    InitialContext ictx = new InitialContext(null);
    try {
        ictx.lookup(""foobar:something"");
        Assert.fail(""Precondition: the foobar: scheme should not yet be registered"");
    } catch (NamingException ne) {
    }
    ObjectFactory tof = new TestObjectFactory();
    InitialContext.addUrlContextFactory(""foobar"", tof);
    String something = (String) ictx.lookup(""foobar:something"");
    Assert.assertTrue(""The object should now be provided by our TestObjectFactory"", something.startsWith(""TestObject:""));
    try {
        InitialContext.removeUrlContextFactory(""foobar:"", new TestObjectFactory());
        Assert.fail(""Should throw an IllegalArgumentException since the associated factory object doesn't match the registration"");
    } catch (IllegalArgumentException iae) {
    }
    Assert.assertEquals(""The foobar: scheme should still be registered"", something, ictx.lookup(""foobar:something""));
    InitialContext.removeUrlContextFactory(""foobar"", tof);
    try {
        ictx.lookup(""foobar:something"");
        Assert.fail(""The foobar: scheme should not be registered any more"");
    } catch (NamingException ne) {
    }
}",test order dependency,4
303,graylog2_graylog2-server,ContentPackTest.shouldDeserializeSerializedContentPack,"@Test
public void shouldDeserializeSerializedContentPack() throws Exception {
    final ContentPack contentPack = createTestContentPack();
    final URL contentPackURL = ContentPackTest.class.getResource(""expected_content_pack.json"");
    Path path = Paths.get(contentPackURL.toURI());
    String expectedJSON = String.join("""", Files.readAllLines(path)).replace(""\n"", """").replace(""\r"", """");
    final String jsonTxt = objectMapper.writeValueAsString(contentPack);
    assertThat(jsonTxt).isEqualTo(expectedJSON);
    final ContentPack readContentPack = objectMapper.readValue(jsonTxt, ContentPack.class);
    assertThat(readContentPack.id()).isEqualTo(contentPack.id());
    assertThat(readContentPack.version()).isEqualTo(contentPack.version());
    assertThat(readContentPack.revision()).isEqualTo(contentPack.revision());
}",unordered collections,3
309,apache_kafka,testForceMetadataRefreshForPatternSubscriptionDuringRebalance,"@Test
public void testForceMetadataRefreshForPatternSubscriptionDuringRebalance() {
    final String consumerId = ""consumer"";
    subscriptions.subscribe(Pattern.compile("".*""), rebalanceListener);
    client.updateMetadata(TestUtils.metadataUpdateWith(1, singletonMap(topic1, 1)));
    assertEquals(singleton(topic1), subscriptions.subscription());
    client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    client.prepareMetadataUpdate(metadataResponse);
    client.prepareResponse(joinGroupFollowerResponse(1, consumerId, ""leader"", Errors.NONE));
    client.prepareResponse(new MockClient.RequestMatcher() {
        @Override
        public boolean matches(AbstractRequest body) {
            SyncGroupRequest sync = (SyncGroupRequest) body;
            return sync.memberId().equals(consumerId) &&
            sync.generationId() == 1 &&
            sync.groupAssignment().isEmpty();
        }
    }, syncGroupResponse(singletonList(t1p), Errors.NONE));
    partitionAssignor.prepare(singletonMap(consumerId, singletonList(t1p)));
    coordinator.poll(time.timer(Long.MAX_VALUE));
    final Set<String> updatedSubscriptionSet = new HashSet<>(Arrays.asList(topic1, topic2));
    assertEquals(updatedSubscriptionSet, subscriptions.subscription());
    metadata.requestUpdate();
    client.poll(Long.MAX_VALUE, time.milliseconds());
    assertFalse(coordinator.rejoinNeededOrPending());
}",concurrency,1
310,apache_cassandra,testTrackMetadata_rowMarkerDelete,"@Test
public void testTrackMetadata_rowMarkerDelete() throws Throwable
{
    createTable(""CREATE TABLE %s (a int, PRIMARY KEY (a))"");
    ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(currentTable());
    execute(""DELETE FROM %s USING TIMESTAMP 9999 WHERE a=1"");
    cfs.forceBlockingFlush();
    assertEquals(1, cfs.getLiveSSTables().size());
    StatsMetadata metadata = cfs.getLiveSSTables().iterator().next().getSSTableMetadata();
    assertEquals(9999, metadata.minTimestamp);
    assertEquals(9999, metadata.maxTimestamp);
    assertEquals(System.currentTimeMillis()/1000, metadata.maxLocalDeletionTime, 5);
    cfs.forceMajorCompaction();
    StatsMetadata metadata2 = cfs.getLiveSSTables().iterator().next().getSSTableMetadata();
    assertEquals(metadata.maxLocalDeletionTime, metadata2.maxLocalDeletionTime);
    assertEquals(metadata.minTimestamp, metadata2.minTimestamp);
    assertEquals(metadata.maxTimestamp, metadata2.maxTimestamp);
}",time,2
311,apache_cassandra,testTrackMetadata_rowTombstone,"@Test
public void testTrackMetadata_rowTombstone() throws Throwable
{
    createTable(""CREATE TABLE %s (a int, b int, c text, PRIMARY KEY (a, b))"");
    ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(currentTable());
    execute(""DELETE FROM %s USING TIMESTAMP 9999 WHERE a = 1"");
    cfs.forceBlockingFlush();
    assertEquals(1, cfs.getLiveSSTables().size());
    StatsMetadata metadata = cfs.getLiveSSTables().iterator().next().getSSTableMetadata();
    assertEquals(9999, metadata.minTimestamp);
    assertEquals(9999, metadata.maxTimestamp);
    assertEquals(System.currentTimeMillis()/1000, metadata.maxLocalDeletionTime, 5);
    assertEquals(nowInSec(), metadata.maxLocalDeletionTime, DELTA);
    cfs.forceMajorCompaction();
    StatsMetadata metadata2 = cfs.getLiveSSTables().iterator().next().getSSTableMetadata();
    assertEquals(metadata.maxLocalDeletionTime, metadata2.maxLocalDeletionTime);
    assertEquals(metadata.minTimestamp, metadata2.minTimestamp);
    assertEquals(metadata.maxTimestamp, metadata2.maxTimestamp);
}",time,2
312,androidx_androidx,testPredictiveLayoutAdd2,"@Test
public void testPredictiveLayoutAdd2() throws Throwable {
    preparePredictiveLayout();
    mActivityTestRule.runOnUiThread(new Runnable() {
        @Override
        public void run() {
            mActivity.addItems(50, new int[]{300, 300, 300, 300});
        }
    });
    waitForItemAnimationStart();
    waitForItemAnimation(5000);
    assertEquals(54, mGridView.getSelectedPosition());
    assertEquals(RecyclerView.SCROLL_STATE_IDLE, mGridView.getScrollState());
}",async wait,0
313,androidx_androidx,onReceive,"@Test
public class Test {
    public void onReceive() {
        object broadcastReceiver = TestBroadcast();
        context.registerReceiver(
        broadcastReceiver,
        IntentFilter(BROADCAST_ACTION)
        );
        String value = ""value"" ;
        context.sendBroadcast(Intent(BROADCAST_ACTION).putExtra(EXTRA_STRING, value));
        shadowOf(getMainLooper()).idle() ;
        assertWithMessage(""Broadcast receiver did not execute"")
        .that(broadcastReceiver.broadcastExecuted.await(1, SECONDS))
        .isTrue();
        assertThat(broadcastReceiver.extraValue.get()).isEqualTo(value);
        assertThat(broadcastReceiver.job.get().isCancelled).isTrue();
    }
}",async wait,0
315,square_okhttp,DuplexTest.duplexWithRedirect,"@Test
public void duplexWithRedirect() throws Exception {
    enableProtocol(HTTP_2);
    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(new MockResponse().clearHeaders().setResponseCode(HttpURLConnection.HTTP_MOVED_PERM).addHeader(""Location: /b""), new MockDuplexResponseBody().sendResponse(""/a has moved!\n"").requestIOException().exhaustResponse());
    server.enqueue(new MockResponse().setBody(""this is /b""));
    Call call = client.newCall(new Request.Builder().url(server.url(""/"")).post(new AsyncRequestBody()).build());
    try (final Response response = call.execute()) {
        BufferedSource responseBody = response.body().source();
        assertThat(responseBody.readUtf8Line()).isEqualTo(""this is /b"");
    }
    BufferedSink requestBody = ((AsyncRequestBody) (call.request().body())).takeSink();
    try {
        requestBody.writeUtf8(""request body\n"");
        requestBody.flush();
        fail();
    } catch (IOException expected) {
        assertThat(expected.getMessage()).isEqualTo(""stream was reset: CANCEL"");
    }
    mockDuplexResponseBody.awaitSuccess();
    assertThat(listener.recordedEventTypes()).containsExactly(""CallStart"", ""DnsStart"", ""DnsEnd"", ""ConnectStart"", ""SecureConnectStart"", ""SecureConnectEnd"", ""ConnectEnd"", ""ConnectionAcquired"", ""RequestHeadersStart"", ""RequestHeadersEnd"", ""RequestBodyStart"", ""ResponseHeadersStart"", ""ResponseHeadersEnd"", ""ResponseBodyStart"", ""ResponseBodyEnd"", ""RequestHeadersStart"", ""RequestHeadersEnd"", ""ResponseHeadersStart"", ""ResponseHeadersEnd"", ""ResponseBodyStart"", ""ResponseBodyEnd"", ""ConnectionReleased"", ""CallEnd"", ""RequestFailed"");
}",async wait,0
319,liquibase_liquibase,DependencyUtilTest.testIndependentBranchesCase,"@Test
public void testIndependentBranchesCase() {
    graph.add(""a"", ""b"");
    graph.add(""b"", ""c1"");
    graph.add(""b"", ""c2"");
    graph.add(""o"", ""p1"");
    graph.add(""p1"", ""r1"");
    graph.add(""r1"", ""s"");
    graph.add(""o"", ""p2"");
    graph.add(""p2"", ""r2"");
    graph.add(""r2"", ""s2"");
    graph.add(""r2"", ""s3"");
    graph.add(""x"", ""y"");
    graph.computeDependencies();
    List<String> expected =
    Arrays.asList(""a"", ""o"", ""x"", ""b"", ""p1"", ""p2"", ""y"", ""c1"", ""c2"", ""r1"", ""r2"", ""s"", ""s2"", ""s3"");
    Assert.assertEquals(expected, dependencyOrder);
}",unordered collections,3
322,triplea-game_triplea,close,"@Test
void close() throws Exception {
    when(webSocketClient.getConnection()).thenReturn(webSocket);
    when(webSocketClient.isOpen()).thenReturn(true);
    webSocketConnection.close();
    Thread.sleep(10);
    verify(webSocket).close();
}",async wait,0
330,androidx_androidx,invalidationInAnotherInstance_closed,"@Test
public void invalidationInAnotherInstance_closed() throws Exception {
    final SampleDatabase db1 = openDatabase(true);
    final SampleDatabase db2 = openDatabase(true);
    final SampleDatabase db3 = openDatabase(true);
    final CountDownLatch invalidated1 = prepareTableObserver(db1);
    final Pair<CountDownLatch, CountDownLatch> changed1 = prepareLiveDataObserver(db1);
    final CountDownLatch invalidated2 = prepareTableObserver(db2);
    final Pair<CountDownLatch, CountDownLatch> changed2 = prepareLiveDataObserver(db2);
    final CountDownLatch invalidated3 = prepareTableObserver(db3);
    final Pair<CountDownLatch, CountDownLatch> changed3 = prepareLiveDataObserver(db3);
    db2.getCustomerDao().insert(CUSTOMER_1);
    assertTrue(invalidated1.await(3, TimeUnit.SECONDS));
    assertTrue(changed1.first.await(3, TimeUnit.SECONDS));
    assertTrue(invalidated2.await(3, TimeUnit.SECONDS));
    assertTrue(changed2.first.await(3, TimeUnit.SECONDS));
    assertTrue(invalidated3.await(3, TimeUnit.SECONDS));
    assertTrue(changed3.first.await(3, TimeUnit.SECONDS));
    db3.close();
    db2.getCustomerDao().insert(CUSTOMER_2);
    assertTrue(changed1.second.await(3, TimeUnit.SECONDS));
    assertTrue(changed2.second.await(3, TimeUnit.SECONDS));
    assertFalse(changed3.second.await(300, TimeUnit.MILLISECONDS));
}",async wait,0
331,androidx_androidx,testSetCallbackWithNull,"@Test
public void testSetCallbackWithNull() throws Exception {
    mSession.setActive(true);
    mCallback.reset(1);
    mSession.setCallback(null, mHandler);
    assertEquals(""Callback shouldn't be called."", 0, mCallback.mOnPlayCalledCount);
}",async wait,0
337,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testOnlyExternalContextAllowsCache,"@Test
public void testOnlyExternalContextAllowsCache() throws Exception {
    KernelServices services = createKernelServicesBuilder(AdditionalInitialization.MANAGEMENT)
    .build();
    Assert.assertTrue(services.isSuccessfulBoot());
    List<ModelNode> list = parse(ModelTestUtils.readResource(this.getClass(), ""subsystem.xml""));
    for (ModelNode addOp : list) {
        PathAddress addr = PathAddress.pathAddress(addOp.require(ModelDescriptionConstants.OP_ADDR));
        if (addr.size() == 2 && addr.getLastElement().getKey().equals(NamingSubsystemModel.BINDING) && BindingType.forName(addOp.get(NamingBindingResourceDefinition.BINDING_TYPE.getName()).asString()) != BindingType.EXTERNAL_CONTEXT) {
            addOp.get(NamingBindingResourceDefinition.CACHE.getName()).set(true);
            services.executeForFailure(addOp);
            addOp.remove(NamingBindingResourceDefinition.CACHE.getName());
            ModelTestUtils.checkOutcome(services.executeOperation(addOp));
            ModelTestUtils.checkFailed(services.executeOperation(Util.getWriteAttributeOperation(addr, NamingBindingResourceDefinition.CACHE.getName(), new ModelNode(true))));
        } else {
            ModelTestUtils.checkOutcome(services.executeOperation(addOp));
        }
    }",test order dependency,4
346,eclipse_jetty.project,project.MavenMetadataTest.testIsExpiredTimestampYesterday,"@Test
public void testIsExpiredTimestampYesterday() {
    LocalDateTime yesterday = LocalDateTime.now().minusDays(1);
    String timestamp = getTimestampFormatter().format(yesterday);
    assertTrue(MavenMetadata.isExpiredTimestamp(timestamp), ""Timestamp should be stale: "" + timestamp);
}",time,2
349,GoogleCloudPlatform_google-cloud-eclipse,CreateAppEngineStandardWtpProjectTest.testNoTestClassesInDeploymentAssembly,"@Test
public void testNoTestClassesInDeploymentAssembly()
throws InvocationTargetException, CoreException {
    CreateAppEngineWtpProject creator = new CreateAppEngineStandardWtpProject(config, adaptable);
    creator.execute(monitor);
    ProjectUtils.waitForProjects(project);
    assertNoTestClassesInDeploymentAssembly();
}
private void assertNoTestClassesInDeploymentAssembly() throws CoreException {
    StructureEdit core = StructureEdit.getStructureEditForRead(project);
    WorkbenchComponent component = core.getComponent();
    assertNotNull(component);
    boolean seenMainSourcePath = false;
    List<ComponentResource> resources = component.getResources();
    for (ComponentResource resource : resources) {
        assertFalse(containsSegment(resource.getSourcePath(), ""test""));
        if (resource.getSourcePath().equals(new Path(""/src/main/java""))
        && resource.getRuntimePath().equals(new Path(""/WEB-INF/classes""))) {
            seenMainSourcePath = true;
        }
    }
    assertTrue(seenMainSourcePath);
}",async wait,0
351,androidx_androidx,testStopTimer_withCleanUp,"@Test
public void testStopTimer_withCleanUp() throws InterruptedException {
    TestTimeLimitExceededListener listenerSpy = spy(mListener);
    mWorkTimer.startTimer(WORKSPEC_ID_1, 100, listenerSpy);
    mWorkTimer.stopTimer(WORKSPEC_ID_1);
    Thread.sleep(100);
    verify(listenerSpy, times(0)).onTimeLimitExceeded(WORKSPEC_ID_1);
    assertThat(mWorkTimer.getTimerMap().size(), is(0));
    assertThat(mWorkTimer.getListeners().size(), is(0));
}",async wait,0
355,ReactiveX_RxJava,OperatorRetryTest.testRetryWithBackpressure,"@Test
public void testRetryWithBackpressure() throws InterruptedException {
    final int NUM_RETRIES = RxRingBuffer.SIZE * 2;
    for (int i = 0; i < 400; i++) {
        @SuppressWarnings(""unchecked"")
        Observer<String> observer = mock(Observer.class);
        Observable<String> origin = Observable.create(new FuncWithErrors(NUM_RETRIES));
        TestSubscriber<String> ts = new TestSubscriber<String>(observer);
        origin.retry().observeOn(Schedulers.computation()).unsafeSubscribe(ts);
        ts.awaitTerminalEvent(5, TimeUnit.SECONDS);
        InOrder inOrder = inOrder(observer);
        verify(observer, never()).onError(any(Throwable.class));
        inOrder.verify(observer, times(NUM_RETRIES + 1)).onNext(""beginningEveryTime"");
        inOrder.verify(observer, times(1)).onNext(""onSuccessOnly"");
        inOrder.verify(observer, times(1)).onCompleted();
        inOrder.verifyNoMoreInteractions();
    }
}",concurrency,1
357,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testLookup,"@Test
public void testLookup() throws Exception {
    final Name name = new CompositeName(""test"");
    final Object object = new Object();
    namingStore.bind(name, object);
    Object result = namingContext.lookup(name);
    assertEquals(object, result);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, ""test"");
    assertEquals(object, result);
}",test order dependency,4
358,OryxProject_oryx,ALSServingInputProducerIT.testALSInputProducer,"@Test
public void testALSInputProducer() throws Exception {
    Map<String, Object> overlayConfig = new HashMap<>();
    overlayConfig.put(""oryx.serving.application-resources"", ""\""com.cloudera.oryx.app.serving,com.cloudera.oryx.app.serving.als\"""");
    overlayConfig.put(""oryx.serving.model-manager-class"", ALSServingModelManager.class.getName());
    Config config = ConfigUtils.overlayOn(overlayConfig, getConfig());
    startMessaging();
    startServer(config);
    @SuppressWarnings(""unchecked"")
    TopicProducer<String, String> inputProducer = ((TopicProducer<String, String>) (getServingLayer().getContext().getServletContext().getAttribute(INPUT_PRODUCER_KEY)));
    String[] inputs = new String[]{ ""abc,123,1.5"", ""xyz,234,-0.5"", ""AB,10,0"" };
    List<Pair<String, String>> keyMessages;
    try (final CloseableIterator<Pair<String, String>> data = new ConsumeData(INPUT_TOPIC, getZKPort()).iterator()) {
        log.info(""Starting consumer thread"");
        ConsumeTopicRunnable consumeInput = new ConsumeTopicRunnable(data);
        new Thread(consumeInput).start();
        Thread.sleep(3000);
        for (String input : inputs) {
            inputProducer.send("""", input);
        }
        Thread.sleep(1000);
        keyMessages = consumeInput.getKeyMessages();
    }
    for (int i = 0; i < keyMessages.size(); i++) {
        Pair<String, String> keyMessage = keyMessages.get(i);
        assertEquals("""", keyMessage.getFirst());
        assertEquals(inputs[i], keyMessage.getSecond());
    }
    assertEquals(inputs.length, keyMessages.size());
}",async wait,0
361,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testListBindings.2.,"@Test
public void testListBindings() throws Exception {
    final Object value = new Object();
    bindObject(ServiceName.JBOSS.append(""TestBean""), value);
    bindObject(ServiceName.JBOSS.append(""foo"", ""TestBean""), value);
    bindObject(ServiceName.JBOSS.append(""foo"", ""bar"", ""TestBean""), value);
    bindObject(ServiceName.JBOSS.append(""foo"", ""bar"", ""baz"", ""TestBean""), value);
    store.add(ServiceName.JBOSS.append(""foos"", ""bar""));
    store.add(ServiceName.JBOSS.append(""fo"", ""bar""));
    store.add(ServiceName.JBOSS.append(""foo"", ""ba"", ""baz""));
    store.add(ServiceName.JBOSS.append(""foo"", ""bart"", ""baz""));
    store.add(ServiceName.JBOSS.append(""foo"", ""bar"", ""ba""));
    store.add(ServiceName.JBOSS.append(""foo"", ""bar"", ""bazt""));
    store.add(ServiceName.JBOSS.append(""foo"", ""bar"", ""art""));
    store.add(ServiceName.JBOSS.append(""other"", ""one""));
    List<Binding> list = store.listBindings(new CompositeName(""""));
    assertEquals(5, list.size());
    assertContains(list, ""TestBean"", Object.class);
    assertContains(list, ""foo"", NamingContext.class);
    assertContains(list, ""fo"", NamingContext.class);
    assertContains(list, ""foos"", NamingContext.class);
    assertContains(list, ""other"", NamingContext.class);
    list = store.listBindings(new CompositeName(""foo""));
    assertEquals(4, list.size());
    assertContains(list, ""TestBean"", Object.class);
    assertContains(list, ""ba"", NamingContext.class);
    assertContains(list, ""bart"", NamingContext.class);
    assertContains(list, ""bar"", NamingContext.class);
    for (Binding binding : list) {
        if (binding.getName().equals(""bar"")) {
            final Object bean = Context.class.cast(binding.getObject()).lookup(""TestBean"");
            assertNotNull(bean);
            assertEquals(value, bean);
        }
    }
}",test order dependency,4
363,aosp-mirror_platform_frameworks_support,basicSwipeTest,"@Test
public void basicSwipeTest(int dir, int swipeDirs, int targetX) throws Throwable {
    final RecyclerView recyclerView = setup(0, swipeDirs);
    mLayoutManager.expectLayouts(1);
    setRecyclerView(recyclerView);
    mLayoutManager.waitForLayout(1);
    final RecyclerView.ViewHolder target = mRecyclerView
    .findViewHolderForAdapterPosition(1);
    TouchUtils.dragViewToX(getInstrumentation(), target.itemView, Gravity.CENTER, targetX);
    Thread.sleep(100);
    final SwipeRecord swipe = mCalback.getSwipe(target);
    assertNotNull(swipe);
    assertEquals(dir, swipe.dir);
    assertEquals(1, mItemTouchHelper.mRecoverAnimations.size());
    assertEquals(1, mItemTouchHelper.mPendingCleanup.size());
    mLayoutManager.expectLayouts(1);
    mAdapter.deleteAndNotify(1, 1);
    mLayoutManager.waitForLayout(1);
    waitForAnimations();
    assertEquals(0, mItemTouchHelper.mRecoverAnimations.size());
    assertEquals(0, mItemTouchHelper.mPendingCleanup.size());
    assertTrue(mCalback.isCleared(target));
}",async wait,0
365,wildfly_wildfly,b19048b72669fc0e96665b1b125dc1fda21f5993.testListBindingsWithContinuation,"@Test
public void testListBindingsWithContinuation() throws Exception {
    bindListWithContinuations();
    NamingEnumeration<Binding> results = namingContext.listBindings(new CompositeName(""comp""));
    checkListWithContinuationsResults(results);
    results = (NamingEnumeration<Binding>) testActionPermission(JndiPermission.ACTION_LIST_BINDINGS, Arrays.asList(
    new JndiPermission(""test"", ""listBindings"")), namingContext, ""comp"");
    checkListWithContinuationsResults(results);
}",test order dependency,4
366,GoogleCloudPlatform_google-cloud-eclipse,XmlValidatorTest.testValidate_badXml,"@Test
public void testValidate_badXml() throws IOException, CoreException {
    XmlValidator validator = new XmlValidator();
    validator.setHelper(new AppEngineWebXmlValidator());
    IFile file = createBogusProjectFile();
    byte[] badXml = BAD_XML.getBytes(StandardCharsets.UTF_8);
    validator.validate(file, badXml);
    IMarker[] emptyMarkers =
    ProjectUtils.waitUntilNoMarkersFound(file, PROBLEM, true, DEPTH_ZERO);
    ArrayAssertions.assertIsEmpty(emptyMarkers);
}",async wait,0
13832,neo4j_neo4j,LoggingResourcePoolMonitorTest.testUpdatedCurrentPeakSizeLogsOnlyOnChange,"    @Test
    public void testUpdatedCurrentPeakSizeLogsOnlyOnChange() throws Exception
    {
        StringLogger logger = mock( StringLogger.class );
        LoggingResourcePoolMonitor monitor = new LoggingResourcePoolMonitor( logger );

        monitor.updatedCurrentPeakSize( 10 );
        verify( logger, times( 1 ) ).debug( anyString() );

        monitor.updatedCurrentPeakSize( 10 );
        verify( logger, times( 1 ) ).debug( anyString() );

        monitor.updatedCurrentPeakSize( 11 );
        verify( logger, times( 2 ) ).debug( anyString() );
    }
",non-flaky,5
13833,neo4j_neo4j,LoggingResourcePoolMonitorTest.testUpdatedTargetSizeOnlyOnChange,"    @Test
    public void testUpdatedTargetSizeOnlyOnChange() throws Exception
    {
        StringLogger logger = mock( StringLogger.class );
        LoggingResourcePoolMonitor monitor = new LoggingResourcePoolMonitor( logger );

        monitor.updatedTargetSize( 10 );
        verify( logger, times( 1 ) ).debug( anyString() );

        monitor.updatedTargetSize( 10 );
        verify( logger, times( 1 ) ).debug( anyString() );

        monitor.updatedTargetSize( 11 );
        verify( logger, times( 2 ) ).debug( anyString() );
    }
",non-flaky,5
13834,neo4j_neo4j,ResponsePackerTest.obligation,"    @Test
    public void shouldHaveFixedTargetTransactionIdEvenIfLastTransactionIdIsMoving() throws Exception
    {
        // GIVEN
        LogicalTransactionStore transactionStore = mock( LogicalTransactionStore.class );
        long lastAppliedTransactionId = 5L;
        IOCursor<CommittedTransactionRepresentation> endlessCursor = new EndlessCursor( lastAppliedTransactionId+1 );
        when( transactionStore.getTransactions( anyLong() ) ).thenReturn( endlessCursor );
        final long targetTransactionId = 8L;
        final TransactionIdStore transactionIdStore = new DeadSimpleTransactionIdStore( targetTransactionId, 0 );
        ResponsePacker packer = new ResponsePacker( transactionStore, transactionIdStore,
                singletonProvider( new StoreId() ) );

        // WHEN
        Response<Object> response = packer.packTransactionStreamResponse( requestContextStartingAt( 5L ), null );
        final AtomicLong nextExpectedVisit = new AtomicLong( lastAppliedTransactionId );
        response.accept( new Response.Handler()
        {
            @Override
            public void obligation( long txId ) throws IOException
            {
                fail( ""Should not be called"" );
            }
",non-flaky,5
13835,neo4j_neo4j,StoreCopyClientTest.shouldCopyStoreFilesAcrossIfACancellationRequestHappensAfterTheTempStoreHasBeenRecovered,"    @Test
    public void shouldCopyStoreFilesAcrossIfACancellationRequestHappensAfterTheTempStoreHasBeenRecovered()
            throws IOException
",non-flaky,5
13836,neo4j_neo4j,StoreCopyClientTest.shouldEndUpWithAnEmptyStoreIfCancellationRequestIssuedJustBeforeRecoveryTakesPlace,"    @Test
    public void shouldEndUpWithAnEmptyStoreIfCancellationRequestIssuedJustBeforeRecoveryTakesPlace()
            throws IOException
",non-flaky,5
13837,neo4j_neo4j,TransactionCommittingResponseUnpackerTest.testStopShouldAllowTransactionsToCompleteCommitAndApply,"    @Test
    public void testStopShouldAllowTransactionsToCompleteCommitAndApply() throws Throwable
    {
        // Given

        // Handcrafted deep mocks, otherwise the dependency resolution throws ClassCastExceptions
        DependencyResolver dependencyResolver = mock( DependencyResolver.class );
        TransactionIdStore txIdStore = mock( TransactionIdStore.class );

        when( dependencyResolver.resolveDependency( TransactionIdStore.class ) ).thenReturn( txIdStore );

        TransactionAppender appender = mockedTransactionAppender();
        LogicalTransactionStore logicalTransactionStore = mock( LogicalTransactionStore.class );
        when( logicalTransactionStore.getAppender() ).thenReturn( appender );
        when( dependencyResolver.resolveDependency( LogicalTransactionStore.class ) )
                .thenReturn( logicalTransactionStore );

        when( dependencyResolver.resolveDependency( TransactionRepresentationStoreApplier.class ) )
                .thenReturn( mock( TransactionRepresentationStoreApplier.class ) );
        LogFile logFile = mock( LogFile.class );
        when( dependencyResolver.resolveDependency( LogFile.class ) ).thenReturn( logFile );
        LogRotation logRotation = mock(LogRotation.class);
        when( dependencyResolver.resolveDependency( LogRotation.class ) ).thenReturn( logRotation );

        setUpIndexUpdatesValidatorMocking( dependencyResolver );

          /*
           * The tx handler is called on every transaction applied after setting its id to committing
           * but before setting it to applied. We use this to stop the unpacker in the middle of the
           * process.
           */
        StoppingTxHandler stoppingTxHandler = new StoppingTxHandler();

        int maxBatchSize = 10;
        TransactionCommittingResponseUnpacker unpacker = new TransactionCommittingResponseUnpacker(
                dependencyResolver, maxBatchSize );
        stoppingTxHandler.setUnpacker( unpacker );

        // When
        unpacker.start();
        long committingTransactionId = BASE_TX_ID + 1;
        DummyTransactionResponse response = new DummyTransactionResponse( committingTransactionId, 1, appender, maxBatchSize );
        unpacker.unpackResponse( response, stoppingTxHandler );

        // Then
        // we can't verify transactionCommitted since that's part of the TransactionAppender, which we have mocked
        verify( txIdStore, times( 1 ) ).transactionClosed( committingTransactionId );
        verify( appender, times( 1 ) ).append( any( TransactionRepresentation.class ), anyLong() );
        verify( appender, times( 1 ) ).force();
        verify( logRotation, times( 1 ) ).rotateLogIfNeeded( logAppendEvent );

        // Then
          // The txhandler has stopped the unpacker. It should not allow any more transactions to go through
        try
        {
            unpacker.unpackResponse( mock( Response.class ), stoppingTxHandler );
            fail( ""A stopped transaction unpacker should not allow transactions to be applied"" );
        }
        catch( IllegalStateException e)
        {
            // good
        }
        verifyNoMoreInteractions( txIdStore );
        verifyNoMoreInteractions( appender );
    }
",non-flaky,5
13838,neo4j_neo4j,TransactionCommittingResponseUnpackerTest.shouldApplyQueuedTransactionsIfMany,"    @Test
    public void shouldApplyQueuedTransactionsIfMany() throws Throwable
    {
        // GIVEN
        DependencyResolver dependencyResolver = mock( DependencyResolver.class );
        TransactionIdStore txIdStore = mock( TransactionIdStore.class );

        when( dependencyResolver.resolveDependency( TransactionIdStore.class ) ).thenReturn( txIdStore );

        TransactionAppender appender = mockedTransactionAppender();
        LogicalTransactionStore logicalTransactionStore = mock( LogicalTransactionStore.class );
        when( logicalTransactionStore.getAppender() ).thenReturn( appender );
        when( dependencyResolver.resolveDependency( LogicalTransactionStore.class ) )
                .thenReturn( logicalTransactionStore );

        when( dependencyResolver.resolveDependency( TransactionRepresentationStoreApplier.class ) )
                .thenReturn( mock( TransactionRepresentationStoreApplier.class ) );

        setUpIndexUpdatesValidatorMocking( dependencyResolver );

        LogFile logFile = mock( LogFile.class );
        when( dependencyResolver.resolveDependency( LogFile.class ) ).thenReturn( logFile );

        LogRotation logRotation = mock(LogRotation.class);
        when( dependencyResolver.resolveDependency( LogRotation.class ) ).thenReturn( logRotation );

        int maxBatchSize = 3;
        TransactionCommittingResponseUnpacker unpacker = new TransactionCommittingResponseUnpacker(
                dependencyResolver, maxBatchSize );
        unpacker.start();

        // WHEN/THEN
        int txCount = maxBatchSize * 2 - 1;
        unpacker.unpackResponse( new DummyTransactionResponse( 2, txCount, appender, maxBatchSize ), NO_OP_TX_HANDLER );

        // and THEN
        verify( appender, times( txCount ) ).append( any( TransactionRepresentation.class ), anyLong() );
        verify( appender, times( 2 ) ).force();
        verify( logRotation, times( 2 ) ).rotateLogIfNeeded( logAppendEvent );
    }
",non-flaky,5
13839,neo4j_neo4j,TransactionCommittingResponseUnpackerTest.shouldAwaitTransactionObligationsToBeFulfilled,"    @Test
    public void shouldAwaitTransactionObligationsToBeFulfilled() throws Throwable
    {
        // GIVEN
        DependencyResolver dependencyResolver = mock( DependencyResolver.class );

        TransactionIdStore txIdStore = mock( TransactionIdStore.class );
        when( dependencyResolver.resolveDependency( TransactionIdStore.class ) ).thenReturn( txIdStore );

        TransactionAppender appender = mock( TransactionAppender.class );
        LogicalTransactionStore logicalTransactionStore = mock( LogicalTransactionStore.class );
        when( logicalTransactionStore.getAppender() ).thenReturn( appender );
        when( dependencyResolver.resolveDependency( LogicalTransactionStore.class ) )
                .thenReturn( logicalTransactionStore );

        when( dependencyResolver.resolveDependency( TransactionRepresentationStoreApplier.class ) )
                .thenReturn( mock( TransactionRepresentationStoreApplier.class ) );
        TransactionObligationFulfiller obligationFulfiller = mock( TransactionObligationFulfiller.class );
        when( dependencyResolver.resolveDependency( TransactionObligationFulfiller.class ) )
                .thenReturn( obligationFulfiller );
        final TransactionCommittingResponseUnpacker unpacker = new TransactionCommittingResponseUnpacker(
                dependencyResolver );
        unpacker.start();

        // WHEN
        unpacker.unpackResponse( new DummyObligationResponse( 4 ), NO_OP_TX_HANDLER );

        // THEN
        verify( obligationFulfiller, times( 1 ) ).fulfill( 4l );
    }
",non-flaky,5
13840,neo4j_neo4j,TransactionCommittingResponseUnpackerTest.shouldIssueKernelPanicInCaseOfFailureToAppendOrApply,"    @Test
    public void shouldIssueKernelPanicInCaseOfFailureToAppendOrApply() throws Throwable
    {
        // GIVEN
        DependencyResolver dependencyResolver = mock( DependencyResolver.class );

        TransactionIdStore txIdStore = mock( TransactionIdStore.class );
        when( dependencyResolver.resolveDependency( TransactionIdStore.class ) ).thenReturn( txIdStore );

        TransactionAppender appender = mock( TransactionAppender.class );
        LogicalTransactionStore logicalTransactionStore = mock( LogicalTransactionStore.class );
        when( logicalTransactionStore.getAppender() ).thenReturn( appender );
        when( dependencyResolver.resolveDependency( LogicalTransactionStore.class ) )
                .thenReturn( logicalTransactionStore );

        when( dependencyResolver.resolveDependency( TransactionRepresentationStoreApplier.class ) )
                .thenReturn( mock( TransactionRepresentationStoreApplier.class ) );
        TransactionObligationFulfiller obligationFulfiller = mock( TransactionObligationFulfiller.class );
        when( dependencyResolver.resolveDependency( TransactionObligationFulfiller.class ) )
                .thenReturn( obligationFulfiller );
        LogFile logFile = mock( LogFile.class );
        when( dependencyResolver.resolveDependency( LogFile.class ) ).thenReturn( logFile );
        KernelHealth kernelHealth = mock( KernelHealth.class );
        when( dependencyResolver.resolveDependency( KernelHealth.class ) ).thenReturn( kernelHealth );
        LogRotation logRotation = mock(LogRotation.class);
        when( dependencyResolver.resolveDependency( LogRotation.class ) ).thenReturn( logRotation );
        final TransactionCommittingResponseUnpacker unpacker = new TransactionCommittingResponseUnpacker(
                dependencyResolver );
        unpacker.start();

        // WHEN failing to append one or more transactions from a transaction stream response
        IOException failure = new IOException( ""Expected failure"" );
        doThrow( failure ).when( appender ).append( any( TransactionRepresentation.class ), anyLong() );
        try
        {
            unpacker.unpackResponse(
                    new DummyTransactionResponse( BASE_TX_ID+1, 1, appender, 10 ), NO_OP_TX_HANDLER );
            fail( ""Should have failed"" );
        }
        catch ( IOException e )
        {
            assertThat( e.getMessage(), containsString( failure.getMessage() ) );
            verify( kernelHealth ).panic( failure );
        }
    }
",non-flaky,5
13841,neo4j_neo4j,TransactionCommittingResponseUnpackerTest.shouldNotApplyTransactionIfIndexUpdatesValidationFails,"    @Test
    public void shouldNotApplyTransactionIfIndexUpdatesValidationFails() throws Throwable
    {
        // Given
        DependencyResolver resolver = mock( DependencyResolver.class );

        when( resolver.resolveDependency( LogFile.class ) ).thenReturn( mock( LogFile.class ) );
        when( resolver.resolveDependency( LogRotation.class ) ).thenReturn( mock( LogRotation.class ) );
        when( resolver.resolveDependency( TransactionIdStore.class ) ).thenReturn( mock( TransactionIdStore.class ) );
        KernelHealth kernelHealth = mock( KernelHealth.class );
        when( resolver.resolveDependency( KernelHealth.class ) ).thenReturn( kernelHealth );
        LogicalTransactionStore txStore = mock( LogicalTransactionStore.class );
        TransactionAppender appender = mockedTransactionAppender();
        when( txStore.getAppender() ).thenReturn( appender );
        when( resolver.resolveDependency( LogicalTransactionStore.class ) ).thenReturn( txStore );
        TransactionRepresentationStoreApplier storeApplier = mock( TransactionRepresentationStoreApplier.class );
        when( resolver.resolveDependency( TransactionRepresentationStoreApplier.class ) ).thenReturn( storeApplier );

        IndexUpdatesValidator validator = mock( IndexUpdatesValidator.class );
        IOException error = new IOException( ""error"" );
        when( validator.validate( any( TransactionRepresentation.class ), eq( TransactionApplicationMode.EXTERNAL ) ) )
                .thenThrow( error );
        when( resolver.resolveDependency( IndexUpdatesValidator.class ) ).thenReturn( validator );

        TransactionCommittingResponseUnpacker unpacker = new TransactionCommittingResponseUnpacker( resolver );
        unpacker.start();

        Response<?> response = new DummyTransactionResponse( BASE_TX_ID + 1, 1, appender, 10 );

        // When
        try
        {
            unpacker.unpackResponse( response, NO_OP_TX_HANDLER );
            fail( ""Should have thrown "" + IOException.class.getSimpleName() );
        }
        catch ( IOException e )
        {
            assertSame( error, e );
        }

        // Then
        verifyZeroInteractions( storeApplier );
        verify( kernelHealth ).panic( error );
    }
",non-flaky,5
13842,neo4j_neo4j,TransactionCommittingResponseUnpackerTest.shouldNotMarkTransactionsAsCommittedIfAppenderClosed,"    @Test
    public void shouldNotMarkTransactionsAsCommittedIfAppenderClosed() throws Throwable
    {
        // GIVEN an unpacker with close-to-real dependencies injected
        DependencyResolver resolver = mock( DependencyResolver.class );
        // (we don't want this FS in every test in this class, so just don't use EFSR)
        FileSystemAbstraction fs = cleanup.add( new EphemeralFileSystemAbstraction() );
        File directory = new File( ""dir"" );
        fs.mkdirs( directory );
        PhysicalLogFiles logFiles = new PhysicalLogFiles( directory, fs );
        TransactionIdStore transactionIdStore = spy( new DeadSimpleTransactionIdStore() );
        LogVersionRepository logVersionRepository = mock( LogVersionRepository.class );
        TransactionMetadataCache transactionMetadataCache = new TransactionMetadataCache( 10, 10 );
        LogFile logFile = life.add( new PhysicalLogFile( fs, logFiles, 1_000, transactionIdStore,
                logVersionRepository, new PhysicalLogFile.Monitor.Adapter(), transactionMetadataCache ) );
        KernelHealth health = mock( KernelHealth.class );
        LogRotation logRotation = LogRotation.NO_ROTATION;
        LogicalTransactionStore logicalTransactionStore = life.add( new PhysicalLogicalTransactionStore( logFile,
                logRotation, transactionMetadataCache, transactionIdStore, IdOrderingQueue.BYPASS,
                health, true ) );
        IndexUpdatesValidator indexUpdatesValidator = mock( IndexUpdatesValidator.class );
        when( indexUpdatesValidator.validate( any( TransactionRepresentation.class ),
                any( TransactionApplicationMode.class ) ) ).thenReturn( ValidatedIndexUpdates.NONE );
        life.start();
        TransactionAppender appender = logicalTransactionStore.getAppender();
        when( resolver.resolveDependency( LogicalTransactionStore.class ) ).thenReturn( logicalTransactionStore );
        when( resolver.resolveDependency( IndexUpdatesValidator.class ) ).thenReturn( indexUpdatesValidator );
        when( resolver.resolveDependency( TransactionIdStore.class ) ).thenReturn( transactionIdStore );
        when( resolver.resolveDependency( TransactionObligationFulfiller.class ) ).thenReturn( null );
        when( resolver.resolveDependency( LogFile.class ) ).thenReturn( logFile );
        when( resolver.resolveDependency( LogRotation.class ) ).thenReturn( logRotation );
        when( resolver.resolveDependency( KernelHealth.class ) ).thenReturn( health );
        when( resolver.resolveDependency( TransactionObligationFulfiller.class ) ).thenThrow(
                new IllegalArgumentException() );
        TransactionCommittingResponseUnpacker unpacker = new TransactionCommittingResponseUnpacker( resolver );
        unpacker.start();

        // and a closed logFile/appender
        life.shutdown();

        // WHEN packing up a transaction response
        try
        {
            unpacker.unpackResponse( new DummyTransactionResponse( BASE_TX_ID+1, 1, appender, 5 ), NO_OP_TX_HANDLER );
            fail( ""Should have failed"" );
        }
        catch ( Exception e )
        {
            // THEN apart from failing we don't want any committed/closed calls to TransactionIdStore
            verify( transactionIdStore, times( 0 ) ).transactionCommitted( anyLong(), anyLong() );
            verify( transactionIdStore, times( 0 ) ).transactionClosed( anyLong() );
        }
    }
",non-flaky,5
13843,neo4j_neo4j,ResourcePoolTest.shouldNotReuseBrokenInstances,"    @Test
    public void shouldNotReuseBrokenInstances() throws Exception
    {
        ResourcePool<Something> pool = new ResourcePool<Something>( 5 )
        {
            @Override
            protected Something create()
            {
                return new Something();
            }

            @Override
            protected boolean isAlive( Something resource )
            {
                return !resource.closed;
            }
        };

        Something somethingFirst = pool.acquire();
        somethingFirst.doStuff();
        pool.release();

        Something something = pool.acquire();
        assertEquals( somethingFirst, something );
        something.doStuff();
        something.close();
        pool.release();

        Something somethingElse = pool.acquire();
        assertFalse( something == somethingElse );
        somethingElse.doStuff();
    }
",non-flaky,5
13844,neo4j_neo4j,ResourcePoolTest.shouldTimeoutGracefully,"    @Test
    public void shouldTimeoutGracefully() throws InterruptedException
    {
        FakeClock clock = new FakeClock();

        ResourcePool.CheckStrategy timeStrategy = new ResourcePool.CheckStrategy.TimeoutCheckStrategy( 100, clock );

        while ( clock.currentTimeMillis() <= 100 )
        {
            assertFalse( timeStrategy.shouldCheck() );
            clock.forward( 10, TimeUnit.MILLISECONDS );
        }

        assertTrue( timeStrategy.shouldCheck() );

        clock.forward( 1, TimeUnit.MILLISECONDS );
        assertFalse( timeStrategy.shouldCheck() );
    }
",non-flaky,5
13845,neo4j_neo4j,ResourcePoolTest.shouldBuildUpGracefullyUntilReachedMinPoolSize,"    @Test
    public void shouldBuildUpGracefullyUntilReachedMinPoolSize() throws InterruptedException
    {
        // GIVEN
        StatefulMonitor stateMonitor = new StatefulMonitor();
        FakeClock clock = new FakeClock();
        final ResourcePool<Something> pool = getResourcePool( stateMonitor, clock, 5 );

        // WHEN
        acquireFromPool( pool, 5 );

        // THEN
        assertEquals( -1, stateMonitor.currentPeakSize.get() );
        assertEquals( -1, stateMonitor.targetSize.get() ); // that means the target size was not updated
        assertEquals( 0, stateMonitor.disposed.get() ); // no disposed happened, since the count to update is 10
    }
",non-flaky,5
13846,neo4j_neo4j,ResourcePoolTest.shouldBuildUpGracefullyWhilePassingMinPoolSizeBeforeTimerRings,"    @Test
    public void shouldBuildUpGracefullyWhilePassingMinPoolSizeBeforeTimerRings() throws InterruptedException
    {
        // GIVEN
        StatefulMonitor stateMonitor = new StatefulMonitor();
        FakeClock clock = new FakeClock();
        final ResourcePool<Something> pool = getResourcePool( stateMonitor, clock, 5 );

        // WHEN
        acquireFromPool( pool, 15 );

        // THEN
        assertEquals( -1, stateMonitor.currentPeakSize.get() );
        assertEquals( 15, stateMonitor.created.get() );
        assertEquals( -1, stateMonitor.targetSize.get() );
        assertEquals( 0, stateMonitor.disposed.get() );
    }
",non-flaky,5
13847,neo4j_neo4j,ResourcePoolTest.shouldUpdateTargetSizeWhenSpikesOccur,"    @Test
    public void shouldUpdateTargetSizeWhenSpikesOccur() throws Exception
    {
        // given
        final int MIN_SIZE = 5;
        final int MAX_SIZE = 10;

        StatefulMonitor stateMonitor = new StatefulMonitor();
        FakeClock clock = new FakeClock();
        final ResourcePool<Something> pool = getResourcePool( stateMonitor, clock, MIN_SIZE );

        // when
        List<ResourceHolder> holders = acquireFromPool( pool, MAX_SIZE );
        clock.forward( 110, TimeUnit.MILLISECONDS );
        holders.addAll( acquireFromPool( pool, 1 ) ); // Needed to trigger the alarm

        // then
        assertEquals( MAX_SIZE + 1, stateMonitor.currentPeakSize.get() );
        // We have not released anything, so targetSize will not be reduced
        assertEquals( MAX_SIZE + 1, stateMonitor.targetSize.get() ); // + 1 from the acquire

        for ( ResourceHolder holder : holders )
        {
            holder.end();
        }
    }
",non-flaky,5
13848,neo4j_neo4j,ResourcePoolTest.shouldKeepSmallPeakAndNeverDisposeIfAcquireAndReleaseContinuously,"    @Test
    public void shouldKeepSmallPeakAndNeverDisposeIfAcquireAndReleaseContinuously() throws Exception
    {
        // given
        final int MIN_SIZE = 1;

        StatefulMonitor stateMonitor = new StatefulMonitor();
        FakeClock clock = new FakeClock();
        final ResourcePool<Something> pool = getResourcePool( stateMonitor, clock, MIN_SIZE );

        // when
        for ( int i = 0; i < 200; i++ )
        {
            List<ResourceHolder> newOnes = acquireFromPool( pool, 1 );
            CountDownLatch release = new CountDownLatch( newOnes.size() );
            for ( ResourceHolder newOne : newOnes )
            {
                newOne.release( release );
            }
            release.await();
        }

        // then
        assertEquals( -1, stateMonitor.currentPeakSize.get() ); // no alarm has rung, -1 is the default
        assertEquals( 1, stateMonitor.created.get() );
        assertEquals( 0, stateMonitor.disposed.get() ); // we should always be below min size, so 0 dispose calls
    }
",non-flaky,5
13849,neo4j_neo4j,ResourcePoolTest.shouldSlowlyReduceTheNumberOfResourcesInThePoolWhenResourcesAreReleased,"    @Test
    public void shouldSlowlyReduceTheNumberOfResourcesInThePoolWhenResourcesAreReleased() throws Exception
    {
        // given
        final int MIN_SIZE = 50;
        final int MAX_SIZE = 200;

        StatefulMonitor stateMonitor = new StatefulMonitor();
        FakeClock clock = new FakeClock();
        final ResourcePool<Something> pool = getResourcePool( stateMonitor, clock, MIN_SIZE );
        List<ResourceHolder> holders = new LinkedList<ResourceHolder>();

        buildAPeakOfAcquiredResourcesAndTriggerAlarmWithSideEffects( MAX_SIZE, clock, pool, holders );

        // when
        // After the peak, stay below MIN_SIZE concurrent usage, using up all already present resources.
        clock.forward( 110, TimeUnit.MILLISECONDS );
        for ( int i = 0; i < MAX_SIZE; i++ )
        {
            acquireFromPool( pool, 1 ).get( 0 ).release();
        }

        // then

        // currentPeakSize must have reset from the latest alarm to MIN_SIZE.
        assertEquals( 1, stateMonitor.currentPeakSize.get() ); // Alarm
        // targetSize must be set to MIN_SIZE since currentPeakSize was that 2 alarms ago and didn't increase
        assertEquals( MIN_SIZE, stateMonitor.targetSize.get() );
        // Only pooled resources must be used, disposing what is in excess
        // +1 for the alarm from buildAPeakOfAcquiredResourcesAndTriggerAlarmWithSideEffects
        assertEquals( MAX_SIZE - MIN_SIZE + 1, stateMonitor.disposed.get() );
    }
",non-flaky,5
13850,neo4j_neo4j,ResourcePoolTest.shouldMaintainPoolAtHighWatermarkWhenConcurrentUsagePassesMinSize,"    @Test
    public void shouldMaintainPoolAtHighWatermarkWhenConcurrentUsagePassesMinSize() throws Exception
    {
        // given
        final int MIN_SIZE = 50;
        final int MAX_SIZE = 200;
        final int MID_SIZE = 90;

        StatefulMonitor stateMonitor = new StatefulMonitor();
        FakeClock clock = new FakeClock();
        final ResourcePool<Something> pool = getResourcePool( stateMonitor, clock, MIN_SIZE );
        List<ResourceHolder> holders = new LinkedList<ResourceHolder>();

        buildAPeakOfAcquiredResourcesAndTriggerAlarmWithSideEffects( MAX_SIZE, clock, pool, holders );

        // when
        // After the peak, stay at MID_SIZE concurrent usage, using up all already present resources in the process
        // but also keeping the high watermark above the MIN_SIZE
        clock.forward( 110, TimeUnit.MILLISECONDS );
        // Requires some rounds to happen, since there is constant racing between releasing and acquiring which does
        // not always result in reaping of resources, as there is reuse
        for ( int i = 0; i < 10; i++ )
        {
            // The latch is necessary to reduce races between batches
            CountDownLatch release = new CountDownLatch( MID_SIZE );
            for ( ResourceHolder holder : acquireFromPool( pool, MID_SIZE ) )
            {
                holder.release( release );
            }
            release.await();
            clock.forward( 110, TimeUnit.MILLISECONDS );
        }

        // then
        // currentPeakSize should be at MID_SIZE
        assertEquals( MID_SIZE, stateMonitor.currentPeakSize.get() );
        // target size too
        assertEquals( MID_SIZE, stateMonitor.targetSize.get() );
        // only the excess from the MAX_SIZE down to mid size must have been disposed
        // +1 for the alarm from buildAPeakOfAcquiredResourcesAndTriggerAlarmWithSideEffects
        assertEquals( MAX_SIZE - MID_SIZE + 1, stateMonitor.disposed.get() );
    }
",non-flaky,5
13851,neo4j_neo4j,ResourcePoolTest.shouldReclaimAndRecreateWhenLullBetweenSpikesOccurs,"    @Test
    public void shouldReclaimAndRecreateWhenLullBetweenSpikesOccurs() throws Exception
    {
        // given
        final int MIN_SIZE = 50;
        final int BELOW_MIN_SIZE = MIN_SIZE / 5;
        final int MAX_SIZE = 200;

        StatefulMonitor stateMonitor = new StatefulMonitor();
        FakeClock clock = new FakeClock();
        final ResourcePool<Something> pool = getResourcePool( stateMonitor, clock, MIN_SIZE );
        List<ResourceHolder> holders = new LinkedList<ResourceHolder>();

        buildAPeakOfAcquiredResourcesAndTriggerAlarmWithSideEffects( MAX_SIZE, clock, pool, holders );

        // when
        // After the peak, stay well below concurrent usage, using up all already present resources in the process
        clock.forward( 110, TimeUnit.MILLISECONDS );
        // Requires some rounds to happen, since there is constant racing between releasing and acquiring which does
        // not always result in reaping of resources, as there is reuse
        for ( int i = 0; i < 30; i++ )
        {
            // The latch is necessary to reduce races between batches
            CountDownLatch release = new CountDownLatch( BELOW_MIN_SIZE );
            for ( ResourceHolder holder : acquireFromPool( pool, BELOW_MIN_SIZE ) )
            {
                holder.release( release );
            }
            release.await();
            clock.forward( 110, TimeUnit.MILLISECONDS );
        }

        // then
        // currentPeakSize should be at MIN_SIZE / 5
        assertEquals( BELOW_MIN_SIZE, stateMonitor.currentPeakSize.get() );
        // target size should remain at MIN_SIZE
        assertEquals( MIN_SIZE, stateMonitor.targetSize.get() );
        // only the excess from the MAX_SIZE down to min size must have been disposed
        // +1 for the alarm from buildAPeakOfAcquiredResourcesAndTriggerAlarmWithSideEffects
        assertEquals( MAX_SIZE - MIN_SIZE + 1, stateMonitor.disposed.get() );

        stateMonitor.created.set( 0 );
        stateMonitor.disposed.set( 0 );

        // when
        // After the lull, recreate a peak
        buildAPeakOfAcquiredResourcesAndTriggerAlarmWithSideEffects( MAX_SIZE, clock, pool, holders );

        // then
        assertEquals( MAX_SIZE - MIN_SIZE + 1, stateMonitor.created.get() );
        assertEquals( 0, stateMonitor.disposed.get() );

    }
",non-flaky,5
13852,neo4j_neo4j,ServerTest.shouldSendExceptionBackToClientOnInvalidChecksum,"    @Test
    public void shouldSendExceptionBackToClientOnInvalidChecksum() throws Exception
    {
        // Given
        Server<Object, Object> server = newServer( checksumVerifier );
        RequestContext ctx = new RequestContext( 0, 1, 0, 1, 12 );

        doThrow(new IllegalStateException(""123"")).when(checksumVerifier).assertMatch( anyLong(), anyLong() );

        // When
        try
        {
            server.messageReceived( channelCtx( channel ), message( reqType, ctx, channel, EMPTY_SERIALIZER ) );
            fail(""Should have failed."");
        }
        catch(IllegalStateException e)
        {
            // Expected
        }

        // Then
        try
        {
            protocol.deserializeResponse( channel.asBlockingReadHandler(), ByteBuffer.allocateDirect( 1024 ), 1,
                    VOID_DESERIALIZER, mock( ResourceReleaser.class ) );
            fail(""Should have failed."");
        }
        catch(IllegalStateException e)
        {
            assertThat(e.getMessage(), equalTo(""123""));
        }

    }
",non-flaky,5
13853,neo4j_neo4j,TestCommunication.clientGetResponseFromServerViaComLayer,"    @Test
    public void clientGetResponseFromServerViaComLayer() throws Throwable
    {
        MadeUpServerImplementation serverImplementation = new MadeUpServerImplementation( storeIdToUse );
        MadeUpServer server = builder.server( serverImplementation );
        MadeUpClient client = builder.client();
        addToLifeAndStart( server, client );

        int value1 = 10;
        int value2 = 5;
        Response<Integer> response = client.multiply( 10, 5 );
        waitUntilResponseHasBeenWritten( server, 1000 );
        assertEquals( (Integer) (value1 * value2), response.response() );
        assertTrue( serverImplementation.gotCalled() );
        assertTrue( server.responseHasBeenWritten() );
    }
",non-flaky,5
13854,neo4j_neo4j,TestCommunication.makeSureClientStoreIdsMustMatch,"    @Test(expected = MismatchingStoreIdException.class)
    public void makeSureClientStoreIdsMustMatch() throws Throwable
    {
        MadeUpServer server = builder.server();
        MadeUpClient client = builder.storeId( new StoreId( 10, 10, 10, 10 ) ).client();
        addToLifeAndStart( server, client );

        client.multiply( 1, 2 );
    }
",non-flaky,5
13855,neo4j_neo4j,TestCommunication.makeSureServerStoreIdsMustMatch,"    @Test(expected = MismatchingStoreIdException.class)
    public void makeSureServerStoreIdsMustMatch() throws Throwable
    {
        MadeUpServer server = builder.storeId( new StoreId( 10, 10, 10, 10 ) ).server();
        MadeUpClient client = builder.client();
        addToLifeAndStart( server, client );

        client.multiply( 1, 2 );
    }
",non-flaky,5
13856,neo4j_neo4j,TestCommunication.makeSureClientCanStreamBigData,"    @Test
    public void makeSureClientCanStreamBigData() throws Throwable
    {
        MadeUpServer server = builder.server();
        MadeUpClient client = builder.client();
        addToLifeAndStart( server, client );


        client.fetchDataStream( new ToAssertionWriter(), FRAME_LENGTH * 3 );
    }
",non-flaky,5
13857,neo4j_neo4j,TestCommunication.fetchDataStream,"    @Test
    public void clientThrowsServerSideErrorMidwayThroughStreaming() throws Throwable
    {
        final String failureMessage = ""Just failing"";
        MadeUpServerImplementation serverImplementation = new MadeUpServerImplementation( storeIdToUse )
        {
            @Override
            public Response<Void> fetchDataStream( MadeUpWriter writer, int dataSize )
            {
                writer.write( new FailingByteChannel( dataSize, failureMessage ) );
                return new TransactionStreamResponse<>( null, storeIdToUse, TransactionStream.EMPTY,
                        ResourceReleaser.NO_OP );
            }
",non-flaky,5
13858,neo4j_neo4j,TestCommunication.communicateBetweenJvms,"    @Test
    public void communicateBetweenJvms() throws Throwable
    {
        ServerInterface server = builder.serverInOtherJvm();
        server.awaitStarted();
        MadeUpClient client = builder.port( MadeUpServerProcess.PORT ).client();
        life.add( client );
        life.start();

        assertEquals( (Integer) (9 * 5), client.multiply( 9, 5 ).response() );
        client.fetchDataStream( new ToAssertionWriter(), 1024 * 1024 * 3 );

        server.shutdown();
    }
",non-flaky,5
13859,neo4j_neo4j,TestCommunication.throwingServerSideExceptionBackToClient,"    @Test
    public void throwingServerSideExceptionBackToClient() throws Throwable
    {
        MadeUpServer server = builder.server();
        MadeUpClient client = builder.client();
        addToLifeAndStart( server, client );

        String exceptionMessage = ""The message"";
        try
        {
            client.throwException( exceptionMessage );
            fail( ""Should have thrown "" + MadeUpException.class.getSimpleName() );
        }
        catch ( MadeUpException e )
        {   // Good
            assertEquals( exceptionMessage, e.getMessage() );
        }
    }
",non-flaky,5
13860,neo4j_neo4j,TestCommunication.applicationProtocolVersionsMustMatch,"    @Test
    public void applicationProtocolVersionsMustMatch() throws Throwable
    {
        MadeUpServer server = builder.applicationProtocolVersion( (byte) (APPLICATION_PROTOCOL_VERSION + 1) ).server();
        MadeUpClient client = builder.client();
        addToLifeAndStart( server, client );

        try
        {
            client.multiply( 10, 20 );
            fail( ""Shouldn't be able to communicate with different application protocol versions"" );
        }
        catch ( IllegalProtocolVersionException e )
        { /* Good */ }
    }
",non-flaky,5
13861,neo4j_neo4j,TestCommunication.applicationProtocolVersionsMustMatchMultiJvm,"    @Test
    public void applicationProtocolVersionsMustMatchMultiJvm() throws Throwable
    {
        ServerInterface server = builder.applicationProtocolVersion( (byte) (APPLICATION_PROTOCOL_VERSION + 1) )
                                        .serverInOtherJvm();
        server.awaitStarted();
        MadeUpClient client = builder.port( MadeUpServerProcess.PORT ).client();
        life.add( client );
        life.start();

        try
        {
            client.multiply( 10, 20 );
            fail( ""Shouldn't be able to communicate with different application protocol versions"" );
        }
        catch ( IllegalProtocolVersionException e )
        { /* Good */ }

        server.shutdown();
    }
",non-flaky,5
13862,neo4j_neo4j,TestCommunication.internalProtocolVersionsMustMatch,"    @Test
    public void internalProtocolVersionsMustMatch() throws Throwable
    {
        MadeUpServer server = builder.internalProtocolVersion( (byte) 1 ).server();
        MadeUpClient client = builder.internalProtocolVersion( (byte) 2 ).client();
        addToLifeAndStart( server, client );

        try
        {
            client.multiply( 10, 20 );
            fail( ""Shouldn't be able to communicate with different application protocol versions"" );
        }
        catch ( IllegalProtocolVersionException e )
        { /* Good */ }
    }
",non-flaky,5
13863,neo4j_neo4j,TestCommunication.internalProtocolVersionsMustMatchMultiJvm,"    @Test
    public void internalProtocolVersionsMustMatchMultiJvm() throws Throwable
    {
        ServerInterface server = builder.internalProtocolVersion( (byte) 1 ).serverInOtherJvm();
        server.awaitStarted();
        MadeUpClient client = builder.port( MadeUpServerProcess.PORT ).internalProtocolVersion( (byte) 2 ).client();
        life.add( client );
        life.start();

        try
        {
            client.multiply( 10, 20 );
            fail( ""Shouldn't be able to communicate with different application protocol versions"" );
        }
        catch ( IllegalProtocolVersionException e )
        { /* Good */ }

        server.shutdown();
    }
",non-flaky,5
13864,neo4j_neo4j,TestCommunication.serverStopsStreamingToDeadClient,"    @Test
    public void serverStopsStreamingToDeadClient() throws Throwable
    {
        MadeUpServer server = builder.server();
        MadeUpClient client = builder.client();
        addToLifeAndStart( server, client );

        int failAtSize = FRAME_LENGTH / 2;
        ClientCrashingWriter writer = new ClientCrashingWriter( client, failAtSize );
        try
        {
            client.fetchDataStream( writer, FRAME_LENGTH * 10 );
            assertTrue( writer.getSizeRead() >= failAtSize );
            fail( ""Should fail in the middle"" );
        }
        catch ( ComException e )
        {   // Expected
        }
        assertTrue( writer.getSizeRead() >= failAtSize );

        long maxWaitUntil = System.currentTimeMillis() + 2 * 1000;
        while ( !server.responseFailureEncountered() && System.currentTimeMillis() < maxWaitUntil )
        {
            yield();
        }
        assertTrue( ""Failure writing the response should have been encountered"", server.responseFailureEncountered() );
        assertFalse( ""Response shouldn't have been successful"", server.responseHasBeenWritten() );
    }
",non-flaky,5
13865,neo4j_neo4j,TestCommunication.assertMatch,"    @Test
    public void serverContextVerificationCanThrowException() throws Throwable
    {
        final String failureMessage = ""I'm failing"";
        TxChecksumVerifier failingVerifier = new TxChecksumVerifier()
        {
            @Override
            public void assertMatch( long txId, long checksum )
            {
                throw new FailingException( failureMessage );
            }
",non-flaky,5
13866,neo4j_neo4j,TestCommunication.clientCanReadChunkSizeBiggerThanItsOwn,"    @Test
    public void clientCanReadChunkSizeBiggerThanItsOwn() throws Throwable
    {   // Given that frameLength is the same for both client and server.
        int serverChunkSize = 20000;
        int clientChunkSize = serverChunkSize / 10;
        MadeUpServer server = builder.chunkSize( serverChunkSize ).server();
        MadeUpClient client = builder.chunkSize( clientChunkSize ).client();

        addToLifeAndStart( server, client );

        // Tell server to stream data occupying roughly two chunks. The chunks
        // from server are 10 times bigger than the clients chunk size.
        client.fetchDataStream( new ToAssertionWriter(), serverChunkSize * 2 );
    }
",non-flaky,5
13867,neo4j_neo4j,TestCommunication.serverCanReadChunkSizeBiggerThanItsOwn,"    @Test
    public void serverCanReadChunkSizeBiggerThanItsOwn() throws Throwable
    {   // Given that frameLength is the same for both client and server.
        int serverChunkSize = 1000;
        int clientChunkSize = serverChunkSize * 10;
        MadeUpServer server = builder.chunkSize( serverChunkSize ).server();
        MadeUpClient client = builder.chunkSize( clientChunkSize ).client();

        addToLifeAndStart( server, client );

        // Tell server to stream data occupying roughly two chunks. The chunks
        // from server are 10 times bigger than the clients chunk size.
        client.sendDataStream( new DataProducer( clientChunkSize * 2 ) );
    }
",non-flaky,5
13868,neo4j_neo4j,TestCommunication.impossibleToHaveBiggerChunkSizeThanFrameSize,"    @Test
    public void impossibleToHaveBiggerChunkSizeThanFrameSize() throws Throwable
    {
        Builder myBuilder = builder.chunkSize( MadeUpServer.FRAME_LENGTH + 10 );
        try
        {
            myBuilder.server().start();
            fail( ""Shouldn't be possible"" );
        }
        catch ( IllegalArgumentException e )
        {   // Good
        }

        try
        {
            myBuilder.client();
            fail( ""Shouldn't be possible"" );
        }
        catch ( IllegalArgumentException e )
        {   // Good
        }
    }
",non-flaky,5
13869,neo4j_neo4j,TestCommunication.answer,"    @Test
    public void clientShouldUseHandlersToHandleComExceptions()
    {
        // Given
        final String comExceptionMessage = ""The ComException"";

        MadeUpCommunicationInterface communication = mock( MadeUpCommunicationInterface.class, new Answer<Response<?>>()
        {
            @Override
            public Response<?> answer( InvocationOnMock _ ) throws ComException
            {
                throw new ComException( comExceptionMessage );
            }
",non-flaky,5
13870,neo4j_neo4j,TestCommunication.masterResponseShouldBeUnpackedIfRequestTypeRequires,"    @Test
    public void masterResponseShouldBeUnpackedIfRequestTypeRequires() throws IOException
    {
        // Given
        ResponseUnpacker responseUnpacker = mock( ResponseUnpacker.class );
        MadeUpClient client = builder.clientWith( responseUnpacker );
        addToLifeAndStart( builder.server(), client );

        // When
        client.multiply( 42, 42 );

        // Then
        ArgumentCaptor<Response> captor = ArgumentCaptor.forClass( Response.class );
        verify( responseUnpacker ).unpackResponse( captor.capture(), any( TxHandler.class ) );
        assertEquals( storeIdToUse, captor.getValue().getStoreId() );
        assertEquals( 42 * 42, captor.getValue().response() );
    }
",non-flaky,5
13871,neo4j_neo4j,TestCommunication.masterResponseShouldNotBeUnpackedIfRequestTypeDoesNotRequire,"    @Test
    public void masterResponseShouldNotBeUnpackedIfRequestTypeDoesNotRequire()
    {
        // Given
        ResponseUnpacker responseUnpacker = mock( ResponseUnpacker.class );
        MadeUpClient client = builder.clientWith( responseUnpacker );
        addToLifeAndStart( builder.server(), client );

        // When
        client.sendDataStream( new KnownDataByteChannel( 100 ) );

        // Then
        verifyZeroInteractions( responseUnpacker );
    }
",non-flaky,5
13872,neo4j_neo4j,TestCommunication.shouldStreamBackTransactions,"    @Test
    public void shouldStreamBackTransactions() throws Exception
    {
        // GIVEN
        int value = 11, txCount = 3;
        life.add( builder.server() );
        MadeUpClient client = life.add( builder.client() );
        life.start();
        Response<Integer> respone = client.streamBackTransactions( value, txCount );
        TransactionStreamVerifyingResponseHandler handler = new TransactionStreamVerifyingResponseHandler( txCount );

        // WHEN
        respone.accept( handler );
        int responseValue = respone.response();

        // THEN
        assertEquals( value, responseValue );
        assertEquals( txCount, handler.expectedTxId );
    }
",non-flaky,5
13873,neo4j_neo4j,TestCommunication.shouldAdhereToTransactionObligations,"    @Test
    public void shouldAdhereToTransactionObligations() throws Exception
    {
        // GIVEN
        int value = 15;
        long desiredObligation = 8;
        life.add( builder.server() );
        MadeUpClient client = life.add( builder.client() );
        life.start();
        Response<Integer> respone = client.informAboutTransactionObligations( value, desiredObligation );
        TransactionObligationVerifyingResponseHandler handler = new TransactionObligationVerifyingResponseHandler();

        // WHEN
        respone.accept( handler );
        int responseValue = respone.response();

        // THEN
        assertEquals( value, responseValue );
        assertEquals( desiredObligation, handler.obligationTxId );
    }
",non-flaky,5
13874,neo4j_neo4j,ServerUtilTest.shouldIgnoreLogicalLogsWhenCopyingFilesForBackup,"    @Test
    public void shouldIgnoreLogicalLogsWhenCopyingFilesForBackup() throws IOException
    {
        // given
        final FileSystemAbstraction fs = new StubFileSystemAbstraction();

        XaDataSource dataSource = mock( XaDataSource.class );

        FileResourceIterator storeFiles = new FileResourceIterator( fs, testDirectory, ""neostore.nodestore.db"" );
        FileResourceIterator logicalLogs = new FileResourceIterator( fs, testDirectory,
        PhysicalLogFile.DEFAULT_NAME + PhysicalLogFile.DEFAULT_VERSION_SUFFIX + ""0"" );

        when( dataSource.listStoreFiles() ).thenReturn( storeFiles );
        when( dataSource.listLogicalLogs() ).thenReturn( logicalLogs );
        when( dataSource.getBranchId() ).thenReturn( ""branch"".getBytes() );
        when( dataSource.getName() ).thenReturn( ""branch"" );

        XaContainer xaContainer = mock( XaContainer.class );
        when( dataSource.getXaContainer() ).thenReturn( xaContainer );

        XaLogicalLog xaLogicalLog = mock( XaLogicalLog.class );

        when( xaContainer.getLogicalLog() ).thenReturn( xaLogicalLog );

        XaResourceManager xaResourceManager = mock( XaResourceManager.class );
        when( xaContainer.getResourceManager() ).thenReturn( xaResourceManager );

        XaDataSourceManager dsManager = new XaDataSourceManager( StringLogger.DEV_NULL );
        dsManager.registerDataSource( dataSource );

        KernelPanicEventGenerator kernelPanicEventGenerator = mock( KernelPanicEventGenerator.class );
        StoreWriter storeWriter = mock( StoreWriter.class );

        // when
        ServerUtil.rotateLogsAndStreamStoreFiles( testDirectory.absolutePath(), dsManager, kernelPanicEventGenerator,
                StringLogger.DEV_NULL, false, storeWriter, fs, StoreCopyMonitor.NONE );

        // then
        verify( storeWriter ).write( eq( ""neostore.nodestore.db"" ), any( ReadableByteChannel.class ),
                any( ByteBuffer.class ), any( Boolean.class ) );
        verify( storeWriter, never() ).write( eq( PhysicalLogFile.DEFAULT_NAME + PhysicalLogFile.DEFAULT_VERSION_SUFFIX + ""0"" ), any( ReadableByteChannel.class ),
                any( ByteBuffer.class ), any( Boolean.class ) );

    }
",non-flaky,5
13875,neo4j_neo4j,ServerUtilTest.shouldCopyLogicalLogFile,"    @Test
    public void shouldCopyLogicalLogFile() throws IOException
    {
        // given
        final FileSystemAbstraction fs = new StubFileSystemAbstraction();

        XaDataSource dataSource = mock( XaDataSource.class );

        FileResourceIterator storeFiles = new FileResourceIterator( fs, testDirectory );
        FileResourceIterator logicalLogs = new FileResourceIterator( fs, testDirectory, PhysicalLogFile.DEFAULT_NAME + PhysicalLogFile.DEFAULT_VERSION_SUFFIX + ""0"" );

        when( dataSource.listStoreFiles() ).thenReturn( storeFiles );
        when( dataSource.listLogicalLogs() ).thenReturn( logicalLogs );
        when( dataSource.getBranchId() ).thenReturn( ""branch"".getBytes() );
        when( dataSource.getName() ).thenReturn( ""branch"" );

        XaContainer xaContainer = mock( XaContainer.class );
        when( dataSource.getXaContainer() ).thenReturn( xaContainer );

        XaLogicalLog xaLogicalLog = mock( XaLogicalLog.class );

        when( xaContainer.getLogicalLog() ).thenReturn( xaLogicalLog );

        XaResourceManager xaResourceManager = mock( XaResourceManager.class );
        when( xaContainer.getResourceManager() ).thenReturn( xaResourceManager );

        XaDataSourceManager dsManager = new XaDataSourceManager( StringLogger.DEV_NULL );
        dsManager.registerDataSource( dataSource );

        KernelPanicEventGenerator kernelPanicEventGenerator = mock( KernelPanicEventGenerator.class );
        StoreWriter storeWriter = mock( StoreWriter.class );

        // when
        ServerUtil.rotateLogsAndStreamStoreFiles( testDirectory.absolutePath(), dsManager, kernelPanicEventGenerator,
                StringLogger.DEV_NULL, true, storeWriter, fs, StoreCopyMonitor.NONE );

        // then
        verify( storeWriter ).write( eq( PhysicalLogFile.DEFAULT_NAME + PhysicalLogFile.DEFAULT_VERSION_SUFFIX + ""0"" ), any( ReadableByteChannel.class ),
                any( ByteBuffer.class ), any( Boolean.class ) );
    }
",non-flaky,5
13876,neo4j_neo4j,ServerUtilTest.shouldNotThrowFileNotFoundExceptionWhenTryingToCopyAMissingLogicalLogFile,"    @Test
    public void shouldNotThrowFileNotFoundExceptionWhenTryingToCopyAMissingLogicalLogFile() throws IOException
    {
        // given
        final FileSystemAbstraction fs = new StubFileSystemAbstraction();

        XaDataSource dataSource = mock( XaDataSource.class );

        FileResourceIterator storeFiles = new FileResourceIterator( fs, testDirectory, ""neostore.nodestore.db"" );

        FileResourceIterator logicalLogs = new FileResourceIterator( fs, testDirectory,
        PhysicalLogFile.DEFAULT_NAME + PhysicalLogFile.DEFAULT_VERSION_SUFFIX + ""0"" );
        logicalLogs.deleteBeforeCopy( PhysicalLogFile.DEFAULT_NAME + PhysicalLogFile.DEFAULT_VERSION_SUFFIX + ""0"" );

        when( dataSource.listStoreFiles() ).thenReturn( storeFiles );
        when( dataSource.listLogicalLogs() ).thenReturn( logicalLogs );

        when( dataSource.getBranchId() ).thenReturn( ""branch"".getBytes() );
        when( dataSource.getName() ).thenReturn( ""branch"" );

        XaContainer xaContainer = mock( XaContainer.class );
        when( dataSource.getXaContainer() ).thenReturn( xaContainer );

        XaResourceManager xaResourceManager = mock( XaResourceManager.class );
        when( xaContainer.getResourceManager() ).thenReturn( xaResourceManager );

        XaDataSourceManager dsManager = new XaDataSourceManager( StringLogger.DEV_NULL );
        dsManager.registerDataSource( dataSource );

        KernelPanicEventGenerator kernelPanicEventGenerator = mock( KernelPanicEventGenerator.class );
        StoreWriter storeWriter = mock( StoreWriter.class );

        // when
        ServerUtil.rotateLogsAndStreamStoreFiles( testDirectory.absolutePath(), dsManager, kernelPanicEventGenerator,
                StringLogger.DEV_NULL, true, storeWriter, fs, StoreCopyMonitor.NONE );

        // then
        verify( storeWriter ).write( eq( ""neostore.nodestore.db"" ), any( ReadableByteChannel.class ),
                any( ByteBuffer.class ), any( Boolean.class ) );
    }
",non-flaky,5
13877,neo4j_neo4j,ServerUtilTest.shouldThrowFileNotFoundExceptionWhenTryingToCopyAStoreFileWhichDoesNotExist,"    @Test
    public void shouldThrowFileNotFoundExceptionWhenTryingToCopyAStoreFileWhichDoesNotExist() throws IOException
    {
        // given
        final FileSystemAbstraction fs = new StubFileSystemAbstraction();

        XaDataSource dataSource = mock( XaDataSource.class );

        FileResourceIterator storeFiles = new FileResourceIterator( fs, testDirectory, ""neostore.nodestore.db"" );
        storeFiles.deleteBeforeCopy( ""neostore.nodestore.db"" );

        FileResourceIterator logicalLogs = new FileResourceIterator( fs, testDirectory );

        when( dataSource.listStoreFiles() ).thenReturn( storeFiles );
        when( dataSource.listLogicalLogs() ).thenReturn( logicalLogs );


        when( dataSource.getBranchId() ).thenReturn( ""branch"".getBytes() );
        when( dataSource.getName() ).thenReturn( ""branch"" );

        XaContainer xaContainer = mock( XaContainer.class );
        when( dataSource.getXaContainer() ).thenReturn( xaContainer );

        XaResourceManager xaResourceManager = mock( XaResourceManager.class );
        when( xaContainer.getResourceManager() ).thenReturn( xaResourceManager );

        XaDataSourceManager dsManager = new XaDataSourceManager( StringLogger.DEV_NULL );
        dsManager.registerDataSource( dataSource );

        KernelPanicEventGenerator kernelPanicEventGenerator = mock( KernelPanicEventGenerator.class );
        StoreWriter storeWriter = mock( StoreWriter.class );

        // when
        try
        {
            ServerUtil.rotateLogsAndStreamStoreFiles( testDirectory.absolutePath(), dsManager,
                    kernelPanicEventGenerator,
                    StringLogger.DEV_NULL, true, storeWriter, fs, StoreCopyMonitor.NONE );
            fail( ""should have thrown exception"" );
        }
        catch ( ServerFailureException e )
        {
            // then
            assertEquals( java.io.FileNotFoundException.class, e.getCause().getClass() );
        }
    }
",non-flaky,5
13878,neo4j_neo4j,TestSlaveContext.assertSimilarity,"    @Test
    public void assertSimilarity()
    {
        // Different machine ids
        assertFalse( new RequestContext( 1234, 1, 2, 0, 0 ).equals( new RequestContext( 1234, 2, 2, 0, 0 ) ) );

        // Different event identifiers
        assertFalse( new RequestContext( 1234, 1, 10, 0, 0 ).equals( new RequestContext( 1234, 1, 20, 0, 0 ) ) );

        // Different session ids
        assertFalse( new RequestContext( 1001, 1, 5, 0, 0 ).equals( new RequestContext( 1101, 1, 5, 0, 0 ) ) );

        // Same everything
        assertEquals( new RequestContext( 12345, 4, 9, 0, 0 ), new RequestContext( 12345, 4, 9, 0, 0 ) );
    }
",non-flaky,5
13879,neo4j_neo4j,ProtocolTest.shouldSerializeAndDeserializeTransactionRepresentation,"    @Test
    public void shouldSerializeAndDeserializeTransactionRepresentation() throws Exception
    {
        // GIVEN
        PhysicalTransactionRepresentation transaction = new PhysicalTransactionRepresentation( justOneNode() );
        byte[] additionalHeader = ""extra"".getBytes();
        int masterId = 1, authorId = 2;
        long timeStarted = 12345, lastTxWhenStarted = 12, timeCommitted = timeStarted+10;
        transaction.setHeader( additionalHeader, masterId, authorId, timeStarted, lastTxWhenStarted, timeCommitted, -1 );
        Protocol.TransactionSerializer serializer = new Protocol.TransactionSerializer( transaction );
        ChannelBuffer buffer = new ChannelBufferWrapper( new InMemoryLogChannel() );

        // WHEN serializing the transaction
        serializer.write( buffer );

        // THEN deserializing the same transaction should yield the same data.
        // ... remember that this deserializer doesn't read the data source name string. Read it manually here
        assertEquals( NeoStoreDataSource.DEFAULT_DATA_SOURCE_NAME, Protocol.readString( buffer ) );
        TransactionRepresentation readTransaction = Protocol.TRANSACTION_REPRESENTATION_DESERIALIZER.read(
                buffer, ByteBuffer.allocate( 1000 ) );
        assertArrayEquals( additionalHeader, readTransaction.additionalHeader() );
        assertEquals( masterId, readTransaction.getMasterId() );
        assertEquals( authorId, readTransaction.getAuthorId() );
        assertEquals( timeStarted, readTransaction.getTimeStarted() );
        assertEquals( lastTxWhenStarted, readTransaction.getLatestCommittedTxWhenStarted() );
        assertEquals( timeCommitted, readTransaction.getTimeCommitted() );
    }
",non-flaky,5
13880,neo4j_neo4j,StoreMigratorFrom20IT.shouldMigrate,"    @Test
    public void shouldMigrate() throws IOException, ConsistencyCheckIncompleteException
    {
        // WHEN
        upgrader( new StoreMigrator( monitor, fs, DevNullLoggingService.DEV_NULL ) )
                .migrateIfNeeded(
                find20FormatStoreDirectory( storeDir.directory() ), schemaIndexProvider, pageCache );

        // THEN
        assertEquals( 100, monitor.eventSize() );
        assertTrue( monitor.isStarted() );
        assertTrue( monitor.isFinished() );

        GraphDatabaseService database = new GraphDatabaseFactory().newEmbeddedDatabase( storeDir.absolutePath() );
        try
        {
            verifyDatabaseContents( database );
        }
        finally
        {
            // CLEANUP
            database.shutdown();
        }

        try ( NeoStore neoStore = storeFactory.newNeoStore( true ) )
        {
            verifyNeoStore( neoStore );
        }
        assertConsistentStore( storeDir.directory() );
    }
",non-flaky,5
13881,neo4j_neo4j,StoreMigratorFrom20IT.shouldMigrateCluster,"    @Test
    public void shouldMigrateCluster() throws Throwable
    {
        // Given
        File legacyStoreDir = find20FormatStoreDirectory( storeDir.directory() );

        // When
        upgrader( new StoreMigrator( monitor, fs, DevNullLoggingService.DEV_NULL ) ).migrateIfNeeded(
                legacyStoreDir, schemaIndexProvider, pageCache );
        ClusterManager.ManagedCluster cluster = buildClusterWithMasterDirIn( fs, legacyStoreDir, life );
        cluster.await( allSeesAllAsAvailable() );
        cluster.sync();

        // Then
        HighlyAvailableGraphDatabase slave1 = cluster.getAnySlave();
        verifySlaveContents( slave1 );
        verifySlaveContents( cluster.getAnySlave( slave1 ) );
        verifyDatabaseContents( cluster.getMaster() );
    }
",non-flaky,5
13882,neo4j_neo4j,StoreMigratorFrom21IT.mustMendDuplicatePropertiesWhenUpgradingFromVersion21,"    @Test
    public void mustMendDuplicatePropertiesWhenUpgradingFromVersion21() throws Exception
    {
        // The rules:
        // If an index is present, all duplicates should be removed and the property set to the value in the index
        // If an index is not present, the property should be set to the value of the last duplicate in the property
        // chain, all duplicates except the first should be removed
        // If an index is not present, the first property in the duplicate chain should be kept for the users
        // benefit, moved to a special property value, `__DUPLICATE_<propkey>`
        //
        // This is the broken store that we are upgrading:
        //
        //   (#0:Label { keyA: ""actual"", keyA: ""phony!"", keyA: ""phony!"" })
        //   (#1 { keyA: ""actual"", keyA: ""actual"", keyA: ""actual"" })
        //   (#2:Label { keyA: ""real1"", keyA: ""phony"", keyA: ""phony"", keyD: ""real2"", keyD: ""phony"", keyD: ""phony"" })
        //   (#3 { keyA: ""real1"", keyA: ""phony"", keyA: ""phony"", keyD: ""real2"", keyD: ""phony"", keyD: ""phony"" })
        //   (#4 { keyA: ""actual"", keyB: ""actual"", keyC: ""actual"" })
        //   (#0)-[#0:REL { keyA: ""actual"", keyA: ""actual"", keyA: ""actual"" }]->(#1)
        //   (#0)-[#1:REL { keyA: ""real1"", keyA: ""phony"", keyA: ""phony"",
        //                  keyD: ""real2"", keyE: ""phony"", keyF: ""phony"" }]->(#1)
        //   (#2)-[#2:REL { keyA: ""actual"", keyB: ""actual"", keyC: ""actual"" }]->(#0)
        //
        // And this is what we want to end up with, after upgrading:
        //
        //   (#0:Label { keyA: ""actual"" })
        //   (#1 { keyA: ""actual"", __DUPLICATE_keyA: ""actual"" })
        //   (#2:Label { keyA: ""real1"", keyD: ""real2"" })
        //   (#3 { keyA: ""real1"", __DUPLICATE_keyA_1: ""real1"", __DUPLICATE_keyA_2: ""real1"",
        //         keyD: ""real2"", __DUPLICATE_keyD_1: ""real2"", __DUPLICATE_keyD_2: ""real2"" })
        //   (#4 { keyA: ""actual"", keyB: ""actual"", keyC: ""actual"" })
        //   (#0)-[#0:REL { keyA: ""actual"", __DUPLICATE_keyA: ""actual"" }]->(#1)
        //   (#0)-[#1:REL { keyA: ""real1"", __DUPLICATE_keyA_1: ""real1"", __DUPLICATE_keyA_2: ""real1"",
        //                  keyD: ""real2"", __DUPLICATE_keyD_1: ""real2"", __DUPLICATE_keyD_2: ""real2"" }]->(#1)
        //   (#2)-[#2:REL { keyA: ""actual"", keyB: ""actual"", keyC: ""actual"" }]->(#0)

        File dir = MigrationTestUtils.find21FormatStoreDirectoryWithDuplicateProperties( storeDir.directory() );

        GraphDatabaseBuilder builder =
                new GraphDatabaseFactory().newEmbeddedDatabaseBuilder( dir.getAbsolutePath() ).setConfig(
                        GraphDatabaseSettings.allow_store_upgrade, ""true"" );
        GraphDatabaseService database = builder.newGraphDatabase();
        database.shutdown();
        ConsistencyCheckService service = new ConsistencyCheckService();

        ConsistencyCheckService.Result result = service.runFullConsistencyCheck(
                dir.getAbsolutePath(), new Config(), ProgressMonitorFactory.NONE, StringLogger.SYSTEM );
        assertTrue( result.isSuccessful() );

        database = builder.newGraphDatabase();
        // Upgrade is now completed. Verify the contents:
        DependencyResolver dependencyResolver = ((GraphDatabaseAPI) database).getDependencyResolver();
        NeoStoreProvider provider = dependencyResolver.resolveDependency( NeoStoreProvider.class );
        NeoStore store = provider.evaluate();
        NodeStore nodeStore = store.getNodeStore();
        RelationshipStore relStore = store.getRelationshipStore();
        PropertyStore propertyStore = store.getPropertyStore();

        // Verify that the properties appear correct to the outside world:
        try ( Transaction ignore = database.beginTx() )
        {
            verifyPropertiesEqual( database.getNodeById( 0 ),
                    Pair.of( ""keyA"", ""actual"" ) );
            verifyPropertiesEqual( database.getNodeById( 1 ),
                    Pair.of( ""keyA"", ""actual"" ),
                    Pair.of( ""__DUPLICATE_keyA_1"", ""actual"" ),
                    Pair.of( ""__DUPLICATE_keyA_2"", ""actual"" ));
            verifyPropertiesEqual( database.getNodeById( 2 ),
                    Pair.of( ""keyA"", ""real1"" ),
                    Pair.of( ""keyD"", ""real2"" ) );
            verifyPropertiesEqual( database.getNodeById( 3 ),
                    Pair.of( ""keyA"", ""real1"" ),
                    Pair.of( ""__DUPLICATE_keyA_1"", ""real1"" ),
                    Pair.of( ""__DUPLICATE_keyA_2"", ""real1"" ),
                    Pair.of( ""keyD"", ""real2"" ),
                    Pair.of( ""__DUPLICATE_keyD_1"", ""real2"" ),
                    Pair.of( ""__DUPLICATE_keyD_2"", ""real2"" ) );
            verifyPropertiesEqual( database.getNodeById( 4 ),
                    Pair.of( ""keyA"", ""actual"" ),
                    Pair.of( ""keyB"", ""actual"" ),
                    Pair.of( ""keyC"", ""actual"" ) );
            verifyPropertiesEqual( database.getRelationshipById( 0 ),
                    Pair.of( ""keyA"", ""actual"" ),
                    Pair.of( ""__DUPLICATE_keyA_1"", ""actual"" ),
                    Pair.of( ""__DUPLICATE_keyA_2"", ""actual"" ));
            verifyPropertiesEqual( database.getRelationshipById( 1 ),
                    Pair.of( ""keyA"", ""real1"" ),
                    Pair.of( ""__DUPLICATE_keyA_1"", ""real1"" ),
                    Pair.of( ""__DUPLICATE_keyA_2"", ""real1"" ),
                    Pair.of( ""keyD"", ""real2"" ),
                    Pair.of( ""__DUPLICATE_keyD_1"", ""real2"" ),
                    Pair.of( ""__DUPLICATE_keyD_2"", ""real2"" ) );
            verifyPropertiesEqual( database.getRelationshipById( 2 ),
                    Pair.of( ""keyA"", ""actual"" ),
                    Pair.of( ""keyB"", ""actual"" ),
                    Pair.of( ""keyC"", ""actual"" ) );
        }

        // Verify that there are no two properties on the entities, that have the same key:
        // (This is important because the verification above cannot tell if we have two keys with the same value)
        verifyNoDuplicatePropertyKeys( propertyStore, nodeStore.getRecord( 0 ).getNextProp() );
        verifyNoDuplicatePropertyKeys( propertyStore, nodeStore.getRecord( 1 ).getNextProp() );
        verifyNoDuplicatePropertyKeys( propertyStore, nodeStore.getRecord( 2 ).getNextProp() );
        verifyNoDuplicatePropertyKeys( propertyStore, relStore.getRecord( 0 ).getNextProp() );
        verifyNoDuplicatePropertyKeys( propertyStore, relStore.getRecord( 1 ).getNextProp() );

        database.shutdown();
    }
",non-flaky,5
13883,neo4j_neo4j,StoreMigratorFrom19IT.shouldMigrate,"    @Test
    public void shouldMigrate() throws IOException, ConsistencyCheckIncompleteException
    {
        // GIVEN
        File legacyStoreDir = find19FormatHugeStoreDirectory( storeDir.directory() );

        // WHEN
        newStoreUpgrader().migrateIfNeeded( legacyStoreDir, schemaIndexProvider, pageCache );

        // THEN
        assertEquals( 100, monitor.eventSize() );
        assertTrue( monitor.isStarted() );
        assertTrue( monitor.isFinished() );

        GraphDatabaseService database = new GraphDatabaseFactory().newEmbeddedDatabase( storeDir.absolutePath() );

        try
        {
            verifyDatabaseContents( database );
        }
        finally
        {
            // CLEANUP
            database.shutdown();
        }

        try ( NeoStore neoStore = storeFactory.newNeoStore( true ) )
        {
            verifyNeoStore( neoStore );
        }

        assertConsistentStore( storeDir.directory() );
    }
",non-flaky,5
13884,neo4j_neo4j,StoreMigratorFrom19IT.shouldMigrateCluster,"    @Test
    public void shouldMigrateCluster() throws Throwable
    {
        // Given
        File legacyStoreDir = find19FormatHugeStoreDirectory( storeDir.directory() );

        // When
        newStoreUpgrader().migrateIfNeeded( legacyStoreDir, schemaIndexProvider, pageCache );

        ClusterManager.ManagedCluster cluster = buildClusterWithMasterDirIn( fs, legacyStoreDir, life );
        cluster.await( allSeesAllAsAvailable() );
        cluster.sync();

        // Then
        HighlyAvailableGraphDatabase slave1 = cluster.getAnySlave();
        verifySlaveContents( slave1 );
        verifySlaveContents( cluster.getAnySlave( slave1 ) );
        verifyDatabaseContents( cluster.getMaster() );
    }
",non-flaky,5
13885,neo4j_neo4j,StoreMigratorFrom19IT.shouldDeduplicateUniquePropertyIndexKeys,"    @Test
    public void shouldDeduplicateUniquePropertyIndexKeys() throws Exception
    {
        // GIVEN
        // a store that contains two nodes with property ""name"" of which there are two key tokens
        File legacyStoreDir = find19FormatStoreDirectory( storeDir.directory() );

        // WHEN
        // upgrading that store, the two key tokens for ""name"" should be merged

        newStoreUpgrader().migrateIfNeeded( storeDir.directory(), schemaIndexProvider, pageCache );

        // THEN
        // verify that the ""name"" property for both the involved nodes
        GraphDatabaseService db = new GraphDatabaseFactory().newEmbeddedDatabase( storeDir.absolutePath() );
        try
        {
            Node nodeA = getNodeWithName( db, ""A"" );
            assertThat( nodeA, inTx( db, hasProperty( ""name"" ).withValue( ""A"" ) ) );

            Node nodeB = getNodeWithName( db, ""B"" );
            assertThat( nodeB, inTx( db, hasProperty( ""name"" ).withValue( ""B"" ) ) );

            Node nodeC = getNodeWithName( db, ""C"" );
            assertThat( nodeC, inTx( db, hasProperty( ""name"" ).withValue( ""C"" ) ) );
            assertThat( nodeC, inTx( db, hasProperty( ""other"" ).withValue( ""a value"" ) ) );
            assertThat( nodeC, inTx( db, hasProperty( ""third"" ).withValue( ""something"" ) ) );
        }
        finally
        {
            db.shutdown();
        }

        // THEN
        // verify that there are no duplicate keys in the store
        try ( PropertyKeyTokenStore tokenStore = storeFactory.newPropertyKeyTokenStore() )
        {
            Token[] tokens = tokenStore.getTokens( MAX_VALUE );
            assertNoDuplicates( tokens );
        }

        assertConsistentStore( storeDir.directory() );
    }
",non-flaky,5
13886,neo4j_neo4j,DataGeneratorTest.shouldGenerateNodesAndRelationshipsWithProperties,"    @Test
    public void shouldGenerateNodesAndRelationshipsWithProperties() throws Exception
    {
        // given
        Configuration.Builder config = Configuration.builder();
        config.setValue( DataGenerator.node_count, 5 );
        config.setValue( DataGenerator.relationships, asList( new RelationshipSpec( ""FOO"", 1 ),
                                                              new RelationshipSpec( ""BAR"", 2 ) ) );
        config.setValue( DataGenerator.node_properties,
                asList( new PropertySpec( PropertyGenerator.STRING, 2 ) ) );
        config.setValue( DataGenerator.relationship_properties,
                asList( new PropertySpec( PropertyGenerator.STRING, 1 ) ) );

        DataGenerator generator = new DataGenerator( config.build() );

        BatchInserter batchInserter = mock( BatchInserter.class );

        // when
        generator.generateData( batchInserter );

        // then
        verify( batchInserter, times( 5 ) ).createNode( argThat( hasSize( 2 ) ) );
        verify( batchInserter, times( 5 ) ).createRelationship( anyLong(), anyLong(), argThat( hasName( ""FOO"" ) ),
                                                                argThat( hasSize( 1 ) ) );
        verify( batchInserter, times( 10 ) )
                .createRelationship( anyLong(), anyLong(), argThat( hasName( ""BAR"" ) ), argThat( hasSize( 1 ) ) );
        verifyNoMoreInteractions( batchInserter );
    }
",non-flaky,5
13887,neo4j_neo4j,JmxDocTest.dumpJmxInfo,"    @Test
    public void dumpJmxInfo() throws Exception
    {
        List<Triplet<String, String, String>> beanItems = new ArrayList<>();
        AsciiDocListGenerator listGenerator = new AsciiDocListGenerator( ""jmx-list"", ""MBeans exposed by Neo4j"", false );

        MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
        SortedMap<String, ObjectName> neo4jBeans = new TreeMap<String, ObjectName>(
                String.CASE_INSENSITIVE_ORDER );

        for ( String query : QUERIES )
        {
            Set<ObjectInstance> beans = mBeanServer.queryMBeans(
                    new ObjectName( query ), null );
            for ( ObjectInstance bean : beans )
            {
                ObjectName objectName = bean.getObjectName();
                String name = objectName.getKeyProperty( BEAN_NAME );
                if ( EXCLUDES.contains( name ) )
                {
                    continue;
                }
                String name0 = objectName.getKeyProperty( BEAN_NAME0 );
                if ( name0 != null )
                {
                    name += '/' + name0;
                }
                neo4jBeans.put( name, bean.getObjectName() );
            }

        }
        assertEquals( ""Sanity checking the number of beans found;"",
                EXPECTED_NUMBER_OF_BEANS, neo4jBeans.size() );
        for ( Map.Entry<String, ObjectName> beanEntry : neo4jBeans.entrySet() )
        {
            ObjectName objectName = beanEntry.getValue();
            String name = beanEntry.getKey();
            Set<ObjectInstance> mBeans = mBeanServer.queryMBeans( objectName,
                    null );
            if ( mBeans.size() != 1 )
            {
                throw new IllegalStateException( ""Unexpected size [""
                        + mBeans.size()
                        + ""] of query result for [""
                        + objectName + ""]."" );
            }
            ObjectInstance bean = mBeans.iterator()
                    .next();
            MBeanInfo info = mBeanServer.getMBeanInfo( objectName );
            String description = info.getDescription()
                    .replace( '\n', ' ' );

            String id = getId( name );
            beanItems.add( Triplet.of( id, name, description ) );

            writeDetailsToFile( id, objectName, bean, info, description );
        }
        Writer fw = null;
        try
        {
            fw = AsciiDocGenerator.getFW( ""target/docs/ops"", ""JMX List"" );
            fw.write( listGenerator.generateListAndTableCombo( beanItems ) );
        }
        finally
        {
            if ( fw != null )
            {
                fw.close();
            }
        }
    }
",non-flaky,5
13888,neo4j_neo4j,HaBeanIT.canGetHaBean,"    @Test
    public void canGetHaBean() throws Throwable
    {
        startCluster( 1 );
        HighAvailability ha = ha( cluster.getMaster() );
        assertNotNull( ""could not get ha bean"", ha );
        assertMasterInformation( ha );
    }
",non-flaky,5
13889,neo4j_neo4j,HaBeanIT.testLatestTxInfoIsCorrect,"    @Test
    public void testLatestTxInfoIsCorrect() throws Throwable
    {
        startCluster( 1 );
        HighlyAvailableGraphDatabase db = cluster.getMaster();
        HighAvailability masterHa = ha( db );
        long lastCommitted = masterHa.getLastCommittedTxId();
        try ( Transaction tx = db.beginTx() )
        {
            db.createNode();
            tx.success();
        }
        assertEquals( lastCommitted + 1, masterHa.getLastCommittedTxId() );
    }
",non-flaky,5
13890,neo4j_neo4j,HaBeanIT.testUpdatePullWorksAndUpdatesLastUpdateTime,"    @Test
    public void testUpdatePullWorksAndUpdatesLastUpdateTime() throws Throwable
    {
        startCluster( 2 );
        HighlyAvailableGraphDatabase master = cluster.getMaster();
        HighlyAvailableGraphDatabase slave = cluster.getAnySlave();
        Transaction tx = master.beginTx();
        master.createNode();
        tx.success();
        tx.finish();
        HighAvailability slaveBean = ha( slave );
        DateFormat format = new SimpleDateFormat( ""yyyy-MM-DD kk:mm:ss.SSSZZZZ"" );
        // To begin with, no updates
        slaveBean.update();
        long timeUpdated = format.parse( slaveBean.getLastUpdateTime() ).getTime();
        assertTrue( timeUpdated > 0 );
    }
",non-flaky,5
13891,neo4j_neo4j,HaBeanIT.testAfterGentleMasterSwitchClusterInfoIsCorrect,"    @Test
    public void testAfterGentleMasterSwitchClusterInfoIsCorrect() throws Throwable
    {
        startCluster( 3 );
        RepairKit masterShutdown = cluster.shutdown( cluster.getMaster() );
        cluster.await( ClusterManager.masterAvailable() );
        cluster.await( ClusterManager.masterSeesSlavesAsAvailable( 1 ) );
        for ( HighlyAvailableGraphDatabase db : cluster.getAllMembers() )
        {
            assertEquals( 2, ha( db ).getInstancesInCluster().length );
        }
        masterShutdown.repair();
        cluster.await( ClusterManager.allSeesAllAsAvailable() );
        for ( HighlyAvailableGraphDatabase db : cluster.getAllMembers() )
        {
            HighAvailability bean = ha( db );

            assertEquals( 3, bean.getInstancesInCluster().length );
            for ( ClusterMemberInfo info : bean.getInstancesInCluster() )
            {
                assertTrue( ""every instance should be available"", info.isAvailable() );
                assertTrue( ""every instances should have at least one role"", info.getRoles().length > 0 );
                if ( HighAvailabilityModeSwitcher.MASTER.equals( info.getRoles()[0] ) )
                {
                    assertEquals( ""coordinator should be master"",
                            HighAvailabilityModeSwitcher.MASTER, info.getHaRole() );
                }
                else
                {
                    assertEquals( ""Either master or slave, no other way"",
                            HighAvailabilityModeSwitcher.SLAVE, info.getRoles()[0] );
                    assertEquals( ""instance "" + info.getInstanceId() + "" is cluster slave but HA master"",
                            HighAvailabilityModeSwitcher.SLAVE, info.getHaRole() );
                }
                for ( String uri : info.getUris() )
                {
                    assertTrue( ""roles should contain URIs"",
                            uri.startsWith( ""ha://"" ) || uri.startsWith( ""backup://"" ) );
                }
            }
        }
    }
",non-flaky,5
13892,neo4j_neo4j,HaBeanIT.testAfterHardMasterSwitchClusterInfoIsCorrect,"    @Test
    public void testAfterHardMasterSwitchClusterInfoIsCorrect() throws Throwable
    {
        startCluster( 3 );
        RepairKit masterShutdown = cluster.fail( cluster.getMaster() );
        cluster.await( ClusterManager.masterAvailable() );
        cluster.await( ClusterManager.masterSeesSlavesAsAvailable( 1 ) );
        for ( HighlyAvailableGraphDatabase db : cluster.getAllMembers() )
        {
            if ( db.getInstanceState() == HighAvailabilityMemberState.PENDING )
            {
                continue;
            }
            // Instance that was hard killed will still be in the cluster
            assertEquals( 3, ha( db ).getInstancesInCluster().length );
        }
        masterShutdown.repair();
        cluster.await( ClusterManager.masterAvailable() );
        cluster.await( ClusterManager.masterSeesSlavesAsAvailable( 2 ) );
        for ( HighlyAvailableGraphDatabase db : cluster.getAllMembers() )
        {
            int mastersFound = 0;
            HighAvailability bean = ha( db );

            assertEquals( 3, bean.getInstancesInCluster().length );
            for ( ClusterMemberInfo info : bean.getInstancesInCluster() )
            {
                assertTrue( bean.getInstanceId() + "": every instance should be available: "" + info.getInstanceId(),
                        info.isAvailable() );
                for ( String role : info.getRoles() )
                {
                    if (role.equals( HighAvailabilityModeSwitcher.MASTER ))
                    {
                        mastersFound++;
                    }
                }
            }
            assertEquals( 1, mastersFound );
        }
    }
",non-flaky,5
13893,neo4j_neo4j,HaBeanIT.canGetBranchedStoreBean,"    @Test
    public void canGetBranchedStoreBean() throws Throwable
    {
        startCluster( 1 );
        BranchedStore bs = beans( cluster.getMaster() ).getBranchedStoreBean();
        assertNotNull( ""could not get branched store bean"", bs );
        assertEquals( ""no branched stores for new db"", 0,
                bs.getBranchedStores().length );
    }
",non-flaky,5
13894,neo4j_neo4j,HaBeanIT.joinedInstanceShowsUpAsSlave,"    @Test
    public void joinedInstanceShowsUpAsSlave() throws Throwable
    {
        startCluster( 2 );
        ClusterMemberInfo[] instancesInCluster = ha( cluster.getMaster() ).getInstancesInCluster();
        assertEquals( 2, instancesInCluster.length );
        ClusterMemberInfo[] secondInstancesInCluster = ha( cluster.getAnySlave() ).getInstancesInCluster();
        assertEquals( 2, secondInstancesInCluster.length );
        assertMasterAndSlaveInformation( instancesInCluster );
        assertMasterAndSlaveInformation( secondInstancesInCluster );
    }
",non-flaky,5
13895,neo4j_neo4j,HaBeanIT.leftInstanceDisappearsFromMemberList,"    @Test
    public void leftInstanceDisappearsFromMemberList() throws Throwable
    {
        // Start the second db and make sure it's visible in the member list.
        // Then shut it down to see if it disappears from the member list again.
        startCluster( 3 );
        assertEquals( 3, ha( cluster.getAnySlave() ).getInstancesInCluster().length );
        cluster.shutdown( cluster.getAnySlave() );

        cluster.await( masterSeesMembers( 2 ) );

        assertEquals( 2, ha( cluster.getMaster() ).getInstancesInCluster().length );
        assertMasterInformation( ha( cluster.getMaster() ) );
    }
",non-flaky,5
13896,neo4j_neo4j,HaBeanIT.failedMemberIsStillInMemberListAlthoughFailed,"    @Test
    public void failedMemberIsStillInMemberListAlthoughFailed() throws Throwable
    {
        startCluster( 3 );
        assertEquals( 3, ha( cluster.getAnySlave() ).getInstancesInCluster().length );

        // Fail the instance
        HighlyAvailableGraphDatabase failedDb = cluster.getAnySlave();
        RepairKit dbFailure = cluster.fail( failedDb );
        await( ha( cluster.getMaster() ), dbAlive( false ) );
        await( ha( cluster.getAnySlave( failedDb )), dbAlive( false ) );

        // Repair the failure and come back
        dbFailure.repair();
        for ( HighlyAvailableGraphDatabase db : cluster.getAllMembers() )
        {
            await( ha( db ), dbAvailability( true ) );
            await( ha( db ), dbAlive( true ) );
        }
    }
",non-flaky,5
13897,neo4j_neo4j,BackupHaIT.makeSureBackupCanBePerformedFromClusterWithDefaultName,"    @Test
    public void makeSureBackupCanBePerformedFromClusterWithDefaultName() throws Throwable
    {
        testBackupFromCluster( null );
    }
",non-flaky,5
13898,neo4j_neo4j,BackupHaIT.makeSureBackupCanBePerformedFromWronglyNamedCluster,"    @Test
    public void makeSureBackupCanBePerformedFromWronglyNamedCluster() throws Throwable
    {
        assertEquals( 0, runBackupToolFromOtherJvmToGetExitCode(
                backupArguments( ""localhost:4445"", BACKUP_PATH.getPath(), ""non.existent"" ) ) );
    }
",non-flaky,5
13899,neo4j_neo4j,BackupHaIT.makeSureBackupCanBeRestored,"    @Test
    public void makeSureBackupCanBeRestored() throws Throwable
    {
        // Run backup
        assertEquals( 0, runBackupToolFromOtherJvmToGetExitCode( backupArguments( ""localhost:4445"",
                BACKUP_PATH.getPath(), null ) ) );

        // Add some new data
        DbRepresentation changedData = createSomeData( cluster.getMaster() );

        stopCluster();

        cleanData();

        copyBackup();

        startCluster();

        // Verify that old data is back
        assertThat( changedData.equals( DbRepresentation.of( cluster.getMaster() ) ), equalTo(false) );
    }
",non-flaky,5
13900,neo4j_neo4j,BackupHaIT.makeSureBackupCanBePerformedFromAnyInstance,"    @Test
    public void makeSureBackupCanBePerformedFromAnyInstance() throws Throwable
    {
        Integer[] backupPorts = {4445, 4446, 4447};

        for ( Integer port : backupPorts )
        {
            // Run backup
            assertEquals( 0, runBackupToolFromOtherJvmToGetExitCode( backupArguments( ""localhost:"" + port,
                    BACKUP_PATH.getPath(), null ) ) );

            // Add some new data
            DbRepresentation changedData = createSomeData( cluster.getMaster() );

            stopCluster();

            cleanData();

            copyBackup();

            startCluster();

            // Verify that old data is back
            assertThat( changedData.equals( DbRepresentation.of( cluster.getMaster() ) ), equalTo(false) );
        }
    }
",non-flaky,5
13901,neo4j_neo4j,TestClientThreadIsolation.run,"    @Test
    public void testTransactionsPulled() throws Exception
    {
        final HighlyAvailableGraphDatabase master =
                (HighlyAvailableGraphDatabase) new TestHighlyAvailableGraphDatabaseFactory().
                newHighlyAvailableDatabaseBuilder( TargetDirectory.forTest( TestClientThreadIsolation.class ).cleanDirectory(
                        ""master"" ).getAbsolutePath() ).
                setConfig( ClusterSettings.server_id, ""1"" ).
                newGraphDatabase();

        final HighlyAvailableGraphDatabase slave1 =
                (HighlyAvailableGraphDatabase) new TestHighlyAvailableGraphDatabaseFactory().
                newHighlyAvailableDatabaseBuilder( TargetDirectory.forTest( TestClientThreadIsolation.class ).cleanDirectory(
                        ""slave1"" ).getAbsolutePath() ).
                setConfig( ClusterSettings.cluster_server, ""127.0.0.1:5002"" ).
                setConfig( ClusterSettings.initial_hosts, ""127.0.0.1:5001"" ).
                setConfig( ClusterSettings.server_id, ""2"" ).
                setConfig( HaSettings.max_concurrent_channels_per_slave, ""2"" ).
                setConfig( HaSettings.ha_server, ""127.0.0.1:8001"" ).
                newGraphDatabase();

        Transaction masterTx = master.beginTx();
        master.createNode().createRelationshipTo( master.createNode(),
                DynamicRelationshipType.withName( ""master"" ) ).setProperty(
                ""largeArray"", new int[20000] );
        masterTx.success();
        masterTx.finish();

        Thread thread1 = new Thread( new Runnable()
        {
            public void run()
            {
                // TODO Figure out how to do this
//                Master masterClient = slave1.getBroker().getMaster().first();
//                Response<Integer> response = masterClient.createRelationshipType(
//                        slave1.getSlaveContext( 10 ), ""name"" );
//                slave1.receive( response ); // will be suspended here
//                response.close();
            }
",non-flaky,5
13902,neo4j_neo4j,TestPullUpdatesApplied.leftCluster,"    @Test
    public void testUpdatesAreWrittenToLogBeforeBeingAppliedToStore() throws Exception
    {
        int master = getCurrentMaster();
        addNode( master );
        int toKill = (master + 1) % dbs.length;
        HighlyAvailableGraphDatabase dbToKill = dbs[toKill];

        final CountDownLatch latch1 = new CountDownLatch( 1 );

        final HighlyAvailableGraphDatabase masterDb = dbs[master];
        masterDb.getDependencyResolver().resolveDependency( ClusterClient.class ).addClusterListener(
                new ClusterListener.Adapter()
                {
                    @Override
                    public void leftCluster( InstanceId instanceId, URI member )
                    {
                        latch1.countDown();
                        masterDb.getDependencyResolver().resolveDependency( ClusterClient.class )
                                .removeClusterListener( this );
                    }
",non-flaky,5
13903,neo4j_neo4j,RollingUpgradeIT.doRollingUpgradeFromPreviousVersionWithMasterLast,"    @Test
    public void doRollingUpgradeFromPreviousVersionWithMasterLast() throws Throwable
    {
        /* High level scenario:
         * 1   Have a cluster of 3 instances running <old version>
         * 1.1 Download a <old version> package
         * 1.2 Unpack the <old version> package
         * 1.4 Assembly classpath and start 3 JVMs running <old version>
         * 1.5 Create some data in the cluster
         * 2   Go over each one restarting into <this version>
         * 2.1 Grab a JVM and kill it
         * 2.2 Start that db inside this test JVM, which will run <this version>
         * 2.3 Perform a write transaction to the current master and see that it picks it up
         * 2.4 Perform a write transaction to to this instance and see that master picks it up
         * 3   Make sure the cluster functions after each one has been restarted
         * 3.1 Do basic transactions on master/slaves.
         * 3.2 Do a master switch
         * 3.3 Restart one slave
         * 3.4 Take down the instances and do consistency check */

        try
        {
            startOldVersionCluster();
            rollOverToNewVersion();
            shutdownAndDoConsistencyChecks();
        }
        catch ( Throwable e )
        {
            e.printStackTrace();
            throw e;
        }
    }
",non-flaky,5
13904,neo4j_neo4j,MasterClientTest.newClientsShouldNotIgnoreStoreIdDifferences,"    @Test(expected = MismatchingStoreIdException.class)
    public void newClientsShouldNotIgnoreStoreIdDifferences() throws Throwable
    {
        // Given
        MasterImpl.SPI masterImplSPI = MasterImplTest.mockedSpi( new StoreId( 1, 2, 3, 4 ) );
        when( masterImplSPI.getTransactionChecksum( anyLong() ) ).thenReturn( 5L );

        cleanupRule.add( newMasterServer( masterImplSPI ) );

        StoreId storeId = new StoreId( 5, 6, 7, 8 );
        MasterClient214 masterClient214 = cleanupRule.add( newMasterClient214( storeId ) );

        // When
        masterClient214.handshake( 1, storeId );
    }
",non-flaky,5
13905,neo4j_neo4j,MasterClientTest.clientShouldReadAndApplyTransactionLogsOnNewLockSessionRequest,"    @Test
    public void clientShouldReadAndApplyTransactionLogsOnNewLockSessionRequest() throws Throwable
    {
        // Given
        MasterImpl master = spy( newMasterImpl( mockMasterImplSpiWith( StoreId.DEFAULT ) ) );
        doReturn( voidResponseWithTransactionLogs() ).when( master ).newLockSession( any( RequestContext.class ) );

        cleanupRule.add( newMasterServer( master ) );

        DependencyResolver resolver = mock( DependencyResolver.class );
        LogicalTransactionStore txStore = mock( LogicalTransactionStore.class );
        TransactionRepresentationStoreApplier txApplier = mock( TransactionRepresentationStoreApplier.class );
        TransactionIdStore txIdStore = mock( TransactionIdStore.class );
        TransactionAppender txAppender = mock( TransactionAppender.class );
        when( txAppender.append( any( TransactionRepresentation.class ), anyLong() ) )
                .thenReturn( mock( Commitment.class ) );
        LogFile logFile = mock( LogFile.class );

        when( resolver.resolveDependency( LogicalTransactionStore.class ) ).thenReturn( txStore );
        when( resolver.resolveDependency( TransactionRepresentationStoreApplier.class ) ).thenReturn( txApplier );
        when( resolver.resolveDependency( TransactionIdStore.class ) ).thenReturn( txIdStore );
        when( resolver.resolveDependency( LogFile.class ) ).thenReturn( logFile );
        when( resolver.resolveDependency( LogRotation.class ) ).thenReturn( mock(LogRotation.class) );
        when( txStore.getAppender() ).thenReturn( txAppender );
        IndexUpdatesValidator indexUpdatesValidator = mock( IndexUpdatesValidator.class );
        when( indexUpdatesValidator.validate( any( TransactionRepresentation.class ),
                any( TransactionApplicationMode.class ) ) ).thenReturn( ValidatedIndexUpdates.NONE );
        when( resolver.resolveDependency( IndexUpdatesValidator.class ) ).thenReturn( indexUpdatesValidator );

        ResponseUnpacker unpacker = initAndStart( new TransactionCommittingResponseUnpacker( resolver ) );

        MasterClient masterClient = cleanupRule.add( newMasterClient214( StoreId.DEFAULT, unpacker ) );

        // When
        masterClient.newLockSession( new RequestContext( 1, 2, 3, 4, 5 ) );

        // Then
        verify( txAppender, times( TX_LOG_COUNT ) ).append( any( TransactionRepresentation.class ), anyLong() );
        // we can't verify transactionCommitted since that's part of the TransactionAppender, which we have mocked
        verify( txApplier, times( TX_LOG_COUNT ) )
                .apply( any( TransactionRepresentation.class ), any( ValidatedIndexUpdates.class ),
                        any( LockGroup.class ), anyLong(), any( TransactionApplicationMode.class ) );
        verify( txIdStore, times( TX_LOG_COUNT ) ).transactionClosed( anyLong() );
    }
",non-flaky,5
13906,neo4j_neo4j,TestClusterIndexDeletion.givenClusterWithCreatedIndexWhenDeleteIndexOnMasterThenIndexIsDeletedOnSlave,"    @Test
    public void givenClusterWithCreatedIndexWhenDeleteIndexOnMasterThenIndexIsDeletedOnSlave() throws Throwable
    {
        ClusterManager clusterManager =
            new ClusterManager( fromXml( getClass().getResource( ""/threeinstances.xml"" ).toURI() ),
                TargetDirectory.forTest( getClass() ).cleanDirectory( ""testCluster"" ),
                MapUtil.stringMap( HaSettings.ha_server.name(), "":6001-6005"",
                        HaSettings.tx_push_factor.name(), ""2"" ));
        try
        {
            // Given
            clusterManager.start();

            clusterManager.getDefaultCluster().await( ClusterManager.allSeesAllAsAvailable() );

            GraphDatabaseAPI master = clusterManager.getDefaultCluster().getMaster();
            try ( Transaction tx = master.beginTx() )
            {
                master.index().forNodes( ""Test"" );
                tx.success();
            }

            HighlyAvailableGraphDatabase aSlave = clusterManager.getDefaultCluster().getAnySlave();
            try ( Transaction tx = aSlave.beginTx() )
            {
                assertThat( aSlave.index().existsForNodes( ""Test"" ), equalTo( true ) );
                tx.success();
            }

            // When
            try ( Transaction tx = master.beginTx() )
            {
                master.index().forNodes( ""Test"" ).delete();
                tx.success();
            }

            // Then
            HighlyAvailableGraphDatabase anotherSlave = clusterManager.getDefaultCluster().getAnySlave();
            try ( Transaction tx = anotherSlave.beginTx() )
            {
                assertThat( anotherSlave.index().existsForNodes( ""Test"" ), equalTo( false ) );
                tx.success();
            }
        }
        finally
        {
            clusterManager.stop();
        }
    }
",non-flaky,5
13907,neo4j_neo4j,PullStormIT.run,"    @Test
    public void testPullStorm() throws Throwable
    {
        // given

        ClusterManager clusterManager = new ClusterManager( ClusterManager.clusterWithAdditionalArbiters( 2, 1 ),
                testDirectory.directory(),
                stringMap( HaSettings.pull_interval.name(), ""0"",
                           HaSettings.tx_push_factor.name(), ""1"") );

        clusterManager.start();

        try
        {
            ClusterManager.ManagedCluster cluster = clusterManager.getDefaultCluster();
            cluster.await( ClusterManager.masterAvailable(  ) );
            cluster.await( ClusterManager.masterSeesSlavesAsAvailable( 1 ) );

            // Create data
            final HighlyAvailableGraphDatabase master = cluster.getMaster();
            {
                Transaction tx = master.beginTx();
                for ( int i = 0; i < 1000; i++ )
                {
                    master.createNode().setProperty( ""foo"", ""bar"" );
                }
                tx.success();
                tx.finish();
            }

            // Slave goes down
            HighlyAvailableGraphDatabase slave = cluster.getAnySlave();
            ClusterManager.RepairKit repairKit = cluster.fail( slave );

            // Create more data
            for ( int i = 0; i < 1000; i++ )
            {
                {
                    Transaction tx = master.beginTx();
                    for ( int j = 0; j < 1000; j++ )
                    {
                        master.createNode().setProperty( ""foo"", ""bar"" );
                        master.createNode().setProperty( ""foo"", ""bar"" );
                    }
                    tx.success();
                    tx.finish();
                }
            }

            // Slave comes back online
            repairKit.repair();

            cluster.await( ClusterManager.masterSeesSlavesAsAvailable( 1 ) );

            // when

            // Create 20 concurrent transactions
            System.out.println( ""Pull storm"" );
            ExecutorService executor = Executors.newFixedThreadPool( 20 );
            for ( int i = 0; i < 20; i++ )
            {
                executor.submit( new Runnable()
                {
                    @Override
                    public void run()
                    {
                        Transaction tx = master.beginTx();
                        master.createNode().setProperty( ""foo"", ""bar"" );
                        tx.success();
                        tx.finish(); // This should cause lots of concurrent calls to pullUpdate()
                    }
",non-flaky,5
13908,neo4j_neo4j,TestBlockLogBuffer.onlyOneNonFullBlock,"    @Test
    public void onlyOneNonFullBlock() throws IOException
    {
        byte[] bytes = new byte[255];
        ChannelBuffer wrappedBuffer = ChannelBuffers.wrappedBuffer( bytes );
        wrappedBuffer.resetWriterIndex();
        BlockLogBuffer buffer = new BlockLogBuffer( wrappedBuffer, new Monitors().newMonitor( ByteCounterMonitor.class ) );

        byte byteValue = 5;
        int intValue = 1234;
        long longValue = 574853;
        float floatValue = 304985.5f;
        double doubleValue = 48493.22d;
        final byte[] bytesValue = new byte[] { 1, 5, 2, 6, 3 };
        buffer.put( byteValue );
        buffer.putInt( intValue );
        buffer.putLong( longValue );
        buffer.putFloat( floatValue );
        buffer.putDouble( doubleValue );
        buffer.put( bytesValue, bytesValue.length );
        buffer.close();

        ByteBuffer verificationBuffer = ByteBuffer.wrap( bytes );
        assertEquals( 30, verificationBuffer.get() );
        assertEquals( byteValue, verificationBuffer.get() );
        assertEquals( intValue, verificationBuffer.getInt() );
        assertEquals( longValue, verificationBuffer.getLong() );
        assertEquals( floatValue, verificationBuffer.getFloat(), 0.0 );
        assertEquals( doubleValue, verificationBuffer.getDouble(), 0.0 );
        byte[] actualBytes = new byte[bytesValue.length];
        verificationBuffer.get( actualBytes );
        assertThat( actualBytes, new ArrayMatches<byte[]>( bytesValue ) );
    }
",non-flaky,5
13909,neo4j_neo4j,TestBlockLogBuffer.readSmallPortions,"    @Test
    public void readSmallPortions() throws IOException
    {
        byte[] bytes = new byte[255];
        ChannelBuffer wrappedBuffer = ChannelBuffers.wrappedBuffer( bytes );
        wrappedBuffer.resetWriterIndex();
        BlockLogBuffer buffer = new BlockLogBuffer( wrappedBuffer, new Monitors().newMonitor( ByteCounterMonitor.class ) );

        byte byteValue = 5;
        int intValue = 1234;
        long longValue = 574853;
        buffer.put( byteValue );
        buffer.putInt( intValue );
        buffer.putLong( longValue );
        buffer.close();

        ReadableByteChannel reader = new BlockLogReader( wrappedBuffer );
        ByteBuffer verificationBuffer = ByteBuffer.wrap( new byte[1] );
        reader.read( verificationBuffer );
        verificationBuffer.flip();
        assertEquals( byteValue, verificationBuffer.get() );
        verificationBuffer = ByteBuffer.wrap( new byte[4] );
        reader.read( verificationBuffer );
        verificationBuffer.flip();
        assertEquals( intValue, verificationBuffer.getInt() );
        verificationBuffer = ByteBuffer.wrap( new byte[8] );
        reader.read( verificationBuffer );
        verificationBuffer.flip();
        assertEquals( longValue, verificationBuffer.getLong() );
    }
",non-flaky,5
13910,neo4j_neo4j,TestBlockLogBuffer.readOnlyOneNonFullBlock,"    @Test
    public void readOnlyOneNonFullBlock() throws IOException
    {
        byte[] bytes = new byte[255];
        ChannelBuffer wrappedBuffer = ChannelBuffers.wrappedBuffer( bytes );
        wrappedBuffer.resetWriterIndex();
        BlockLogBuffer buffer = new BlockLogBuffer( wrappedBuffer, new Monitors().newMonitor( ByteCounterMonitor.class ) );

        byte byteValue = 5;
        int intValue = 1234;
        long longValue = 574853;
        float floatValue = 304985.5f;
        double doubleValue = 48493.22d;
        final byte[] bytesValue = new byte[] { 1, 5, 2, 6, 3 };
        buffer.put( byteValue );
        buffer.putInt( intValue );
        buffer.putLong( longValue );
        buffer.putFloat( floatValue );
        buffer.putDouble( doubleValue );
        buffer.put( bytesValue, bytesValue.length );
        buffer.close();

        ReadableByteChannel reader = new BlockLogReader( wrappedBuffer );
        ByteBuffer verificationBuffer = ByteBuffer.wrap( new byte[1000] );
        reader.read( verificationBuffer );
        verificationBuffer.flip();
        assertEquals( byteValue, verificationBuffer.get() );
        assertEquals( intValue, verificationBuffer.getInt() );
        assertEquals( longValue, verificationBuffer.getLong() );
        assertEquals( floatValue, verificationBuffer.getFloat(), 0.0 );
        assertEquals( doubleValue, verificationBuffer.getDouble(), 0.0 );
        byte[] actualBytes = new byte[bytesValue.length];
        verificationBuffer.get( actualBytes );
        assertThat( actualBytes, new ArrayMatches<byte[]>( bytesValue ) );
    }
",non-flaky,5
13911,neo4j_neo4j,TestBlockLogBuffer.onlyOneFullBlock,"    @Test
    public void onlyOneFullBlock() throws Exception
    {
        byte[] bytes = new byte[256];
        ChannelBuffer wrappedBuffer = ChannelBuffers.wrappedBuffer( bytes );
        wrappedBuffer.resetWriterIndex();
        BlockLogBuffer buffer = new BlockLogBuffer( wrappedBuffer, new Monitors().newMonitor( ByteCounterMonitor.class ) );

        byte[] bytesValue = new byte[255];
        bytesValue[0] = 1;
        bytesValue[254] = -1;
        buffer.put( bytesValue, bytesValue.length );
        buffer.close();

        ByteBuffer verificationBuffer = ByteBuffer.wrap( bytes );
        assertEquals( (byte) 255, verificationBuffer.get() );
        byte[] actualBytes = new byte[bytesValue.length];
        verificationBuffer.get( actualBytes );
        assertThat( actualBytes, new ArrayMatches<byte[]>( bytesValue ) );
    }
",non-flaky,5
13912,neo4j_neo4j,TestBlockLogBuffer.readOnlyOneFullBlock,"    @Test
    public void readOnlyOneFullBlock() throws Exception
    {
        byte[] bytes = new byte[256];
        ChannelBuffer wrappedBuffer = ChannelBuffers.wrappedBuffer( bytes );
        wrappedBuffer.resetWriterIndex();
        BlockLogBuffer buffer = new BlockLogBuffer( wrappedBuffer, new Monitors().newMonitor( ByteCounterMonitor.class ) );

        byte[] bytesValue = new byte[255];
        bytesValue[0] = 1;
        bytesValue[254] = -1;
        buffer.put( bytesValue, bytesValue.length );
        buffer.close();

        ReadableByteChannel reader = new BlockLogReader( wrappedBuffer );
        ByteBuffer verificationBuffer = ByteBuffer.wrap( new byte[1000] );
        reader.read( verificationBuffer );
        verificationBuffer.flip();
        byte[] actualBytes = new byte[bytesValue.length];
        verificationBuffer.get( actualBytes );
        assertThat( actualBytes, new ArrayMatches<byte[]>( bytesValue ) );
    }
",non-flaky,5
13913,neo4j_neo4j,TestBlockLogBuffer.canWriteLargestAtomAfterFillingBuffer,"    @Test
    public void canWriteLargestAtomAfterFillingBuffer() throws Exception
    {
        byte[] bytes = new byte[300];
        ChannelBuffer wrappedBuffer = ChannelBuffers.wrappedBuffer( bytes );
        wrappedBuffer.resetWriterIndex();
        BlockLogBuffer buffer = new BlockLogBuffer( wrappedBuffer, new Monitors().newMonitor( ByteCounterMonitor.class ) );

        byte[] bytesValue = new byte[255];
        bytesValue[0] = 1;
        bytesValue[254] = -1;
        long longValue = 123456;
        buffer.put( bytesValue, bytesValue.length );
        buffer.putLong( longValue );
        buffer.close();

        ByteBuffer verificationBuffer = ByteBuffer.wrap( bytes );
        assertEquals( (byte) 0, verificationBuffer.get() );
        byte[] actualBytes = new byte[bytesValue.length];
        verificationBuffer.get( actualBytes );
        assertThat( actualBytes, new ArrayMatches<byte[]>( bytesValue ) );
        assertEquals( (byte) 8, verificationBuffer.get() );
        assertEquals( longValue, verificationBuffer.getLong() );
    }
",non-flaky,5
13914,neo4j_neo4j,TestBlockLogBuffer.canWriteReallyLargeByteArray,"    @Test
    public void canWriteReallyLargeByteArray() throws Exception
    {
        byte[] bytes = new byte[650];
        ChannelBuffer wrappedBuffer = ChannelBuffers.wrappedBuffer( bytes );
        wrappedBuffer.resetWriterIndex();
        BlockLogBuffer buffer = new BlockLogBuffer( wrappedBuffer, new Monitors().newMonitor( ByteCounterMonitor.class ) );

        byte[] bytesValue = new byte[600];
        bytesValue[1] = 1;
        bytesValue[99] = 2;
        bytesValue[199] = 3;
        bytesValue[299] = 4;
        bytesValue[399] = 5;
        bytesValue[499] = 6;
        bytesValue[599] = 7;
        buffer.put( bytesValue, bytesValue.length );
        buffer.close();

        byte[] actual;
        ByteBuffer verificationBuffer = ByteBuffer.wrap( bytes );
        assertEquals( (byte) 0, verificationBuffer.get() );
        actual = new byte[255];
        verificationBuffer.get( actual );
        assertThat( actual, new ArrayMatches<byte[]>( Arrays.copyOfRange( bytesValue, 0, 255 ) ) );
        assertEquals( (byte) 0, verificationBuffer.get() );
        actual = new byte[255];
        verificationBuffer.get( actual );
        assertThat( actual, new ArrayMatches<byte[]>( Arrays.copyOfRange( bytesValue, 255, 510 ) ) );
        assertEquals( (byte) 90, verificationBuffer.get() );
        actual = new byte[90];
        verificationBuffer.get( actual );
        assertThat( actual, new ArrayMatches<byte[]>( Arrays.copyOfRange( bytesValue, 510, 600 ) ) );
    }
",non-flaky,5
13915,neo4j_neo4j,TestBlockLogBuffer.canReaderReallyLargeByteArray,"    @Test
    public void canReaderReallyLargeByteArray() throws Exception
    {
        byte[] bytes = new byte[650];
        ChannelBuffer wrappedBuffer = ChannelBuffers.wrappedBuffer( bytes );
        wrappedBuffer.resetWriterIndex();
        BlockLogBuffer buffer = new BlockLogBuffer( wrappedBuffer, new Monitors().newMonitor( ByteCounterMonitor.class ) );

        byte[] bytesValue = new byte[600];
        bytesValue[1] = 1;
        bytesValue[99] = 2;
        bytesValue[199] = 3;
        bytesValue[299] = 4;
        bytesValue[399] = 5;
        bytesValue[499] = 6;
        bytesValue[599] = 7;
        buffer.put( bytesValue, bytesValue.length );
        buffer.close();

        byte[] actual;
        BlockLogReader reader = new BlockLogReader( wrappedBuffer );
        ByteBuffer verificationBuffer = ByteBuffer.wrap( new byte[1000] );
        reader.read( verificationBuffer );
        verificationBuffer.flip();
        actual = new byte[255];
        verificationBuffer.get( actual );
        assertThat( actual, new ArrayMatches<byte[]>( Arrays.copyOfRange( bytesValue, 0, 255 ) ) );
        actual = new byte[255];
        verificationBuffer.get( actual );
        assertThat( actual, new ArrayMatches<byte[]>( Arrays.copyOfRange( bytesValue, 255, 510 ) ) );
        actual = new byte[90];
        verificationBuffer.get( actual );
        assertThat( actual, new ArrayMatches<byte[]>( Arrays.copyOfRange( bytesValue, 510, 600 ) ) );
    }
",non-flaky,5
13916,neo4j_neo4j,HaCacheIT.shouldUpdateSlaveCacheWhenRemovingRelationshipGroupFromDenseNode,"    @Test
    public void shouldUpdateSlaveCacheWhenRemovingRelationshipGroupFromDenseNode() throws Throwable
    {
        ClusterManager manager = new ClusterManager( clusterOfSize( 3 ), root.directory(),
                                                     stringMap( tx_push_factor.name(), ""2"",
                                                                cache_type.name(), ""strong"",
                                                                dense_node_threshold.name(), """" + DENSE_NODE ) );
        try
        {
            // given
            manager.start();
            ClusterManager.ManagedCluster cluster = manager.getDefaultCluster();
            cluster.await( ClusterManager.masterAvailable() );
            cluster.await( ClusterManager.masterSeesAllSlavesAsAvailable() );
            HighlyAvailableGraphDatabase master = cluster.getMaster();
            long nodeId; // a dense node
            try ( Transaction tx = master.beginTx() )
            {
                Node node = master.createNode();
                for ( int i = 0; i < DENSE_NODE; i++ )
                {
                    node.createRelationshipTo( master.createNode(), withName( ""FOO"" ) );
                }
                master.createNode().createRelationshipTo( node, withName( ""BAR"" ) );

                tx.success();
                nodeId = node.getId();
            }
            // fully cache node on all instances
            int count = 0;
            for ( HighlyAvailableGraphDatabase db : cluster.getAllMembers() )
            {
                try ( Transaction tx = db.beginTx() )
                {
                    int these = count( db.getNodeById( nodeId ).getRelationships() );
                    assertTrue( String.format( ""expected=%s, count here=%s"", count, these ),
                                these != 0 && (count == 0 || these == count) );
                    count = these;
                    tx.success();
                }
            }

            // when
            try ( Transaction tx = master.beginTx() )
            {
                for ( Relationship relationship : master.getNodeById( nodeId ).getRelationships( withName( ""BAR"" ) ) )
                {
                    relationship.delete();
                }
                tx.success();
            }

            // then
            HighlyAvailableGraphDatabase slave = cluster.getAnySlave();
            try ( Transaction tx = slave.beginTx() )
            {
                List<String> relationships = new ArrayList<>();
                for ( Relationship relationship : slave.getNodeById( nodeId ).getRelationships() )
                {
                    relationships.add( String.format( ""(%d)-[%d:%s]->(%d)"",
                                                      relationship.getStartNode().getId(),
                                                      relationship.getId(), relationship.getType().name(),
                                                      relationship.getEndNode().getId() ) );
                }
                assertEquals( joinLines( relationships ), count - 1, relationships.size() );
                assertEquals( count - 1, count( slave.getNodeById( nodeId ).getRelationships() ) );

                tx.success();
            }
        }
        finally
        {
            manager.shutdown();
        }
    }
",non-flaky,5
13917,neo4j_neo4j,MultipleClusterTest.runTwoClusters,"    @Test
    public void runTwoClusters() throws Throwable
    {
        File root = TargetDirectory.forTest( getClass() ).cleanDirectory( ""cluster"" );

        ClusterManager clusterManager = new ClusterManager(
                fromXml( getClass().getResource( ""/twoclustertest.xml"" ).toURI() ), root, MapUtil.stringMap() );

        try
        {
            clusterManager.start();
            ManagedCluster cluster1 = clusterManager.getCluster( ""neo4j.ha"" );

            long cluster1NodeId;
            {
                GraphDatabaseService master = cluster1.getMaster();
                logging.getLogger().info( ""CREATE NODE"" );
                Transaction tx = master.beginTx();
                Node node = master.createNode();
                node.setProperty( ""cluster"", ""neo4j.ha"" );
                cluster1NodeId = node.getId();
                logging.getLogger().info( ""CREATED NODE"" );
                tx.success();
                tx.finish();
            }

            ManagedCluster cluster2 = clusterManager.getCluster( ""neo4j.ha2"" );
            long cluster2NodeId;
            {
                GraphDatabaseService master = cluster2.getMaster();
                logging.getLogger().info( ""CREATE NODE"" );
                Transaction tx = master.beginTx();
                Node node = master.createNode();
                node.setProperty( ""cluster"", ""neo4j.ha2"" );
                cluster2NodeId = node.getId();
                logging.getLogger().info( ""CREATED NODE"" );
                tx.success();
                tx.finish();
            }

            // Verify properties in all cluster nodes
            for ( HighlyAvailableGraphDatabase highlyAvailableGraphDatabase : cluster1.getAllMembers() )
            {
                highlyAvailableGraphDatabase.getDependencyResolver().resolveDependency( UpdatePullerClient.class ).pullUpdates();

                Transaction transaction = highlyAvailableGraphDatabase.beginTx();
                assertEquals( ""neo4j.ha"", highlyAvailableGraphDatabase.getNodeById( cluster1NodeId ).getProperty(
                        ""cluster"" ) );
                transaction.finish();
            }

            for ( HighlyAvailableGraphDatabase highlyAvailableGraphDatabase : cluster2.getAllMembers() )
            {
                highlyAvailableGraphDatabase.getDependencyResolver().resolveDependency( UpdatePullerClient.class ).pullUpdates();

                Transaction transaction = highlyAvailableGraphDatabase.beginTx();
                assertEquals( ""neo4j.ha2"", highlyAvailableGraphDatabase.getNodeById( cluster2NodeId ).getProperty(
                        ""cluster"" ) );
                transaction.finish();
            }
        }
        finally
        {
            clusterManager.stop();
        }
    }
",non-flaky,5
13918,neo4j_neo4j,QuorumWritesIT.testMasterStopsWritesWhenMajorityIsUnavailable,"    @Test
    public void testMasterStopsWritesWhenMajorityIsUnavailable() throws Throwable
    {
        File root = TargetDirectory.forTest( getClass() ).cleanDirectory(
                ""testMasterStopsWritesWhenMajorityIsUnavailable"" );
        ClusterManager clusterManager = new ClusterManager( clusterOfSize( 3 ), root,
                MapUtil.stringMap( HaSettings.tx_push_factor.name(), ""2"", HaSettings.state_switch_timeout.name(), ""5s""
                ) );
        try
        {
            clusterManager.start();
            ClusterManager.ManagedCluster cluster = clusterManager.getDefaultCluster();
            cluster.await( ClusterManager.masterAvailable(  ) );
            cluster.await( ClusterManager.masterSeesAllSlavesAsAvailable() );

            HighlyAvailableGraphDatabase master = cluster.getMaster();

            doTx( master );

            final CountDownLatch latch1 = new CountDownLatch( 1 );
            waitOnHeartbeatFail( master, latch1 );

            HighlyAvailableGraphDatabase slave1 = cluster.getAnySlave();
            cluster.fail( slave1 );

            latch1.await();
            slave1.shutdown();

            doTx( master );

            final CountDownLatch latch2 = new CountDownLatch( 1 );
            waitOnHeartbeatFail( master, latch2 );

            HighlyAvailableGraphDatabase slave2 = cluster.getAnySlave( slave1 );
            ClusterManager.RepairKit rk2 = cluster.fail( slave2 );

            latch2.await();

            // The master should stop saying that it's master
            assertFalse( master.isMaster() );

            try
            {
                doTx( master );
                fail( ""After both slaves fail txs should not go through"" );
            }
            catch ( TransactionFailureException e )
            {
                assertEquals( ""Timeout waiting for cluster to elect master"", e.getMessage() );
            }

            // This is not a hack, this simulates a period of inactivity in the cluster.
            Thread.sleep( 120000 ); // TODO Define ""inactivity"" and await that condition instead of 120 seconds.

            final CountDownLatch latch3 = new CountDownLatch( 1 );
            final CountDownLatch latch4 = new CountDownLatch( 1 );
            final CountDownLatch latch5 = new CountDownLatch( 1 );
            waitOnHeartbeatAlive( master, latch3 );
//            waitOnRoleIsAvailable( master, latch4, HighAvailabilityModeSwitcher.MASTER );
            waitOnRoleIsAvailable( master, latch5, HighAvailabilityModeSwitcher.SLAVE );

            rk2.repair();

            latch3.await();

            cluster.await( ClusterManager.masterAvailable( slave1, slave2 ) );

//            latch4.await();
            latch5.await();

            cluster.await( ClusterManager.masterAvailable(  ) );

            assertTrue( master.isMaster() );
            assertFalse( slave2.isMaster() );

            Node finalNode = doTx( master );

            try ( Transaction transaction = slave2.beginTx() )
            {
                slave2.getNodeById( finalNode.getId() );
                transaction.success();
            }
        }
        finally
        {
            clusterManager.stop();
        }
    }
",non-flaky,5
13919,neo4j_neo4j,QuorumWritesIT.testInstanceCanBeReplacedToReestablishQuorum,"    @Test
    public void testInstanceCanBeReplacedToReestablishQuorum() throws Throwable
    {
        File root = TargetDirectory.forTest( getClass() ).cleanDirectory(
                ""testInstanceCanBeReplacedToReestablishQuorum""
        );
        ClusterManager clusterManager = new ClusterManager( clusterOfSize( 3 ), root,
                MapUtil.stringMap( HaSettings.tx_push_factor.name(), ""2"", HaSettings.state_switch_timeout.name(), ""5s"" ) );
        clusterManager.start();
        ClusterManager.ManagedCluster cluster = clusterManager.getDefaultCluster();

        HighlyAvailableGraphDatabase master = cluster.getMaster();

        cluster.await( ClusterManager.masterSeesAllSlavesAsAvailable() );

        doTx( master );

        final CountDownLatch latch1 = new CountDownLatch( 1 );
        waitOnHeartbeatFail( master, latch1 );

        HighlyAvailableGraphDatabase slave1 = cluster.getAnySlave();
        cluster.fail( slave1 );

        latch1.await();
        slave1.shutdown();

        doTx( master );

        final CountDownLatch latch2 = new CountDownLatch( 1 );
        waitOnHeartbeatFail( master, latch2 );

        HighlyAvailableGraphDatabase slave2 = cluster.getAnySlave( slave1 );
        cluster.fail( slave2 );

        latch2.await();

        // The master should stop saying that it's master
        assertFalse( master.isMaster() );

        try
        {
            doTx( master );
            fail( ""After both slaves fail txs should not go through"" );
        }
        catch ( TransactionFailureException e )
        {
            assertEquals( ""Timeout waiting for cluster to elect master"", e.getMessage() );
        }

        // This is not a hack, this simulates a period of inactivity in the cluster.
        Thread.sleep( 120000 ); // TODO Define ""inactivity"" and await that condition instead of 120 seconds.

        final CountDownLatch latch3 = new CountDownLatch( 1 );
        final CountDownLatch latch4 = new CountDownLatch( 1 );
        final CountDownLatch latch5 = new CountDownLatch( 1 );
        waitOnHeartbeatAlive( master, latch3 );
        waitOnRoleIsAvailable( master, latch4, HighAvailabilityModeSwitcher.MASTER );
        waitOnRoleIsAvailable( master, latch5, HighAvailabilityModeSwitcher.SLAVE );

        HighlyAvailableGraphDatabase replacement =
                (HighlyAvailableGraphDatabase) new TestHighlyAvailableGraphDatabaseFactory().
                newHighlyAvailableDatabaseBuilder( new File( root, ""replacement"" ).getAbsolutePath() ).
                setConfig( ClusterSettings.cluster_server, "":5010"" ).
                setConfig( HaSettings.ha_server, "":6010"" ).
                setConfig( ClusterSettings.server_id, ""3"" ).
                setConfig( ClusterSettings.initial_hosts, cluster.getInitialHostsConfigString() ).
                setConfig( HaSettings.tx_push_factor, ""0"" ).
                newGraphDatabase();

        latch3.await();
        latch4.await();
        latch5.await();

        assertTrue( master.isMaster() );
        assertFalse( replacement.isMaster() );

        Node finalNode = doTx( master );

        Transaction transaction = replacement.beginTx();
        try
        {
            replacement.getNodeById( finalNode.getId() );
        }
        finally
        {
            transaction.finish();
        }

        clusterManager.stop();
        replacement.shutdown();
    }
",non-flaky,5
13920,neo4j_neo4j,ConstraintsInHAIT.creatingConstraintOnSlaveIsNotAllowed,"    @Test
    public void creatingConstraintOnSlaveIsNotAllowed() throws Exception
    {
        // given
        ClusterManager.ManagedCluster cluster = clusterRule.startCluster();
        HighlyAvailableGraphDatabase slave = cluster.getAnySlave();

        slave.beginTx();
        try
        {
            ConstraintCreator constraintCreator = slave.schema()
                    .constraintFor( DynamicLabel.label( ""LabelName"" ) ).assertPropertyIsUnique( ""PropertyName"" );

            // when
            constraintCreator.create();
            fail( ""should have thrown exception"" );
        }
        catch ( InvalidTransactionTypeException e )
        {
            assertThat(e.getMessage(), equalTo(""Modifying the database schema can only be done on the master server, "" +
                    ""this server is a slave. Please issue schema modification commands directly to the master.""));
        }
    }
",non-flaky,5
13921,neo4j_neo4j,ForeignStoreIdIT.emptyForeignDbShouldJoinAfterHavingItsEmptyDbDeleted,"    @Test
    public void emptyForeignDbShouldJoinAfterHavingItsEmptyDbDeleted() throws Exception
    {
        // GIVEN
        // -- one instance running
        firstInstance = new TestHighlyAvailableGraphDatabaseFactory()
                .newHighlyAvailableDatabaseBuilder( DIR.cleanDirectory( ""1"" ).getAbsolutePath() )
                .setConfig( server_id, ""1"" )
                .setConfig( cluster_server, ""127.0.0.1:5001"" )
                .setConfig( ha_server, ""127.0.0.1:6031"" )
                .setConfig( initial_hosts, ""127.0.0.1:5001"" )
                .newGraphDatabase();
        // -- another instance preparing to join with a store with a different store ID
        String foreignDbStoreDir = createAnotherStore( DIR.cleanDirectory( ""2"" ), 0 );

        // WHEN
        // -- the other joins
        foreignInstance = new TestHighlyAvailableGraphDatabaseFactory()
                .newHighlyAvailableDatabaseBuilder( foreignDbStoreDir )
                .setConfig( server_id, ""2"" )
                .setConfig( initial_hosts, ""127.0.0.1:5001"" )
                .setConfig( cluster_server, ""127.0.0.1:5002"" )
                .setConfig( ha_server, ""127.0.0.1:6032"" )
                .newGraphDatabase();
        // -- and creates a node
        long foreignNode = createNode( foreignInstance, ""foreigner"" );

        // THEN
        // -- that node should arrive at the master
        assertEquals( foreignNode, findNode( firstInstance, ""foreigner"" ) );
    }
",non-flaky,5
13922,neo4j_neo4j,ForeignStoreIdIT.nonEmptyForeignDbShouldNotBeAbleToJoin,"    @Test
    public void nonEmptyForeignDbShouldNotBeAbleToJoin() throws Exception
    {
        // GIVEN
        // -- one instance running
        firstInstance = new TestHighlyAvailableGraphDatabaseFactory()
                .newHighlyAvailableDatabaseBuilder( DIR.cleanDirectory( ""1"" ).getAbsolutePath() )
                .setConfig( server_id, ""1"" )
                .setConfig( initial_hosts, ""127.0.0.1:5001"" )
                .setConfig( cluster_server, ""127.0.0.1:5001"" )
                .setConfig( ha_server, ""127.0.0.1:6041"" )
                .newGraphDatabase();
        createNodes( firstInstance, 3, ""first"" );
        // -- another instance preparing to join with a store with a different store ID
        String foreignDbStoreDir = createAnotherStore( DIR.cleanDirectory( ""2"" ), 1 );

        // WHEN
        // -- the other joins
        foreignInstance = new TestHighlyAvailableGraphDatabaseFactory()
                .newHighlyAvailableDatabaseBuilder( foreignDbStoreDir )
                .setConfig( server_id, ""2"" )
                .setConfig( initial_hosts, ""127.0.0.1:5001"" )
                .setConfig( cluster_server, ""127.0.0.1:5002"" )
                .setConfig( ha_server, ""127.0.0.1:6042"" )
                .setConfig( state_switch_timeout, ""5s"" )
                .newGraphDatabase();

        try
        {
            // THEN
            // -- that node should arrive at the master
            createNode( foreignInstance, ""foreigner"" );
            fail( ""Shouldn't be able to create a node, since it shouldn't have joined"" );
        }
        catch ( Exception e )
        {
            // Good
        }
    }
",non-flaky,5
13923,neo4j_neo4j,TestPullUpdates.makeSureUpdatePullerGetsGoingAfterMasterSwitch,"    @Test
    public void makeSureUpdatePullerGetsGoingAfterMasterSwitch() throws Throwable
    {
        File root = TargetDirectory.forTest( getClass() ).cleanDirectory( testName.getMethodName() );
        ClusterManager clusterManager = new ClusterManager( clusterOfSize( 3 ), root, MapUtil.stringMap(
                HaSettings.pull_interval.name(), PULL_INTERVAL+""ms"",
                ClusterSettings.heartbeat_interval.name(), ""2s"",
                ClusterSettings.heartbeat_timeout.name(), ""30s"") );
        clusterManager.start();
        cluster = clusterManager.getDefaultCluster();
        cluster.await( allSeesAllAsAvailable() );

        cluster.info( ""### Creating initial dataset"" );
        long commonNodeId = createNodeOnMaster();

        HighlyAvailableGraphDatabase master = cluster.getMaster();
        setProperty( master, commonNodeId, 1 );
        cluster.info( ""### Initial dataset created"" );
        awaitPropagation( 1, commonNodeId, cluster );

        cluster.info( ""### Shutting down master"" );
        ClusterManager.RepairKit masterShutdownRK = cluster.shutdown( master );

        cluster.info( ""### Awaiting new master"" );
        cluster.await( masterAvailable( master ) );
        cluster.await( masterSeesSlavesAsAvailable( 1 ) );

        cluster.info( ""### Doing a write to master"" );
        setProperty( cluster.getMaster(), commonNodeId, 2 );
        awaitPropagation( 2, commonNodeId, cluster, master );

        cluster.info( ""### Repairing cluster"" );
        masterShutdownRK.repair();
        cluster.await( masterAvailable() );
        cluster.await( masterSeesSlavesAsAvailable( 2 ) );
        cluster.await( allSeesAllAsAvailable() );

        cluster.info( ""### Awaiting change propagation"" );
        awaitPropagation( 2, commonNodeId, cluster );
    }
",non-flaky,5
13924,neo4j_neo4j,TestPullUpdates.pullUpdatesShellAppPullsUpdates,"    @Test
    public void pullUpdatesShellAppPullsUpdates() throws Throwable
    {
        File root = TargetDirectory.forTest( getClass() ).cleanDirectory( testName.getMethodName() );
        Map<Integer, Map<String, String>> instanceConfig = new HashMap<>();
        for (int i = 1; i <= 2; i++)
        {
            Map<String, String> thisInstance =
                    MapUtil.stringMap( ShellSettings.remote_shell_port.name(), """" + (SHELL_PORT + i) );
            instanceConfig.put( i, thisInstance );
        }
        ClusterManager clusterManager = new ClusterManager( clusterOfSize( 2 ), root, MapUtil.stringMap(
                HaSettings.pull_interval.name(), ""0"",
                HaSettings.tx_push_factor.name(), ""0"" ,
                ShellSettings.remote_shell_enabled.name(), ""true""
                ), instanceConfig );
        clusterManager.start();
        cluster = clusterManager.getDefaultCluster();

        long commonNodeId = createNodeOnMaster();

        setProperty( cluster.getMaster(), commonNodeId, 1 );
        callPullUpdatesViaShell( 2 );
        HighlyAvailableGraphDatabase slave = cluster.getAnySlave();
        try ( Transaction tx = slave.beginTx() )
        {
            assertEquals( 1, slave.getNodeById( commonNodeId ).getProperty( ""i"" ) );
        }
    }
",non-flaky,5
13925,neo4j_neo4j,TestPullUpdates.leftCluster,"    @Test
    public void shouldPullUpdatesOnStartupNoMatterWhat() throws Exception
    {
        GraphDatabaseService slave = null;
        GraphDatabaseService master = null;
        try
        {
            File testRootDir = TargetDirectory.forTest( getClass() ).cleanDirectory( testName.getMethodName() );
            File masterDir = new File( testRootDir, ""master"" );
            master = new TestHighlyAvailableGraphDatabaseFactory().
                    newHighlyAvailableDatabaseBuilder( masterDir.getAbsolutePath() )
                    .setConfig( ClusterSettings.server_id, ""1"" )
                    .setConfig( ClusterSettings.initial_hosts, "":5001"" )
                    .newGraphDatabase();

            // Copy the store, then shutdown, so update pulling later makes sense
            File slaveDir = new File( testRootDir, ""slave"" );
            slave = new TestHighlyAvailableGraphDatabaseFactory().
                    newHighlyAvailableDatabaseBuilder( slaveDir.getAbsolutePath() )
                    .setConfig( ClusterSettings.server_id, ""2"" )
                    .setConfig( ClusterSettings.initial_hosts, "":5001"" )
                    .newGraphDatabase();

            // Required to block until the slave has left for sure
            final CountDownLatch slaveLeftLatch = new CountDownLatch( 1 );

            final ClusterClient masterClusterClient = ( (HighlyAvailableGraphDatabase) master ).getDependencyResolver()
                    .resolveDependency( ClusterClient.class );

            masterClusterClient.addClusterListener( new ClusterListener.Adapter()
            {
                @Override
                public void leftCluster( InstanceId instanceId, URI member )
                {
                    slaveLeftLatch.countDown();
                    masterClusterClient.removeClusterListener( this );
                }
",non-flaky,5
13926,neo4j_neo4j,TestProver.aClusterSnapshotShouldEqualItsOrigin,"    @Test
    public void aClusterSnapshotShouldEqualItsOrigin() throws Exception
    {
        // Given
        Logging logging = new TestLogging();
        ClusterConfiguration config = new ClusterConfiguration( ""default"",
                logging.getMessagesLog( ClusterConfiguration.class ),
                ""cluster://localhost:5001"",
                ""cluster://localhost:5002"",
                ""cluster://localhost:5003"" );

        ClusterState state = new ClusterState(
                asList(
                        newClusterInstance( new InstanceId( 1 ), new URI( ""cluster://localhost:5001"" ),
                                new Monitors(), config, logging ),
                        newClusterInstance( new InstanceId( 2 ), new URI( ""cluster://localhost:5002"" ),
                                new Monitors(), config, logging ),
                        newClusterInstance( new InstanceId( 3 ), new URI( ""cluster://localhost:5003"" ),
                                new Monitors(), config, logging ) ),
                emptySetOf( ClusterAction.class )
        );

        // When
        ClusterState snapshot = state.snapshot();

        // Then
        assertEquals( state, snapshot );
        assertEquals( state.hashCode(), snapshot.hashCode() );
    }
",non-flaky,5
13927,neo4j_neo4j,TestProver.twoStatesWithSameSetupAndPendingMessagesShouldBeEqual,"    @Test
    public void twoStatesWithSameSetupAndPendingMessagesShouldBeEqual() throws Exception
    {
        // Given
        Logging logging = new TestLogging();
        ClusterConfiguration config = new ClusterConfiguration( ""default"",
                logging.getMessagesLog( ClusterConfiguration.class ),
                ""cluster://localhost:5001"",
                ""cluster://localhost:5002"",
                ""cluster://localhost:5003"" );

        ClusterState state = new ClusterState(
                asList(
                        newClusterInstance( new InstanceId( 1 ), new URI( ""cluster://localhost:5001"" ),
                                new Monitors(), config, logging ),
                        newClusterInstance( new InstanceId( 2 ), new URI( ""cluster://localhost:5002"" ),
                                new Monitors(), config, logging ),
                        newClusterInstance( new InstanceId( 3 ), new URI( ""cluster://localhost:5003"" ),
                                new Monitors(), config, logging ) ),
                emptySetOf( ClusterAction.class )
        );

        // When
        ClusterState firstState = state.performAction( new MessageDeliveryAction( Message.to( ClusterMessage.join,
                new URI( ""cluster://localhost:5002"" ), new Object[]{""defaultcluster"",
                        new URI[]{new URI( ""cluster://localhost:5003"" )}} ).setHeader( Message.CONVERSATION_ID,
                ""-1"" ).setHeader( Message.FROM, ""cluster://localhost:5002"" ) ) );
        ClusterState secondState = state.performAction( new MessageDeliveryAction( Message.to( ClusterMessage.join,
                new URI( ""cluster://localhost:5002"" ), new Object[]{""defaultcluster"",
                        new URI[]{new URI( ""cluster://localhost:5003"" )}} ).setHeader( Message.CONVERSATION_ID,
                ""-1"" ).setHeader( Message.FROM, ""cluster://localhost:5002"" ) ) );

        // Then
        assertEquals( firstState, secondState );
        assertEquals( firstState.hashCode(), secondState.hashCode() );
    }
",non-flaky,5
13928,neo4j_neo4j,TestProverTimeouts.equalsShouldBeLogicalAndNotExact,"    @Test
    public void equalsShouldBeLogicalAndNotExact() throws Exception
    {
        // Given
        ProverTimeouts timeouts1 = new ProverTimeouts( new URI(""http://asd"") );
        ProverTimeouts timeouts2 = new ProverTimeouts( new URI(""http://asd"") );

        timeouts1.setTimeout( ""a"", Message.internal( ProposerMessage.join ) );
        timeouts1.setTimeout( ""b"", Message.internal( ProposerMessage.join ) );
        timeouts1.setTimeout( ""c"", Message.internal( ProposerMessage.join ) );

        timeouts2.setTimeout( ""b"", Message.internal( ProposerMessage.join ) );
        timeouts2.setTimeout( ""c"", Message.internal( ProposerMessage.join ) );

        // When
        timeouts1.cancelTimeout( ""a"" );

        // Then
        assertEquals(timeouts1, timeouts2);
    }
",non-flaky,5
13929,neo4j_neo4j,ClusterTransactionTest.call,"    @Test
    public void givenClusterWhenShutdownMasterThenCannotStartTransactionOnSlave() throws Throwable
    {
        // Given
        ClusterManager clusterManager = new ClusterManager(
                fromXml( getClass().getResource( ""/threeinstances.xml"" ).toURI() ),
                forTest( getClass() ).cleanDirectory( ""testCluster"" ),
                stringMap( HaSettings.ha_server.name(), "":6001-6005"", HaSettings.tx_push_factor.name(), ""2"" ) );
        try
        {
            clusterManager.start();

            clusterManager.getDefaultCluster().await( ClusterManager.allSeesAllAsAvailable() );

            GraphDatabaseAPI master = clusterManager.getDefaultCluster().getMaster();
            final GraphDatabaseAPI slave = clusterManager.getDefaultCluster().getAnySlave();

            // When
            final FutureTask<Boolean> result = new FutureTask<>( new Callable<Boolean>()
            {
                @Override
                public Boolean call() throws Exception
                {
                    try ( Transaction tx = slave.beginTx() )
                    {
                        tx.acquireWriteLock( slave.getNodeById( 0 ) );
                        // Fail
                        return false;
                    }
                    catch ( Exception e )
                    {
                        // Ok!
                        return true;
                    }
                }
",non-flaky,5
13930,neo4j_neo4j,TransactionConstraintsIT.startTxAsSlaveAndFinishItAfterHavingSwitchedToMasterShouldNotSucceed,"    @Test
    public void startTxAsSlaveAndFinishItAfterHavingSwitchedToMasterShouldNotSucceed() throws Exception
    {
        // GIVEN
        GraphDatabaseService db = cluster.getAnySlave();
        takeTheLeadInAnEventualMasterSwitch( db );

        // WHEN
        Transaction tx = db.beginTx();
        try
        {
            db.createNode().setProperty( ""name"", ""slave"" );
            tx.success();
        }
        finally
        {
            cluster.shutdown( cluster.getMaster() );
            assertFinishGetsTransactionFailure( tx );
        }

        cluster.await( masterAvailable() );

        // THEN
        assertEquals( db, cluster.getMaster() );
        // to prevent a deadlock scenario which occurs if this test exists (and @After starts)
        // before the db has recovered from its KERNEL_PANIC
        awaitFullyOperational( db );
    }
",non-flaky,5
13931,neo4j_neo4j,TransactionConstraintsIT.startTxAsSlaveAndFinishItAfterAnotherMasterBeingAvailableShouldNotSucceed,"    @Test
    public void startTxAsSlaveAndFinishItAfterAnotherMasterBeingAvailableShouldNotSucceed() throws Exception
    {
        // GIVEN
        HighlyAvailableGraphDatabase db = cluster.getAnySlave();

        // WHEN
        HighlyAvailableGraphDatabase theOtherSlave;
        Transaction tx = db.beginTx();
        try
        {
            db.createNode().setProperty( ""name"", ""slave"" );
            tx.success();
        }
        finally
        {
            theOtherSlave = cluster.getAnySlave( db );
            takeTheLeadInAnEventualMasterSwitch( theOtherSlave );
            cluster.shutdown( cluster.getMaster() );
            assertFinishGetsTransactionFailure( tx );
        }

        cluster.await( ClusterManager.masterAvailable() );

        // THEN
        assertFalse( db.isMaster() );
        assertTrue( theOtherSlave.isMaster() );
        // to prevent a deadlock scenario which occurs if this test exists (and @After starts)
        // before the db has recovered from its KERNEL_PANIC
        awaitFullyOperational( db );
    }
",non-flaky,5
21167,androidx_androidx,PreferenceGroupInitialExpandedChildrenCountTest.createPreferenceGroupAdapter_displayTopLevelPreferences,"    @Test
    public void createPreferenceGroupAdapter_displayTopLevelPreferences() {
        // No limit, should display all 10 preferences
        PreferenceGroupAdapter preferenceGroupAdapter = new PreferenceGroupAdapter(mScreen);
        assertPreferencesAreExpanded(preferenceGroupAdapter);

        // Limit > child count, should display all 10 preferences
        mScreen.setInitialExpandedChildrenCount(TOTAL_PREFERENCE + 4);
        preferenceGroupAdapter = new PreferenceGroupAdapter(mScreen);
        assertPreferencesAreExpanded(preferenceGroupAdapter);

        // Limit = child count, should display all 10 preferences
        mScreen.setInitialExpandedChildrenCount(TOTAL_PREFERENCE);
        preferenceGroupAdapter = new PreferenceGroupAdapter(mScreen);
        assertPreferencesAreExpanded(preferenceGroupAdapter);

        // Limit < child count, should display up to the limit + expand button
        mScreen.setInitialExpandedChildrenCount(INITIAL_EXPANDED_COUNT);
        preferenceGroupAdapter = new PreferenceGroupAdapter(mScreen);
        assertPreferencesAreCollapsed(preferenceGroupAdapter);
        for (int i = 0; i < INITIAL_EXPANDED_COUNT; i++) {
            assertEquals(mPreferenceList.get(i), preferenceGroupAdapter.getItem(i));
        }
        assertEquals(CollapsiblePreferenceGroupController.ExpandButton.class,
                preferenceGroupAdapter.getItem(INITIAL_EXPANDED_COUNT).getClass());
    }
",non-flaky,5
21168,androidx_androidx,PreferenceGroupInitialExpandedChildrenCountTest.createPreferenceGroupAdapter_displayNestedPreferences,"    @Test
    public void createPreferenceGroupAdapter_displayNestedPreferences() {
        final PreferenceScreen screen = mPreferenceManager.createPreferenceScreen(mContext);
        screen.setKey(PREFERENCE_KEY);
        final List<Preference> preferenceList = new ArrayList<>();

        // Add 2 preferences and 2 categories to screen
        createTestPreferences(screen, preferenceList, 2);
        createTestPreferencesCategory(screen, preferenceList, 4);
        createTestPreferencesCategory(screen, preferenceList, 4);

        // No limit, should display all 10 preferences + 2 categories
        PreferenceGroupAdapter preferenceGroupAdapter = new PreferenceGroupAdapter(screen);
        assertEquals(TOTAL_PREFERENCE + 2, preferenceGroupAdapter.getItemCount());

        // Limit > child count, should display all 10 preferences + 2 categories
        screen.setInitialExpandedChildrenCount(TOTAL_PREFERENCE + 4);
        preferenceGroupAdapter = new PreferenceGroupAdapter(screen);
        assertEquals(TOTAL_PREFERENCE + 2, preferenceGroupAdapter.getItemCount());

        // Limit = child count, should display all 10 preferences + 2 categories
        screen.setInitialExpandedChildrenCount(TOTAL_PREFERENCE);
        preferenceGroupAdapter = new PreferenceGroupAdapter(screen);
        assertEquals(TOTAL_PREFERENCE + 2, preferenceGroupAdapter.getItemCount());

        // Limit < child count, should display 2 preferences and the first 3 preference in the
        // category + expand button
        screen.setInitialExpandedChildrenCount(INITIAL_EXPANDED_COUNT);
        preferenceGroupAdapter = new PreferenceGroupAdapter(screen);
        assertEquals(INITIAL_EXPANDED_COUNT + 2, preferenceGroupAdapter.getItemCount());
        for (int i = 0; i <= INITIAL_EXPANDED_COUNT; i++) {
            assertEquals(preferenceList.get(i), preferenceGroupAdapter.getItem(i));
        }
        assertEquals(CollapsiblePreferenceGroupController.ExpandButton.class,
                preferenceGroupAdapter.getItem(INITIAL_EXPANDED_COUNT + 1).getClass());
    }
",non-flaky,5
21169,androidx_androidx,PreferenceGroupInitialExpandedChildrenCountTest.createPreferenceGroupAdapter_setExpandButtonSummary,"    @Test
    public void createPreferenceGroupAdapter_setExpandButtonSummary() {
        mScreen.setInitialExpandedChildrenCount(INITIAL_EXPANDED_COUNT);
        PreferenceGroupAdapter preferenceGroupAdapter = new PreferenceGroupAdapter(mScreen);
        // Preference 5 to Preference 9 are collapsed
        CharSequence summary = mPreferenceList.get(INITIAL_EXPANDED_COUNT).getTitle();
        for (int i = INITIAL_EXPANDED_COUNT + 1; i < TOTAL_PREFERENCE; i++) {
            summary = mContext.getString(R.string.summary_collapsed_preference_list,
                    summary, mPreferenceList.get(i).getTitle());
        }
        final Preference expandButton = preferenceGroupAdapter.getItem(INITIAL_EXPANDED_COUNT);
        assertEquals(summary, expandButton.getSummary());
    }
",non-flaky,5
21170,androidx_androidx,PreferenceGroupInitialExpandedChildrenCountTest.createPreferenceGroupAdapter_expandButtonSummaryShouldListVisiblePreferencesOnly,"    @Test
    public void createPreferenceGroupAdapter_expandButtonSummaryShouldListVisiblePreferencesOnly() {
        mScreen.setInitialExpandedChildrenCount(INITIAL_EXPANDED_COUNT);
        mPreferenceList.get(INITIAL_EXPANDED_COUNT + 1).setVisible(false);
        mPreferenceList.get(INITIAL_EXPANDED_COUNT + 4).setVisible(false);
        PreferenceGroupAdapter preferenceGroupAdapter = new PreferenceGroupAdapter(mScreen);
        // Preference 5 to Preference 9 are collapsed, only preferences 5, 7, 8 are visible
        CharSequence summary = mPreferenceList.get(INITIAL_EXPANDED_COUNT).getTitle();
        summary = mContext.getString(R.string.summary_collapsed_preference_list,
                summary, mPreferenceList.get(INITIAL_EXPANDED_COUNT + 2).getTitle());
        summary = mContext.getString(R.string.summary_collapsed_preference_list,
                summary, mPreferenceList.get(INITIAL_EXPANDED_COUNT + 3).getTitle());
        final Preference expandButton = preferenceGroupAdapter.getItem(INITIAL_EXPANDED_COUNT);
        assertEquals(summary, expandButton.getSummary());
    }
",non-flaky,5
21171,androidx_androidx,PreferenceGroupInitialExpandedChildrenCountTest.clickExpandButton_shouldShowAllPreferences,"    @Test
    public void clickExpandButton_shouldShowAllPreferences() {
        mScreen.setInitialExpandedChildrenCount(INITIAL_EXPANDED_COUNT);

        // First showing 5 preference with expand button
        PreferenceGroupAdapter preferenceGroupAdapter =
                PreferenceGroupAdapter.createInstanceWithCustomHandler(mScreen, mHandler);
        assertPreferencesAreCollapsed(preferenceGroupAdapter);

        // Click the expand button, should review all preferences
        final Preference expandButton = preferenceGroupAdapter.getItem(INITIAL_EXPANDED_COUNT);
        expandButton.performClick();
        assertPreferencesAreExpanded(preferenceGroupAdapter);
    }
",non-flaky,5
21172,androidx_androidx,PreferenceGroupInitialExpandedChildrenCountTest.onPreferenceVisibilityChange_shouldSyncPreferencesIfCollapsed,"    @Test
    public void onPreferenceVisibilityChange_shouldSyncPreferencesIfCollapsed() {
        // No limit set, should not sync preference
        PreferenceGroupAdapter preferenceGroupAdapter =
                PreferenceGroupAdapter.createInstanceWithCustomHandler(mScreen, mHandler);
        preferenceGroupAdapter.onPreferenceVisibilityChange(mPreferenceList.get(3));
        verify(mHandler, never()).sendMessageDelayed(any(Message.class), anyLong());

        // Has limit set, should sync preference
        mScreen.setInitialExpandedChildrenCount(INITIAL_EXPANDED_COUNT);
        preferenceGroupAdapter =
                PreferenceGroupAdapter.createInstanceWithCustomHandler(mScreen, mHandler);
        preferenceGroupAdapter.onPreferenceVisibilityChange(mPreferenceList.get(3));
        verify(mHandler).sendMessageDelayed(any(Message.class), anyLong());

        // Preferences expanded already, should not sync preference
        final Preference expandButton = preferenceGroupAdapter.getItem(INITIAL_EXPANDED_COUNT);
        expandButton.performClick();
        reset(mHandler);
        preferenceGroupAdapter.onPreferenceVisibilityChange(mPreferenceList.get(3));
        verify(mHandler, never()).sendMessageDelayed(any(Message.class), anyLong());
    }
",non-flaky,5
21173,androidx_androidx,PreferenceGroupInitialExpandedChildrenCountTest.saveInstanceState_shouldSaveMaxNumberOfChildrenToShow,"    @Test
    public void saveInstanceState_shouldSaveMaxNumberOfChildrenToShow() {
        // No limit set, should save max value
        Parcelable state = mScreen.onSaveInstanceState();
        assertEquals(PreferenceGroup.SavedState.class, state.getClass());
        assertEquals(Integer.MAX_VALUE,
                ((PreferenceGroup.SavedState) state).mInitialExpandedChildrenCount);

        // Has limit set, should save limit
        mScreen.setInitialExpandedChildrenCount(INITIAL_EXPANDED_COUNT);
        state = mScreen.onSaveInstanceState();
        assertEquals(PreferenceGroup.SavedState.class, state.getClass());
        assertEquals(INITIAL_EXPANDED_COUNT,
                ((PreferenceGroup.SavedState) state).mInitialExpandedChildrenCount);
    }
",non-flaky,5
21174,androidx_androidx,PreferenceGroupInitialExpandedChildrenCountTest.restoreInstanceState_noChange_shouldDoNothing,"    @Test
    public void restoreInstanceState_noChange_shouldDoNothing() {
        PreferenceGroup.SavedState state;

        // Initialized as expanded, restore as expanded, should remain expanded
        state = new PreferenceGroup.SavedState(
                Preference.BaseSavedState.EMPTY_STATE, Integer.MAX_VALUE);
        PreferenceGroupAdapter preferenceGroupAdapter =
                PreferenceGroupAdapter.createInstanceWithCustomHandler(mScreen, mHandler);
        mScreen.onRestoreInstanceState(state);
        assertPreferencesAreExpanded(preferenceGroupAdapter);
        verify(mHandler, never()).sendMessageDelayed(any(Message.class), anyLong());

        // Initialized as collapsed, restore as collapsed, should remain collapsed
        mScreen.setInitialExpandedChildrenCount(INITIAL_EXPANDED_COUNT);
        state = new PreferenceGroup.SavedState(
                Preference.BaseSavedState.EMPTY_STATE, INITIAL_EXPANDED_COUNT);
        preferenceGroupAdapter =
                PreferenceGroupAdapter.createInstanceWithCustomHandler(mScreen, mHandler);
        mScreen.onRestoreInstanceState(state);
        assertPreferencesAreCollapsed(preferenceGroupAdapter);
        verify(mHandler, never()).sendMessageDelayed(any(Message.class), anyLong());
    }
",non-flaky,5
21175,androidx_androidx,PreferenceGroupInitialExpandedChildrenCountTest.restoreHierarchyState_previouslyCollapsed_shouldRestoreToCollapsedState,"    @Test
    public void restoreHierarchyState_previouslyCollapsed_shouldRestoreToCollapsedState() {
        PreferenceGroup.SavedState state =
                new PreferenceGroup.SavedState(
                        Preference.BaseSavedState.EMPTY_STATE, Integer.MAX_VALUE);
        // Initialized as expanded, restore as collapsed, should collapse
        state.mInitialExpandedChildrenCount = INITIAL_EXPANDED_COUNT;
        mScreen.setInitialExpandedChildrenCount(Integer.MAX_VALUE);
        PreferenceGroupAdapter preferenceGroupAdapter =
                PreferenceGroupAdapter.createInstanceWithCustomHandler(mScreen, mHandler);
        mScreen.onRestoreInstanceState(state);
        verify(mHandler).sendMessageDelayed(any(Message.class), anyLong());
        assertPreferencesAreCollapsed(preferenceGroupAdapter);
    }
",non-flaky,5
21176,androidx_androidx,PreferenceGroupInitialExpandedChildrenCountTest.restoreHierarchyState_previouslyExpanded_shouldRestoreToExpandedState,"    @Test
    public void restoreHierarchyState_previouslyExpanded_shouldRestoreToExpandedState() {
        PreferenceGroup.SavedState state =
                new PreferenceGroup.SavedState(
                        Preference.BaseSavedState.EMPTY_STATE, Integer.MAX_VALUE);
        // Initialized as collapsed, restore as expanded, should expand
        state.mInitialExpandedChildrenCount = Integer.MAX_VALUE;
        mScreen.setInitialExpandedChildrenCount(INITIAL_EXPANDED_COUNT);
        PreferenceGroupAdapter preferenceGroupAdapter =
                PreferenceGroupAdapter.createInstanceWithCustomHandler(mScreen, mHandler);
        mScreen.onRestoreInstanceState(state);
        verify(mHandler).sendMessageDelayed(any(Message.class), anyLong());
        assertPreferencesAreExpanded(preferenceGroupAdapter);
    }
",non-flaky,5
21177,androidx_androidx,PreferenceVisibilityTest.testPreferencesAreCreatedWithTheVisibilitySetInXml,"    @Test
    public void testPreferencesAreCreatedWithTheVisibilitySetInXml() {
        final Context context = InstrumentationRegistry.getTargetContext();
        final PreferenceManager manager = new PreferenceManager(context);
        final PreferenceScreen screen = manager.inflateFromResource(context,
                R.layout.test_visibility,
                null);

        // Preference without visibility set should be visible
        assertTrue(screen.getPreference(0).isVisible());
        // Preference with visibility set to true should be visible
        assertTrue(screen.getPreference(1).isVisible());
        // Preference with visibility set to false should not be invisible
        assertFalse(screen.getPreference(2).isVisible());
    }
",non-flaky,5
21178,androidx_androidx,SimplePreferenceComparisonCallbackTest.testNull,"    @Test
    public void testNull() throws Exception {
        assertTrue(""Compare all null"",
                mComparisonCallback.arePreferenceContentsTheSame(mPref1, mPref2));
    }
",non-flaky,5
21179,androidx_androidx,SimplePreferenceComparisonCallbackTest.testClassComparison,"    @Test
    public void testClassComparison() throws Exception {
        final Preference checkboxPreference =
                new CheckBoxPreference(InstrumentationRegistry.getTargetContext());
        assertFalse(""Compare class"",
                mComparisonCallback.arePreferenceContentsTheSame(mPref1, checkboxPreference));
    }
",non-flaky,5
21180,androidx_androidx,SimplePreferenceComparisonCallbackTest.testDetached,"    @Test
    public void testDetached() throws Exception {
        mPref1.onDetached();
        mPref1.onAttached();
        assertFalse(""Compare same, detached"",
                mComparisonCallback.arePreferenceContentsTheSame(mPref1, mPref1));
    }
",non-flaky,5
21181,androidx_androidx,SimplePreferenceComparisonCallbackTest.testTitleComparison,"    @Test
    public void testTitleComparison() throws Exception {
        mPref1.setTitle(""value 1"");

        assertFalse(""Compare non-null to null"",
                mComparisonCallback.arePreferenceContentsTheSame(mPref1, mPref2));
        assertFalse(""Compare null to non-null"",
                mComparisonCallback.arePreferenceContentsTheSame(mPref2, mPref1));

        mPref2.setTitle(""value 1"");

        assertTrue(""Compare identical"",
                mComparisonCallback.arePreferenceContentsTheSame(mPref1, mPref2));

        mPref2.setTitle(""value 2"");

        assertFalse(""Compare different"",
                mComparisonCallback.arePreferenceContentsTheSame(mPref1, mPref2));
    }
",non-flaky,5
21182,androidx_androidx,SimplePreferenceComparisonCallbackTest.testSummaryComparison,"    @Test
    public void testSummaryComparison() throws Exception {
        mPref1.setSummary(""value 1"");

        assertFalse(""Compare non-null to null"",
                mComparisonCallback.arePreferenceContentsTheSame(mPref1, mPref2));
        assertFalse(""Compare null to non-null"",
                mComparisonCallback.arePreferenceContentsTheSame(mPref2, mPref1));

        mPref2.setSummary(""value 1"");

        assertTrue(""Compare identical"",
                mComparisonCallback.arePreferenceContentsTheSame(mPref1, mPref2));

        mPref2.setSummary(""value 2"");

        assertFalse(""Compare different"",
                mComparisonCallback.arePreferenceContentsTheSame(mPref1, mPref2));
    }
",non-flaky,5
21183,androidx_androidx,SimplePreferenceComparisonCallbackTest.testIconComparison,"    @Test
    public void testIconComparison() throws Exception {
        final Drawable drawable1 = new ComparisonDrawable(1);
        final Drawable drawable1a = new ComparisonDrawable(1);
        final Drawable drawable2 = new ComparisonDrawable(2);

        mPref1.setIcon(drawable1);

        assertFalse(""Compare non-null to null"",
                mComparisonCallback.arePreferenceContentsTheSame(mPref1, mPref2));
        assertFalse(""Compare null to non-null"",
                mComparisonCallback.arePreferenceContentsTheSame(mPref2, mPref1));

        mPref2.setIcon(drawable1);

        assertTrue(""Compare aliased"",
                mComparisonCallback.arePreferenceContentsTheSame(mPref1, mPref2));

        mPref2.setIcon(drawable1a);

        assertTrue(""Compare equal"",
                mComparisonCallback.arePreferenceContentsTheSame(mPref1, mPref2));

        mPref2.setIcon(drawable2);

        assertFalse(""Compare unequal"",
                mComparisonCallback.arePreferenceContentsTheSame(mPref1, mPref2));
    }
",non-flaky,5
21184,androidx_androidx,SimplePreferenceComparisonCallbackTest.testEnabledComparison,"    @Test
    public void testEnabledComparison() throws Exception {
        mPref1.setEnabled(true);
        mPref2.setEnabled(true);

        assertTrue(""Compare enabled"",
                mComparisonCallback.arePreferenceContentsTheSame(mPref1, mPref2));

        mPref2.setEnabled(false);

        assertFalse(""Compare enabled/disabled"",
                mComparisonCallback.arePreferenceContentsTheSame(mPref1, mPref2));
        assertFalse(""Compare disable/enabled"",
                mComparisonCallback.arePreferenceContentsTheSame(mPref2, mPref1));

        mPref1.setEnabled(false);

        assertTrue(""Compare disabled"",
                mComparisonCallback.arePreferenceContentsTheSame(mPref1, mPref2));
    }
",non-flaky,5
21185,androidx_androidx,SimplePreferenceComparisonCallbackTest.testSelectableComparison,"    @Test
    public void testSelectableComparison() throws Exception {
        mPref1.setSelectable(true);
        mPref2.setSelectable(true);

        assertTrue(""Compare selectable"",
                mComparisonCallback.arePreferenceContentsTheSame(mPref1, mPref2));

        mPref2.setSelectable(false);

        assertFalse(""Compare selectable/unselectable"",
                mComparisonCallback.arePreferenceContentsTheSame(mPref1, mPref2));
        assertFalse(""Compare unselectable/selectable"",
                mComparisonCallback.arePreferenceContentsTheSame(mPref2, mPref1));

        mPref1.setSelectable(false);

        assertTrue(""Compare unselectable"",
                mComparisonCallback.arePreferenceContentsTheSame(mPref1, mPref2));
    }
",non-flaky,5
21186,androidx_androidx,SimplePreferenceComparisonCallbackTest.testTwoStateComparison,"    @Test
    public void testTwoStateComparison() throws Exception {
        final TwoStatePreference checkbox1 =
                new CheckBoxPreference(InstrumentationRegistry.getTargetContext());
        final TwoStatePreference checkbox2 =
                new CheckBoxPreference(InstrumentationRegistry.getTargetContext());

        checkbox1.setChecked(true);
        checkbox2.setChecked(true);

        assertTrue(""Compare checked"",
                mComparisonCallback.arePreferenceContentsTheSame(checkbox1, checkbox2));

        checkbox2.setChecked(false);

        assertFalse(""Compare checked/unchecked"",
                mComparisonCallback.arePreferenceContentsTheSame(checkbox1, checkbox2));
        assertFalse(""Compare unchecked/checked"",
                mComparisonCallback.arePreferenceContentsTheSame(checkbox2, checkbox1));

        checkbox1.setChecked(false);

        assertTrue(""Compare unchecked"",
                mComparisonCallback.arePreferenceContentsTheSame(checkbox1, checkbox2));
    }
",non-flaky,5
21187,androidx_androidx,SimplePreferenceComparisonCallbackTest.testDropDownComparison,"    @Test
    public void testDropDownComparison() throws Exception {
        final Preference dropdown1 =
                new DropDownPreference(InstrumentationRegistry.getTargetContext());
        final Preference dropdown2 =
                new DropDownPreference(InstrumentationRegistry.getTargetContext());

        assertTrue(""Compare aliased drop down pref"",
                mComparisonCallback.arePreferenceContentsTheSame(dropdown1, dropdown1));
        assertFalse(""Compare distinct drop down prefs"",
                mComparisonCallback.arePreferenceContentsTheSame(dropdown1, dropdown2));
    }
",non-flaky,5
21188,androidx_androidx,PreferenceIconSpaceTest.bindViewHolder_iconSpaceReserved_shouldReserveIconSpace,"    @Test
    public void bindViewHolder_iconSpaceReserved_shouldReserveIconSpace() {
        PreferenceViewHolder holder = PreferenceViewHolder.createInstanceForTests(mViewGroup);
        mPreference.setIconSpaceReserved(true);
        mPreference.onBindViewHolder(holder);

        verify(mIconView).setVisibility(View.INVISIBLE);
        verify(mImageFrame).setVisibility(View.INVISIBLE);
    }
",non-flaky,5
21189,androidx_androidx,PreferenceIconSpaceTest.bindViewHolder_iconSpaceNotReserved_shouldNotReserveIconSpace,"    @Test
    public void bindViewHolder_iconSpaceNotReserved_shouldNotReserveIconSpace() {
        PreferenceViewHolder holder = PreferenceViewHolder.createInstanceForTests(mViewGroup);
        mPreference.setIconSpaceReserved(false);
        mPreference.onBindViewHolder(holder);

        verify(mIconView).setVisibility(View.GONE);
        verify(mImageFrame).setVisibility(View.GONE);
    }
",non-flaky,5
21190,androidx_androidx,PreferenceIconSpaceTest.bindViewHolder_hasIcon_shouldDisplayIcon,"    @Test
    public void bindViewHolder_hasIcon_shouldDisplayIcon() {
        PreferenceViewHolder holder = PreferenceViewHolder.createInstanceForTests(mViewGroup);
        mPreference.setIcon(new ColorDrawable(Color.BLACK));
        mPreference.onBindViewHolder(holder);

        verify(mIconView).setVisibility(View.VISIBLE);
        verify(mImageFrame).setVisibility(View.VISIBLE);
    }
",non-flaky,5
21191,androidx_androidx,PreferenceDataStoreTest.testThatDataStoreIsNullByDefault,"    @Test
    public void testThatDataStoreIsNullByDefault() {
        Preference preference = new Preference(mContext);
        mScreen.addPreference(preference);

        assertNull(preference.getPreferenceDataStore());
        assertNotNull(preference.getSharedPreferences());

        assertNull(mManager.getPreferenceDataStore());
        assertNotNull(mManager.getSharedPreferences());
    }
",non-flaky,5
21192,androidx_androidx,PreferenceDataStoreTest.testSetGetOnPreference,"    @Test
    public void testSetGetOnPreference() {
        Preference preference = new Preference(mContext);

        preference.setPreferenceDataStore(mDataStore);

        assertEquals(mDataStore, preference.getPreferenceDataStore());
    }
",non-flaky,5
21193,androidx_androidx,PreferenceDataStoreTest.testSetGetOnPreferenceManager,"    @Test
    public void testSetGetOnPreferenceManager() {
        mManager.setPreferenceDataStore(mDataStore);

        assertEquals(mDataStore, mManager.getPreferenceDataStore());
        assertNull(mManager.getSharedPreferences());
    }
",non-flaky,5
21194,androidx_androidx,PreferenceDataStoreTest.testSetOnPreferenceManagerGetOnPreference,"    @Test
    public void testSetOnPreferenceManagerGetOnPreference() {
        Preference preference = new Preference(mContext);
        mScreen.addPreference(preference);

        mManager.setPreferenceDataStore(mDataStore);

        assertEquals(mDataStore, preference.getPreferenceDataStore());
        assertNull(preference.getSharedPreferences());
    }
",non-flaky,5
21195,androidx_androidx,PreferenceDataStoreTest.testDataStoresHierarchy,"    @Test
    public void testDataStoresHierarchy() {
        mPreference.setPreferenceDataStore(mDataStore);
        PreferenceDataStore secondaryDataStore = mock(PreferenceDataStore.class,
                Mockito.CALLS_REAL_METHODS);
        mManager.setPreferenceDataStore(secondaryDataStore);
        mScreen.addPreference(mPreference);

        mPreference.putString(TEST_STR);

        // Check that the Preference returns the correct data store.
        assertEquals(mDataStore, mPreference.getPreferenceDataStore());

        // Check that the secondary data store assigned to the manager was NOT used.
        verifyZeroInteractions(secondaryDataStore);

        // Check that the primary data store assigned directly to the preference was used.
        verify(mDataStore, atLeastOnce()).putString(eq(KEY), anyString());
    }
",non-flaky,5
21196,androidx_androidx,PreferenceDataStoreTest.testInitialValueIsFromDataStoreOnPreference,"    @Test
    public void testInitialValueIsFromDataStoreOnPreference() {
        when(mDataStore.getBoolean(anyString(), anyBoolean())).thenReturn(true);

        CheckBoxPreference pref = new CheckBoxPreference(mContext);
        pref.setKey(""CheckboxTestPref"");
        pref.setPreferenceDataStore(mDataStore);

        mScreen.addPreference(pref);

        assertTrue(pref.isChecked());
    }
",non-flaky,5
21197,androidx_androidx,PreferenceDataStoreTest.testInitialValueIsFromDataStoreOnPreferenceManager,"    @Test
    public void testInitialValueIsFromDataStoreOnPreferenceManager() {
        when(mDataStore.getBoolean(anyString(), anyBoolean())).thenReturn(true);

        mManager.setPreferenceDataStore(mDataStore);
        CheckBoxPreference pref = new CheckBoxPreference(mContext);
        pref.setKey(""CheckboxTestPref"");

        mScreen.addPreference(pref);

        assertTrue(pref.isChecked());
    }
",non-flaky,5
21198,androidx_androidx,PreferenceDataStoreTest.testPutStringWithDataStoreOnPref,"    @Test
    public void testPutStringWithDataStoreOnPref() {
        mPreference.setPreferenceDataStore(mDataStore);
        mScreen.addPreference(mPreference);
        putStringTestCommon();
    }
",non-flaky,5
21199,androidx_androidx,PreferenceDataStoreTest.testPutStringWithDataStoreOnMgr,"    @Test
    public void testPutStringWithDataStoreOnMgr() {
        mManager.setPreferenceDataStore(mDataStore);
        mScreen.addPreference(mPreference);
        putStringTestCommon();
    }
",non-flaky,5
21200,androidx_androidx,PreferenceDataStoreTest.testGetStringWithDataStoreOnPref,"    @Test
    public void testGetStringWithDataStoreOnPref() {
        mPreference.setPreferenceDataStore(mDataStore);
        mScreen.addPreference(mPreference);

        mPreference.getString(TEST_STR);

        verify(mDataStore, atLeastOnce()).getString(eq(KEY), eq(TEST_STR));
    }
",non-flaky,5
21201,androidx_androidx,PreferenceDataStoreTest.testGetStringWithDataStoreOnMgr,"    @Test
    public void testGetStringWithDataStoreOnMgr() {
        mManager.setPreferenceDataStore(mDataStore);
        mScreen.addPreference(mPreference);

        mPreference.getString(TEST_STR);

        verify(mDataStore, atLeastOnce()).getString(eq(KEY), eq(TEST_STR));
    }
",non-flaky,5
21202,androidx_androidx,PreferenceDataStoreTest.testDefaultStringValue,"    @Test
    public void testDefaultStringValue() {
        mPreference.setPreferenceDataStore(mDataStore);
        mPreference.setDefaultValue(TEST_DEFAULT_STR);
        mSharedPref.edit().putString(KEY, TEST_WRONG_STR).commit();
        mScreen.addPreference(mPreference);
        mSharedPref.edit().remove(KEY).commit();
        assertEquals(TEST_DEFAULT_STR, mPreference.getDefaultValue());
    }
",non-flaky,5
21203,androidx_androidx,PreferenceDataStoreTest.testPutStringSetWithDataStoreOnPref,"    @Test
    public void testPutStringSetWithDataStoreOnPref() {
        mPreference.setPreferenceDataStore(mDataStore);
        mScreen.addPreference(mPreference);
        putStringSetTestCommon();
    }
",non-flaky,5
21204,androidx_androidx,PreferenceDataStoreTest.testPutStringSetWithDataStoreOnMgr,"    @Test
    public void testPutStringSetWithDataStoreOnMgr() {
        mManager.setPreferenceDataStore(mDataStore);
        mScreen.addPreference(mPreference);
        putStringSetTestCommon();
    }
",non-flaky,5
21205,androidx_androidx,PreferenceDataStoreTest.testGetStringSetWithDataStoreOnPref,"    @Test
    public void testGetStringSetWithDataStoreOnPref() {
        mPreference.setPreferenceDataStore(mDataStore);
        mScreen.addPreference(mPreference);
        Set<String> testSet = new HashSet<>();

        mPreference.getStringSet(testSet);

        verify(mDataStore, atLeastOnce()).getStringSet(eq(KEY), eq(testSet));
    }
",non-flaky,5
21206,androidx_androidx,PreferenceDataStoreTest.testGetStringSetWithDataStoreOnMgr,"    @Test
    public void testGetStringSetWithDataStoreOnMgr() {
        mManager.setPreferenceDataStore(mDataStore);
        mScreen.addPreference(mPreference);
        Set<String> testSet = new HashSet<>();

        mPreference.getStringSet(testSet);

        verify(mDataStore, atLeastOnce()).getStringSet(eq(KEY), eq(testSet));
    }
",non-flaky,5
21207,androidx_androidx,PreferenceDataStoreTest.testPutIntWithDataStoreOnPref,"    @Test
    public void testPutIntWithDataStoreOnPref() {
        mPreference.setPreferenceDataStore(mDataStore);
        mScreen.addPreference(mPreference);
        putIntTestCommon();
    }
",non-flaky,5
21208,androidx_androidx,PreferenceDataStoreTest.testPutIntWithDataStoreOnMgr,"    @Test
    public void testPutIntWithDataStoreOnMgr() {
        mManager.setPreferenceDataStore(mDataStore);
        mScreen.addPreference(mPreference);
        putIntTestCommon();
    }
",non-flaky,5
21209,androidx_androidx,PreferenceDataStoreTest.testGetIntWithDataStoreOnPref,"    @Test
    public void testGetIntWithDataStoreOnPref() {
        mPreference.setPreferenceDataStore(mDataStore);
        mScreen.addPreference(mPreference);

        mPreference.getInt(1);

        verify(mDataStore, atLeastOnce()).getInt(eq(KEY), eq(1));
    }
",non-flaky,5
21210,androidx_androidx,PreferenceDataStoreTest.testGetIntWithDataStoreOnMgr,"    @Test
    public void testGetIntWithDataStoreOnMgr() {
        mManager.setPreferenceDataStore(mDataStore);
        mScreen.addPreference(mPreference);

        mPreference.getInt(1);

        verify(mDataStore, atLeastOnce()).getInt(eq(KEY), eq(1));
    }
",non-flaky,5
21211,androidx_androidx,PreferenceDataStoreTest.testPutLongWithDataStoreOnPref,"    @Test
    public void testPutLongWithDataStoreOnPref() {
        mPreference.setPreferenceDataStore(mDataStore);
        mScreen.addPreference(mPreference);
        putLongTestCommon();
    }
",non-flaky,5
21212,androidx_androidx,PreferenceDataStoreTest.testPutLongWithDataStoreOnMgr,"    @Test
    public void testPutLongWithDataStoreOnMgr() {
        mManager.setPreferenceDataStore(mDataStore);
        mScreen.addPreference(mPreference);
        putLongTestCommon();
    }
",non-flaky,5
21213,androidx_androidx,PreferenceDataStoreTest.testGetLongWithDataStoreOnPref,"    @Test
    public void testGetLongWithDataStoreOnPref() {
        mPreference.setPreferenceDataStore(mDataStore);
        mScreen.addPreference(mPreference);

        mPreference.getLong(1L);

        verify(mDataStore, atLeastOnce()).getLong(eq(KEY), eq(1L));
    }
",non-flaky,5
21214,androidx_androidx,PreferenceDataStoreTest.testGetLongWithDataStoreOnMgr,"    @Test
    public void testGetLongWithDataStoreOnMgr() {
        mManager.setPreferenceDataStore(mDataStore);
        mScreen.addPreference(mPreference);

        mPreference.getLong(1L);

        verify(mDataStore, atLeastOnce()).getLong(eq(KEY), eq(1L));
    }
",non-flaky,5
21215,androidx_androidx,PreferenceDataStoreTest.testPutFloatWithDataStoreOnPref,"    @Test
    public void testPutFloatWithDataStoreOnPref() {
        mPreference.setPreferenceDataStore(mDataStore);
        mScreen.addPreference(mPreference);
        putFloatTestCommon();
    }
",non-flaky,5
21216,androidx_androidx,PreferenceDataStoreTest.testPutFloatWithDataStoreOnMgr,"    @Test
    public void testPutFloatWithDataStoreOnMgr() {
        mManager.setPreferenceDataStore(mDataStore);
        mScreen.addPreference(mPreference);
        putFloatTestCommon();
    }
",non-flaky,5
21217,androidx_androidx,PreferenceDataStoreTest.testGetFloatWithDataStoreOnPref,"    @Test
    public void testGetFloatWithDataStoreOnPref() {
        mPreference.setPreferenceDataStore(mDataStore);
        mScreen.addPreference(mPreference);

        mPreference.getFloat(1f);

        verify(mDataStore, atLeastOnce()).getFloat(eq(KEY), eq(1f));
    }
",non-flaky,5
21218,androidx_androidx,PreferenceDataStoreTest.testGetFloatWithDataStoreOnMgr,"    @Test
    public void testGetFloatWithDataStoreOnMgr() {
        mManager.setPreferenceDataStore(mDataStore);
        mScreen.addPreference(mPreference);

        mPreference.getFloat(1f);

        verify(mDataStore, atLeastOnce()).getFloat(eq(KEY), eq(1f));
    }
",non-flaky,5
21219,androidx_androidx,PreferenceDataStoreTest.testPutBooleanWithDataStoreOnPref,"    @Test
    public void testPutBooleanWithDataStoreOnPref() {
        mPreference.setPreferenceDataStore(mDataStore);
        mScreen.addPreference(mPreference);
        putBooleanTestCommon();
    }
",non-flaky,5
21220,androidx_androidx,PreferenceDataStoreTest.testPutBooleanWithDataStoreOnMgr,"    @Test
    public void testPutBooleanWithDataStoreOnMgr() {
        mManager.setPreferenceDataStore(mDataStore);
        mScreen.addPreference(mPreference);
        putBooleanTestCommon();
    }
",non-flaky,5
21221,androidx_androidx,PreferenceDataStoreTest.testGetBooleanWithDataStoreOnPref,"    @Test
    public void testGetBooleanWithDataStoreOnPref() {
        mPreference.setPreferenceDataStore(mDataStore);
        mScreen.addPreference(mPreference);

        mPreference.getBoolean(true);

        verify(mDataStore, atLeastOnce()).getBoolean(eq(KEY), eq(true));
    }
",non-flaky,5
21222,androidx_androidx,PreferenceDataStoreTest.testGetBooleanWithDataStoreOnMgr,"    @Test
    public void testGetBooleanWithDataStoreOnMgr() {
        mManager.setPreferenceDataStore(mDataStore);
        mScreen.addPreference(mPreference);

        mPreference.getBoolean(true);

        verify(mDataStore, atLeastOnce()).getBoolean(eq(KEY), eq(true));
    }
",non-flaky,5
21223,androidx_androidx,PreferenceDataStoreTest.testSharedPrefNotNullIfNoDS,"    @Test
    public void testSharedPrefNotNullIfNoDS() {
        mScreen.addPreference(mPreference);

        assertNotNull(mPreference.getSharedPreferences());
    }
",non-flaky,5
21224,androidx_androidx,PreferenceDataStoreTest.testSharedPrefNotNullIfNoDSMgr,"    @Test
    public void testSharedPrefNotNullIfNoDSMgr() {
        assertNotNull(mManager.getSharedPreferences());
    }
",non-flaky,5
21225,androidx_androidx,PreferenceDataStoreTest.testSharedPrefNullIfWithDS,"    @Test
    public void testSharedPrefNullIfWithDS() {
        mScreen.addPreference(mPreference);

        mPreference.setPreferenceDataStore(mDataStore);

        assertNull(mPreference.getSharedPreferences());
    }
",non-flaky,5
21226,androidx_androidx,PreferenceDataStoreTest.testSharedPrefNullIfWithDSMgr,"    @Test
    public void testSharedPrefNullIfWithDSMgr() {
        mManager.setPreferenceDataStore(mDataStore);

        assertNull(mManager.getSharedPreferences());
    }
",non-flaky,5
21227,androidx_androidx,ExpandablePreferenceTest.expandablePreference_inPreferenceScreen_collapsesCorrectly,"    @Test
    public void expandablePreference_inPreferenceScreen_collapsesCorrectly() {

        mScreen.setKey(""screen"");
        mScreen.setInitialExpandedChildrenCount(1);

        mScreen.addPreference(mPreference1);
        mScreen.addPreference(mPreference2);
        mScreen.addPreference(mPreference3);

        PreferenceGroupAdapter preferenceGroupAdapter = new PreferenceGroupAdapter(mScreen);

        assertEquals(2, preferenceGroupAdapter.getItemCount());

        assertEquals(mPreference1, preferenceGroupAdapter.getItem(0));
        assertEquals(""Advanced"", preferenceGroupAdapter.getItem(1).getTitle());
        assertEquals(""Preference 2, Preference 3"", preferenceGroupAdapter.getItem(1).getSummary());
    }
",non-flaky,5
21228,androidx_androidx,ExpandablePreferenceTest.expandablePreference_inCategory_collapsesCorrectly,"    @Test
    public void expandablePreference_inCategory_collapsesCorrectly() {
        PreferenceCategory category = new PreferenceCategory(mContext);

        mScreen.addPreference(category);

        category.setKey(""category"");
        category.setInitialExpandedChildrenCount(1);

        category.addPreference(mPreference1);
        category.addPreference(mPreference2);
        category.addPreference(mPreference3);

        PreferenceGroupAdapter preferenceGroupAdapter = new PreferenceGroupAdapter(mScreen);

        assertEquals(3, preferenceGroupAdapter.getItemCount());

        assertEquals(category, preferenceGroupAdapter.getItem(0));
        assertEquals(mPreference1, preferenceGroupAdapter.getItem(1));
        assertEquals(""Advanced"", preferenceGroupAdapter.getItem(2).getTitle());
        assertEquals(""Preference 2, Preference 3"", preferenceGroupAdapter.getItem(2).getSummary());
    }
",non-flaky,5
21229,androidx_androidx,ExpandablePreferenceTest.expandablePreference_inNestedCategory_collapsesCorrectly,"    @Test
    public void expandablePreference_inNestedCategory_collapsesCorrectly() {
        PreferenceCategory category = new PreferenceCategory(mContext);
        PreferenceCategory nestedCategory = new PreferenceCategory(mContext);

        mScreen.addPreference(category);
        category.addPreference(nestedCategory);

        nestedCategory.setKey(""nested_category"");
        nestedCategory.setInitialExpandedChildrenCount(1);

        nestedCategory.addPreference(mPreference1);
        nestedCategory.addPreference(mPreference2);
        nestedCategory.addPreference(mPreference3);

        PreferenceGroupAdapter preferenceGroupAdapter = new PreferenceGroupAdapter(mScreen);

        assertEquals(4, preferenceGroupAdapter.getItemCount());

        assertEquals(category, preferenceGroupAdapter.getItem(0));
        assertEquals(nestedCategory, preferenceGroupAdapter.getItem(1));
        assertEquals(mPreference1, preferenceGroupAdapter.getItem(2));
        assertEquals(""Advanced"", preferenceGroupAdapter.getItem(3).getTitle());
        assertEquals(""Preference 2, Preference 3"", preferenceGroupAdapter.getItem(3).getSummary());
    }
",non-flaky,5
21230,androidx_androidx,ExpandablePreferenceTest.expandablePreference_inCategoryContainingAnotherCategory_collapsesCorrectly,"    @Test
    public void expandablePreference_inCategoryContainingAnotherCategory_collapsesCorrectly() {
        PreferenceCategory category = new PreferenceCategory(mContext);
        PreferenceCategory nestedCategory = new PreferenceCategory(mContext);

        mScreen.addPreference(category);

        category.setKey(""nested_category"");
        category.setInitialExpandedChildrenCount(1);

        category.addPreference(mPreference1);
        category.addPreference(nestedCategory);
        nestedCategory.addPreference(mPreference2);
        nestedCategory.addPreference(mPreference3);

        PreferenceGroupAdapter preferenceGroupAdapter = new PreferenceGroupAdapter(mScreen);

        assertEquals(3, preferenceGroupAdapter.getItemCount());

        assertEquals(category, preferenceGroupAdapter.getItem(0));
        assertEquals(mPreference1, preferenceGroupAdapter.getItem(1));
        assertEquals(""Advanced"", preferenceGroupAdapter.getItem(2).getTitle());
        assertEquals(""Preference 2, Preference 3"", preferenceGroupAdapter.getItem(2).getSummary());

        // If the nested category has a title, display that in the summary instead of the children
        final String title = ""Category"";
        nestedCategory.setTitle(title);

        preferenceGroupAdapter = new PreferenceGroupAdapter(mScreen);

        assertEquals(3, preferenceGroupAdapter.getItemCount());

        assertEquals(category, preferenceGroupAdapter.getItem(0));
        assertEquals(mPreference1, preferenceGroupAdapter.getItem(1));
        assertEquals(""Advanced"", preferenceGroupAdapter.getItem(2).getTitle());
        assertEquals(title, preferenceGroupAdapter.getItem(2).getSummary());
    }
",non-flaky,5
21231,androidx_androidx,ExpandablePreferenceTest.nestedExpandablePreferences_notAllowed_shouldThrowAnException,"    @Test(expected = IllegalArgumentException.class)
    public void nestedExpandablePreferences_notAllowed_shouldThrowAnException() {
        PreferenceCategory category = new PreferenceCategory(mContext);
        PreferenceCategory nestedCategory = new PreferenceCategory(mContext);

        mScreen.addPreference(category);
        category.addPreference(nestedCategory);

        category.setKey(""category"");
        category.setInitialExpandedChildrenCount(1);

        nestedCategory.setKey(""nested_category"");
        nestedCategory.setInitialExpandedChildrenCount(1);

        // Trying to nest expandable preferences should throw an exception
        new PreferenceGroupAdapter(mScreen);
    }
",non-flaky,5
21232,androidx_androidx,PreferencePersistTest.string_retrieveWhenEmpty_returnsDefault,"    @Test
    public void string_retrieveWhenEmpty_returnsDefault() {
        final String expected = ""Default"";

        String result = mPreference.getString(expected);

        assertEquals(expected, result);
    }
",non-flaky,5
21233,androidx_androidx,PreferencePersistTest.string_persist_getsStoredToSharedPrefs,"    @Test
    public void string_persist_getsStoredToSharedPrefs() {
        final String expected = ""Test"";

        boolean wasPersisted = mPreference.putString(expected);

        assertTrue(wasPersisted);
        assertEquals(expected, mSharedPref.getString(KEY, null));
    }
",non-flaky,5
21234,androidx_androidx,PreferencePersistTest.string_persistWhileDisabled_notPersisted,"    @Test
    public void string_persistWhileDisabled_notPersisted() {
        mPreference.setPersistent(false);

        boolean wasPersisted = mPreference.putString(""Test"");

        assertFalse(wasPersisted);
        assertNull(mSharedPref.getString(KEY, null));
    }
",non-flaky,5
21235,androidx_androidx,PreferencePersistTest.string_persistAndRetrieve_returnsPersistedValue,"    @Test
    public void string_persistAndRetrieve_returnsPersistedValue() {
        final String expected = ""Test"";

        mPreference.putString(expected);
        String result = mPreference.getString(""Default"");

        assertEquals(expected, result);
    }
",non-flaky,5
21236,androidx_androidx,PreferencePersistTest.string_persistTwiceAndRetrieve_returnsSecondValue,"    @Test
    public void string_persistTwiceAndRetrieve_returnsSecondValue() {
        final String expected = ""Second"";

        mPreference.putString(""First"");
        mPreference.putString(expected);
        String result = mPreference.getString(""Default"");

        assertEquals(expected, result);
    }
",non-flaky,5
21237,androidx_androidx,PreferencePersistTest.stringSet_retrieveWhenEmpty_returnsDefault,"    @Test
    public void stringSet_retrieveWhenEmpty_returnsDefault() {
        final Set<String> expected = TEST_DEFAULT_STR_SET;

        Set<String> result = mPreference.getStringSet(expected);

        assertThat(result, containsInAnyOrder(expected.toArray()));
    }
",non-flaky,5
21238,androidx_androidx,PreferencePersistTest.stringSet_persist_getsStoredToSharedPrefs,"    @Test
    public void stringSet_persist_getsStoredToSharedPrefs() {
        boolean wasPersisted = mPreference.putStringSet(TEST_DEFAULT_STR_SET);

        assertTrue(wasPersisted);
        assertThat(mSharedPref.getStringSet(KEY, null),
                containsInAnyOrder(TEST_DEFAULT_STR_SET.toArray()));
    }
",non-flaky,5
21239,androidx_androidx,PreferencePersistTest.stringSet_persistWhileDisabled_notPersisted,"    @Test
    public void stringSet_persistWhileDisabled_notPersisted() {
        mPreference.setPersistent(false);

        boolean wasPersisted = mPreference.putStringSet(TEST_STR_SET);

        assertFalse(wasPersisted);
        assertNull(mSharedPref.getString(KEY, null));
    }
",non-flaky,5
21240,androidx_androidx,PreferencePersistTest.stringSet_persistAndRetrieve_returnsPersistedValue,"    @Test
    public void stringSet_persistAndRetrieve_returnsPersistedValue() {
        final Set<String> expected = TEST_STR_SET;

        mPreference.putStringSet(expected);
        Set<String> result = mPreference.getStringSet(TEST_DEFAULT_STR_SET);

        assertThat(result, containsInAnyOrder(expected.toArray()));
    }
",non-flaky,5
21241,androidx_androidx,PreferencePersistTest.stringSet_persistTwiceAndRetrieve_returnsSecondValue,"    @Test
    public void stringSet_persistTwiceAndRetrieve_returnsSecondValue() {
        final Set<String> expected = TEST_STR_SET2;

        mPreference.putStringSet(TEST_STR_SET);
        mPreference.putStringSet(expected);
        Set<String> result = mPreference.getStringSet(TEST_DEFAULT_STR_SET);

        assertThat(result, containsInAnyOrder(expected.toArray()));
    }
",non-flaky,5
21242,androidx_androidx,PreferencePersistTest.int_retrieveWhenEmpty_returnsDefault,"    @Test
    public void int_retrieveWhenEmpty_returnsDefault() {
        final int expected = 1;
        int result = mPreference.getInt(expected);

        assertEquals(expected, result);
    }
",non-flaky,5
21243,androidx_androidx,PreferencePersistTest.int_persist_getsStoredToSharedPrefs,"    @Test
    public void int_persist_getsStoredToSharedPrefs() {
        final int expected = 1;

        boolean wasPersisted = mPreference.putInt(expected);

        assertTrue(wasPersisted);
        assertEquals(expected, mSharedPref.getInt(KEY, -1));
    }
",non-flaky,5
21244,androidx_androidx,PreferencePersistTest.int_persistWhileDisabled_notPersisted,"    @Test
    public void int_persistWhileDisabled_notPersisted() {
        mPreference.setPersistent(false);

        boolean wasPersisted = mPreference.putInt(1);

        assertFalse(wasPersisted);
        assertEquals(-1, mSharedPref.getLong(KEY, -1));
    }
",non-flaky,5
21245,androidx_androidx,PreferencePersistTest.int_persistAndRetrieve_returnsPersistedValue,"    @Test
    public void int_persistAndRetrieve_returnsPersistedValue() {
        final int expected = 1;

        mPreference.putInt(expected);
        int result = mPreference.getInt(-1);

        assertEquals(expected, result);
    }
",non-flaky,5
21246,androidx_androidx,PreferencePersistTest.int_persistTwiceAndRetrieve_returnsSecondValue,"    @Test
    public void int_persistTwiceAndRetrieve_returnsSecondValue() {
        final int expected = 2;

        mPreference.putInt(1);
        mPreference.putInt(expected);
        int result = mPreference.getInt(-1);

        assertEquals(expected, result);
    }
",non-flaky,5
21247,androidx_androidx,PreferencePersistTest.long_retrieveWhenEmpty_returnsDefault,"    @Test
    public void long_retrieveWhenEmpty_returnsDefault() {
        assertEquals(1, mPreference.getLong(1));
    }
",non-flaky,5
21248,androidx_androidx,PreferencePersistTest.long_persist_getsStoredToSharedPrefs,"    @Test
    public void long_persist_getsStoredToSharedPrefs() {
        final long expected = 1;

        boolean wasPersisted = mPreference.putLong(expected);

        assertTrue(wasPersisted);
        assertEquals(expected, mSharedPref.getLong(KEY, -1));
    }
",non-flaky,5
21249,androidx_androidx,PreferencePersistTest.long_persistWhileDisabled_notPersisted,"    @Test
    public void long_persistWhileDisabled_notPersisted() {
        mPreference.setPersistent(false);

        boolean wasPersisted = mPreference.putLong(1);

        assertFalse(wasPersisted);
        assertEquals(-1, mSharedPref.getLong(KEY, -1));
    }
",non-flaky,5
21250,androidx_androidx,PreferencePersistTest.long_persistAndRetrieve_returnsPersistedValue,"    @Test
    public void long_persistAndRetrieve_returnsPersistedValue() {
        final long expected = 1;

        mPreference.putLong(expected);
        long result = mPreference.getLong(-1);

        assertEquals(expected, result);
    }
",non-flaky,5
21251,androidx_androidx,PreferencePersistTest.long_persistTwiceAndRetrieve_returnsSecondValue,"    @Test
    public void long_persistTwiceAndRetrieve_returnsSecondValue() {
        final long expected = 2;

        mPreference.putLong(1);
        mPreference.putLong(expected);
        long result = mPreference.getLong(-1);

        assertEquals(expected, result);
    }
",non-flaky,5
21252,androidx_androidx,PreferencePersistTest.float_retrieveWhenEmpty_returnsDefault,"    @Test
    public void float_retrieveWhenEmpty_returnsDefault() {
        assertEquals(1, mPreference.getFloat(1), FLOAT_PRECISION);
    }
",non-flaky,5
21253,androidx_androidx,PreferencePersistTest.float_persist_getsStoredToSharedPrefs,"    @Test
    public void float_persist_getsStoredToSharedPrefs() {
        final float expected = 1;

        boolean wasPersisted = mPreference.putFloat(expected);

        assertTrue(wasPersisted);
        assertEquals(expected, mSharedPref.getFloat(KEY, -1), FLOAT_PRECISION);
    }
",non-flaky,5
21254,androidx_androidx,PreferencePersistTest.float_persistWhileDisabled_notPersisted,"    @Test
    public void float_persistWhileDisabled_notPersisted() {
        mPreference.setPersistent(false);

        boolean wasPersisted = mPreference.putFloat(1);

        assertFalse(wasPersisted);
        assertEquals(-1, mSharedPref.getFloat(KEY, -1), FLOAT_PRECISION);
    }
",non-flaky,5
21255,androidx_androidx,PreferencePersistTest.float_persistAndRetrieve_returnsPersistedValue,"    @Test
    public void float_persistAndRetrieve_returnsPersistedValue() {
        final float expected = 1;

        mPreference.putFloat(expected);
        float result = mPreference.getFloat(-1);

        assertEquals(expected, result, FLOAT_PRECISION);
    }
",non-flaky,5
21256,androidx_androidx,PreferencePersistTest.float_persistTwiceAndRetrieve_returnsSecondValue,"    @Test
    public void float_persistTwiceAndRetrieve_returnsSecondValue() {
        final float expected = 2;

        mPreference.putFloat(1);
        mPreference.putFloat(expected);
        float result = mPreference.getFloat(-1);

        assertEquals(expected, result, FLOAT_PRECISION);
    }
",non-flaky,5
21257,androidx_androidx,PreferencePersistTest.boolean_retrieveWhenEmpty_returnsDefault,"    @Test
    public void boolean_retrieveWhenEmpty_returnsDefault() {
        final boolean expected = true;

        boolean result = mPreference.getBoolean(expected);

        assertEquals(expected, result);
    }
",non-flaky,5
21258,androidx_androidx,PreferencePersistTest.boolean_persist_getsStoredToSharedPrefs,"    @Test
    public void boolean_persist_getsStoredToSharedPrefs() {
        final boolean expected = true;

        boolean wasPersisted = mPreference.putBoolean(expected);

        assertTrue(wasPersisted);
        assertEquals(expected, mSharedPref.getBoolean(KEY, !expected));
    }
",non-flaky,5
21259,androidx_androidx,PreferencePersistTest.boolean_persistWhileDisabled_notPersisted,"    @Test
    public void boolean_persistWhileDisabled_notPersisted() {
        mPreference.setPersistent(false);

        boolean wasPersisted = mPreference.putBoolean(true);

        assertFalse(wasPersisted);
        assertEquals(false, mSharedPref.getBoolean(KEY, false));
    }
",non-flaky,5
21260,androidx_androidx,PreferencePersistTest.boolean_persistAndRetrieve_returnsPersistedValue,"    @Test
    public void boolean_persistAndRetrieve_returnsPersistedValue() {
        final boolean expected = true;

        mPreference.putBoolean(expected);
        boolean result = mPreference.getBoolean(!expected);

        assertEquals(expected, result);
    }
",non-flaky,5
21261,androidx_androidx,PreferencePersistTest.boolean_persistTwiceAndRetrieve_returnsSecondValue,"    @Test
    public void boolean_persistTwiceAndRetrieve_returnsSecondValue() {
        final boolean expected = false;

        mPreference.putBoolean(!expected);
        mPreference.putBoolean(expected);
        boolean result = mPreference.getBoolean(!expected);

        assertEquals(expected, result);
    }
",non-flaky,5
21262,androidx_androidx,PreferenceParentGroupTest.parentAddRemoveTest,"    @Test
    public void parentAddRemoveTest() {
        PreferenceManager manager = new PreferenceManager(mContext);

        PreferenceScreen screen = manager.createPreferenceScreen(mContext);
        assertNull(screen.getParent());

        PreferenceCategory category = new PreferenceCategory(mContext);
        assertNull(category.getParent());

        CheckBoxPreference pref = new CheckBoxPreference(mContext);
        assertNull(pref.getParent());

        screen.addPreference(category);
        assertEquals(screen, category.getParent());

        category.addPreference(pref);
        assertEquals(category, pref.getParent());

        screen.removePreference(category);
        assertNull(category.getParent());

        category.removePreference(pref);
        assertNull(pref.getParent());
    }
",non-flaky,5
21263,androidx_androidx,PreferenceParentGroupTest.parentReassignTest,"    @Test
    public void parentReassignTest() {
        PreferenceManager manager = new PreferenceManager(mContext);

        PreferenceScreen screen = manager.createPreferenceScreen(mContext);

        PreferenceCategory category1 = new PreferenceCategory(mContext);
        screen.addPreference(category1);
        PreferenceCategory category2 = new PreferenceCategory(mContext);
        screen.addPreference(category2);

        CheckBoxPreference pref = new CheckBoxPreference(mContext);
        assertNull(pref.getParent());

        category1.addPreference(pref);
        assertEquals(category1, pref.getParent());

        category1.removePreference(pref);
        category2.addPreference(pref);
        assertEquals(category2, pref.getParent());
    }
",non-flaky,5
21264,androidx_androidx,PreferenceParentGroupTest.parentDoubleAddTest,"    @Test
    public void parentDoubleAddTest() throws InterruptedException {
        PreferenceManager manager = new PreferenceManager(mContext);

        PreferenceScreen screen = manager.createPreferenceScreen(mContext);

        PreferenceCategory category1 = new PreferenceCategory(mContext);
        screen.addPreference(category1);
        PreferenceCategory category2 = new PreferenceCategory(mContext);
        screen.addPreference(category2);

        CheckBoxPreference pref = new CheckBoxPreference(mContext);
        assertNull(pref.getParent());

        category1.addPreference(pref);
        category2.addPreference(pref);

        assertEquals(category2, pref.getParent());
    }
",non-flaky,5
21265,androidx_androidx,PreferenceSingleLineTitleTest.bindViewHolder_singleLineTitleNotSet_shouldNotSetSingleLine,"    @Test
    public void bindViewHolder_singleLineTitleNotSet_shouldNotSetSingleLine() {
        PreferenceViewHolder holder = PreferenceViewHolder.createInstanceForTests(mViewGroup);
        mPreference.onBindViewHolder(holder);

        verify(mTitleView, never()).setSingleLine(anyBoolean());
    }
",non-flaky,5
21266,androidx_androidx,PreferenceSingleLineTitleTest.bindViewHolder_singleLineTitleSetToTrue_shouldSetSingleLineToTrue,"    @Test
    public void bindViewHolder_singleLineTitleSetToTrue_shouldSetSingleLineToTrue() {
        PreferenceViewHolder holder = PreferenceViewHolder.createInstanceForTests(mViewGroup);
        mPreference.setSingleLineTitle(true);
        mPreference.onBindViewHolder(holder);

        verify(mTitleView).setSingleLine(true);
    }
",non-flaky,5
26827,wildfly_wildfly,JndiPermissionTestCase.testNameImplies,"    @Test
    public void testNameImplies() {
        // check the compat <<ALL BINDINGS>> name
        assertEquals(new JndiPermission(""<<ALL BINDINGS>>"", ""*""), new JndiPermission(""-"", ""*""));

        // check the root - name
        assertTrue(new JndiPermission(""-"", ""*"").implies(new JndiPermission(""-"", ""*"")));
        assertTrue(new JndiPermission(""-"", ""*"").implies(new JndiPermission("""", ""*"")));
        assertTrue(new JndiPermission(""-"", ""*"").implies(new JndiPermission(""foo"", ""*"")));
        assertTrue(new JndiPermission(""-"", ""*"").implies(new JndiPermission(""/foo"", ""*"")));
        assertTrue(new JndiPermission(""-"", ""*"").implies(new JndiPermission(""foo/"", ""*"")));
        assertTrue(new JndiPermission(""-"", ""*"").implies(new JndiPermission(""foo/bar/baz/zap"", ""*"")));
        assertTrue(new JndiPermission(""-"", ""*"").implies(new JndiPermission(""java:foo"", ""*"")));

        // check the non-root - name
        assertTrue(new JndiPermission(""/-"", ""*"").implies(new JndiPermission(""/-"", ""*"")));
        assertTrue(new JndiPermission(""/-"", ""*"").implies(new JndiPermission(""/"", ""*"")));
        assertTrue(new JndiPermission(""/-"", ""*"").implies(new JndiPermission(""//"", ""*"")));
        assertTrue(new JndiPermission(""/-"", ""*"").implies(new JndiPermission(""////"", ""*"")));
        assertTrue(new JndiPermission(""/-"", ""*"").implies(new JndiPermission(""/foo"", ""*"")));
        assertTrue(new JndiPermission(""/-"", ""*"").implies(new JndiPermission(""/foo"", ""*"")));
        assertTrue(new JndiPermission(""/-"", ""*"").implies(new JndiPermission(""/foo/"", ""*"")));
        assertTrue(new JndiPermission(""/-"", ""*"").implies(new JndiPermission(""/foo/bar/baz/zap"", ""*"")));
        assertTrue(new JndiPermission(""/-"", ""*"").implies(new JndiPermission(""java:/foo"", ""*"")));

        assertTrue(new JndiPermission(""foo/-"", ""*"").implies(new JndiPermission(""foo/-"", ""*"")));
        assertTrue(new JndiPermission(""foo/-"", ""*"").implies(new JndiPermission(""foo/foo"", ""*"")));
        assertTrue(new JndiPermission(""foo/-"", ""*"").implies(new JndiPermission(""foo/foo"", ""*"")));
        assertTrue(new JndiPermission(""foo/-"", ""*"").implies(new JndiPermission(""foo/foo/"", ""*"")));
        assertTrue(new JndiPermission(""foo/-"", ""*"").implies(new JndiPermission(""foo/foo/bar/baz/zap"", ""*"")));
        assertTrue(new JndiPermission(""foo/-"", ""*"").implies(new JndiPermission(""java:foo/foo"", ""*"")));

        // check the * name
        assertTrue(new JndiPermission(""*"", ""*"").implies(new JndiPermission("""", ""*"")));
        assertTrue(new JndiPermission(""*"", ""*"").implies(new JndiPermission(""foo"", ""*"")));
        assertFalse(new JndiPermission(""*"", ""*"").implies(new JndiPermission(""foo/bar"", ""*"")));
        assertFalse(new JndiPermission(""*"", ""*"").implies(new JndiPermission(""foo/"", ""*"")));
        assertFalse(new JndiPermission(""*"", ""*"").implies(new JndiPermission(""/foo"", ""*"")));
        assertTrue(new JndiPermission(""*/*"", ""*"").implies(new JndiPermission(""/foo"", ""*"")));
        assertTrue(new JndiPermission(""/*"", ""*"").implies(new JndiPermission(""/foo"", ""*"")));
        assertTrue(new JndiPermission(""*/foo"", ""*"").implies(new JndiPermission(""/foo"", ""*"")));

        // check java: support
        assertEquals(new JndiPermission(""java:"", ""*""), new JndiPermission("""", ""*""));
        assertEquals(new JndiPermission(""java:/"", ""*""), new JndiPermission(""/"", ""*""));
        assertEquals(new JndiPermission(""java:-"", ""*""), new JndiPermission(""-"", ""*""));
        assertEquals(new JndiPermission(""java:*"", ""*""), new JndiPermission(""*"", ""*""));
    }
",non-flaky,5
26828,wildfly_wildfly,JndiPermissionTestCase.testActions,"    @Test
    public void testActions() {
        assertEquals(new JndiPermission(""foo"", ""*""), new JndiPermission(""foo"", ""all""));
        assertEquals(new JndiPermission(""foo"", ""*""), new JndiPermission(""foo"", ""lookup,bind,rebind,unbind,list,listBindings,createSubcontext,destroySubcontext,addNamingListener""));
        assertEquals(new JndiPermission(""foo"", ""*""), new JndiPermission(""foo"", ""unbind,list,listBindings,createSubcontext,destroySubcontext,addNamingListener,lookup,bind,rebind""));

        assertTrue(new JndiPermission(""foo"", ""*"").implies(new JndiPermission(""foo"", ""lookup"")));
        assertTrue(new JndiPermission(""foo"", """").implies(new JndiPermission(""foo"", """")));
        assertTrue(new JndiPermission(""foo"", ""*"").implies(new JndiPermission(""foo"", """")));
        assertFalse(new JndiPermission(""foo"", """").implies(new JndiPermission(""foo"", ""bind"")));
        assertTrue(new JndiPermission(""foo"", """").withActions(""bind"").implies(new JndiPermission(""foo"", ""bind"")));
        assertFalse(new JndiPermission(""foo"", ""unbind"").withoutActions(""unbind"").implies(new JndiPermission(""foo"", ""unbind"")));
    }
",non-flaky,5
26829,wildfly_wildfly,JndiPermissionTestCase.testCollection,"    @Test
    public void testCollection() {
        final PermissionCollection permissionCollection = new JndiPermission("""", """").newPermissionCollection();
        Enumeration<Permission> e;
        permissionCollection.add(new JndiPermission(""foo/bar"", ""lookup,bind""));
        assertTrue(permissionCollection.implies(new JndiPermission(""foo/bar"", ""lookup,bind"")));
        assertFalse(permissionCollection.implies(new JndiPermission(""foo/bar"", ""lookup,bind,unbind"")));
        assertFalse(permissionCollection.implies(new JndiPermission(""foo/bar"", ""unbind"")));
        assertNotNull(e = permissionCollection.elements());
        assertTrue(e.hasMoreElements());
        assertEquals(new JndiPermission(""foo/bar"", ""lookup,bind""), e.nextElement());
        assertFalse(e.hasMoreElements());
        permissionCollection.add(new JndiPermission(""foo/bar"", ""unbind""));
        assertTrue(permissionCollection.implies(new JndiPermission(""foo/bar"", ""lookup,bind"")));
        assertTrue(permissionCollection.implies(new JndiPermission(""foo/bar"", ""lookup,bind,unbind"")));
        assertTrue(permissionCollection.implies(new JndiPermission(""foo/bar"", ""unbind"")));
        assertNotNull(e = permissionCollection.elements());
        assertTrue(e.hasMoreElements());
        assertEquals(new JndiPermission(""foo/bar"", ""lookup,bind,unbind""), e.nextElement());
        assertFalse(e.hasMoreElements());
        permissionCollection.add(new JndiPermission(""-"", ""lookup""));
        assertTrue(permissionCollection.implies(new JndiPermission(""foo/bar"", ""lookup,bind"")));
        assertTrue(permissionCollection.implies(new JndiPermission(""foo/bar"", ""lookup,bind,unbind"")));
        assertTrue(permissionCollection.implies(new JndiPermission(""foo/bar"", ""unbind"")));
        assertTrue(permissionCollection.implies(new JndiPermission(""baz/zap"", ""lookup"")));
        assertTrue(permissionCollection.implies(new JndiPermission("""", ""lookup"")));
        assertFalse(permissionCollection.implies(new JndiPermission(""baz/zap"", ""lookup,bind,unbind"")));
        assertFalse(permissionCollection.implies(new JndiPermission(""baz/zap"", ""unbind"")));
        assertNotNull(e = permissionCollection.elements());
        assertTrue(e.hasMoreElements());
        assertEquals(new JndiPermission(""foo/bar"", ""lookup,bind,unbind""), e.nextElement());
        assertTrue(e.hasMoreElements());
        assertEquals(new JndiPermission(""-"", ""lookup""), e.nextElement());
        assertFalse(e.hasMoreElements());
        permissionCollection.add(new JndiPermission(""-"", ""bind,unbind""));
        assertTrue(permissionCollection.implies(new JndiPermission(""foo/bar"", ""lookup,bind"")));
        assertTrue(permissionCollection.implies(new JndiPermission(""foo/bar"", ""lookup,bind,unbind"")));
        assertTrue(permissionCollection.implies(new JndiPermission(""foo/bar"", ""unbind"")));
        assertTrue(permissionCollection.implies(new JndiPermission(""baz/zap"", ""lookup"")));
        assertTrue(permissionCollection.implies(new JndiPermission("""", ""lookup"")));
        assertTrue(permissionCollection.implies(new JndiPermission(""baz/zap"", ""lookup,bind,unbind"")));
        assertTrue(permissionCollection.implies(new JndiPermission(""baz/zap"", ""unbind"")));
        assertNotNull(e = permissionCollection.elements());
        assertTrue(e.hasMoreElements());
        assertEquals(new JndiPermission(""-"", ""lookup,bind,unbind""), e.nextElement());
        assertFalse(e.hasMoreElements());
    }
",non-flaky,5
26830,wildfly_wildfly,JndiPermissionTestCase.testSecurity,"    @Test
    public void testSecurity() {
        assertEquals(new JndiPermission(""-"", Integer.MAX_VALUE).getActionBits(), JndiPermission.ACTION_ALL);
        assertEquals(new JndiPermission(""-"", Integer.MAX_VALUE), new JndiPermission(""-"", ""*""));
    }
",non-flaky,5
26831,wildfly_wildfly,JndiPermissionTestCase.testSerialization,"    @Test
    public void testSerialization() {
        final JndiPermission jndiPermission = new JndiPermission(""foo/blap/-"", ""bind,lookup"");
        assertEquals(jndiPermission, ((SerializedJndiPermission)jndiPermission.writeReplace()).readResolve());
    }
",non-flaky,5
26832,wildfly_wildfly,JndiPermissionTestCase.testCollectionSecurity,"    @Test
    public void testCollectionSecurity() {
        final PermissionCollection permissionCollection = new JndiPermission("""", """").newPermissionCollection();
        permissionCollection.add(new JndiPermission(""foo/bar"", ""unbind,rebind""));
        permissionCollection.setReadOnly();
        try {
            permissionCollection.add(new JndiPermission(""fob/baz"", ""unbind,rebind""));
            fail(""Expected exception"");
        } catch (SecurityException ignored) {
        }
    }
",non-flaky,5
26833,wildfly_wildfly,JndiPermissionTestCase.testCollectionSerialization,"    @Test
    public void testCollectionSerialization() {
        final PermissionCollection permissionCollection = new JndiPermission("""", """").newPermissionCollection();
        permissionCollection.add(new JndiPermission(""foo/bar"", ""createSubcontext,rebind""));
        permissionCollection.add(new JndiPermission(""foo"", ""addNamingListener""));
        permissionCollection.add(new JndiPermission(""-"", ""lookup,rebind""));
        final PermissionCollection other = (PermissionCollection) ((SerializedJndiPermissionCollection) ((JndiPermissionCollection)permissionCollection).writeReplace()).readResolve();
        Enumeration<Permission> e;
        assertNotNull(e = other.elements());
        assertTrue(e.hasMoreElements());
        assertEquals(new JndiPermission(""foo/bar"", ""createSubcontext,rebind""), e.nextElement());
        assertTrue(e.hasMoreElements());
        assertEquals(new JndiPermission(""foo"", ""addNamingListener""), e.nextElement());
        assertTrue(e.hasMoreElements());
        assertEquals(new JndiPermission(""-"", ""lookup,rebind""), e.nextElement());
        assertFalse(e.hasMoreElements());
    }
",non-flaky,5
26834,wildfly_wildfly,ExternalContextsNavigableSetTestCase.testGetParentContext,"    @Test
    public void testGetParentContext() throws Exception {
        final ServiceName nameA = ServiceName.JBOSS.append(""a"");
        final ServiceName nameP = ServiceName.JBOSS.append(""p"");
        final ServiceName namePC = ServiceName.JBOSS.append(""p"",""c"");
        final ServiceName nameZ = ServiceName.JBOSS.append(""z"");
        ExternalContextsNavigableSet set = new ExternalContextsNavigableSet();
        set.addExternalContext(nameP);
        assertNull(set.getParentExternalContext(nameA));
        assertNull(set.getParentExternalContext(nameP));
        assertNotNull(set.getParentExternalContext(namePC));
        assertEquals(nameP, set.getParentExternalContext(namePC));
        assertNull(set.getParentExternalContext(nameZ));
    }
",non-flaky,5
26835,wildfly_wildfly,WritableServiceBasedNamingStoreTestCase.testBindNoOwner,"    @Test
    public void testBindNoOwner() throws Exception {
        try {
            store.bind(new CompositeName(""test""), new Object());
            fail(""Should have failed with a read-only context exception"");
        } catch (UnsupportedOperationException expected) {
        }
    }
",non-flaky,5
26836,wildfly_wildfly,WritableServiceBasedNamingStoreTestCase.testBind,"    @Test
    public void testBind() throws Exception {
        final Name name = new CompositeName(""test"");
        final Object value = new Object();
        WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);
        try {
            store.bind(name, value);
        } finally {
            WritableServiceBasedNamingStore.popOwner();
        }
        assertEquals(value, store.lookup(name));
    }
",non-flaky,5
26837,wildfly_wildfly,WritableServiceBasedNamingStoreTestCase.testBindNested,"    @Test
    public void testBindNested() throws Exception {
        final Name name = new CompositeName(""nested/test"");
        final Object value = new Object();
        WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);
        try {
            store.bind(name, value);
        } finally {
            WritableServiceBasedNamingStore.popOwner();
        }
        assertEquals(value, store.lookup(name));
    }
",non-flaky,5
26838,wildfly_wildfly,WritableServiceBasedNamingStoreTestCase.testUnbind,"    @Test
    public void testUnbind() throws Exception {
        final Name name = new CompositeName(""test"");
        final Object value = new Object();
        WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);
        try {
            store.bind(name, value);
            store.unbind(name);
        } finally {
            WritableServiceBasedNamingStore.popOwner();
        }
        try {
            store.lookup(name);
            fail(""Should have thrown name not found"");
        } catch (NameNotFoundException expect) {
        }
    }
",non-flaky,5
26839,wildfly_wildfly,WritableServiceBasedNamingStoreTestCase.testUnBindNoOwner,"    @Test
    public void testUnBindNoOwner() throws Exception {
        try {
            store.unbind(new CompositeName(""test""));
            fail(""Should have failed with a read-only context exception"");
        } catch (UnsupportedOperationException expected) {
        }
    }
",non-flaky,5
26840,wildfly_wildfly,WritableServiceBasedNamingStoreTestCase.testCreateSubcontext,"    @Test
    public void testCreateSubcontext() throws Exception {
        WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);
        try {
            assertTrue(((NamingContext) store.createSubcontext(new CompositeName(""test""))).getNamingStore() instanceof WritableServiceBasedNamingStore);
        } finally {
            WritableServiceBasedNamingStore.popOwner();
        }
    }
",non-flaky,5
26841,wildfly_wildfly,WritableServiceBasedNamingStoreTestCase.testCreateSubContextNoOwner,"    @Test
    public void testCreateSubContextNoOwner() throws Exception {
        try {
            store.createSubcontext(new CompositeName(""test""));
            fail(""Should have failed with a read-only context exception"");
        } catch (UnsupportedOperationException expected) {
        }
    }
",non-flaky,5
26842,wildfly_wildfly,WritableServiceBasedNamingStoreTestCase.testRebind,"    @Test
    public void testRebind() throws Exception {
        final Name name = new CompositeName(""test"");
        final Object value = new Object();
        final Object newValue = new Object();
        WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);
        try {
            store.bind(name, value);
            store.rebind(name, newValue);
        } finally {
            WritableServiceBasedNamingStore.popOwner();
        }
        assertEquals(newValue, store.lookup(name));
    }
",non-flaky,5
26843,wildfly_wildfly,WritableServiceBasedNamingStoreTestCase.testRebindNoOwner,"    @Test
    public void testRebindNoOwner() throws Exception {
        try {
            store.rebind(new CompositeName(""test""), new Object());
            fail(""Should have failed with a read-only context exception"");
        } catch (UnsupportedOperationException expected) {
        }
    }
",non-flaky,5
26844,wildfly_wildfly,WritableServiceBasedNamingStoreTestCase.testPermissions,"    @Test
    public void testPermissions() throws Exception {

        final NamingContext namingContext = new NamingContext(store, null);
        final String name = ""a/b"";
        final Object value = new Object();
        ArrayList<JndiPermission> permissions = new ArrayList<JndiPermission>();

        // simple bind test, note that permission must have absolute path
        WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);
        try {
            permissions.add(new JndiPermission(store.getBaseName()+""/""+name,""bind,list,listBindings""));
            store.bind(new CompositeName(name), value);
        } finally {
            WritableServiceBasedNamingStore.popOwner();
        }

        // all of these lookup should work
        permissions.set(0,new JndiPermission(store.getBaseName()+""/""+name,JndiPermission.ACTION_LOOKUP));
        assertEquals(value, testActionWithPermission(JndiPermission.ACTION_LOOKUP, permissions, namingContext, name));
        permissions.set(0,new JndiPermission(store.getBaseName()+""/-"",JndiPermission.ACTION_LOOKUP));
        assertEquals(value, testActionWithPermission(JndiPermission.ACTION_LOOKUP, permissions, namingContext, name));
                permissions.set(0,new JndiPermission(store.getBaseName()+""/a/*"",JndiPermission.ACTION_LOOKUP));
        assertEquals(value, testActionWithPermission(JndiPermission.ACTION_LOOKUP, permissions, namingContext, name));
        permissions.set(0,new JndiPermission(store.getBaseName()+""/a/-"",JndiPermission.ACTION_LOOKUP));
        assertEquals(value, testActionWithPermission(JndiPermission.ACTION_LOOKUP, permissions, namingContext, name));
        permissions.set(0,new JndiPermission(""<<ALL BINDINGS>>"",JndiPermission.ACTION_LOOKUP));
        assertEquals(value, testActionWithPermission(JndiPermission.ACTION_LOOKUP, permissions, namingContext, name));
        permissions.set(0,new JndiPermission(store.getBaseName()+""/""+name,JndiPermission.ACTION_LOOKUP));
        assertEquals(value, testActionWithPermission(JndiPermission.ACTION_LOOKUP, permissions, namingContext, store.getBaseName()+""/""+name));
        NamingContext aNamingContext = (NamingContext) namingContext.lookup(""a"");
        permissions.set(0,new JndiPermission(store.getBaseName()+""/""+name,JndiPermission.ACTION_LOOKUP));
        assertEquals(value, testActionWithPermission(JndiPermission.ACTION_LOOKUP, permissions, aNamingContext, ""b""));
        // this lookup should not work, no permission
        try {
            testActionWithPermission(JndiPermission.ACTION_LOOKUP, Collections.<JndiPermission>emptyList(), namingContext, name);
            fail(""Should have failed due to missing permission"");
        } catch (AccessControlException e) {

        }
        // a permission which only allows entries in store.getBaseName()
        try {
            permissions.set(0,new JndiPermission(store.getBaseName()+""/*"",JndiPermission.ACTION_LOOKUP));
            testActionWithPermission(JndiPermission.ACTION_LOOKUP, permissions, namingContext, name);
            fail(""Should have failed due to missing permission"");
        } catch (AccessControlException e) {

        }
        // permissions which are not absolute paths (do not include store base name, i.e. java:)
        try {
            permissions.set(0,new JndiPermission(name,JndiPermission.ACTION_LOOKUP));
            testActionWithPermission(JndiPermission.ACTION_LOOKUP, permissions, namingContext, name);
            fail(""Should have failed due to missing permission"");
        } catch (AccessControlException e) {

        }
        if (! ""java:"".equals(store.getBaseName().toString())) {
            try {
                permissions.set(0,new JndiPermission(""/""+name,JndiPermission.ACTION_LOOKUP));
                testActionWithPermission(JndiPermission.ACTION_LOOKUP, permissions, namingContext, name);
                fail(""Should have failed due to missing permission"");
            } catch (AccessControlException e) {

            }
            try {
                permissions.set(0,new JndiPermission(""/-"",JndiPermission.ACTION_LOOKUP));
                testActionWithPermission(JndiPermission.ACTION_LOOKUP, permissions, namingContext, name);
                fail(""Should have failed due to missing permission"");
            } catch (AccessControlException e) {
            }
        }
    }
",non-flaky,5
26845,wildfly_wildfly,WritableServiceBasedNamingStoreTestCase.testOwnerBindingReferences,"    @Test
    public void testOwnerBindingReferences() throws Exception {
        final Name name = new CompositeName(""test"");
        final ServiceName serviceName = store.buildServiceName(name);
        final Object value = new Object();

        // ensure bind does not exists
        try {
            store.lookup(name);
            fail(""Should have thrown name not found"");
        } catch (NameNotFoundException expect) {
        }
        final RuntimeBindReleaseService.References duBindingReferences = (RuntimeBindReleaseService.References) container.getService(JndiNamingDependencyProcessor.serviceName(OWNER_FOO)).getValue();
        WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);
        try {
            store.bind(name, value);
            // Foo's RuntimeBindReleaseService should now have a reference to the new bind
            assertTrue(duBindingReferences.contains(serviceName));

            store.rebind(name, value);
            // after rebind, Foo's RuntimeBindReleaseService should continue to have a reference to the bind
            assertTrue(duBindingReferences.contains(serviceName));

            store.unbind(name);
        } finally {
            WritableServiceBasedNamingStore.popOwner();
        }
    }
",non-flaky,5
26846,wildfly_wildfly,WritableServiceBasedNamingStoreTestCase.testMultipleOwnersBindingReferences,"    @Test
    public void testMultipleOwnersBindingReferences() throws Exception {
        final Name name = new CompositeName(""test"");
        final ServiceName serviceName = store.buildServiceName(name);
        final Object value = new Object();

        // ensure bind does not exists
        try {
            store.lookup(name);
            fail(""Should have thrown name not found"");
        } catch (NameNotFoundException expect) {
        }
        // ensure the owners RuntimeBindReleaseService have no reference to the future bind
        final RuntimeBindReleaseService.References fooDuBindingReferences = (RuntimeBindReleaseService.References) container.getService(JndiNamingDependencyProcessor.serviceName(OWNER_FOO)).getValue();
        assertFalse(fooDuBindingReferences.contains(serviceName));
        final RuntimeBindReleaseService.References barDuBindingReferences = (RuntimeBindReleaseService.References) container.getService(JndiNamingDependencyProcessor.serviceName(OWNER_BAR)).getValue();
        assertFalse(barDuBindingReferences.contains(serviceName));

        WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);
        try {
            store.bind(name, value);
            // Foo's RuntimeBindReleaseService should now have a reference to the new bind
            assertTrue(fooDuBindingReferences.contains(serviceName));
            // Bar's RuntimeBindReleaseService reference to the bind should not exist
            assertFalse(barDuBindingReferences.contains(serviceName));
        } finally {
            WritableServiceBasedNamingStore.popOwner();
        }

        WritableServiceBasedNamingStore.pushOwner(OWNER_BAR);
        try {
            store.rebind(name, value);
            // after rebind, Foo's RuntimeBindReleaseService reference to the bind should still exist
            assertTrue(fooDuBindingReferences.contains(serviceName));
            // after rebind, Bar's RuntimeBindReleaseService reference to the bind should now exist
            assertTrue(barDuBindingReferences.contains(serviceName));
        } finally {
            WritableServiceBasedNamingStore.popOwner();
        }

        WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);
        try {
            store.unbind(name);
        } finally {
            WritableServiceBasedNamingStore.popOwner();
        }
    }
",non-flaky,5
26847,wildfly_wildfly,NamingSubsystemTestCase.testSchemaOfSubsystemTemplates,"    @Test
    public void testSchemaOfSubsystemTemplates() throws Exception {
        super.testSchemaOfSubsystemTemplates();
    }
",non-flaky,5
26848,wildfly_wildfly,NamingSubsystemTestCase.testOnlyExternalContextAllowsCache,"    @Test
    public void testOnlyExternalContextAllowsCache() throws Exception {
        KernelServices services = createKernelServicesBuilder(AdditionalInitialization.MANAGEMENT)
                .build();
        Assert.assertTrue(services.isSuccessfulBoot());

        List<ModelNode> list = parse(ModelTestUtils.readResource(this.getClass(), ""subsystem.xml""));

        for (ModelNode addOp : list) {
            PathAddress addr = PathAddress.pathAddress(addOp.require(ModelDescriptionConstants.OP_ADDR));
            if (addr.size() == 2 && addr.getLastElement().getKey().equals(NamingSubsystemModel.BINDING) && BindingType.forName(addOp.get(NamingBindingResourceDefinition.BINDING_TYPE.getName()).asString()) != BindingType.EXTERNAL_CONTEXT) {
                //Add the cache attribute and make sure it fails
                addOp.get(NamingBindingResourceDefinition.CACHE.getName()).set(true);
                services.executeForFailure(addOp);

                //Remove the cache attribute and make sure it succeeds
                addOp.remove(NamingBindingResourceDefinition.CACHE.getName());
                ModelTestUtils.checkOutcome(services.executeOperation(addOp));

                //Try to write the cache attribute, which should fail
                ModelTestUtils.checkFailed(services.executeOperation(Util.getWriteAttributeOperation(addr, NamingBindingResourceDefinition.CACHE.getName(), new ModelNode(true))));

            } else {
                ModelTestUtils.checkOutcome(services.executeOperation(addOp));
            }
        }


    }
",non-flaky,5
26849,wildfly_wildfly,NamingSubsystemTestCase.testCompositeBindingOps,"    @Test
    public void testCompositeBindingOps() throws Exception {
        final KernelServices services = createKernelServicesBuilder(createAdditionalInitialization()).setSubsystemXml(getSubsystemXml()).build();
        // add binding 'alookup' through composite op
        // note that a binding-type of 'lookup' requires 'lookup' attr value, which in this case is set by a followup step
        final ModelNode addr = Operations.createAddress(ModelDescriptionConstants.SUBSYSTEM, NamingExtension.SUBSYSTEM_NAME, NamingSubsystemModel.BINDING, ""java:global/alookup"");
        final ModelNode addOp = Operations.createAddOperation(addr);
        addOp.get(NamingSubsystemModel.BINDING_TYPE).set(NamingSubsystemModel.LOOKUP);
        final ModelNode compositeOp = Operations.CompositeOperationBuilder.create()
                .addStep(addOp)
                .addStep(Operations.createWriteAttributeOperation(addr, NamingSubsystemModel.LOOKUP, ""java:global/a""))
                .build().getOperation();
        ModelTestUtils.checkOutcome(services.executeOperation(compositeOp));
    }
",non-flaky,5
26850,wildfly_wildfly,NamingSubsystemTestCase.testCompositeBindingUpdate,"    @Test
    public void testCompositeBindingUpdate() throws Exception {
        final KernelServices services = createKernelServicesBuilder(createAdditionalInitialization()).setSubsystemXml(getSubsystemXml()).build();
        // updates binding 'a' through composite op
        // binding-type used is lookup, op should succeed even if lookup value is set by a followup step
        final ModelNode addr = Operations.createAddress(ModelDescriptionConstants.SUBSYSTEM, NamingExtension.SUBSYSTEM_NAME, NamingSubsystemModel.BINDING, ""java:global/a"");
        final ModelNode compositeOp = Operations.CompositeOperationBuilder.create()
                .addStep(Operations.createWriteAttributeOperation(addr, NamingSubsystemModel.BINDING_TYPE, NamingSubsystemModel.LOOKUP))
                .addStep(Operations.createWriteAttributeOperation(addr, NamingSubsystemModel.LOOKUP, ""java:global/b""))
                .build().getOperation();
        ModelTestUtils.checkOutcome(services.executeOperation(compositeOp));
    }
",non-flaky,5
26851,wildfly_wildfly,NamingSubsystemTestCase.testRejectionsEAP7,"    @Test
    public void testRejectionsEAP7() throws Exception {
        testTransformer(""subsystem.xml"", ModelTestControllerVersion.EAP_7_0_0, ModelVersion.create(2, 0), ""wildfly-naming"");
    }
",non-flaky,5
26852,wildfly_wildfly,NamingSubsystemTestCase.testRejectionsEAP6,"    @Test
    public void testRejectionsEAP6() throws Exception {
        testTransformer(""subsystem.xml"", ModelTestControllerVersion.EAP_6_4_0, ModelVersion.create(1, 3),""jboss-as-naming"");
    }
",non-flaky,5
26853,wildfly_wildfly,ObjectFactoryTestCase.testBindAndRetrieveObjectFactoryFromNamingContext,"    @Test
    public void testBindAndRetrieveObjectFactoryFromNamingContext() throws Exception {
        final Reference reference = new Reference(""java.util.String"", TestObjectFactory.class.getName(), null);
        namingStore.bind(new CompositeName(""test""), reference);

        final Object result = namingContext.lookup(""test"");
        assertTrue(result instanceof String);
        assertEquals(""Test ParsedResult"", result);
    }
",non-flaky,5
26854,wildfly_wildfly,ObjectFactoryTestCase.testBindAndRetrieveObjectFactoryFromInitialContext,"    @Test
    public void testBindAndRetrieveObjectFactoryFromInitialContext() throws Exception {
        final Reference reference = new Reference(""java.util.String"", TestObjectFactory.class.getName(), null);
        namingStore.bind(new CompositeName(""test""), reference);

        final InitialContext initialContext = new InitialContext();
        final Object result = initialContext.lookup(""test"");
        assertTrue(result instanceof String);
        assertEquals(""Test ParsedResult"", result);
    }
",non-flaky,5
26855,wildfly_wildfly,ServiceBasedNamingStoreTestCase.testLookupBase,"    @Test
    public void testLookupBase() throws Exception {
        final Object obj = store.lookup(new CompositeName());
        assertNotNull(obj);
    }
",non-flaky,5
26856,wildfly_wildfly,ServiceBasedNamingStoreTestCase.testLookupBinding,"    @Test
    public void testLookupBinding() throws Exception {
        final ServiceName bindingName = ServiceName.JBOSS.append(""foo"", ""bar"");
        final Object value = new Object();
        bindObject(bindingName, value);

        final Object obj = store.lookup(new CompositeName(""foo/bar""));
        assertNotNull(obj);
        assertEquals(value, obj);
    }
",non-flaky,5
26857,wildfly_wildfly,ServiceBasedNamingStoreTestCase.testLookupParentContext,"    @Test
    public void testLookupParentContext() throws Exception {
        final ServiceName bindingName = ServiceName.JBOSS.append(""foo"", ""bar"");
        store.add(bindingName);
        final Object obj = store.lookup(new CompositeName(""foo""));
        assertNotNull(obj);
        assertTrue(obj instanceof Context);
    }
",non-flaky,5
26858,wildfly_wildfly,ServiceBasedNamingStoreTestCase.lookup,"    @Test
    public void testStoredContext() throws Exception {
        final ServiceName bindingName = ServiceName.JBOSS.append(""foo-stored"").append(""again"");
        bindObject(bindingName, new Context() {
            @Override
            public Object lookup(Name name) throws NamingException {
                if (""blah/blah2"".equals(name.toString())) {
                    return new Integer(5);
                }

                return null;
            }
",non-flaky,5
26859,wildfly_wildfly,ServiceBasedNamingStoreTestCase.testLookupNestedContext,"    @Test
    public void testLookupNestedContext() throws Exception {
        final ServiceName bindingName = ServiceName.JBOSS.append(""foo"", ""bar"", ""baz"", ""TestBean"");
        store.add(bindingName);
        store.add(ServiceName.JBOSS.append(""foos"", ""bar""));
        store.add(ServiceName.JBOSS.append(""fo"", ""bar""));
        store.add(ServiceName.JBOSS.append(""foo"", ""ba""));
        store.add(ServiceName.JBOSS.append(""foo"", ""bart""));
        store.add(ServiceName.JBOSS.append(""foo"", ""bar"", ""ba""));
        store.add(ServiceName.JBOSS.append(""foo"", ""bar"", ""bazt""));
        store.add(ServiceName.JBOSS.append(""foo"", ""bar"", ""art""));

        Object obj = store.lookup(new CompositeName(""foo""));
        assertNotNull(obj);
        assertTrue(obj instanceof Context);

        obj = Context.class.cast(obj).lookup(new CompositeName(""bar""));
        assertNotNull(obj);
        assertTrue(obj instanceof Context);

        obj = Context.class.cast(obj).lookup(new CompositeName(""baz""));
        assertNotNull(obj);
        assertTrue(obj instanceof Context);
    }
",non-flaky,5
26860,wildfly_wildfly,ServiceBasedNamingStoreTestCase.testLookupBindingUsingNestedContext,"    @Test
    public void testLookupBindingUsingNestedContext() throws Exception {
        final ServiceName bindingName = ServiceName.JBOSS.append(""foo"", ""bar"", ""baz"", ""TestBean"");
        final Object value = new Object();
        bindObject(bindingName, value);

        Object context = store.lookup(new CompositeName(""foo""));
        assertNotNull(context);
        assertTrue(context instanceof Context);

        Object obj = Context.class.cast(context).lookup(new CompositeName(""bar/baz/TestBean""));
        assertNotNull(obj);
        assertEquals(value, obj);

        context = Context.class.cast(context).lookup(new CompositeName(""bar""));
        obj = Context.class.cast(context).lookup(new CompositeName(""baz/TestBean""));
        assertNotNull(obj);
        assertEquals(value, obj);


        context = Context.class.cast(context).lookup(new CompositeName(""baz""));
        obj = Context.class.cast(context).lookup(new CompositeName(""TestBean""));
        assertNotNull(obj);
        assertEquals(value, obj);
    }
",non-flaky,5
26861,wildfly_wildfly,ServiceBasedNamingStoreTestCase.testList,"    @Test
    public void testList() throws Exception {
        final Object value = new Object();
        bindObject(ServiceName.JBOSS.append(""TestBean""), value);
        bindObject(ServiceName.JBOSS.append(""foo"", ""TestBean""), value);
        bindObject(ServiceName.JBOSS.append(""foo"", ""bar"", ""TestBean""), value);
        bindObject(ServiceName.JBOSS.append(""foo"", ""bar"", ""baz"", ""TestBean""), value);

        store.add(ServiceName.JBOSS.append(""foos"", ""bar""));
        store.add(ServiceName.JBOSS.append(""fo"", ""bar""));
        store.add(ServiceName.JBOSS.append(""foo"", ""ba"", ""baz""));
        store.add(ServiceName.JBOSS.append(""foo"", ""bart"", ""baz""));
        store.add(ServiceName.JBOSS.append(""foo"", ""bar"", ""ba""));
        store.add(ServiceName.JBOSS.append(""foo"", ""bar"", ""bazt""));
        store.add(ServiceName.JBOSS.append(""foo"", ""bar"", ""art""));
        store.add(ServiceName.JBOSS.append(""other"", ""one""));

        List<NameClassPair> list = store.list(new CompositeName(""""));
        assertEquals(5, list.size());
        assertContains(list, ""TestBean"", Object.class);
        assertContains(list, ""foo"", Context.class);
        assertContains(list, ""fo"", Context.class);
        assertContains(list, ""foos"", Context.class);
        assertContains(list, ""other"", Context.class);


        list = store.list(new CompositeName(""foo""));
        assertEquals(4, list.size());
        assertContains(list, ""TestBean"", Object.class);
        assertContains(list, ""ba"", Context.class);
        assertContains(list, ""bart"", Context.class);
        assertContains(list, ""bar"", Context.class);
    }
",non-flaky,5
26862,wildfly_wildfly,ServiceBasedNamingStoreTestCase.testListBindings,"    @Test
    public void testListBindings() throws Exception {
        final Object value = new Object();
        bindObject(ServiceName.JBOSS.append(""TestBean""), value);
        bindObject(ServiceName.JBOSS.append(""foo"", ""TestBean""), value);
        bindObject(ServiceName.JBOSS.append(""foo"", ""bar"", ""TestBean""), value);
        bindObject(ServiceName.JBOSS.append(""foo"", ""bar"", ""baz"", ""TestBean""), value);

        store.add(ServiceName.JBOSS.append(""foos"", ""bar""));
        store.add(ServiceName.JBOSS.append(""fo"", ""bar""));
        store.add(ServiceName.JBOSS.append(""foo"", ""ba"", ""baz""));
        store.add(ServiceName.JBOSS.append(""foo"", ""bart"", ""baz""));
        store.add(ServiceName.JBOSS.append(""foo"", ""bar"", ""ba""));
        store.add(ServiceName.JBOSS.append(""foo"", ""bar"", ""bazt""));
        store.add(ServiceName.JBOSS.append(""foo"", ""bar"", ""art""));
        store.add(ServiceName.JBOSS.append(""other"", ""one""));

        List<Binding> list = store.listBindings(new CompositeName(""""));
        assertEquals(5, list.size());
        assertContains(list, ""TestBean"", Object.class);
        assertContains(list, ""foo"", NamingContext.class);
        assertContains(list, ""fo"", NamingContext.class);
        assertContains(list, ""foos"", NamingContext.class);
        assertContains(list, ""other"", NamingContext.class);


        list = store.listBindings(new CompositeName(""foo""));
        assertEquals(4, list.size());
        assertContains(list, ""TestBean"", Object.class);
        assertContains(list, ""ba"", NamingContext.class);
        assertContains(list, ""bart"", NamingContext.class);
        assertContains(list, ""bar"", NamingContext.class);

        for (Binding binding : list) {
            if (binding.getName().equals(""bar"")) {
                final Object bean = Context.class.cast(binding.getObject()).lookup(""TestBean"");
                assertNotNull(bean);
                assertEquals(value, bean);
            }
        }
    }
",non-flaky,5
26863,wildfly_wildfly,InitialContextTestCase.testRegisterURLSchemeHandler,"    @Test
    public void testRegisterURLSchemeHandler() throws Exception {
        InitialContext ictx = new InitialContext(null);

        try {
            ictx.lookup(""foobar:something"");
            Assert.fail(""Precondition: the foobar: scheme should not yet be registered"");
        } catch (NamingException ne) {
            // good
        }

        ObjectFactory tof = new TestObjectFactory();
        InitialContext.addUrlContextFactory(""foobar"", tof);
        String something = (String) ictx.lookup(""foobar:something"");
        Assert.assertTrue(""The object should now be provided by our TestObjectFactory"", something.startsWith(""TestObject:""));

        try {
            InitialContext.removeUrlContextFactory(""foobar:"", new TestObjectFactory());
            Assert.fail(""Should throw an IllegalArgumentException since the associated factory object doesn't match the registration"");
        } catch (IllegalArgumentException iae) {
            // good;
        }

        Assert.assertEquals(""The foobar: scheme should still be registered"", something, ictx.lookup(""foobar:something""));

        InitialContext.removeUrlContextFactory(""foobar"", tof);
        try {
            ictx.lookup(""foobar:something"");
            Assert.fail(""The foobar: scheme should not be registered any more"");
        } catch (NamingException ne) {
            // good
        }
    }
",non-flaky,5
26864,wildfly_wildfly,NamingEventCoordinatorTestCase.testFireObjectEvent,"    @Test
    public void testFireObjectEvent() throws Exception {
        final NamingEventCoordinator coordinator = new NamingEventCoordinator();

        final CollectingListener objectListener = new CollectingListener(1);
        coordinator.addListener(""test/path"", EventContext.OBJECT_SCOPE, objectListener);
        final CollectingListener subtreeListener = new CollectingListener(0);
        coordinator.addListener(""test"", EventContext.SUBTREE_SCOPE, subtreeListener);
        final CollectingListener oneLevelListener = new CollectingListener(0);
        coordinator.addListener(""test"", EventContext.ONELEVEL_SCOPE, oneLevelListener);

        coordinator.fireEvent(context, new CompositeName(""test/path""), null, null, NamingEvent.OBJECT_ADDED, ""bind"", EventContext.OBJECT_SCOPE);

        objectListener.latch.await(1, TimeUnit.SECONDS);

        assertEquals(1, objectListener.capturedEvents.size());
        assertTrue(oneLevelListener.capturedEvents.isEmpty());
        assertTrue(subtreeListener.capturedEvents.isEmpty());
    }
",non-flaky,5
26865,wildfly_wildfly,NamingEventCoordinatorTestCase.testFireSubTreeEvent,"    @Test
    public void testFireSubTreeEvent() throws Exception {
        final NamingEventCoordinator coordinator = new NamingEventCoordinator();

        final CollectingListener objectListener = new CollectingListener(0);
        coordinator.addListener(""test/path"", EventContext.OBJECT_SCOPE, objectListener);
        final CollectingListener subtreeListener = new CollectingListener(1);
        coordinator.addListener(""test"", EventContext.SUBTREE_SCOPE, subtreeListener);
        final CollectingListener oneLevelListener = new CollectingListener(0);
        coordinator.addListener(""test"", EventContext.ONELEVEL_SCOPE, oneLevelListener);

        coordinator.fireEvent(context, new CompositeName(""test/path""), null, null, NamingEvent.OBJECT_ADDED, ""bind"", EventContext.SUBTREE_SCOPE);

        subtreeListener.latch.await(1, TimeUnit.SECONDS);

        assertTrue(objectListener.capturedEvents.isEmpty());
        assertTrue(oneLevelListener.capturedEvents.isEmpty());
        assertEquals(1, subtreeListener.capturedEvents.size());
    }
",non-flaky,5
26866,wildfly_wildfly,NamingEventCoordinatorTestCase.testFireOneLevelEvent,"    @Test
    public void testFireOneLevelEvent() throws Exception {
        final NamingEventCoordinator coordinator = new NamingEventCoordinator();

        final CollectingListener objectListener = new CollectingListener(0);
        coordinator.addListener(""test/path"", EventContext.OBJECT_SCOPE, objectListener);
        final CollectingListener subtreeListener = new CollectingListener(0);
        coordinator.addListener(""test"", EventContext.SUBTREE_SCOPE, subtreeListener);
        final CollectingListener oneLevelListener = new CollectingListener(1);
        coordinator.addListener(""test"", EventContext.ONELEVEL_SCOPE, oneLevelListener);

        coordinator.fireEvent(context, new CompositeName(""test/path""), null, null, NamingEvent.OBJECT_ADDED, ""bind"", EventContext.ONELEVEL_SCOPE);

        oneLevelListener.latch.await(1, TimeUnit.SECONDS);

        assertTrue(objectListener.capturedEvents.isEmpty());
        assertTrue(subtreeListener.capturedEvents.isEmpty());
        assertEquals(1, oneLevelListener.capturedEvents.size());
    }
",non-flaky,5
26867,wildfly_wildfly,NamingEventCoordinatorTestCase.testFireAllEvent,"    @Test
    public void testFireAllEvent() throws Exception {
        final NamingEventCoordinator coordinator = new NamingEventCoordinator();

        final CollectingListener objectListener = new CollectingListener(1);
        coordinator.addListener(""test/path"", EventContext.OBJECT_SCOPE, objectListener);
        final CollectingListener subtreeListener = new CollectingListener(1);
        coordinator.addListener(""test"", EventContext.SUBTREE_SCOPE, subtreeListener);
        final CollectingListener oneLevelListener = new CollectingListener(1);
        coordinator.addListener(""test"", EventContext.ONELEVEL_SCOPE, oneLevelListener);

        coordinator.fireEvent(context, new CompositeName(""test/path""), null, null, NamingEvent.OBJECT_ADDED, ""bind"", EventContext.OBJECT_SCOPE, EventContext.ONELEVEL_SCOPE, EventContext.SUBTREE_SCOPE);

        objectListener.latch.await(1, TimeUnit.SECONDS);
        oneLevelListener.latch.await(1, TimeUnit.SECONDS);
        subtreeListener.latch.await(1, TimeUnit.SECONDS);

        assertEquals(1, objectListener.capturedEvents.size());
        assertEquals(1, subtreeListener.capturedEvents.size());
        assertEquals(1, oneLevelListener.capturedEvents.size());
    }
",non-flaky,5
26868,wildfly_wildfly,NamingEventCoordinatorTestCase.testFireMultiLevelEvent,"    @Test
    public void testFireMultiLevelEvent() throws Exception {
        final NamingEventCoordinator coordinator = new NamingEventCoordinator();

        final CollectingListener subtreeListener = new CollectingListener(1);
        coordinator.addListener(""foo"", EventContext.SUBTREE_SCOPE, subtreeListener);

        final CollectingListener subtreeListenerTwo = new CollectingListener(1);
        coordinator.addListener(""foo/bar"", EventContext.SUBTREE_SCOPE, subtreeListenerTwo);

        final CollectingListener subtreeListenerThree = new CollectingListener(1);
        coordinator.addListener(""foo/bar/baz"", EventContext.SUBTREE_SCOPE, subtreeListenerThree);

        coordinator.fireEvent(context, new CompositeName(""foo/bar/baz/boo""), null, null, NamingEvent.OBJECT_ADDED, ""bind"", EventContext.OBJECT_SCOPE, EventContext.ONELEVEL_SCOPE, EventContext.SUBTREE_SCOPE);

        subtreeListener.latch.await(1, TimeUnit.SECONDS);
        subtreeListenerTwo.latch.await(1, TimeUnit.SECONDS);
        subtreeListenerThree.latch.await(1, TimeUnit.SECONDS);

        assertEquals(1, subtreeListener.capturedEvents.size());
        assertEquals(1, subtreeListenerTwo.capturedEvents.size());
        assertEquals(1, subtreeListenerThree.capturedEvents.size());
    }
",non-flaky,5
26869,wildfly_wildfly,NamingContextTestCase.testLookup,"    @Test
    public void testLookup() throws Exception {
        final Name name = new CompositeName(""test"");
        final Object object = new Object();
        namingStore.bind(name, object);

        Object result = namingContext.lookup(name);
        assertEquals(object, result);

        //the same with security permissions
        result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, ""test"");
        assertEquals(object, result);
    }
",non-flaky,5
26870,wildfly_wildfly,NamingContextTestCase.testLookupReference,"    @Test
    public void testLookupReference() throws Exception {
        final Name name = new CompositeName(""test"");
        final Reference reference = new Reference(String.class.getName(), new StringRefAddr(""blah"", ""test""), TestObjectFactory.class.getName(), null);
        namingStore.bind(name, reference);

        Object result = namingContext.lookup(name);
        assertEquals(""test"", result);

        //the same with security permissions
        result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, ""test"");
        assertEquals(""test"", result);
    }
",non-flaky,5
26871,wildfly_wildfly,NamingContextTestCase.testLookupWithContinuation,"    @Test
    public void testLookupWithContinuation() throws Exception {
        namingStore.bind(new CompositeName(""comp/nested""), ""test"");

        final Reference reference = new Reference(String.class.getName(), new StringRefAddr(""nns"", ""comp""), TestObjectFactoryWithNameResolution.class.getName(), null);
        namingStore.bind(new CompositeName(""test""), reference);

        Object result = namingContext.lookup(new CompositeName(""test/nested""));
        assertEquals(""test"", result);

        //the same with security permissions
        result = testActionPermission(JndiPermission.ACTION_LOOKUP, Arrays.asList(new JndiPermission(""comp/nested"", ""lookup"")), namingContext, ""test/nested"");
        assertEquals(""test"", result);
    }
",non-flaky,5
26872,wildfly_wildfly,NamingContextTestCase.testLookupWitResolveResult,"    @Test
    public void testLookupWitResolveResult() throws Exception {
        namingStore.bind(new CompositeName(""test/nested""), ""test"");

        final Reference reference = new Reference(String.class.getName(), new StringRefAddr(""blahh"", ""test""), TestObjectFactoryWithNameResolution.class.getName(), null);
        namingStore.bind(new CompositeName(""comp""), reference);

        Object result = namingContext.lookup(new CompositeName(""comp/nested""));
        assertEquals(""test"", result);

        //the same with security permissions
        result = testActionPermission(JndiPermission.ACTION_LOOKUP, Arrays.asList(new JndiPermission(""test/nested"", ""lookup"")), namingContext, ""comp/nested"");
        assertEquals(""test"", result);
    }
",non-flaky,5
26873,wildfly_wildfly,NamingContextTestCase.testLookupLink,"    @Test
    public void testLookupLink() throws Exception {
        final Name name = new CompositeName(""test"");
        namingStore.bind(name, ""testValue"", String.class);
        final Name linkName = new CompositeName(""link"");
        namingStore.bind(linkName, new LinkRef(""./test""));
        Object result = namingContext.lookup(linkName);
        assertEquals(""testValue"", result);

        //the same with security permissions
        result = testActionPermission(JndiPermission.ACTION_LOOKUP, Arrays.asList(new JndiPermission(""test"", ""lookup"")), namingContext, ""link"");
        assertEquals(""testValue"", result);

        System.setProperty(Context.INITIAL_CONTEXT_FACTORY, InitialContextFactory.class.getName());
        namingStore.rebind(linkName, new LinkRef(name));
        result = namingContext.lookup(linkName);
        assertEquals(""testValue"", result);

        //the same with security permissions
        result = testActionPermission(JndiPermission.ACTION_LOOKUP, Arrays.asList(new JndiPermission(""test"", ""lookup"")), namingContext, ""link"");
        assertEquals(""testValue"", result);
    }
",non-flaky,5
26874,wildfly_wildfly,NamingContextTestCase.testLookupContextLink,"    @Test
    public void testLookupContextLink() throws Exception {
        final Name name = new CompositeName(""test/value"");
        namingStore.bind(name, ""testValue"");
        final Name linkName = new CompositeName(""link"");
        namingStore.bind(linkName, new LinkRef(""./test""));
        Object result = namingContext.lookup(""link/value"");
        assertEquals(""testValue"", result);

        //the same with security permissions
        result = testActionPermission(JndiPermission.ACTION_LOOKUP, Arrays.asList(new JndiPermission(""test"", ""lookup""),
                new JndiPermission(""test/value"", ""lookup"")), namingContext, ""link/value"");

        assertEquals(""testValue"", result);
    }
",non-flaky,5
26875,wildfly_wildfly,NamingContextTestCase.testLookupNameNotFound,"    @Test
    public void testLookupNameNotFound() throws Exception {
        try {
            namingContext.lookup(new CompositeName(""test""));
            fail(""Should have thrown and NameNotFoundException"");
        } catch (NameNotFoundException expected) {
        }

        //the same with security permissions
        try {
            testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, ""test"");
            fail(""Should have thrown and NameNotFoundException with appropriate permissions"");
        } catch (NameNotFoundException expected) {
        }
    }
",non-flaky,5
26876,wildfly_wildfly,NamingContextTestCase.testLookupEmptyName,"    @Test
    public void testLookupEmptyName() throws Exception {
        Object result = namingContext.lookup(new CompositeName());
        assertTrue(result instanceof NamingContext);
        result = namingContext.lookup(new CompositeName(""""));
        assertTrue(result instanceof NamingContext);

        //the same with security permissions
        result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, null);
        assertTrue(result instanceof NamingContext);
        result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, """");
        assertTrue(result instanceof NamingContext);
    }
",non-flaky,5
26877,wildfly_wildfly,NamingContextTestCase.testBind,"    @Test
    public void testBind() throws Exception {
        Name name = new CompositeName(""test"");
        final Object value = new Object();
        namingContext.bind(name, value);
        assertEquals(value, namingStore.lookup(name));

        //the same with security permissions
        name = new CompositeName(""securitytest"");
        testActionPermission(JndiPermission.ACTION_BIND, namingContext, ""securitytest"", value);
        assertEquals(value, namingStore.lookup(name));
    }
",non-flaky,5
26878,wildfly_wildfly,NamingContextTestCase.testBindReferenceable,"    @Test
    public void testBindReferenceable() throws Exception {
        Name name = new CompositeName(""test"");
        final TestObjectReferenceable referenceable = new TestObjectReferenceable(""addr"");
        namingContext.bind(name, referenceable);
        Object result = namingContext.lookup(name);
        assertEquals(referenceable.addr, result);

        //the same with security permissions
        name = new CompositeName(""securitytest"");
        testActionPermission(JndiPermission.ACTION_BIND, namingContext, ""securitytest"", referenceable);
        result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, ""securitytest"");
        assertEquals(referenceable.addr, result);
    }
",non-flaky,5
26879,wildfly_wildfly,NamingContextTestCase.testUnbind,"    @Test
    public void testUnbind() throws Exception {
        final Name name = new CompositeName(""test"");
        final Object value = new Object();
        namingStore.bind(name, value);
        namingContext.unbind(name);
        try {
            namingStore.lookup(name);
            fail(""Should have thrown name not found"");
        } catch (NameNotFoundException expect) {}

        //the same with security permissions
        testActionPermission(JndiPermission.ACTION_BIND, namingContext, ""test"", value);
        testActionPermission(JndiPermission.ACTION_UNBIND, namingContext, ""test"");
        try {
            namingStore.lookup(name);
            fail(""Should have thrown name not found"");
        } catch (NameNotFoundException expect) {}
    }
",non-flaky,5
26880,wildfly_wildfly,NamingContextTestCase.testCreateSubcontext,"    @Test
    public void testCreateSubcontext() throws Exception {
        assertTrue(namingContext.createSubcontext(new CompositeName(""test"")) instanceof NamingContext);

        //the same with security permissions
        assertTrue(testActionPermission(JndiPermission.ACTION_CREATE_SUBCONTEXT, namingContext, ""securitytest"") instanceof NamingContext);
    }
",non-flaky,5
26881,wildfly_wildfly,NamingContextTestCase.testRebind,"    @Test
    public void testRebind() throws Exception {
        final Name name = new CompositeName(""test"");
        final Object value = new Object();
        namingStore.bind(name, value);
        Object newValue = new Object();
        namingContext.rebind(name, newValue);
        assertEquals(newValue, namingStore.lookup(name));

        //the same with security permissions
        newValue = new Object();
        testActionPermission(JndiPermission.ACTION_REBIND, namingContext, ""test"", newValue);
        assertEquals(newValue, namingStore.lookup(name));
    }
",non-flaky,5
26882,wildfly_wildfly,NamingContextTestCase.testRebindReferenceable,"    @Test
    public void testRebindReferenceable() throws Exception {
        final Name name = new CompositeName(""test"");
        final TestObjectReferenceable referenceable = new TestObjectReferenceable(""addr"");
        namingContext.bind(name, referenceable);
        TestObjectReferenceable newReferenceable = new TestObjectReferenceable(""newAddr"");
        namingContext.rebind(name, newReferenceable);
        Object result = namingContext.lookup(name);
        assertEquals(newReferenceable.addr, result);

        //the same with security permissions
        newReferenceable = new TestObjectReferenceable(""yetAnotherNewAddr"");
        testActionPermission(JndiPermission.ACTION_REBIND, namingContext, ""test"", newReferenceable);
        result = namingContext.lookup(name);
        assertEquals(newReferenceable.addr, result);
    }
",non-flaky,5
26883,wildfly_wildfly,NamingContextTestCase.testListNameNotFound,"    @Test
    public void testListNameNotFound() throws Exception {
        try {
            namingContext.list(new CompositeName(""test""));
            fail(""Should have thrown and NameNotFoundException"");
        } catch (NameNotFoundException expected) {
        }

        //the same with security permissions
        try {
            testActionPermission(JndiPermission.ACTION_LIST, namingContext, ""test"");
            fail(""Should have thrown and NameNotFoundException with appropriate permissions"");
        } catch (NameNotFoundException expected) {
        }
    }
",non-flaky,5
26884,wildfly_wildfly,NamingContextTestCase.testList,"    @Test
    public void testList() throws Exception {
        bindList();

        NamingEnumeration<NameClassPair> results = namingContext.list(new CompositeName());
        checkListResults(results);

        //the same with security permissions
        results = (NamingEnumeration<NameClassPair>) testActionPermission(JndiPermission.ACTION_LIST, namingContext, null);
        checkListResults(results);
    }
",non-flaky,5
26885,wildfly_wildfly,NamingContextTestCase.testListWithContinuation,"    @Test
    public void testListWithContinuation() throws Exception {
        bindListWithContinuations();

        NamingEnumeration<NameClassPair> results = namingContext.list(new CompositeName(""comp""));
        checkListWithContinuationsResults(results);

        //the same with security permissions
        results = (NamingEnumeration<NameClassPair>) testActionPermission(JndiPermission.ACTION_LIST, Arrays.asList(
                new JndiPermission(""test"", ""list"")), namingContext, ""comp"");

        checkListWithContinuationsResults(results);
    }
",non-flaky,5
26886,wildfly_wildfly,NamingContextTestCase.testListBindingsNameNotFound,"    @Test
    public void testListBindingsNameNotFound() throws Exception {
        try {
            namingContext.listBindings(new CompositeName(""test""));
            fail(""Should have thrown and NameNotFoundException"");
        } catch (NameNotFoundException expected) {
        }

        //the same with security permissions
        try {
            testActionPermission(JndiPermission.ACTION_LIST_BINDINGS, namingContext, ""test"");
            fail(""Should have thrown and NameNotFoundException with appropriate permissions"");
        } catch (NameNotFoundException expected) {
        }
    }
",non-flaky,5
26887,wildfly_wildfly,NamingContextTestCase.testListBindings,"    @Test
    public void testListBindings() throws Exception {
        bindList();

        NamingEnumeration<Binding> results = namingContext.listBindings(new CompositeName());
        checkListResults(results);

        //the same with security permissions
        results = (NamingEnumeration<Binding>) testActionPermission(JndiPermission.ACTION_LIST_BINDINGS, namingContext, null);
        checkListResults(results);
    }
",non-flaky,5
26888,wildfly_wildfly,NamingContextTestCase.testListBindingsWithContinuation,"    @Test
    public void testListBindingsWithContinuation() throws Exception {
        bindListWithContinuations();

        NamingEnumeration<Binding> results = namingContext.listBindings(new CompositeName(""comp""));
        checkListWithContinuationsResults(results);

        //the same with security permissions
        results = (NamingEnumeration<Binding>) testActionPermission(JndiPermission.ACTION_LIST_BINDINGS, Arrays.asList(
                new JndiPermission(""test"", ""listBindings"")), namingContext, ""comp"");

        checkListWithContinuationsResults(results);
    }
",non-flaky,5
26889,wildfly_wildfly,InMemoryNamingStoreTestCase.testBindEmptyName,"    @Test
    public void testBindEmptyName() throws Exception {
        try {
            nameStore.bind(new CompositeName(), new Object(), Object.class);
            fail(""Should have thrown and InvalidNameException"");
        } catch(InvalidNameException expected){}

        try {
            nameStore.bind(new CompositeName(""""), new Object(), Object.class);
            fail(""Should have thrown and InvalidNameException"");
        } catch(InvalidNameException expected){}
    }
",non-flaky,5
26890,wildfly_wildfly,InMemoryNamingStoreTestCase.testBindAndLookup,"    @Test
    public void testBindAndLookup() throws Exception {
        final Name name = new CompositeName(""test"");
        final Object object = new Object();
        nameStore.bind(name, object, Object.class);
        final Object result = nameStore.lookup(name);
        assertEquals(object, result);
    }
",non-flaky,5
26891,wildfly_wildfly,InMemoryNamingStoreTestCase.testLookupNameNotFound,"    @Test
    public void testLookupNameNotFound() throws Exception {
        try {
            nameStore.lookup(new CompositeName(""test""));
            fail(""Should have thrown and NameNotFoundException"");
        } catch(NameNotFoundException expected) {}
    }
",non-flaky,5
26892,wildfly_wildfly,InMemoryNamingStoreTestCase.testLookupEmptyName,"    @Test
    public void testLookupEmptyName() throws Exception {
        Object result = nameStore.lookup(new CompositeName());
        assertTrue(result instanceof NamingContext);
        result = nameStore.lookup(new CompositeName(""""));
        assertTrue(result instanceof NamingContext);
    }
",non-flaky,5
26893,wildfly_wildfly,InMemoryNamingStoreTestCase.testBindAndLookupResolveResult,"    @Test
    public void testBindAndLookupResolveResult() throws Exception {
        final Name name = new CompositeName(""test"");
        final Reference reference = new Reference(Context.class.getName());
        nameStore.bind(name, reference, Context.class);
        final Object result = nameStore.lookup(new CompositeName(""test/value""));
        assertTrue(result instanceof ResolveResult);
    }
",non-flaky,5
26894,wildfly_wildfly,InMemoryNamingStoreTestCase.testUnbindNotFound,"    @Test
    public void testUnbindNotFound() throws Exception {
        try {
            nameStore.unbind(new CompositeName(""test""));
            fail(""Should have thrown and NameNotFoundException"");
        } catch(NameNotFoundException expected) {}
    }
",non-flaky,5
26895,wildfly_wildfly,InMemoryNamingStoreTestCase.testBindUnbindLookup,"    @Test
    public void testBindUnbindLookup() throws Exception {
        final Name name = new CompositeName(""test"");
        final Object object = new Object();
        nameStore.bind(name, object, Object.class);
        final Object result = nameStore.lookup(name);
        assertEquals(object, result);
        nameStore.unbind(name);
        try {
            nameStore.lookup(name);
            fail(""Should have thrown and NameNotFoundException"");
        } catch(NameNotFoundException expected) {}
    }
",non-flaky,5
26896,wildfly_wildfly,InMemoryNamingStoreTestCase.testRebindEmptyName,"    @Test
    public void testRebindEmptyName() throws Exception {
        try {
            nameStore.rebind(new CompositeName(), new Object(), Object.class);
            fail(""Should have thrown and InvalidNameException"");
        } catch(InvalidNameException expected){}

        try {
            nameStore.rebind(new CompositeName(""""), new Object(), Object.class);
            fail(""Should have thrown and InvalidNameException"");
        } catch(InvalidNameException expected){}
    }
",non-flaky,5
26897,wildfly_wildfly,InMemoryNamingStoreTestCase.testRebindInvalidContext,"    @Test
    public void testRebindInvalidContext() throws Exception {
        try {
            nameStore.rebind(new CompositeName(""subcontext/test""), new Object(), Object.class);
            fail(""Should have thrown and NameNotFoundException"");
        } catch(NameNotFoundException expected){}
    }
",non-flaky,5
26898,wildfly_wildfly,InMemoryNamingStoreTestCase.testRebindAndLookup,"    @Test
    public void testRebindAndLookup() throws Exception {
        final Name name = new CompositeName(""test"");
        final Object object = new Object();
        nameStore.rebind(name, object, Object.class);
        final Object result = nameStore.lookup(name);
        assertEquals(object, result);
    }
",non-flaky,5
26899,wildfly_wildfly,InMemoryNamingStoreTestCase.testBindAndRebind,"    @Test
    public void testBindAndRebind() throws Exception {
        final Name name = new CompositeName(""test"");
        final Object object = new Object();
        nameStore.bind(name, object, Object.class);
        assertEquals(object, nameStore.lookup(name));
        final Object objectTwo = new Object();
        nameStore.rebind(name, objectTwo, Object.class);
        assertEquals(objectTwo, nameStore.lookup(name));
    }
",non-flaky,5
26900,wildfly_wildfly,InMemoryNamingStoreTestCase.testListNameNotFound,"    @Test
    public void testListNameNotFound() throws Exception {
        try {
            nameStore.list(new CompositeName(""test""));
            fail(""Should have thrown and NameNotFoundException"");
        } catch(NameNotFoundException expected) {}
    }
",non-flaky,5
26901,wildfly_wildfly,InMemoryNamingStoreTestCase.testList,"    @Test
    public void testList() throws Exception {
        final Name name = new CompositeName(""test"");
        final Object object = new Object();
        nameStore.bind(name, object, Object.class);
        final Name nameTwo = new CompositeName(""testTwo"");
        final Object objectTwo = new Object();
        nameStore.bind(nameTwo, objectTwo, Object.class);
        final Name nameThree = new CompositeName(""testThree"");
        final Object objectThree = new Object();
        nameStore.bind(nameThree, objectThree, Object.class);

        nameStore.bind(new CompositeName(""testContext/test""), ""test"");

        final List<NameClassPair> results = nameStore.list(new CompositeName());
        assertEquals(4, results.size());
        final Set<String> expected = new HashSet<String>(Arrays.asList(""test"", ""testTwo"", ""testThree"", ""testContext""));
        for(NameClassPair result : results) {
            final String resultName = result.getName();
            if(""test"".equals(resultName) || ""testTwo"".equals(resultName) || ""testThree"".equals(resultName)) {
                assertEquals(Object.class.getName(), result.getClassName());
            } else if(""testContext"".equals(resultName)) {
                assertEquals(Context.class.getName(), result.getClassName());
            } else {
                fail(""Unknown result name: "" + resultName);
            }
            expected.remove(resultName);
        }
        assertTrue(""Not all expected results were returned"", expected.isEmpty());
    }
",non-flaky,5
26902,wildfly_wildfly,InMemoryNamingStoreTestCase.testListBindingsNameNotFound,"    @Test
    public void testListBindingsNameNotFound() throws Exception {
        try {
            nameStore.listBindings(new CompositeName(""test""));
            fail(""Should have thrown and NameNotFoundException"");
        } catch(NameNotFoundException expected) {}
    }
",non-flaky,5
26903,wildfly_wildfly,InMemoryNamingStoreTestCase.testListBindings,"    @Test
    public void testListBindings() throws Exception {
        final Name name = new CompositeName(""test"");
        final Object object = new Object();
        nameStore.bind(name, object);
        final Name nameTwo = new CompositeName(""testTwo"");
        final Object objectTwo = new Object();
        nameStore.bind(nameTwo, objectTwo);
        final Name nameThree = new CompositeName(""testThree"");
        final Object objectThree = new Object();
        nameStore.bind(nameThree, objectThree);

        nameStore.bind(new CompositeName(""testContext/test""), ""test"");

        final List<Binding> results = nameStore.listBindings(new CompositeName());
        assertEquals(4, results.size());
        final Set<String> expected = new HashSet<String>(Arrays.asList(""test"", ""testTwo"", ""testThree"", ""testContext""));
        for(Binding result : results) {
            final String resultName = result.getName();
            if(""test"".equals(resultName)) {
                assertEquals(Object.class.getName(), result.getClassName());
                assertEquals(object, result.getObject());
            } else if(""testTwo"".equals(resultName)) {
                assertEquals(Object.class.getName(), result.getClassName());
                assertEquals(objectTwo, result.getObject());
            } else if(""testThree"".equals(resultName)) {
                assertEquals(Object.class.getName(), result.getClassName());
                assertEquals(objectThree, result.getObject());
            } else if(""testContext"".equals(resultName)) {
                assertEquals(Context.class.getName(), result.getClassName());
            } else {
                fail(""Unknown result name: "" + resultName);
            }
            expected.remove(resultName);
        }
        assertTrue(""Not all expected results were returned"", expected.isEmpty());
    }
",non-flaky,5
26904,wildfly_wildfly,InMemoryNamingStoreTestCase.testAutoRemove,"    @Test
    public void testAutoRemove() throws Exception {
        nameStore.bind(new CompositeName(""test/item""), new Object());

        assertNotNull(nameStore.lookup(new CompositeName(""test/item"")));
        assertNotNull(nameStore.lookup(new CompositeName(""test"")));

        nameStore.unbind(new CompositeName(""test/item""));

        try {
            nameStore.lookup(new CompositeName(""test""));
            fail(""Should have throw name not found exception"");
        } catch (NameNotFoundException expected){}
    }
",non-flaky,5
26905,wildfly_wildfly,InitialContextFactoryTestCase.testInitialFactory,"    @Test
    public void testInitialFactory() throws Exception {
        // Test with sys prop
        System.setProperty(Context.INITIAL_CONTEXT_FACTORY, InitialContextFactory.class.getName());
        InitialContext initialContext = new InitialContext();
        Context context = (Context) initialContext.lookup("""");
        assertTrue(context instanceof NamingContext);

        // Test with builder
        if (!NamingManager.hasInitialContextFactoryBuilder()) {
            NamingManager.setInitialContextFactoryBuilder(new InitialContextFactoryBuilder());
        }
        initialContext = new InitialContext();
        context = (Context) initialContext.lookup("""");
        assertTrue(context instanceof NamingContext);
    }
",non-flaky,5
26906,wildfly_wildfly,InitialContextFactoryTestCase.testJavaContext,"    @Test
    public void testJavaContext() throws Exception {
        System.setProperty(Context.INITIAL_CONTEXT_FACTORY, InitialContextFactory.class.getName());
        System.setProperty(Context.URL_PKG_PREFIXES, ""org.jboss.as.naming.interfaces"");
        InitialContext initialContext = new InitialContext();
        Context context = (Context) initialContext.lookup(""java:"");
        assertTrue(context instanceof NamingContext);
    }
",non-flaky,5
26907,wildfly_wildfly,JSFSubsystemTransformersTestCase.testTransformersEAP700,"    @Test
    public void testTransformersEAP700() throws Exception {
        testTransformers(ModelTestControllerVersion.EAP_7_0_0, legacyVersion, ""/jsf-transformers.xml"");
    }
",non-flaky,5
26908,wildfly_wildfly,JSFSubsystemTransformersTestCase.testRejectTransformersEAP700,"    @Test
    public void testRejectTransformersEAP700() throws Exception {
        doRejectTest(ModelTestControllerVersion.EAP_7_0_0, legacyVersion);
    }
",non-flaky,5
26909,wildfly_wildfly,JSFSubsystemTestCase.testSchemaOfSubsystemTemplates,"    @Test
    public void testSchemaOfSubsystemTemplates() throws Exception {
        super.testSchemaOfSubsystemTemplates();
    }
",non-flaky,5
26910,wildfly_wildfly,JSFModuleIdFactoryTestCase.noModulePathTest,"     @Test
     public void noModulePathTest() {
     JSFModuleIdFactory factory = JSFModuleIdFactory.getInstance();
     Assert.assertEquals(1, factory.getActiveJSFVersions().size());

     Assert.assertEquals(API_MODULE, factory.getApiModId(""main"").getName());
     Assert.assertEquals(""main"", factory.getApiModId(""main"").getSlot());
     Assert.assertEquals(IMPL_MODULE, factory.getImplModId(""main"").getName());
     Assert.assertEquals(""main"", factory.getImplModId(""main"").getSlot());
     Assert.assertEquals(INJECTION_MODULE, factory.getInjectionModId(""main"").getName());
     Assert.assertEquals(""main"", factory.getInjectionModId(""main"").getSlot());
     } */
",non-flaky,5
26911,wildfly_wildfly,JSFModuleIdFactoryTestCase.getActiveJSFVersionsTest,"    @Test
    public void getActiveJSFVersionsTest() {
        List<String> versions = factory.getActiveJSFVersions();
        Assert.assertEquals(3, versions.size());
        Assert.assertTrue(versions.contains(""main""));
        Assert.assertFalse(versions.contains(""1.2""));
        Assert.assertTrue(versions.contains(""myfaces""));
        Assert.assertTrue(versions.contains(""myfaces2""));
    }
",non-flaky,5
26912,wildfly_wildfly,JSFModuleIdFactoryTestCase.computeSlotTest,"    @Test
    public void computeSlotTest() {
        Assert.assertEquals(""main"", factory.computeSlot(""main""));
        Assert.assertEquals(""main"", factory.computeSlot(null));
        Assert.assertEquals(""main"", factory.computeSlot(JsfVersionMarker.JSF_2_0));
        Assert.assertEquals(""myfaces2"", factory.computeSlot(""myfaces2""));
    }
",non-flaky,5
26913,wildfly_wildfly,JSFModuleIdFactoryTestCase.validSlotTest,"    @Test
    public void validSlotTest() {
        Assert.assertTrue(factory.isValidJSFSlot(""main""));
        Assert.assertFalse(factory.isValidJSFSlot(""1.2""));
        Assert.assertTrue(factory.isValidJSFSlot(""myfaces""));
        Assert.assertTrue(factory.isValidJSFSlot(""myfaces2""));
        Assert.assertTrue(factory.isValidJSFSlot(JsfVersionMarker.JSF_2_0));
        Assert.assertFalse(factory.isValidJSFSlot(JsfVersionMarker.WAR_BUNDLES_JSF_IMPL));
        Assert.assertFalse(factory.isValidJSFSlot(""bogus""));
        Assert.assertFalse(factory.isValidJSFSlot(""bogus2""));
   }
",non-flaky,5
26914,wildfly_wildfly,JSFModuleIdFactoryTestCase.modIdsTest,"    @Test
    public void modIdsTest() {
        Assert.assertEquals(API_MODULE, factory.getApiModId(""main"").getName());
        Assert.assertEquals(""main"", factory.getApiModId(""main"").getSlot());
        Assert.assertEquals(IMPL_MODULE, factory.getImplModId(""main"").getName());
        Assert.assertEquals(""main"", factory.getImplModId(""main"").getSlot());
        Assert.assertEquals(INJECTION_MODULE, factory.getInjectionModId(""main"").getName());
        Assert.assertEquals(""main"", factory.getInjectionModId(""main"").getSlot());

        Assert.assertEquals(API_MODULE, factory.getApiModId(""myfaces"").getName());
        Assert.assertEquals(""myfaces"", factory.getApiModId(""myfaces"").getSlot());
        Assert.assertEquals(IMPL_MODULE, factory.getImplModId(""myfaces"").getName());
        Assert.assertEquals(""myfaces"", factory.getImplModId(""myfaces"").getSlot());
        Assert.assertEquals(INJECTION_MODULE, factory.getInjectionModId(""myfaces"").getName());
        Assert.assertEquals(""myfaces"", factory.getInjectionModId(""myfaces"").getSlot());

        Assert.assertEquals(API_MODULE, factory.getApiModId(""myfaces2"").getName());
        Assert.assertEquals(""myfaces2"", factory.getApiModId(""myfaces2"").getSlot());
        Assert.assertEquals(IMPL_MODULE, factory.getImplModId(""myfaces2"").getName());
        Assert.assertEquals(""myfaces2"", factory.getImplModId(""myfaces2"").getSlot());
        Assert.assertEquals(INJECTION_MODULE, factory.getInjectionModId(""myfaces2"").getName());
        Assert.assertEquals(""myfaces2"", factory.getInjectionModId(""myfaces2"").getSlot());
    }
",non-flaky,5
26915,wildfly_wildfly,MailSubsystem10TestCase.testParseSubsystem,"    @Test
    public void testParseSubsystem() throws Exception {
        //Parse the subsystem xml into operations
        List<ModelNode> operations = super.parse(getSubsystemXml());

        ///Check that we have the expected number of operations
        //log.info(""operations: "" + operations);
        //log.info(""operations.size: "" + operations.size());
        Assert.assertEquals(7, operations.size());

        //Check that each operation has the correct content
        ModelNode addSubsystem = operations.get(0);
        Assert.assertEquals(ADD, addSubsystem.get(OP).asString());
        PathAddress addr = PathAddress.pathAddress(addSubsystem.get(OP_ADDR));
        Assert.assertEquals(1, addr.size());
        PathElement element = addr.getElement(0);
        Assert.assertEquals(SUBSYSTEM, element.getKey());
        Assert.assertEquals(MailExtension.SUBSYSTEM_NAME, element.getValue());
    }
",non-flaky,5
26916,wildfly_wildfly,MailTransformersTestCase.testTransformerEAP700,"    @Test
    public void testTransformerEAP700() throws Exception {
        testTransformation(ModelTestControllerVersion.EAP_7_0_0, MODEL_VERSION_EAP70);
    }
",non-flaky,5
26917,wildfly_wildfly,MailTransformersTestCase.testTransformerEAP640,"    @Test
    public void testTransformerEAP640() throws Exception {
        testTransformation(ModelTestControllerVersion.EAP_6_4_0, MODEL_VERSION_EAP6X);
    }
",non-flaky,5
26918,wildfly_wildfly,MailTransformersTestCase.testRejectingTransformersEAP_7_0_0,"    @Test
    public void testRejectingTransformersEAP_7_0_0() throws Exception {
        testRejectingTransformers(EAP_7_0_0, MODEL_VERSION_EAP70);
    }
",non-flaky,5
26919,wildfly_wildfly,MailTransformersTestCase.testRejectingTransformersEAP_6_4_0,"    @Test
    public void testRejectingTransformersEAP_6_4_0() throws Exception {
        testRejectingTransformers(EAP_6_4_0, MODEL_VERSION_EAP6X);
    }
",non-flaky,5
26920,wildfly_wildfly,MailSubsystem20TestCase.testExpressions,"    @Test
    public void testExpressions() throws Exception {
        standardSubsystemTest(""subsystem_1_1_expressions.xml"", false);
    }
",non-flaky,5
26921,wildfly_wildfly,MailSubsystem20TestCase.test11,"    @Test
    public void test11() throws Exception {
        standardSubsystemTest(""subsystem_1_1.xml"", false);
    }
",non-flaky,5
26922,wildfly_wildfly,MailSubsystem20TestCase.test12,"    @Test
    public void test12() throws Exception {
        standardSubsystemTest(""subsystem_1_2.xml"", false);
    }
",non-flaky,5
26923,wildfly_wildfly,MailSubsystem20TestCase.testRuntime,"    @Test
    public void testRuntime() throws Exception {
        KernelServicesBuilder builder = createKernelServicesBuilder(new DefaultInitializer())
                .setSubsystemXml(getSubsystemXml());
        KernelServices mainServices = builder.build();
        if (!mainServices.isSuccessfulBoot()) {
            Assert.fail(mainServices.getBootError().toString());
        }
        ServiceController<?> javaMailService = mainServices.getContainer().getService(MailSessionDefinition.SESSION_CAPABILITY.getCapabilityServiceName(""defaultMail""));
        javaMailService.setMode(ServiceController.Mode.ACTIVE);
        Session session = (Session) javaMailService.getValue();
        Assert.assertNotNull(""session should not be null"", session);
        Properties properties = session.getProperties();
        Assert.assertNotNull(""smtp host should be set"", properties.getProperty(""mail.smtp.host""));
        Assert.assertNotNull(""pop3 host should be set"", properties.getProperty(""mail.pop3.host""));
        Assert.assertNotNull(""imap host should be set"", properties.getProperty(""mail.imap.host""));

        ServiceController<?> defaultMailService = mainServices.getContainer().getService(MailSessionDefinition.SESSION_CAPABILITY.getCapabilityServiceName(""default2""));
        session = (Session) defaultMailService.getValue();
        Assert.assertEquals(""Debug should be true"", true, session.getDebug());


        ServiceController<?> customMailService = mainServices.getContainer().getService(MailSessionDefinition.SESSION_CAPABILITY.getCapabilityServiceName(""custom""));
        session = (Session) customMailService.getValue();
        properties = session.getProperties();
        String host = properties.getProperty(""mail.smtp.host"");
        Assert.assertNotNull(""smtp host should be set"", host);
        Assert.assertEquals(""mail.example.com"", host);

        Assert.assertEquals(""localhost"", properties.get(""mail.pop3.host"")); //this one should be read out of socket binding
        Assert.assertEquals(""some-custom-prop-value"", properties.get(""mail.pop3.custom_prop"")); //this one should be extra property
        Assert.assertEquals(""fully-qualified-prop-name"", properties.get(""some.fully.qualified.property"")); //this one should be extra property

        MailSessionService service = (MailSessionService) customMailService.getService();
        Credentials credentials = service.getConfig().getCustomServers()[0].getCredentials();
        Assert.assertEquals(credentials.getUsername(), ""username"");
        Assert.assertEquals(credentials.getPassword(), ""password"");


    }
",non-flaky,5
26924,wildfly_wildfly,MailSubsystem30TestCase.testSchemaOfSubsystemTemplates,"    @Test
    public void testSchemaOfSubsystemTemplates() throws Exception {
        super.testSchemaOfSubsystemTemplates();
    }
",non-flaky,5
26925,wildfly_wildfly,MailSubsystem30TestCase.testRuntime,"    @Test
    public void testRuntime() throws Exception {
        KernelServicesBuilder builder = createKernelServicesBuilder(new DefaultInitializer())
                .setSubsystemXml(getSubsystemXml());
        KernelServices mainServices = builder.build();
        if (!mainServices.isSuccessfulBoot()) {
            Assert.fail(mainServices.getBootError().toString());
        }
        ServiceController<?> javaMailService = mainServices.getContainer().getService(MailSessionDefinition.SESSION_CAPABILITY.getCapabilityServiceName(""defaultMail""));
        javaMailService.setMode(ServiceController.Mode.ACTIVE);
        Session session = (Session) javaMailService.getValue();
        Assert.assertNotNull(""session should not be null"", session);
        Properties properties = session.getProperties();
        Assert.assertNotNull(""smtp host should be set"", properties.getProperty(""mail.smtp.host""));
        Assert.assertNotNull(""pop3 host should be set"", properties.getProperty(""mail.pop3.host""));
        Assert.assertNotNull(""imap host should be set"", properties.getProperty(""mail.imap.host""));
        PasswordAuthentication auth = session.requestPasswordAuthentication(InetAddress.getLocalHost(), 25, ""smtp"", """", """");
        Assert.assertEquals(""nobody"", auth.getUserName());
        Assert.assertEquals(""pass"", auth.getPassword());

        ServiceController<?> defaultMailService = mainServices.getContainer().getService(MailSessionDefinition.SESSION_CAPABILITY.getCapabilityServiceName(""default2""));
        session = (Session) defaultMailService.getValue();
        Assert.assertEquals(""Debug should be true"", true, session.getDebug());


        ServiceController<?> customMailService = mainServices.getContainer().getService(MailSessionDefinition.SESSION_CAPABILITY.getCapabilityServiceName(""custom""));
        session = (Session) customMailService.getValue();
        properties = session.getProperties();
        String host = properties.getProperty(""mail.smtp.host"");
        Assert.assertNotNull(""smtp host should be set"", host);
        Assert.assertEquals(""mail.example.com"", host);

        Assert.assertEquals(""localhost"", properties.get(""mail.pop3.host"")); //this one should be read out of socket binding
        Assert.assertEquals(""some-custom-prop-value"", properties.get(""mail.pop3.custom_prop"")); //this one should be extra property
        Assert.assertEquals(""fully-qualified-prop-name"", properties.get(""some.fully.qualified.property"")); //this one should be extra property

        MailSessionService service = (MailSessionService) customMailService.getService();
        Credentials credentials = service.getConfig().getCustomServers()[0].getCredentials();
        Assert.assertEquals(credentials.getUsername(), ""username"");
        Assert.assertEquals(credentials.getPassword(), ""password"");


    }
",non-flaky,5
26926,wildfly_wildfly,MailSubsystemTestBase.testOperations,"    @Test
    public void testOperations() throws Exception {
        KernelServicesBuilder builder = createKernelServicesBuilder(new DefaultInitializer())
                .setSubsystemXml(getSubsystemXml());
        KernelServices mainServices = builder.build();
        if (!mainServices.isSuccessfulBoot()) {
            Assert.fail(mainServices.getBootError().toString());
        }

        PathAddress sessionAddress = PathAddress.pathAddress(MailExtension.SUBSYSTEM_PATH, PathElement.pathElement(MailExtension.MAIL_SESSION_PATH.getKey(), ""defaultMail""));
        ModelNode result;

        ModelNode removeServerOp = Util.createRemoveOperation(sessionAddress.append(""server"", ""imap""));
        removeServerOp.get(OPERATION_HEADERS).get(ALLOW_RESOURCE_SERVICE_RESTART).set(true);
        result = mainServices.executeOperation(removeServerOp);
        checkResult(result);

        ModelNode addServerOp = Util.createAddOperation(sessionAddress.append(""server"", ""imap""));
        addServerOp.get(OPERATION_HEADERS).get(ALLOW_RESOURCE_SERVICE_RESTART).set(true);
        addServerOp.get(""outbound-socket-binding-ref"").set(""mail-imap"");
        addServerOp.get(""username"").set(""user"");
        addServerOp.get(""password"").set(""pswd"");

        result = mainServices.executeOperation(addServerOp);
        checkResult(result);

        checkResult(mainServices.executeOperation(removeServerOp)); //to make sure noting is left behind
        checkResult(mainServices.executeOperation(addServerOp));

        ModelNode writeOp = Util.createEmptyOperation(WRITE_ATTRIBUTE_OPERATION, sessionAddress);
        writeOp.get(OPERATION_HEADERS).get(ALLOW_RESOURCE_SERVICE_RESTART).set(true);
        writeOp.get(""name"").set(""debug"");
        writeOp.get(""value"").set(false);
        result = mainServices.executeOperation(writeOp);
        checkResult(result);


        ServiceController<?> javaMailService = mainServices.getContainer().getService(MailSessionDefinition.SESSION_CAPABILITY.getCapabilityServiceName(""defaultMail""));
        javaMailService.setMode(ServiceController.Mode.ACTIVE);
        Session session = (Session) javaMailService.getValue();
        Assert.assertNotNull(""session should not be null"", session);
        Properties properties = session.getProperties();
        Assert.assertNotNull(""smtp host should be set"", properties.getProperty(""mail.smtp.host""));
        Assert.assertNotNull(""imap host should be set"", properties.getProperty(""mail.imap.host""));


        PathAddress nonExisting = PathAddress.pathAddress(MailExtension.SUBSYSTEM_PATH, PathElement.pathElement(MailExtension.MAIL_SESSION_PATH.getKey(), ""non-existing-session""));
        ModelNode addSession = Util.createAddOperation(nonExisting);
        addSession.get(""jndi-name"").set(""java:/bah"");
        checkResult(mainServices.executeOperation(addSession));
        removeServerOp = Util.createRemoveOperation(nonExisting.append(""server"", ""imap""));
        //removeServerOp.get(OPERATION_HEADERS).get(ALLOW_RESOURCE_SERVICE_RESTART).set(true);
        result = mainServices.executeOperation(removeServerOp);
        checkForFailure(result);


    }
",non-flaky,5
70765,apache_kafka,StartAndStopCounterTest.shouldRecordStarts,"    @Test
    public void shouldRecordStarts() {
        assertEquals(0, counter.starts());
        counter.recordStart();
        assertEquals(1, counter.starts());
        counter.recordStart();
        assertEquals(2, counter.starts());
        assertEquals(2, counter.starts());
    }
",non-flaky,5
70766,apache_kafka,StartAndStopCounterTest.shouldRecordStops,"    @Test
    public void shouldRecordStops() {
        assertEquals(0, counter.stops());
        counter.recordStop();
        assertEquals(1, counter.stops());
        counter.recordStop();
        assertEquals(2, counter.stops());
        assertEquals(2, counter.stops());
    }
",non-flaky,5
70767,apache_kafka,StartAndStopCounterTest.shouldExpectRestarts,"    @Test
    public void shouldExpectRestarts() throws Exception {
        waiters = Executors.newSingleThreadExecutor();

        latch = counter.expectedRestarts(1);
        Future<Boolean> future = asyncAwait(100, TimeUnit.MILLISECONDS);

        clock.sleep(1000);
        counter.recordStop();
        counter.recordStart();
        assertTrue(future.get(200, TimeUnit.MILLISECONDS));
        assertTrue(future.isDone());
    }
",non-flaky,5
70768,apache_kafka,StartAndStopCounterTest.shouldFailToWaitForRestartThatNeverHappens,"    @Test
    public void shouldFailToWaitForRestartThatNeverHappens() throws Exception {
        waiters = Executors.newSingleThreadExecutor();

        latch = counter.expectedRestarts(1);
        Future<Boolean> future = asyncAwait(100, TimeUnit.MILLISECONDS);

        clock.sleep(1000);
        // Record a stop but NOT a start
        counter.recordStop();
        assertFalse(future.get(200, TimeUnit.MILLISECONDS));
        assertTrue(future.isDone());
    }
",non-flaky,5
70769,apache_kafka,ConnectWorkerIntegrationTest.testAddAndRemoveWorker,"    @Test
    public void testAddAndRemoveWorker() throws Exception {
        connect = connectBuilder.build();
        // start the clusters
        connect.start();

        int numTasks = 4;
        // create test topic
        connect.kafka().createTopic(""test-topic"", NUM_TOPIC_PARTITIONS);

        // setup up props for the sink connector
        Map<String, String> props = new HashMap<>();
        props.put(CONNECTOR_CLASS_CONFIG, MonitorableSourceConnector.class.getSimpleName());
        props.put(TASKS_MAX_CONFIG, String.valueOf(numTasks));
        props.put(""throughput"", String.valueOf(1));
        props.put(""messages.per.poll"", String.valueOf(10));
        props.put(KEY_CONVERTER_CLASS_CONFIG, StringConverter.class.getName());
        props.put(VALUE_CONVERTER_CLASS_CONFIG, StringConverter.class.getName());

        waitForCondition(() -> assertWorkersUp(NUM_WORKERS).orElse(false),
                WORKER_SETUP_DURATION_MS, ""Initial group of workers did not start in time."");

        // start a source connector
        connect.configureConnector(CONNECTOR_NAME, props);

        waitForCondition(() -> assertConnectorAndTasksRunning(CONNECTOR_NAME, numTasks).orElse(false),
                CONNECTOR_SETUP_DURATION_MS, ""Connector tasks did not start in time."");

        WorkerHandle extraWorker = connect.addWorker();

        waitForCondition(() -> assertWorkersUp(NUM_WORKERS + 1).orElse(false),
                WORKER_SETUP_DURATION_MS, ""Expanded group of workers did not start in time."");

        waitForCondition(() -> assertConnectorAndTasksRunning(CONNECTOR_NAME, numTasks).orElse(false),
                CONNECTOR_SETUP_DURATION_MS, ""Connector tasks are not all in running state."");

        Set<WorkerHandle> workers = connect.activeWorkers();
        assertTrue(workers.contains(extraWorker));

        connect.removeWorker(extraWorker);

        waitForCondition(() -> assertWorkersUp(NUM_WORKERS).orElse(false) && !assertWorkersUp(NUM_WORKERS + 1).orElse(false),
                WORKER_SETUP_DURATION_MS, ""Group of workers did not shrink in time."");

        workers = connect.activeWorkers();
        assertFalse(workers.contains(extraWorker));
    }
",non-flaky,5
70770,apache_kafka,ConnectWorkerIntegrationTest.testRestartFailedTask,"    @Test
    public void testRestartFailedTask() throws Exception {
        connect = connectBuilder.build();
        // start the clusters
        connect.start();

        int numTasks = 1;

        // Properties for the source connector. The task should fail at startup due to the bad broker address.
        Map<String, String> connectorProps = new HashMap<>();
        connectorProps.put(CONNECTOR_CLASS_CONFIG, MonitorableSourceConnector.class.getName());
        connectorProps.put(TASKS_MAX_CONFIG, Objects.toString(numTasks));
        connectorProps.put(CONNECTOR_CLIENT_PRODUCER_OVERRIDES_PREFIX + BOOTSTRAP_SERVERS_CONFIG, ""nobrokerrunningatthisaddress"");

        waitForCondition(() -> assertWorkersUp(NUM_WORKERS).orElse(false),
                WORKER_SETUP_DURATION_MS, ""Initial group of workers did not start in time."");

        // Try to start the connector and its single task.
        connect.configureConnector(CONNECTOR_NAME, connectorProps);

        waitForCondition(() -> assertConnectorTasksFailed(CONNECTOR_NAME, numTasks).orElse(false),
                CONNECTOR_SETUP_DURATION_MS, ""Connector tasks did not fail in time"");

        // Reconfigure the connector without the bad broker address.
        connectorProps.remove(CONNECTOR_CLIENT_PRODUCER_OVERRIDES_PREFIX + BOOTSTRAP_SERVERS_CONFIG);
        connect.configureConnector(CONNECTOR_NAME, connectorProps);

        // Restart the failed task
        String taskRestartEndpoint = connect.endpointForResource(
            String.format(""connectors/%s/tasks/0/restart"", CONNECTOR_NAME));
        connect.executePost(taskRestartEndpoint, """", Collections.emptyMap());

        // Ensure the task started successfully this time
        waitForCondition(() -> assertConnectorAndTasksRunning(CONNECTOR_NAME, numTasks).orElse(false),
            CONNECTOR_SETUP_DURATION_MS, ""Connector tasks are not all in running state."");
    }
",non-flaky,5
70771,apache_kafka,ConnectWorkerIntegrationTest.testBrokerCoordinator,"    @Test
    public void testBrokerCoordinator() throws Exception {
        workerProps.put(DistributedConfig.SCHEDULED_REBALANCE_MAX_DELAY_MS_CONFIG, String.valueOf(5000));
        connect = connectBuilder.workerProps(workerProps).build();
        // start the clusters
        connect.start();
        int numTasks = 4;
        // create test topic
        connect.kafka().createTopic(""test-topic"", NUM_TOPIC_PARTITIONS);

        // setup up props for the sink connector
        Map<String, String> props = new HashMap<>();
        props.put(CONNECTOR_CLASS_CONFIG, MonitorableSourceConnector.class.getSimpleName());
        props.put(TASKS_MAX_CONFIG, String.valueOf(numTasks));
        props.put(""topic"", ""test-topic"");
        props.put(""throughput"", String.valueOf(1));
        props.put(""messages.per.poll"", String.valueOf(10));
        props.put(KEY_CONVERTER_CLASS_CONFIG, StringConverter.class.getName());
        props.put(VALUE_CONVERTER_CLASS_CONFIG, StringConverter.class.getName());

        waitForCondition(() -> assertWorkersUp(NUM_WORKERS).orElse(false),
                WORKER_SETUP_DURATION_MS, ""Initial group of workers did not start in time."");

        // start a source connector
        connect.configureConnector(CONNECTOR_NAME, props);

        waitForCondition(() -> assertConnectorAndTasksRunning(CONNECTOR_NAME, numTasks).orElse(false),
                CONNECTOR_SETUP_DURATION_MS, ""Connector tasks did not start in time."");

        connect.kafka().stopOnlyKafka();

        waitForCondition(() -> assertWorkersUp(NUM_WORKERS).orElse(false),
                WORKER_SETUP_DURATION_MS, ""Group of workers did not remain the same after broker shutdown"");

        // Allow for the workers to discover that the coordinator is unavailable, wait is
        // heartbeat timeout * 2 + 4sec
        Thread.sleep(TimeUnit.SECONDS.toMillis(10));

        connect.kafka().startOnlyKafkaOnSamePorts();

        // Allow for the kafka brokers to come back online
        Thread.sleep(TimeUnit.SECONDS.toMillis(10));

        waitForCondition(() -> assertWorkersUp(NUM_WORKERS).orElse(false),
                WORKER_SETUP_DURATION_MS, ""Group of workers did not remain the same within the ""
                        + ""designated time."");

        // Allow for the workers to rebalance and reach a steady state
        Thread.sleep(TimeUnit.SECONDS.toMillis(10));

        waitForCondition(() -> assertConnectorAndTasksRunning(CONNECTOR_NAME, numTasks).orElse(false),
                CONNECTOR_SETUP_DURATION_MS, ""Connector tasks did not start in time."");
    }
",non-flaky,5
70772,apache_kafka,RebalanceSourceConnectorsIntegrationTest.testStartTwoConnectors,"    @Test
    public void testStartTwoConnectors() throws Exception {
        // create test topic
        connect.kafka().createTopic(TOPIC_NAME, NUM_TOPIC_PARTITIONS);

        // setup up props for the source connector
        Map<String, String> props = new HashMap<>();
        props.put(CONNECTOR_CLASS_CONFIG, MonitorableSourceConnector.class.getSimpleName());
        props.put(TASKS_MAX_CONFIG, String.valueOf(NUM_TASKS));
        props.put(""throughput"", String.valueOf(1));
        props.put(""messages.per.poll"", String.valueOf(10));
        props.put(TOPIC_CONFIG, TOPIC_NAME);
        props.put(KEY_CONVERTER_CLASS_CONFIG, StringConverter.class.getName());
        props.put(VALUE_CONVERTER_CLASS_CONFIG, StringConverter.class.getName());

        // start a source connector
        connect.configureConnector(CONNECTOR_NAME, props);

        waitForCondition(() -> this.assertConnectorAndTasksRunning(CONNECTOR_NAME, NUM_TASKS).orElse(false),
                CONNECTOR_SETUP_DURATION_MS, ""Connector tasks did not start in time."");

        // start a source connector
        connect.configureConnector(""another-source"", props);

        waitForCondition(() -> this.assertConnectorAndTasksRunning(CONNECTOR_NAME, NUM_TASKS).orElse(false),
                CONNECTOR_SETUP_DURATION_MS, ""Connector tasks did not start in time."");

        waitForCondition(() -> this.assertConnectorAndTasksRunning(""another-source"", 4).orElse(false),
                CONNECTOR_SETUP_DURATION_MS, ""Connector tasks did not start in time."");
    }
",non-flaky,5
70773,apache_kafka,RebalanceSourceConnectorsIntegrationTest.testReconfigConnector,"    @Test
    public void testReconfigConnector() throws Exception {
        ConnectorHandle connectorHandle = RuntimeHandles.get().connectorHandle(CONNECTOR_NAME);

        // create test topic
        String anotherTopic = ""another-topic"";
        connect.kafka().createTopic(TOPIC_NAME, NUM_TOPIC_PARTITIONS);
        connect.kafka().createTopic(anotherTopic, NUM_TOPIC_PARTITIONS);

        // setup up props for the source connector
        Map<String, String> props = new HashMap<>();
        props.put(CONNECTOR_CLASS_CONFIG, MonitorableSourceConnector.class.getSimpleName());
        props.put(TASKS_MAX_CONFIG, String.valueOf(NUM_TASKS));
        props.put(""throughput"", String.valueOf(1));
        props.put(""messages.per.poll"", String.valueOf(10));
        props.put(TOPIC_CONFIG, TOPIC_NAME);
        props.put(KEY_CONVERTER_CLASS_CONFIG, StringConverter.class.getName());
        props.put(VALUE_CONVERTER_CLASS_CONFIG, StringConverter.class.getName());

        // start a source connector
        connect.configureConnector(CONNECTOR_NAME, props);

        waitForCondition(() -> this.assertConnectorAndTasksRunning(CONNECTOR_NAME, NUM_TASKS).orElse(false),
                CONNECTOR_SETUP_DURATION_MS, ""Connector tasks did not start in time."");

        int numRecordsProduced = 100;
        long recordTransferDurationMs = TimeUnit.SECONDS.toMillis(30);

        // consume all records from the source topic or fail, to ensure that they were correctly produced
        int recordNum = connect.kafka().consume(numRecordsProduced, recordTransferDurationMs, TOPIC_NAME).count();
        assertTrue(""Not enough records produced by source connector. Expected at least: "" + numRecordsProduced + "" + but got "" + recordNum,
                recordNum >= numRecordsProduced);

        // expect that we're going to restart the connector and its tasks
        StartAndStopLatch restartLatch = connectorHandle.expectedStarts(1);

        // Reconfigure the source connector by changing the Kafka topic used as output
        props.put(TOPIC_CONFIG, anotherTopic);
        connect.configureConnector(CONNECTOR_NAME, props);

        // Wait for the connector *and tasks* to be restarted
        assertTrue(""Failed to alter connector configuration and see connector and tasks restart ""
                   + ""within "" + CONNECTOR_SETUP_DURATION_MS + ""ms"",
                restartLatch.await(CONNECTOR_SETUP_DURATION_MS, TimeUnit.MILLISECONDS));

        // And wait for the Connect to show the connectors and tasks are running
        waitForCondition(() -> this.assertConnectorAndTasksRunning(CONNECTOR_NAME, NUM_TASKS).orElse(false),
                CONNECTOR_SETUP_DURATION_MS, ""Connector tasks did not start in time."");

        // consume all records from the source topic or fail, to ensure that they were correctly produced
        recordNum = connect.kafka().consume(numRecordsProduced, recordTransferDurationMs, anotherTopic).count();
        assertTrue(""Not enough records produced by source connector. Expected at least: "" + numRecordsProduced + "" + but got "" + recordNum,
                recordNum >= numRecordsProduced);
    }
",non-flaky,5
70774,apache_kafka,RebalanceSourceConnectorsIntegrationTest.testDeleteConnector,"    @Test
    public void testDeleteConnector() throws Exception {
        // create test topic
        connect.kafka().createTopic(TOPIC_NAME, NUM_TOPIC_PARTITIONS);

        // setup up props for the source connector
        Map<String, String> props = new HashMap<>();
        props.put(CONNECTOR_CLASS_CONFIG, MonitorableSourceConnector.class.getSimpleName());
        props.put(TASKS_MAX_CONFIG, String.valueOf(NUM_TASKS));
        props.put(""throughput"", String.valueOf(1));
        props.put(""messages.per.poll"", String.valueOf(10));
        props.put(TOPIC_CONFIG, TOPIC_NAME);
        props.put(KEY_CONVERTER_CLASS_CONFIG, StringConverter.class.getName());
        props.put(VALUE_CONVERTER_CLASS_CONFIG, StringConverter.class.getName());

        waitForCondition(() -> this.assertWorkersUp(3),
                WORKER_SETUP_DURATION_MS, ""Connect workers did not start in time."");

        // start a source connector
        IntStream.range(0, 4).forEachOrdered(
            i -> {
                try {
                    connect.configureConnector(CONNECTOR_NAME + i, props);
                } catch (IOException e) {
                    throw new ConnectException(e);
                }
            });

        waitForCondition(() -> this.assertConnectorAndTasksRunning(CONNECTOR_NAME + 3, NUM_TASKS).orElse(true),
                CONNECTOR_SETUP_DURATION_MS, ""Connector tasks did not start in time."");

        // delete connector
        connect.deleteConnector(CONNECTOR_NAME + 3);

        waitForCondition(() -> !this.assertConnectorAndTasksRunning(CONNECTOR_NAME + 3, NUM_TASKS).orElse(true),
                CONNECTOR_SETUP_DURATION_MS, ""Connector tasks did not stop in time."");

        waitForCondition(this::assertConnectorAndTasksAreUnique,
                WORKER_SETUP_DURATION_MS, ""Connect and tasks are imbalanced between the workers."");
    }
",non-flaky,5
70775,apache_kafka,RebalanceSourceConnectorsIntegrationTest.testAddingWorker,"    @Test
    public void testAddingWorker() throws Exception {
        // create test topic
        connect.kafka().createTopic(TOPIC_NAME, NUM_TOPIC_PARTITIONS);

        // setup up props for the source connector
        Map<String, String> props = new HashMap<>();
        props.put(CONNECTOR_CLASS_CONFIG, MonitorableSourceConnector.class.getSimpleName());
        props.put(TASKS_MAX_CONFIG, String.valueOf(NUM_TASKS));
        props.put(""throughput"", String.valueOf(1));
        props.put(""messages.per.poll"", String.valueOf(10));
        props.put(TOPIC_CONFIG, TOPIC_NAME);
        props.put(KEY_CONVERTER_CLASS_CONFIG, StringConverter.class.getName());
        props.put(VALUE_CONVERTER_CLASS_CONFIG, StringConverter.class.getName());

        waitForCondition(() -> this.assertWorkersUp(3),
                WORKER_SETUP_DURATION_MS, ""Connect workers did not start in time."");

        // start a source connector
        IntStream.range(0, 4).forEachOrdered(
            i -> {
                try {
                    connect.configureConnector(CONNECTOR_NAME + i, props);
                } catch (IOException e) {
                    throw new ConnectException(e);
                }
            });

        waitForCondition(() -> this.assertConnectorAndTasksRunning(CONNECTOR_NAME + 3, NUM_TASKS).orElse(false),
                CONNECTOR_SETUP_DURATION_MS, ""Connector tasks did not start in time."");

        connect.addWorker();

        waitForCondition(() -> this.assertWorkersUp(4),
                WORKER_SETUP_DURATION_MS, ""Connect workers did not start in time."");

        waitForCondition(() -> this.assertConnectorAndTasksRunning(CONNECTOR_NAME + 3, NUM_TASKS).orElse(false),
                CONNECTOR_SETUP_DURATION_MS, ""Connector tasks did not start in time."");

        waitForCondition(this::assertConnectorAndTasksAreUnique,
                WORKER_SETUP_DURATION_MS, ""Connect and tasks are imbalanced between the workers."");
    }
",non-flaky,5
70776,apache_kafka,RebalanceSourceConnectorsIntegrationTest.testRemovingWorker,"    @Test
    public void testRemovingWorker() throws Exception {
        // create test topic
        connect.kafka().createTopic(TOPIC_NAME, NUM_TOPIC_PARTITIONS);

        // setup up props for the source connector
        Map<String, String> props = new HashMap<>();
        props.put(CONNECTOR_CLASS_CONFIG, MonitorableSourceConnector.class.getSimpleName());
        props.put(TASKS_MAX_CONFIG, String.valueOf(NUM_TASKS));
        props.put(""throughput"", String.valueOf(1));
        props.put(""messages.per.poll"", String.valueOf(10));
        props.put(TOPIC_CONFIG, TOPIC_NAME);
        props.put(KEY_CONVERTER_CLASS_CONFIG, StringConverter.class.getName());
        props.put(VALUE_CONVERTER_CLASS_CONFIG, StringConverter.class.getName());

        waitForCondition(() -> this.assertWorkersUp(3),
                WORKER_SETUP_DURATION_MS, ""Connect workers did not start in time."");

        // start a source connector
        IntStream.range(0, 4).forEachOrdered(
            i -> {
                try {
                    connect.configureConnector(CONNECTOR_NAME + i, props);
                } catch (IOException e) {
                    throw new ConnectException(e);
                }
            });

        waitForCondition(() -> this.assertConnectorAndTasksRunning(CONNECTOR_NAME + 3, NUM_TASKS).orElse(false),
                CONNECTOR_SETUP_DURATION_MS, ""Connector tasks did not start in time."");

        connect.removeWorker();

        waitForCondition(() -> this.assertWorkersUp(2),
                WORKER_SETUP_DURATION_MS, ""Connect workers did not start in time."");

        waitForCondition(this::assertConnectorAndTasksAreUnique,
                WORKER_SETUP_DURATION_MS, ""Connect and tasks are imbalanced between the workers."");
    }
",non-flaky,5
70777,apache_kafka,SessionedProtocolIntegrationTest.ensureInternalEndpointIsSecured,"    @Test
    public void ensureInternalEndpointIsSecured() throws Throwable {
        final String connectorTasksEndpoint = connect.endpointForResource(String.format(
            ""connectors/%s/tasks"",
            CONNECTOR_NAME
        ));
        final Map<String, String> emptyHeaders = new HashMap<>();
        final Map<String, String> invalidSignatureHeaders = new HashMap<>();
        invalidSignatureHeaders.put(SIGNATURE_HEADER, ""S2Fma2Flc3F1ZQ=="");
        invalidSignatureHeaders.put(SIGNATURE_ALGORITHM_HEADER, ""HmacSHA256"");

        // We haven't created the connector yet, but this should still return a 400 instead of a 404
        // if the endpoint is secured
        log.info(
            ""Making a POST request to the {} endpoint with no connector started and no signature header; "" 
                + ""expecting 400 error response"",
            connectorTasksEndpoint
        );
        assertEquals(
            BAD_REQUEST.getStatusCode(),
            connect.executePost(connectorTasksEndpoint, ""[]"", emptyHeaders)
        );

        // Try again, but with an invalid signature
        log.info(
            ""Making a POST request to the {} endpoint with no connector started and an invalid signature header; ""
                + ""expecting 403 error response"",
            connectorTasksEndpoint
        );
        assertEquals(
            FORBIDDEN.getStatusCode(),
            connect.executePost(connectorTasksEndpoint, ""[]"", invalidSignatureHeaders)
        );

        // Create the connector now
        // setup up props for the sink connector
        Map<String, String> connectorProps = new HashMap<>();
        connectorProps.put(CONNECTOR_CLASS_CONFIG, MonitorableSinkConnector.class.getSimpleName());
        connectorProps.put(TASKS_MAX_CONFIG, String.valueOf(1));
        connectorProps.put(TOPICS_CONFIG, ""test-topic"");
        connectorProps.put(KEY_CONVERTER_CLASS_CONFIG, StringConverter.class.getName());
        connectorProps.put(VALUE_CONVERTER_CLASS_CONFIG, StringConverter.class.getName());

        // start a sink connector
        log.info(""Starting the {} connector"", CONNECTOR_NAME);
        StartAndStopLatch startLatch = connectorHandle.expectedStarts(1);
        connect.configureConnector(CONNECTOR_NAME, connectorProps);
        startLatch.await(CONNECTOR_SETUP_DURATION_MS, TimeUnit.MILLISECONDS);


        // Verify the exact same behavior, after starting the connector

        // We haven't created the connector yet, but this should still return a 400 instead of a 404
        // if the endpoint is secured
        log.info(
            ""Making a POST request to the {} endpoint with the connector started and no signature header; ""
                + ""expecting 400 error response"",
            connectorTasksEndpoint
        );
        assertEquals(
            BAD_REQUEST.getStatusCode(),
            connect.executePost(connectorTasksEndpoint, ""[]"", emptyHeaders)
        );

        // Try again, but with an invalid signature
        log.info(
            ""Making a POST request to the {} endpoint with the connector started and an invalid signature header; ""
                + ""expecting 403 error response"",
            connectorTasksEndpoint
        );
        assertEquals(
            FORBIDDEN.getStatusCode(),
            connect.executePost(connectorTasksEndpoint, ""[]"", invalidSignatureHeaders)
        );
    }
",non-flaky,5
70778,apache_kafka,ErrorHandlingIntegrationTest.testSkipRetryAndDLQWithHeaders,"    @Test
    public void testSkipRetryAndDLQWithHeaders() throws Exception {
        // create test topic
        connect.kafka().createTopic(""test-topic"");

        // setup connector config
        Map<String, String> props = new HashMap<>();
        props.put(CONNECTOR_CLASS_CONFIG, MonitorableSinkConnector.class.getSimpleName());
        props.put(TASKS_MAX_CONFIG, String.valueOf(NUM_TASKS));
        props.put(TOPICS_CONFIG, ""test-topic"");
        props.put(KEY_CONVERTER_CLASS_CONFIG, StringConverter.class.getName());
        props.put(VALUE_CONVERTER_CLASS_CONFIG, StringConverter.class.getName());
        props.put(TRANSFORMS_CONFIG, ""failing_transform"");
        props.put(""transforms.failing_transform.type"", FaultyPassthrough.class.getName());

        // log all errors, along with message metadata
        props.put(ERRORS_LOG_ENABLE_CONFIG, ""true"");
        props.put(ERRORS_LOG_INCLUDE_MESSAGES_CONFIG, ""true"");

        // produce bad messages into dead letter queue
        props.put(DLQ_TOPIC_NAME_CONFIG, DLQ_TOPIC);
        props.put(DLQ_CONTEXT_HEADERS_ENABLE_CONFIG, ""true"");
        props.put(DLQ_TOPIC_REPLICATION_FACTOR_CONFIG, ""1"");

        // tolerate all erros
        props.put(ERRORS_TOLERANCE_CONFIG, ""all"");

        // retry for up to one second
        props.put(ERRORS_RETRY_TIMEOUT_CONFIG, ""1000"");

        // set expected records to successfully reach the task
        connectorHandle.taskHandle(TASK_ID).expectedRecords(EXPECTED_CORRECT_RECORDS);

        connect.configureConnector(CONNECTOR_NAME, props);

        waitForCondition(this::checkForPartitionAssignment,
                CONNECTOR_SETUP_DURATION_MS,
                ""Connector task was not assigned a partition."");

        // produce some strings into test topic
        for (int i = 0; i < NUM_RECORDS_PRODUCED; i++) {
            connect.kafka().produce(""test-topic"", ""key-"" + i, ""value-"" + i);
        }

        // consume all records from test topic
        log.info(""Consuming records from test topic"");
        int i = 0;
        for (ConsumerRecord<byte[], byte[]> rec : connect.kafka().consume(NUM_RECORDS_PRODUCED, CONSUME_MAX_DURATION_MS, ""test-topic"")) {
            String k = new String(rec.key());
            String v = new String(rec.value());
            log.debug(""Consumed record (key='{}', value='{}') from topic {}"", k, v, rec.topic());
            assertEquals(""Unexpected key"", k, ""key-"" + i);
            assertEquals(""Unexpected value"", v, ""value-"" + i);
            i++;
        }

        // wait for records to reach the task
        connectorHandle.taskHandle(TASK_ID).awaitRecords(CONSUME_MAX_DURATION_MS);

        // consume failed records from dead letter queue topic
        log.info(""Consuming records from test topic"");
        ConsumerRecords<byte[], byte[]> messages = connect.kafka().consume(EXPECTED_INCORRECT_RECORDS, CONSUME_MAX_DURATION_MS, DLQ_TOPIC);
        for (ConsumerRecord<byte[], byte[]> recs : messages) {
            log.debug(""Consumed record (key={}, value={}) from dead letter queue topic {}"",
                    new String(recs.key()), new String(recs.value()), DLQ_TOPIC);
            assertTrue(recs.headers().toArray().length > 0);
            assertValue(""test-topic"", recs.headers(), ERROR_HEADER_ORIG_TOPIC);
            assertValue(RetriableException.class.getName(), recs.headers(), ERROR_HEADER_EXCEPTION);
            assertValue(""Error when value='value-7'"", recs.headers(), ERROR_HEADER_EXCEPTION_MESSAGE);
        }

        connect.deleteConnector(CONNECTOR_NAME);
    }
",non-flaky,5
70779,apache_kafka,ConnectorClientPolicyIntegrationTest.testCreateWithOverridesForNonePolicy,"    @Test
    public void testCreateWithOverridesForNonePolicy() throws Exception {
        Map<String, String> props = basicConnectorConfig();
        props.put(ConnectorConfig.CONNECTOR_CLIENT_CONSUMER_OVERRIDES_PREFIX + SaslConfigs.SASL_JAAS_CONFIG, ""sasl"");
        assertFailCreateConnector(""None"", props);
    }
",non-flaky,5
70780,apache_kafka,ConnectorClientPolicyIntegrationTest.testCreateWithNotAllowedOverridesForPrincipalPolicy,"    @Test
    public void testCreateWithNotAllowedOverridesForPrincipalPolicy() throws Exception {
        Map<String, String> props = basicConnectorConfig();
        props.put(ConnectorConfig.CONNECTOR_CLIENT_CONSUMER_OVERRIDES_PREFIX + SaslConfigs.SASL_JAAS_CONFIG, ""sasl"");
        props.put(ConnectorConfig.CONNECTOR_CLIENT_CONSUMER_OVERRIDES_PREFIX + ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, ""latest"");
        assertFailCreateConnector(""Principal"", props);
    }
",non-flaky,5
70781,apache_kafka,ConnectorClientPolicyIntegrationTest.testCreateWithAllowedOverridesForPrincipalPolicy,"    @Test
    public void testCreateWithAllowedOverridesForPrincipalPolicy() throws Exception {
        Map<String, String> props = basicConnectorConfig();
        props.put(ConnectorConfig.CONNECTOR_CLIENT_CONSUMER_OVERRIDES_PREFIX + CommonClientConfigs.SECURITY_PROTOCOL_CONFIG, ""PLAIN"");
        assertPassCreateConnector(""Principal"", props);
    }
",non-flaky,5
70782,apache_kafka,ConnectorClientPolicyIntegrationTest.testCreateWithAllowedOverridesForAllPolicy,"    @Test
    public void testCreateWithAllowedOverridesForAllPolicy() throws Exception {
        // setup up props for the sink connector
        Map<String, String> props = basicConnectorConfig();
        props.put(ConnectorConfig.CONNECTOR_CLIENT_CONSUMER_OVERRIDES_PREFIX + CommonClientConfigs.CLIENT_ID_CONFIG, ""test"");
        assertPassCreateConnector(""All"", props);
    }
",non-flaky,5
70783,apache_kafka,StartAndStopLatchTest.shouldReturnFalseWhenAwaitingForStartToNeverComplete,"    @Test
    public void shouldReturnFalseWhenAwaitingForStartToNeverComplete() throws Throwable {
        latch = new StartAndStopLatch(1, 1, this::complete, dependents, clock);
        future = asyncAwait(100);
        clock.sleep(10);
        assertFalse(future.get(200, TimeUnit.MILLISECONDS));
        assertTrue(future.isDone());
    }
",non-flaky,5
70784,apache_kafka,StartAndStopLatchTest.shouldReturnFalseWhenAwaitingForStopToNeverComplete,"    @Test
    public void shouldReturnFalseWhenAwaitingForStopToNeverComplete() throws Throwable {
        latch = new StartAndStopLatch(1, 1, this::complete, dependents, clock);
        future = asyncAwait(100);
        latch.recordStart();
        clock.sleep(10);
        assertFalse(future.get(200, TimeUnit.MILLISECONDS));
        assertTrue(future.isDone());
    }
",non-flaky,5
70785,apache_kafka,StartAndStopLatchTest.shouldReturnTrueWhenAwaitingForStartAndStopToComplete,"    @Test
    public void shouldReturnTrueWhenAwaitingForStartAndStopToComplete() throws Throwable {
        latch = new StartAndStopLatch(1, 1, this::complete, dependents, clock);
        future = asyncAwait(100);
        latch.recordStart();
        latch.recordStop();
        clock.sleep(10);
        assertTrue(future.get(200, TimeUnit.MILLISECONDS));
        assertTrue(future.isDone());
    }
",non-flaky,5
70786,apache_kafka,StartAndStopLatchTest.shouldReturnFalseWhenAwaitingForDependentLatchToComplete,"    @Test
    public void shouldReturnFalseWhenAwaitingForDependentLatchToComplete() throws Throwable {
        StartAndStopLatch depLatch = new StartAndStopLatch(1, 1, this::complete, null, clock);
        dependents = Collections.singletonList(depLatch);
        latch = new StartAndStopLatch(1, 1, this::complete, dependents, clock);

        future = asyncAwait(100);
        latch.recordStart();
        latch.recordStop();
        clock.sleep(10);
        assertFalse(future.get(200, TimeUnit.MILLISECONDS));
        assertTrue(future.isDone());
    }
",non-flaky,5
70787,apache_kafka,StartAndStopLatchTest.shouldReturnTrueWhenAwaitingForStartAndStopAndDependentLatch,"    @Test
    public void shouldReturnTrueWhenAwaitingForStartAndStopAndDependentLatch() throws Throwable {
        StartAndStopLatch depLatch = new StartAndStopLatch(1, 1, this::complete, null, clock);
        dependents = Collections.singletonList(depLatch);
        latch = new StartAndStopLatch(1, 1, this::complete, dependents, clock);

        future = asyncAwait(100);
        latch.recordStart();
        latch.recordStop();
        depLatch.recordStart();
        depLatch.recordStop();
        clock.sleep(10);
        assertTrue(future.get(200, TimeUnit.MILLISECONDS));
        assertTrue(future.isDone());
    }
",non-flaky,5
70788,apache_kafka,ExampleConnectIntegrationTest.testSinkConnector,"    @Test
    public void testSinkConnector() throws Exception {
        // create test topic
        connect.kafka().createTopic(""test-topic"", NUM_TOPIC_PARTITIONS);

        // setup up props for the sink connector
        Map<String, String> props = new HashMap<>();
        props.put(CONNECTOR_CLASS_CONFIG, MonitorableSinkConnector.class.getSimpleName());
        props.put(TASKS_MAX_CONFIG, String.valueOf(NUM_TASKS));
        props.put(TOPICS_CONFIG, ""test-topic"");
        props.put(KEY_CONVERTER_CLASS_CONFIG, StringConverter.class.getName());
        props.put(VALUE_CONVERTER_CLASS_CONFIG, StringConverter.class.getName());

        // expect all records to be consumed by the connector
        connectorHandle.expectedRecords(NUM_RECORDS_PRODUCED);

        // expect all records to be consumed by the connector
        connectorHandle.expectedCommits(NUM_RECORDS_PRODUCED);

        // start a sink connector
        connect.configureConnector(CONNECTOR_NAME, props);

        waitForCondition(this::checkForPartitionAssignment,
                CONNECTOR_SETUP_DURATION_MS,
                ""Connector tasks were not assigned a partition each."");

        // produce some messages into source topic partitions
        for (int i = 0; i < NUM_RECORDS_PRODUCED; i++) {
            connect.kafka().produce(""test-topic"", i % NUM_TOPIC_PARTITIONS, ""key"", ""simple-message-value-"" + i);
        }

        // consume all records from the source topic or fail, to ensure that they were correctly produced.
        assertEquals(""Unexpected number of records consumed"", NUM_RECORDS_PRODUCED,
                connect.kafka().consume(NUM_RECORDS_PRODUCED, RECORD_TRANSFER_DURATION_MS, ""test-topic"").count());

        // wait for the connector tasks to consume all records.
        connectorHandle.awaitRecords(RECORD_TRANSFER_DURATION_MS);

        // wait for the connector tasks to commit all records.
        connectorHandle.awaitCommits(RECORD_TRANSFER_DURATION_MS);

        // delete connector
        connect.deleteConnector(CONNECTOR_NAME);
    }
",non-flaky,5
70789,apache_kafka,ExampleConnectIntegrationTest.testSourceConnector,"    @Test
    public void testSourceConnector() throws Exception {
        // create test topic
        connect.kafka().createTopic(""test-topic"", NUM_TOPIC_PARTITIONS);

        // setup up props for the sink connector
        Map<String, String> props = new HashMap<>();
        props.put(CONNECTOR_CLASS_CONFIG, MonitorableSourceConnector.class.getSimpleName());
        props.put(TASKS_MAX_CONFIG, String.valueOf(NUM_TASKS));
        props.put(""topic"", ""test-topic"");
        props.put(""throughput"", String.valueOf(500));
        props.put(KEY_CONVERTER_CLASS_CONFIG, StringConverter.class.getName());
        props.put(VALUE_CONVERTER_CLASS_CONFIG, StringConverter.class.getName());

        // expect all records to be produced by the connector
        connectorHandle.expectedRecords(NUM_RECORDS_PRODUCED);

        // expect all records to be produced by the connector
        connectorHandle.expectedCommits(NUM_RECORDS_PRODUCED);

        // start a source connector
        connect.configureConnector(CONNECTOR_NAME, props);

        // wait for the connector tasks to produce enough records
        connectorHandle.awaitRecords(RECORD_TRANSFER_DURATION_MS);

        // wait for the connector tasks to commit enough records
        connectorHandle.awaitCommits(RECORD_TRANSFER_DURATION_MS);

        // consume all records from the source topic or fail, to ensure that they were correctly produced
        int recordNum = connect.kafka().consume(NUM_RECORDS_PRODUCED, RECORD_TRANSFER_DURATION_MS, ""test-topic"").count();
        assertTrue(""Not enough records produced by source connector. Expected at least: "" + NUM_RECORDS_PRODUCED + "" + but got "" + recordNum,
                recordNum >= NUM_RECORDS_PRODUCED);

        // delete connector
        connect.deleteConnector(CONNECTOR_NAME);
    }
",non-flaky,5
70790,apache_kafka,RestExtensionIntegrationTest.testRestExtensionApi,"    @Test
    public void testRestExtensionApi() throws IOException, InterruptedException {
        // setup Connect worker properties
        Map<String, String> workerProps = new HashMap<>();
        workerProps.put(REST_EXTENSION_CLASSES_CONFIG, IntegrationTestRestExtension.class.getName());

        // build a Connect cluster backed by Kafka and Zk
        connect = new EmbeddedConnectCluster.Builder()
            .name(""connect-cluster"")
            .numWorkers(1)
            .numBrokers(1)
            .workerProps(workerProps)
            .build();

        // start the clusters
        connect.start();

        WorkerHandle worker = connect.workers().stream()
            .findFirst()
            .orElseThrow(() -> new AssertionError(""At least one worker handle should be available""));

        waitForCondition(
            this::extensionIsRegistered,
            REST_EXTENSION_REGISTRATION_TIMEOUT_MS,
            ""REST extension was never registered""
        );

        ConnectorHandle connectorHandle = RuntimeHandles.get().connectorHandle(""test-conn"");
        try {
            // setup up props for the connector
            Map<String, String> connectorProps = new HashMap<>();
            connectorProps.put(CONNECTOR_CLASS_CONFIG, MonitorableSinkConnector.class.getSimpleName());
            connectorProps.put(TASKS_MAX_CONFIG, String.valueOf(1));
            connectorProps.put(TOPICS_CONFIG, ""test-topic"");

            // start a connector
            connectorHandle.taskHandle(connectorHandle.name() + ""-0"");
            StartAndStopLatch connectorStartLatch = connectorHandle.expectedStarts(1);
            connect.configureConnector(connectorHandle.name(), connectorProps);
            connectorStartLatch.await(CONNECTOR_HEALTH_AND_CONFIG_TIMEOUT_MS, TimeUnit.MILLISECONDS);

            String workerId = String.format(""%s:%d"", worker.url().getHost(), worker.url().getPort());
            ConnectorHealth expectedHealth = new ConnectorHealth(
                connectorHandle.name(),
                new ConnectorState(
                    ""RUNNING"",
                    workerId,
                    null
                ),
                Collections.singletonMap(
                    0,
                    new TaskState(0, ""RUNNING"", workerId, null)
                ),
                ConnectorType.SINK
            );

            connectorProps.put(NAME_CONFIG, connectorHandle.name());

            // Test the REST extension API; specifically, that the connector's health and configuration
            // are available to the REST extension we registered and that they contain expected values
            waitForCondition(
                () -> verifyConnectorHealthAndConfig(connectorHandle.name(), expectedHealth, connectorProps),
                CONNECTOR_HEALTH_AND_CONFIG_TIMEOUT_MS,
                ""Connector health and/or config was never accessible by the REST extension""
            );
        } finally {
            RuntimeHandles.get().deleteConnector(connectorHandle.name());
        }
    }
",non-flaky,5
70791,apache_kafka,DelegatingClassLoaderTest.testWhiteListedManifestResources,"    @Test
    public void testWhiteListedManifestResources() {
        assertTrue(
            DelegatingClassLoader.serviceLoaderManifestForPlugin(""META-INF/services/org.apache.kafka.connect.rest.ConnectRestExtension""));
        assertTrue(
            DelegatingClassLoader.serviceLoaderManifestForPlugin(""META-INF/services/org.apache.kafka.common.config.provider.ConfigProvider""));
    }
",non-flaky,5
70792,apache_kafka,DelegatingClassLoaderTest.testOtherResources,"    @Test
    public void testOtherResources() {
        assertFalse(
            DelegatingClassLoader.serviceLoaderManifestForPlugin(""META-INF/services/org.apache.kafka.connect.transforms.Transformation""));
        assertFalse(DelegatingClassLoader.serviceLoaderManifestForPlugin(""resource/version.properties""));
    }
",non-flaky,5
70793,apache_kafka,DelegatingClassLoaderTest.testLoadingUnloadedPluginClass,"    @Test(expected = ClassNotFoundException.class)
    public void testLoadingUnloadedPluginClass() throws ClassNotFoundException {
        TestPlugins.assertAvailable();
        DelegatingClassLoader classLoader = new DelegatingClassLoader(Collections.emptyList());
        classLoader.initLoaders();
        for (String pluginClassName : TestPlugins.pluginClasses()) {
            classLoader.loadClass(pluginClassName);
        }
    }
",non-flaky,5
70794,apache_kafka,DelegatingClassLoaderTest.testLoadingPluginClass,"    @Test
    public void testLoadingPluginClass() throws ClassNotFoundException {
        TestPlugins.assertAvailable();
        DelegatingClassLoader classLoader = new DelegatingClassLoader(TestPlugins.pluginPath());
        classLoader.initLoaders();
        for (String pluginClassName : TestPlugins.pluginClasses()) {
            assertNotNull(classLoader.loadClass(pluginClassName));
            assertNotNull(classLoader.pluginClassLoader(pluginClassName));
        }
    }
",non-flaky,5
70795,apache_kafka,PluginUtilsTest.testJavaLibraryClasses,"    @Test
    public void testJavaLibraryClasses() {
        assertFalse(PluginUtils.shouldLoadInIsolation(""java.""));
        assertFalse(PluginUtils.shouldLoadInIsolation(""java.lang.Object""));
        assertFalse(PluginUtils.shouldLoadInIsolation(""java.lang.String""));
        assertFalse(PluginUtils.shouldLoadInIsolation(""java.util.HashMap$Entry""));
        assertFalse(PluginUtils.shouldLoadInIsolation(""java.io.Serializable""));
        assertFalse(PluginUtils.shouldLoadInIsolation(""javax.rmi.""));
        assertFalse(PluginUtils.shouldLoadInIsolation(
                ""javax.management.loading.ClassLoaderRepository"")
        );
        assertFalse(PluginUtils.shouldLoadInIsolation(""org.omg.CORBA.""));
        assertFalse(PluginUtils.shouldLoadInIsolation(""org.omg.CORBA.Object""));
        assertFalse(PluginUtils.shouldLoadInIsolation(""org.w3c.dom.""));
        assertFalse(PluginUtils.shouldLoadInIsolation(""org.w3c.dom.traversal.TreeWalker""));
        assertFalse(PluginUtils.shouldLoadInIsolation(""org.xml.sax.""));
        assertFalse(PluginUtils.shouldLoadInIsolation(""org.xml.sax.EntityResolver""));
    }
",non-flaky,5
70796,apache_kafka,PluginUtilsTest.testThirdPartyClasses,"    @Test
    public void testThirdPartyClasses() {
        assertFalse(PluginUtils.shouldLoadInIsolation(""org.slf4j.""));
        assertFalse(PluginUtils.shouldLoadInIsolation(""org.slf4j.LoggerFactory""));
    }
",non-flaky,5
70797,apache_kafka,PluginUtilsTest.testConnectFrameworkClasses,"    @Test
    public void testConnectFrameworkClasses() {
        assertFalse(PluginUtils.shouldLoadInIsolation(""org.apache.kafka.common.""));
        assertFalse(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.common.config.AbstractConfig"")
        );
        assertFalse(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.common.config.ConfigDef$Type"")
        );
        assertFalse(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.common.serialization.Deserializer"")
        );
        assertFalse(PluginUtils.shouldLoadInIsolation(""org.apache.kafka.connect.""));
        assertFalse(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.connector.Connector"")
        );
        assertFalse(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.source.SourceConnector"")
        );
        assertFalse(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.sink.SinkConnector"")
        );
        assertFalse(PluginUtils.shouldLoadInIsolation(""org.apache.kafka.connect.connector.Task""));
        assertFalse(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.source.SourceTask"")
        );
        assertFalse(PluginUtils.shouldLoadInIsolation(""org.apache.kafka.connect.sink.SinkTask""));
        assertFalse(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.transforms.Transformation"")
        );
        assertFalse(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.storage.Converter"")
        );
        assertFalse(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.storage.OffsetBackingStore"")
        );
        assertFalse(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.clients.producer.ProducerConfig"")
        );
        assertFalse(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.clients.consumer.ConsumerConfig"")
        );
        assertFalse(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.clients.admin.KafkaAdminClient"")
        );
        assertFalse(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.rest.ConnectRestExtension"")
        );
    }
",non-flaky,5
70798,apache_kafka,PluginUtilsTest.testAllowedConnectFrameworkClasses,"    @Test
    public void testAllowedConnectFrameworkClasses() {
        assertTrue(PluginUtils.shouldLoadInIsolation(""org.apache.kafka.connect.transforms.""));
        assertTrue(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.transforms.ExtractField"")
        );
        assertTrue(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.transforms.ExtractField$Key"")
        );
        assertTrue(PluginUtils.shouldLoadInIsolation(""org.apache.kafka.connect.json.""));
        assertTrue(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.json.JsonConverter"")
        );
        assertTrue(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.json.JsonConverter$21"")
        );
        assertTrue(PluginUtils.shouldLoadInIsolation(""org.apache.kafka.connect.file.""));
        assertTrue(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.file.FileStreamSourceTask"")
        );
        assertTrue(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.file.FileStreamSinkConnector"")
        );
        assertTrue(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.mirror.MirrorSourceTask"")
        );
        assertTrue(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.mirror.MirrorSourceConnector"")
        );
        assertTrue(PluginUtils.shouldLoadInIsolation(""org.apache.kafka.connect.converters.""));
        assertTrue(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.converters.ByteArrayConverter"")
        );
        assertTrue(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.converters.DoubleConverter"")
        );
        assertTrue(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.converters.FloatConverter"")
        );
        assertTrue(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.converters.IntegerConverter"")
        );
        assertTrue(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.converters.LongConverter"")
        );
        assertTrue(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.converters.ShortConverter"")
        );
        assertTrue(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.storage.StringConverter"")
        );
        assertTrue(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.storage.SimpleHeaderConverter"")
        );
        assertTrue(PluginUtils.shouldLoadInIsolation(
            ""org.apache.kafka.connect.rest.basic.auth.extension.BasicAuthSecurityRestExtension""
        ));
    }
",non-flaky,5
70799,apache_kafka,PluginUtilsTest.testClientConfigProvider,"    @Test
    public void testClientConfigProvider() {
        assertFalse(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.common.config.provider.ConfigProvider"")
        );
        assertTrue(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.common.config.provider.FileConfigProvider"")
        );
        assertTrue(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.common.config.provider.FutureConfigProvider"")
        );
    }
",non-flaky,5
70800,apache_kafka,PluginUtilsTest.testConnectorClientConfigOverridePolicy,"    @Test
    public void testConnectorClientConfigOverridePolicy() {
        assertFalse(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.connector.policy.ConnectorClientConfigOverridePolicy"")
        );
        assertTrue(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.connector.policy.AbstractConnectorClientConfigOverridePolicy"")
        );
        assertTrue(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.connector.policy.AllConnectorClientConfigOverridePolicy"")
        );
        assertTrue(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.connector.policy.NoneConnectorClientConfigOverridePolicy"")
        );
        assertTrue(PluginUtils.shouldLoadInIsolation(
                ""org.apache.kafka.connect.connector.policy.PrincipalConnectorClientConfigOverridePolicy"")
        );
    }
",non-flaky,5
70801,apache_kafka,PluginUtilsTest.testEmptyPluginUrls,"    @Test
    public void testEmptyPluginUrls() throws Exception {
        assertEquals(Collections.<Path>emptyList(), PluginUtils.pluginUrls(pluginPath));
    }
",non-flaky,5
70802,apache_kafka,PluginUtilsTest.testEmptyStructurePluginUrls,"    @Test
    public void testEmptyStructurePluginUrls() throws Exception {
        createBasicDirectoryLayout();
        assertEquals(Collections.<Path>emptyList(), PluginUtils.pluginUrls(pluginPath));
    }
",non-flaky,5
70803,apache_kafka,PluginUtilsTest.testPluginUrlsWithJars,"    @Test
    public void testPluginUrlsWithJars() throws Exception {
        createBasicDirectoryLayout();

        List<Path> expectedUrls = createBasicExpectedUrls();

        assertUrls(expectedUrls, PluginUtils.pluginUrls(pluginPath));
    }
",non-flaky,5
70804,apache_kafka,PluginUtilsTest.testOrderOfPluginUrlsWithJars,"    @Test
    public void testOrderOfPluginUrlsWithJars() throws Exception {
        createBasicDirectoryLayout();
        // Here this method is just used to create the files. The result is not used.
        createBasicExpectedUrls();

        List<Path> actual = PluginUtils.pluginUrls(pluginPath);
        // 'simple-transform.jar' is created first. In many cases, without sorting within the
        // PluginUtils, this jar will be placed before 'another-transform.jar'. However this is
        // not guaranteed because a DirectoryStream does not maintain a certain order in its
        // results. Besides this test case, sorted order in every call to assertUrls below.
        int i = Arrays.toString(actual.toArray()).indexOf(""another-transform.jar"");
        int j = Arrays.toString(actual.toArray()).indexOf(""simple-transform.jar"");
        assertTrue(i < j);
    }
",non-flaky,5
70805,apache_kafka,PluginUtilsTest.testPluginUrlsWithZips,"    @Test
    public void testPluginUrlsWithZips() throws Exception {
        createBasicDirectoryLayout();

        List<Path> expectedUrls = new ArrayList<>();
        expectedUrls.add(Files.createFile(pluginPath.resolve(""connectorA/my-sink.zip"")));
        expectedUrls.add(Files.createFile(pluginPath.resolve(""connectorB/a-source.zip"")));
        expectedUrls.add(Files.createFile(pluginPath.resolve(""transformC/simple-transform.zip"")));
        expectedUrls.add(Files.createFile(
                pluginPath.resolve(""transformC/deps/another-transform.zip""))
        );

        assertUrls(expectedUrls, PluginUtils.pluginUrls(pluginPath));
    }
",non-flaky,5
70806,apache_kafka,PluginUtilsTest.testPluginUrlsWithClasses,"    @Test
    public void testPluginUrlsWithClasses() throws Exception {
        Files.createDirectories(pluginPath.resolve(""org/apache/kafka/converters""));
        Files.createDirectories(pluginPath.resolve(""com/mycompany/transforms""));
        Files.createDirectories(pluginPath.resolve(""edu/research/connectors""));
        Files.createFile(pluginPath.resolve(""org/apache/kafka/converters/README.txt""));
        Files.createFile(pluginPath.resolve(""org/apache/kafka/converters/AlienFormat.class""));
        Files.createDirectories(pluginPath.resolve(""com/mycompany/transforms/Blackhole.class""));
        Files.createDirectories(pluginPath.resolve(""edu/research/connectors/HalSink.class""));

        List<Path> expectedUrls = new ArrayList<>();
        expectedUrls.add(pluginPath);

        assertUrls(expectedUrls, PluginUtils.pluginUrls(pluginPath));
    }
",non-flaky,5
70807,apache_kafka,PluginUtilsTest.testPluginUrlsWithAbsoluteSymlink,"    @Test
    public void testPluginUrlsWithAbsoluteSymlink() throws Exception {
        createBasicDirectoryLayout();

        Path anotherPath = rootDir.newFolder(""moreplugins"").toPath().toRealPath();
        Files.createDirectories(anotherPath.resolve(""connectorB-deps""));
        Files.createSymbolicLink(
                pluginPath.resolve(""connectorB/deps/symlink""),
                anotherPath.resolve(""connectorB-deps"")
        );

        List<Path> expectedUrls = createBasicExpectedUrls();
        expectedUrls.add(Files.createFile(anotherPath.resolve(""connectorB-deps/converter.jar"")));

        assertUrls(expectedUrls, PluginUtils.pluginUrls(pluginPath));
    }
",non-flaky,5
70808,apache_kafka,PluginUtilsTest.testPluginUrlsWithRelativeSymlinkBackwards,"    @Test
    public void testPluginUrlsWithRelativeSymlinkBackwards() throws Exception {
        createBasicDirectoryLayout();

        Path anotherPath = rootDir.newFolder(""moreplugins"").toPath().toRealPath();
        Files.createDirectories(anotherPath.resolve(""connectorB-deps""));
        Files.createSymbolicLink(
                pluginPath.resolve(""connectorB/deps/symlink""),
                Paths.get(""../../../moreplugins/connectorB-deps"")
        );

        List<Path> expectedUrls = createBasicExpectedUrls();
        expectedUrls.add(Files.createFile(anotherPath.resolve(""connectorB-deps/converter.jar"")));

        assertUrls(expectedUrls, PluginUtils.pluginUrls(pluginPath));
    }
",non-flaky,5
70809,apache_kafka,PluginUtilsTest.testPluginUrlsWithRelativeSymlinkForwards,"    @Test
    public void testPluginUrlsWithRelativeSymlinkForwards() throws Exception {
        // Since this test case defines a relative symlink within an already included path, the main
        // assertion of this test is absence of exceptions and correct resolution of paths.
        createBasicDirectoryLayout();
        Files.createDirectories(pluginPath.resolve(""connectorB/deps/more""));
        Files.createSymbolicLink(
                pluginPath.resolve(""connectorB/deps/symlink""),
                Paths.get(""more"")
        );

        List<Path> expectedUrls = createBasicExpectedUrls();
        expectedUrls.add(
                Files.createFile(pluginPath.resolve(""connectorB/deps/more/converter.jar""))
        );

        assertUrls(expectedUrls, PluginUtils.pluginUrls(pluginPath));
    }
",non-flaky,5
70810,apache_kafka,PluginsTest.shouldInstantiateAndConfigureConverters,"    @Test
    public void shouldInstantiateAndConfigureConverters() {
        instantiateAndConfigureConverter(WorkerConfig.KEY_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.CURRENT_CLASSLOADER);
        // Validate extra configs got passed through to overridden converters
        assertEquals(""true"", converter.configs.get(JsonConverterConfig.SCHEMAS_ENABLE_CONFIG));
        assertEquals(""foo1"", converter.configs.get(""extra.config""));

        instantiateAndConfigureConverter(WorkerConfig.VALUE_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.PLUGINS);
        // Validate extra configs got passed through to overridden converters
        assertEquals(""true"", converter.configs.get(JsonConverterConfig.SCHEMAS_ENABLE_CONFIG));
        assertEquals(""foo2"", converter.configs.get(""extra.config""));
    }
",non-flaky,5
70811,apache_kafka,PluginsTest.shouldInstantiateAndConfigureInternalConverters,"    @Test
    public void shouldInstantiateAndConfigureInternalConverters() {
        instantiateAndConfigureInternalConverter(WorkerConfig.INTERNAL_KEY_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.CURRENT_CLASSLOADER);
        // Validate schemas.enable is defaulted to false for internal converter
        assertEquals(false, internalConverter.configs.get(JsonConverterConfig.SCHEMAS_ENABLE_CONFIG));
        // Validate internal converter properties can still be set
        assertEquals(""bar1"", internalConverter.configs.get(""extra.config""));

        instantiateAndConfigureInternalConverter(WorkerConfig.INTERNAL_VALUE_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.PLUGINS);
        // Validate schemas.enable is defaulted to false for internal converter
        assertEquals(false, internalConverter.configs.get(JsonConverterConfig.SCHEMAS_ENABLE_CONFIG));
        // Validate internal converter properties can still be set
        assertEquals(""bar2"", internalConverter.configs.get(""extra.config""));
    }
",non-flaky,5
70812,apache_kafka,PluginsTest.shouldInstantiateAndConfigureExplicitlySetHeaderConverterWithCurrentClassLoader,"    @Test
    public void shouldInstantiateAndConfigureExplicitlySetHeaderConverterWithCurrentClassLoader() {
        assertNotNull(props.get(WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG));
        HeaderConverter headerConverter = plugins.newHeaderConverter(config,
                                                                     WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG,
                                                                     ClassLoaderUsage.CURRENT_CLASSLOADER);
        assertNotNull(headerConverter);
        assertTrue(headerConverter instanceof TestHeaderConverter);
        this.headerConverter = (TestHeaderConverter) headerConverter;

        // Validate extra configs got passed through to overridden converters
        assertConverterType(ConverterType.HEADER, this.headerConverter.configs);
        assertEquals(""baz"", this.headerConverter.configs.get(""extra.config""));

        headerConverter = plugins.newHeaderConverter(config,
                                                     WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG,
                                                     ClassLoaderUsage.PLUGINS);
        assertNotNull(headerConverter);
        assertTrue(headerConverter instanceof TestHeaderConverter);
        this.headerConverter = (TestHeaderConverter) headerConverter;

        // Validate extra configs got passed through to overridden converters
        assertConverterType(ConverterType.HEADER, this.headerConverter.configs);
        assertEquals(""baz"", this.headerConverter.configs.get(""extra.config""));
    }
",non-flaky,5
70813,apache_kafka,PluginsTest.shouldInstantiateAndConfigureConnectRestExtension,"    @Test
    public void shouldInstantiateAndConfigureConnectRestExtension() {
        props.put(WorkerConfig.REST_EXTENSION_CLASSES_CONFIG,
                  TestConnectRestExtension.class.getName());
        createConfig();

        List<ConnectRestExtension> connectRestExtensions =
            plugins.newPlugins(config.getList(WorkerConfig.REST_EXTENSION_CLASSES_CONFIG),
                               config,
                               ConnectRestExtension.class);
        assertNotNull(connectRestExtensions);
        assertEquals(""One Rest Extension expected"", 1, connectRestExtensions.size());
        assertNotNull(connectRestExtensions.get(0));
        assertTrue(""Should be instance of TestConnectRestExtension"",
                   connectRestExtensions.get(0) instanceof TestConnectRestExtension);
        assertNotNull(((TestConnectRestExtension) connectRestExtensions.get(0)).configs);
        assertEquals(config.originals(),
                     ((TestConnectRestExtension) connectRestExtensions.get(0)).configs);
    }
",non-flaky,5
70814,apache_kafka,PluginsTest.shouldInstantiateAndConfigureDefaultHeaderConverter,"    @Test
    public void shouldInstantiateAndConfigureDefaultHeaderConverter() {
        props.remove(WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG);
        createConfig();

        // Because it's not explicitly set on the supplied configuration, the logic to use the current classloader for the connector
        // will exit immediately, and so this method always returns null
        HeaderConverter headerConverter = plugins.newHeaderConverter(config,
                                                                     WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG,
                                                                     ClassLoaderUsage.CURRENT_CLASSLOADER);
        assertNull(headerConverter);
        // But we should always find it (or the worker's default) when using the plugins classloader ...
        headerConverter = plugins.newHeaderConverter(config,
                                                     WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG,
                                                     ClassLoaderUsage.PLUGINS);
        assertNotNull(headerConverter);
        assertTrue(headerConverter instanceof SimpleHeaderConverter);
    }
",non-flaky,5
70815,apache_kafka,PluginsTest.shouldThrowIfPluginThrows,"    @Test(expected = ConnectException.class)
    public void shouldThrowIfPluginThrows() {
        TestPlugins.assertAvailable();

        plugins.newPlugin(
            TestPlugins.ALWAYS_THROW_EXCEPTION,
            new AbstractConfig(new ConfigDef(), Collections.emptyMap()),
            Converter.class
        );
    }
",non-flaky,5
70816,apache_kafka,PluginsTest.shouldShareStaticValuesBetweenSamePlugin,"    @Test
    public void shouldShareStaticValuesBetweenSamePlugin() {
        // Plugins are not isolated from other instances of their own class.
        TestPlugins.assertAvailable();
        Converter firstPlugin = plugins.newPlugin(
            TestPlugins.ALIASED_STATIC_FIELD,
            new AbstractConfig(new ConfigDef(), Collections.emptyMap()),
            Converter.class
        );

        assertInstanceOf(SamplingTestPlugin.class, firstPlugin, ""Cannot collect samples"");

        Converter secondPlugin = plugins.newPlugin(
            TestPlugins.ALIASED_STATIC_FIELD,
            new AbstractConfig(new ConfigDef(), Collections.emptyMap()),
            Converter.class
        );

        assertInstanceOf(SamplingTestPlugin.class, secondPlugin, ""Cannot collect samples"");
        assertSame(
            ((SamplingTestPlugin) firstPlugin).otherSamples(),
            ((SamplingTestPlugin) secondPlugin).otherSamples()
        );
    }
",non-flaky,5
70817,apache_kafka,PluginsTest.newPluginShouldServiceLoadWithPluginClassLoader,"    @Test
    public void newPluginShouldServiceLoadWithPluginClassLoader() {
        TestPlugins.assertAvailable();
        Converter plugin = plugins.newPlugin(
            TestPlugins.SERVICE_LOADER,
            new AbstractConfig(new ConfigDef(), Collections.emptyMap()),
            Converter.class
        );

        assertInstanceOf(SamplingTestPlugin.class, plugin, ""Cannot collect samples"");
        Map<String, SamplingTestPlugin> samples = ((SamplingTestPlugin) plugin).flatten();
        // Assert that the service loaded subclass is found in both environments
        assertTrue(samples.containsKey(""ServiceLoadedSubclass.static""));
        assertTrue(samples.containsKey(""ServiceLoadedSubclass.dynamic""));
        assertPluginClassLoaderAlwaysActive(samples);
    }
",non-flaky,5
70818,apache_kafka,PluginsTest.newPluginShouldInstantiateWithPluginClassLoader,"    @Test
    public void newPluginShouldInstantiateWithPluginClassLoader() {
        TestPlugins.assertAvailable();
        Converter plugin = plugins.newPlugin(
            TestPlugins.ALIASED_STATIC_FIELD,
            new AbstractConfig(new ConfigDef(), Collections.emptyMap()),
            Converter.class
        );

        assertInstanceOf(SamplingTestPlugin.class, plugin, ""Cannot collect samples"");
        Map<String, SamplingTestPlugin> samples = ((SamplingTestPlugin) plugin).flatten();
        assertPluginClassLoaderAlwaysActive(samples);
    }
",non-flaky,5
70819,apache_kafka,PluginsTest.shouldFailToFindConverterInCurrentClassloader,"    @Test(expected = ConfigException.class)
    public void shouldFailToFindConverterInCurrentClassloader() {
        TestPlugins.assertAvailable();
        props.put(WorkerConfig.KEY_CONVERTER_CLASS_CONFIG, TestPlugins.SAMPLING_CONVERTER);
        createConfig();
    }
",non-flaky,5
70820,apache_kafka,PluginsTest.newConverterShouldConfigureWithPluginClassLoader,"    @Test
    public void newConverterShouldConfigureWithPluginClassLoader() {
        TestPlugins.assertAvailable();
        props.put(WorkerConfig.KEY_CONVERTER_CLASS_CONFIG, TestPlugins.SAMPLING_CONVERTER);
        ClassLoader classLoader = plugins.delegatingLoader().pluginClassLoader(TestPlugins.SAMPLING_CONVERTER);
        ClassLoader savedLoader = Plugins.compareAndSwapLoaders(classLoader);
        createConfig();
        Plugins.compareAndSwapLoaders(savedLoader);

        Converter plugin = plugins.newConverter(
            config,
            WorkerConfig.KEY_CONVERTER_CLASS_CONFIG,
            ClassLoaderUsage.PLUGINS
        );

        assertInstanceOf(SamplingTestPlugin.class, plugin, ""Cannot collect samples"");
        Map<String, SamplingTestPlugin> samples = ((SamplingTestPlugin) plugin).flatten();
        assertTrue(samples.containsKey(""configure""));
        assertPluginClassLoaderAlwaysActive(samples);
    }
",non-flaky,5
70821,apache_kafka,PluginsTest.newConfigProviderShouldConfigureWithPluginClassLoader,"    @Test
    public void newConfigProviderShouldConfigureWithPluginClassLoader() {
        TestPlugins.assertAvailable();
        String providerPrefix = ""some.provider"";
        props.put(providerPrefix + "".class"", TestPlugins.SAMPLING_CONFIG_PROVIDER);

        PluginClassLoader classLoader = plugins.delegatingLoader().pluginClassLoader(TestPlugins.SAMPLING_CONFIG_PROVIDER);
        assertNotNull(classLoader);
        ClassLoader savedLoader = Plugins.compareAndSwapLoaders(classLoader);
        createConfig();
        Plugins.compareAndSwapLoaders(savedLoader);

        ConfigProvider plugin = plugins.newConfigProvider(
            config,
            providerPrefix,
            ClassLoaderUsage.PLUGINS
        );

        assertInstanceOf(SamplingTestPlugin.class, plugin, ""Cannot collect samples"");
        Map<String, SamplingTestPlugin> samples = ((SamplingTestPlugin) plugin).flatten();
        assertTrue(samples.containsKey(""configure""));
        assertPluginClassLoaderAlwaysActive(samples);
    }
",non-flaky,5
70822,apache_kafka,PluginsTest.newHeaderConverterShouldConfigureWithPluginClassLoader,"    @Test
    public void newHeaderConverterShouldConfigureWithPluginClassLoader() {
        TestPlugins.assertAvailable();
        props.put(WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, TestPlugins.SAMPLING_HEADER_CONVERTER);
        ClassLoader classLoader = plugins.delegatingLoader().pluginClassLoader(TestPlugins.SAMPLING_HEADER_CONVERTER);
        ClassLoader savedLoader = Plugins.compareAndSwapLoaders(classLoader);
        createConfig();
        Plugins.compareAndSwapLoaders(savedLoader);

        HeaderConverter plugin = plugins.newHeaderConverter(
            config,
            WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG,
            ClassLoaderUsage.PLUGINS
        );

        assertInstanceOf(SamplingTestPlugin.class, plugin, ""Cannot collect samples"");
        Map<String, SamplingTestPlugin> samples = ((SamplingTestPlugin) plugin).flatten();
        assertTrue(samples.containsKey(""configure"")); // HeaderConverter::configure was called
        assertPluginClassLoaderAlwaysActive(samples);
    }
",non-flaky,5
70823,apache_kafka,PluginsTest.newPluginsShouldConfigureWithPluginClassLoader,"    @Test
    public void newPluginsShouldConfigureWithPluginClassLoader() {
        TestPlugins.assertAvailable();
        List<Configurable> configurables = plugins.newPlugins(
            Collections.singletonList(TestPlugins.SAMPLING_CONFIGURABLE),
            config,
            Configurable.class
        );
        assertEquals(1, configurables.size());
        Configurable plugin = configurables.get(0);

        assertInstanceOf(SamplingTestPlugin.class, plugin, ""Cannot collect samples"");
        Map<String, SamplingTestPlugin> samples = ((SamplingTestPlugin) plugin).flatten();
        assertTrue(samples.containsKey(""configure"")); // Configurable::configure was called
        assertPluginClassLoaderAlwaysActive(samples);
    }
",non-flaky,5
70824,apache_kafka,PluginDescTest.testRegularPluginDesc,"    @Test
    public void testRegularPluginDesc() {
        PluginDesc<Connector> connectorDesc = new PluginDesc<>(
                Connector.class,
                regularVersion,
                pluginLoader
        );

        assertPluginDesc(connectorDesc, Connector.class, regularVersion, pluginLoader.location());

        PluginDesc<Converter> converterDesc = new PluginDesc<>(
                Converter.class,
                snaphotVersion,
                pluginLoader
        );

        assertPluginDesc(converterDesc, Converter.class, snaphotVersion, pluginLoader.location());

        PluginDesc<Transformation> transformDesc = new PluginDesc<>(
                Transformation.class,
                noVersion,
                pluginLoader
        );

        assertPluginDesc(transformDesc, Transformation.class, noVersion, pluginLoader.location());
    }
",non-flaky,5
70825,apache_kafka,PluginDescTest.testPluginDescWithSystemClassLoader,"    @Test
    public void testPluginDescWithSystemClassLoader() {
        String location = ""classpath"";
        PluginDesc<SinkConnector> connectorDesc = new PluginDesc<>(
                SinkConnector.class,
                regularVersion,
                systemLoader
        );

        assertPluginDesc(connectorDesc, SinkConnector.class, regularVersion, location);

        PluginDesc<Converter> converterDesc = new PluginDesc<>(
                Converter.class,
                snaphotVersion,
                systemLoader
        );

        assertPluginDesc(converterDesc, Converter.class, snaphotVersion, location);

        PluginDesc<Transformation> transformDesc = new PluginDesc<>(
                Transformation.class,
                noVersion,
                systemLoader
        );

        assertPluginDesc(transformDesc, Transformation.class, noVersion, location);
    }
",non-flaky,5
70826,apache_kafka,PluginDescTest.testPluginDescWithNullVersion,"    @Test
    public void testPluginDescWithNullVersion() {
        String nullVersion = ""null"";
        PluginDesc<SourceConnector> connectorDesc = new PluginDesc<>(
                SourceConnector.class,
                null,
                pluginLoader
        );

        assertPluginDesc(
                connectorDesc,
                SourceConnector.class,
                nullVersion,
                pluginLoader.location()
        );

        String location = ""classpath"";
        PluginDesc<Converter> converterDesc = new PluginDesc<>(
                Converter.class,
                null,
                systemLoader
        );

        assertPluginDesc(converterDesc, Converter.class, nullVersion, location);
    }
",non-flaky,5
70827,apache_kafka,PluginDescTest.testPluginDescEquality,"    @Test
    public void testPluginDescEquality() {
        PluginDesc<Connector> connectorDescPluginPath = new PluginDesc<>(
                Connector.class,
                snaphotVersion,
                pluginLoader
        );

        PluginDesc<Connector> connectorDescClasspath = new PluginDesc<>(
                Connector.class,
                snaphotVersion,
                systemLoader
        );

        assertEquals(connectorDescPluginPath, connectorDescClasspath);
        assertEquals(connectorDescPluginPath.hashCode(), connectorDescClasspath.hashCode());

        PluginDesc<Converter> converterDescPluginPath = new PluginDesc<>(
                Converter.class,
                noVersion,
                pluginLoader
        );

        PluginDesc<Converter> converterDescClasspath = new PluginDesc<>(
                Converter.class,
                noVersion,
                systemLoader
        );

        assertEquals(converterDescPluginPath, converterDescClasspath);
        assertEquals(converterDescPluginPath.hashCode(), converterDescClasspath.hashCode());

        PluginDesc<Transformation> transformDescPluginPath = new PluginDesc<>(
                Transformation.class,
                null,
                pluginLoader
        );

        PluginDesc<Transformation> transformDescClasspath = new PluginDesc<>(
                Transformation.class,
                noVersion,
                pluginLoader
        );

        assertNotEquals(transformDescPluginPath, transformDescClasspath);
    }
",non-flaky,5
70828,apache_kafka,PluginDescTest.testPluginDescComparison,"    @Test
    public void testPluginDescComparison() {
        PluginDesc<Connector> connectorDescPluginPath = new PluginDesc<>(
                Connector.class,
                regularVersion,
                pluginLoader
        );

        PluginDesc<Connector> connectorDescClasspath = new PluginDesc<>(
                Connector.class,
                newerVersion,
                systemLoader
        );

        assertNewer(connectorDescPluginPath, connectorDescClasspath);

        PluginDesc<Converter> converterDescPluginPath = new PluginDesc<>(
                Converter.class,
                noVersion,
                pluginLoader
        );

        PluginDesc<Converter> converterDescClasspath = new PluginDesc<>(
                Converter.class,
                snaphotVersion,
                systemLoader
        );

        assertNewer(converterDescPluginPath, converterDescClasspath);

        PluginDesc<Transformation> transformDescPluginPath = new PluginDesc<>(
                Transformation.class,
                null,
                pluginLoader
        );

        PluginDesc<Transformation> transformDescClasspath = new PluginDesc<>(
                Transformation.class,
                regularVersion,
                systemLoader
        );

        assertNewer(transformDescPluginPath, transformDescClasspath);
    }
",non-flaky,5
70829,apache_kafka,WorkerConfigTest.testAdminListenersConfigAllowedValues,"    @Test
    public void testAdminListenersConfigAllowedValues() {
        Map<String, String> props = baseProps();

        // no value set for ""admin.listeners""
        WorkerConfig config = new WorkerConfig(WorkerConfig.baseConfigDef(), props);
        assertNull(""Default value should be null."", config.getList(WorkerConfig.ADMIN_LISTENERS_CONFIG));

        props.put(WorkerConfig.ADMIN_LISTENERS_CONFIG, """");
        config = new WorkerConfig(WorkerConfig.baseConfigDef(), props);
        assertTrue(config.getList(WorkerConfig.ADMIN_LISTENERS_CONFIG).isEmpty());

        props.put(WorkerConfig.ADMIN_LISTENERS_CONFIG, ""http://a.b:9999, https://a.b:7812"");
        config = new WorkerConfig(WorkerConfig.baseConfigDef(), props);
        assertEquals(config.getList(WorkerConfig.ADMIN_LISTENERS_CONFIG), Arrays.asList(""http://a.b:9999"", ""https://a.b:7812""));

        new WorkerConfig(WorkerConfig.baseConfigDef(), props);
    }
",non-flaky,5
70830,apache_kafka,WorkerConfigTest.testAdminListenersNotAllowingEmptyStrings,"    @Test(expected = ConfigException.class)
    public void testAdminListenersNotAllowingEmptyStrings() {
        Map<String, String> props = baseProps();
        props.put(WorkerConfig.ADMIN_LISTENERS_CONFIG, ""http://a.b:9999,"");
        new WorkerConfig(WorkerConfig.baseConfigDef(), props);
    }
",non-flaky,5
70831,apache_kafka,WorkerConfigTest.testAdminListenersNotAllowingBlankStrings,"    @Test(expected = ConfigException.class)
    public void testAdminListenersNotAllowingBlankStrings() {
        Map<String, String> props = baseProps();
        props.put(WorkerConfig.ADMIN_LISTENERS_CONFIG, ""http://a.b:9999, ,https://a.b:9999"");
        new WorkerConfig(WorkerConfig.baseConfigDef(), props);
    }
",non-flaky,5
70832,apache_kafka,WorkerSourceTaskTest.answer,"    @Test
    public void testStartPaused() throws Exception {
        final CountDownLatch pauseLatch = new CountDownLatch(1);

        createWorkerTask(TargetState.PAUSED);

        statusListener.onPause(taskId);
        EasyMock.expectLastCall().andAnswer(new IAnswer<Void>() {
            @Override
            public Void answer() throws Throwable {
                pauseLatch.countDown();
                return null;
            }
",non-flaky,5
70833,apache_kafka,WorkerSourceTaskTest.testPause,"    @Test
    public void testPause() throws Exception {
        createWorkerTask();

        sourceTask.initialize(EasyMock.anyObject(SourceTaskContext.class));
        EasyMock.expectLastCall();
        sourceTask.start(TASK_PROPS);
        EasyMock.expectLastCall();
        statusListener.onStartup(taskId);
        EasyMock.expectLastCall();

        AtomicInteger count = new AtomicInteger(0);
        CountDownLatch pollLatch = expectPolls(10, count);
        // In this test, we don't flush, so nothing goes any further than the offset writer

        statusListener.onPause(taskId);
        EasyMock.expectLastCall();

        sourceTask.stop();
        EasyMock.expectLastCall();
        expectOffsetFlush(true);

        statusListener.onShutdown(taskId);
        EasyMock.expectLastCall();

        producer.close(EasyMock.anyObject(Duration.class));
        EasyMock.expectLastCall();

        transformationChain.close();
        EasyMock.expectLastCall();

        PowerMock.replayAll();

        workerTask.initialize(TASK_CONFIG);
        Future<?> taskFuture = executor.submit(workerTask);
        assertTrue(awaitLatch(pollLatch));

        workerTask.transitionTo(TargetState.PAUSED);

        int priorCount = count.get();
        Thread.sleep(100);

        // since the transition is observed asynchronously, the count could be off by one loop iteration
        assertTrue(count.get() - priorCount <= 1);

        workerTask.stop();
        assertTrue(workerTask.awaitStop(1000));

        taskFuture.get();

        PowerMock.verifyAll();
    }
",non-flaky,5
70834,apache_kafka,WorkerSourceTaskTest.testPollsInBackground,"    @Test
    public void testPollsInBackground() throws Exception {
        createWorkerTask();

        sourceTask.initialize(EasyMock.anyObject(SourceTaskContext.class));
        EasyMock.expectLastCall();
        sourceTask.start(TASK_PROPS);
        EasyMock.expectLastCall();
        statusListener.onStartup(taskId);
        EasyMock.expectLastCall();

        final CountDownLatch pollLatch = expectPolls(10);
        // In this test, we don't flush, so nothing goes any further than the offset writer

        sourceTask.stop();
        EasyMock.expectLastCall();
        expectOffsetFlush(true);

        statusListener.onShutdown(taskId);
        EasyMock.expectLastCall();

        producer.close(EasyMock.anyObject(Duration.class));
        EasyMock.expectLastCall();

        transformationChain.close();
        EasyMock.expectLastCall();

        PowerMock.replayAll();

        workerTask.initialize(TASK_CONFIG);
        Future<?> taskFuture = executor.submit(workerTask);

        assertTrue(awaitLatch(pollLatch));
        workerTask.stop();
        assertTrue(workerTask.awaitStop(1000));

        taskFuture.get();
        assertPollMetrics(10);

        PowerMock.verifyAll();
    }
",non-flaky,5
70835,apache_kafka,WorkerSourceTaskTest.answer,"    @Test
    public void testFailureInPoll() throws Exception {
        createWorkerTask();

        sourceTask.initialize(EasyMock.anyObject(SourceTaskContext.class));
        EasyMock.expectLastCall();
        sourceTask.start(TASK_PROPS);
        EasyMock.expectLastCall();
        statusListener.onStartup(taskId);
        EasyMock.expectLastCall();

        final CountDownLatch pollLatch = new CountDownLatch(1);
        final RuntimeException exception = new RuntimeException();
        EasyMock.expect(sourceTask.poll()).andAnswer(new IAnswer<List<SourceRecord>>() {
            @Override
            public List<SourceRecord> answer() throws Throwable {
                pollLatch.countDown();
                throw exception;
            }
",non-flaky,5
70836,apache_kafka,WorkerSourceTaskTest.testPollReturnsNoRecords,"    @Test
    public void testPollReturnsNoRecords() throws Exception {
        // Test that the task handles an empty list of records
        createWorkerTask();

        sourceTask.initialize(EasyMock.anyObject(SourceTaskContext.class));
        EasyMock.expectLastCall();
        sourceTask.start(TASK_PROPS);
        EasyMock.expectLastCall();
        statusListener.onStartup(taskId);
        EasyMock.expectLastCall();

        // We'll wait for some data, then trigger a flush
        final CountDownLatch pollLatch = expectEmptyPolls(1, new AtomicInteger());
        expectOffsetFlush(true);

        sourceTask.stop();
        EasyMock.expectLastCall();
        expectOffsetFlush(true);

        statusListener.onShutdown(taskId);
        EasyMock.expectLastCall();

        producer.close(EasyMock.anyObject(Duration.class));
        EasyMock.expectLastCall();

        transformationChain.close();
        EasyMock.expectLastCall();

        PowerMock.replayAll();

        workerTask.initialize(TASK_CONFIG);
        Future<?> taskFuture = executor.submit(workerTask);

        assertTrue(awaitLatch(pollLatch));
        assertTrue(workerTask.commitOffsets());
        workerTask.stop();
        assertTrue(workerTask.awaitStop(1000));

        taskFuture.get();
        assertPollMetrics(0);

        PowerMock.verifyAll();
    }
",non-flaky,5
70837,apache_kafka,WorkerSourceTaskTest.testCommit,"    @Test
    public void testCommit() throws Exception {
        // Test that the task commits properly when prompted
        createWorkerTask();

        sourceTask.initialize(EasyMock.anyObject(SourceTaskContext.class));
        EasyMock.expectLastCall();
        sourceTask.start(TASK_PROPS);
        EasyMock.expectLastCall();
        statusListener.onStartup(taskId);
        EasyMock.expectLastCall();

        // We'll wait for some data, then trigger a flush
        final CountDownLatch pollLatch = expectPolls(1);
        expectOffsetFlush(true);

        sourceTask.stop();
        EasyMock.expectLastCall();
        expectOffsetFlush(true);

        statusListener.onShutdown(taskId);
        EasyMock.expectLastCall();

        producer.close(EasyMock.anyObject(Duration.class));
        EasyMock.expectLastCall();

        transformationChain.close();
        EasyMock.expectLastCall();

        PowerMock.replayAll();

        workerTask.initialize(TASK_CONFIG);
        Future<?> taskFuture = executor.submit(workerTask);

        assertTrue(awaitLatch(pollLatch));
        assertTrue(workerTask.commitOffsets());
        workerTask.stop();
        assertTrue(workerTask.awaitStop(1000));

        taskFuture.get();
        assertPollMetrics(1);

        PowerMock.verifyAll();
    }
",non-flaky,5
70838,apache_kafka,WorkerSourceTaskTest.testCommitFailure,"    @Test
    public void testCommitFailure() throws Exception {
        // Test that the task commits properly when prompted
        createWorkerTask();

        sourceTask.initialize(EasyMock.anyObject(SourceTaskContext.class));
        EasyMock.expectLastCall();
        sourceTask.start(TASK_PROPS);
        EasyMock.expectLastCall();
        statusListener.onStartup(taskId);
        EasyMock.expectLastCall();

        // We'll wait for some data, then trigger a flush
        final CountDownLatch pollLatch = expectPolls(1);
        expectOffsetFlush(true);

        sourceTask.stop();
        EasyMock.expectLastCall();
        expectOffsetFlush(false);

        statusListener.onShutdown(taskId);
        EasyMock.expectLastCall();

        producer.close(EasyMock.anyObject(Duration.class));
        EasyMock.expectLastCall();

        transformationChain.close();
        EasyMock.expectLastCall();

        PowerMock.replayAll();

        workerTask.initialize(TASK_CONFIG);
        Future<?> taskFuture = executor.submit(workerTask);

        assertTrue(awaitLatch(pollLatch));
        assertTrue(workerTask.commitOffsets());
        workerTask.stop();
        assertTrue(workerTask.awaitStop(1000));

        taskFuture.get();
        assertPollMetrics(1);

        PowerMock.verifyAll();
    }
",non-flaky,5
70839,apache_kafka,WorkerSourceTaskTest.testSendRecordsConvertsData,"    @Test
    public void testSendRecordsConvertsData() throws Exception {
        createWorkerTask();

        List<SourceRecord> records = new ArrayList<>();
        // Can just use the same record for key and value
        records.add(new SourceRecord(PARTITION, OFFSET, ""topic"", null, KEY_SCHEMA, KEY, RECORD_SCHEMA, RECORD));

        Capture<ProducerRecord<byte[], byte[]>> sent = expectSendRecordAnyTimes();

        PowerMock.replayAll();

        Whitebox.setInternalState(workerTask, ""toSend"", records);
        Whitebox.invokeMethod(workerTask, ""sendRecords"");
        assertEquals(SERIALIZED_KEY, sent.getValue().key());
        assertEquals(SERIALIZED_RECORD, sent.getValue().value());

        PowerMock.verifyAll();
    }
",non-flaky,5
70840,apache_kafka,WorkerSourceTaskTest.testSendRecordsPropagatesTimestamp,"    @Test
    public void testSendRecordsPropagatesTimestamp() throws Exception {
        final Long timestamp = System.currentTimeMillis();

        createWorkerTask();

        List<SourceRecord> records = Collections.singletonList(
                new SourceRecord(PARTITION, OFFSET, ""topic"", null, KEY_SCHEMA, KEY, RECORD_SCHEMA, RECORD, timestamp)
        );

        Capture<ProducerRecord<byte[], byte[]>> sent = expectSendRecordAnyTimes();

        PowerMock.replayAll();

        Whitebox.setInternalState(workerTask, ""toSend"", records);
        Whitebox.invokeMethod(workerTask, ""sendRecords"");
        assertEquals(timestamp, sent.getValue().timestamp());

        PowerMock.verifyAll();
    }
",non-flaky,5
70841,apache_kafka,WorkerSourceTaskTest.testSendRecordsCorruptTimestamp,"    @Test(expected = InvalidRecordException.class)
    public void testSendRecordsCorruptTimestamp() throws Exception {
        final Long timestamp = -3L;
        createWorkerTask();

        List<SourceRecord> records = Collections.singletonList(
                new SourceRecord(PARTITION, OFFSET, ""topic"", null, KEY_SCHEMA, KEY, RECORD_SCHEMA, RECORD, timestamp)
        );

        Capture<ProducerRecord<byte[], byte[]>> sent = expectSendRecordAnyTimes();

        PowerMock.replayAll();

        Whitebox.setInternalState(workerTask, ""toSend"", records);
        Whitebox.invokeMethod(workerTask, ""sendRecords"");
        assertEquals(null, sent.getValue().timestamp());

        PowerMock.verifyAll();
    }
",non-flaky,5
70842,apache_kafka,WorkerSourceTaskTest.testSendRecordsNoTimestamp,"    @Test
    public void testSendRecordsNoTimestamp() throws Exception {
        final Long timestamp = -1L;
        createWorkerTask();

        List<SourceRecord> records = Collections.singletonList(
                new SourceRecord(PARTITION, OFFSET, ""topic"", null, KEY_SCHEMA, KEY, RECORD_SCHEMA, RECORD, timestamp)
        );

        Capture<ProducerRecord<byte[], byte[]>> sent = expectSendRecordAnyTimes();

        PowerMock.replayAll();

        Whitebox.setInternalState(workerTask, ""toSend"", records);
        Whitebox.invokeMethod(workerTask, ""sendRecords"");
        assertEquals(null, sent.getValue().timestamp());

        PowerMock.verifyAll();
    }
",non-flaky,5
70843,apache_kafka,WorkerSourceTaskTest.testSendRecordsRetries,"    @Test
    public void testSendRecordsRetries() throws Exception {
        createWorkerTask();

        // Differentiate only by Kafka partition so we can reuse conversion expectations
        SourceRecord record1 = new SourceRecord(PARTITION, OFFSET, ""topic"", 1, KEY_SCHEMA, KEY, RECORD_SCHEMA, RECORD);
        SourceRecord record2 = new SourceRecord(PARTITION, OFFSET, ""topic"", 2, KEY_SCHEMA, KEY, RECORD_SCHEMA, RECORD);
        SourceRecord record3 = new SourceRecord(PARTITION, OFFSET, ""topic"", 3, KEY_SCHEMA, KEY, RECORD_SCHEMA, RECORD);

        // First round
        expectSendRecordOnce(false);
        // Any Producer retriable exception should work here
        expectSendRecordSyncFailure(new org.apache.kafka.common.errors.TimeoutException(""retriable sync failure""));

        // Second round
        expectSendRecordOnce(true);
        expectSendRecordOnce(false);

        PowerMock.replayAll();

        // Try to send 3, make first pass, second fail. Should save last two
        Whitebox.setInternalState(workerTask, ""toSend"", Arrays.asList(record1, record2, record3));
        Whitebox.invokeMethod(workerTask, ""sendRecords"");
        assertEquals(true, Whitebox.getInternalState(workerTask, ""lastSendFailed""));
        assertEquals(Arrays.asList(record2, record3), Whitebox.getInternalState(workerTask, ""toSend""));

        // Next they all succeed
        Whitebox.invokeMethod(workerTask, ""sendRecords"");
        assertEquals(false, Whitebox.getInternalState(workerTask, ""lastSendFailed""));
        assertNull(Whitebox.getInternalState(workerTask, ""toSend""));

        PowerMock.verifyAll();
    }
",non-flaky,5
70844,apache_kafka,WorkerSourceTaskTest.testSendRecordsProducerCallbackFail,"    @Test(expected = ConnectException.class)
    public void testSendRecordsProducerCallbackFail() throws Exception {
        createWorkerTask();

        SourceRecord record1 = new SourceRecord(PARTITION, OFFSET, ""topic"", 1, KEY_SCHEMA, KEY, RECORD_SCHEMA, RECORD);
        SourceRecord record2 = new SourceRecord(PARTITION, OFFSET, ""topic"", 2, KEY_SCHEMA, KEY, RECORD_SCHEMA, RECORD);

        expectSendRecordProducerCallbackFail();

        PowerMock.replayAll();

        Whitebox.setInternalState(workerTask, ""toSend"", Arrays.asList(record1, record2));
        Whitebox.invokeMethod(workerTask, ""sendRecords"");
    }
",non-flaky,5
70845,apache_kafka,WorkerSourceTaskTest.testSendRecordsTaskCommitRecordFail,"    @Test
    public void testSendRecordsTaskCommitRecordFail() throws Exception {
        createWorkerTask();

        // Differentiate only by Kafka partition so we can reuse conversion expectations
        SourceRecord record1 = new SourceRecord(PARTITION, OFFSET, ""topic"", 1, KEY_SCHEMA, KEY, RECORD_SCHEMA, RECORD);
        SourceRecord record2 = new SourceRecord(PARTITION, OFFSET, ""topic"", 2, KEY_SCHEMA, KEY, RECORD_SCHEMA, RECORD);
        SourceRecord record3 = new SourceRecord(PARTITION, OFFSET, ""topic"", 3, KEY_SCHEMA, KEY, RECORD_SCHEMA, RECORD);

        // Source task commit record failure will not cause the task to abort
        expectSendRecordOnce(false);
        expectSendRecordTaskCommitRecordFail(false, false);
        expectSendRecordOnce(false);

        PowerMock.replayAll();

        Whitebox.setInternalState(workerTask, ""toSend"", Arrays.asList(record1, record2, record3));
        Whitebox.invokeMethod(workerTask, ""sendRecords"");
        assertEquals(false, Whitebox.getInternalState(workerTask, ""lastSendFailed""));
        assertNull(Whitebox.getInternalState(workerTask, ""toSend""));

        PowerMock.verifyAll();
    }
",non-flaky,5
70846,apache_kafka,WorkerSourceTaskTest.answer,"    @Test
    public void testSlowTaskStart() throws Exception {
        final CountDownLatch startupLatch = new CountDownLatch(1);
        final CountDownLatch finishStartupLatch = new CountDownLatch(1);

        createWorkerTask();

        sourceTask.initialize(EasyMock.anyObject(SourceTaskContext.class));
        EasyMock.expectLastCall();
        sourceTask.start(TASK_PROPS);
        EasyMock.expectLastCall().andAnswer(new IAnswer<Object>() {
            @Override
            public Object answer() throws Throwable {
                startupLatch.countDown();
                assertTrue(awaitLatch(finishStartupLatch));
                return null;
            }
",non-flaky,5
70847,apache_kafka,WorkerSourceTaskTest.testCancel,"    @Test
    public void testCancel() {
        createWorkerTask();

        offsetReader.close();
        PowerMock.expectLastCall();

        PowerMock.replayAll();

        workerTask.cancel();

        PowerMock.verifyAll();
    }
",non-flaky,5
70848,apache_kafka,WorkerSourceTaskTest.testMetricsGroup,"    @Test
    public void testMetricsGroup() {
        SourceTaskMetricsGroup group = new SourceTaskMetricsGroup(taskId, metrics);
        SourceTaskMetricsGroup group1 = new SourceTaskMetricsGroup(taskId1, metrics);
        for (int i = 0; i != 10; ++i) {
            group.recordPoll(100, 1000 + i * 100);
            group.recordWrite(10);
        }
        for (int i = 0; i != 20; ++i) {
            group1.recordPoll(100, 1000 + i * 100);
            group1.recordWrite(10);
        }
        assertEquals(1900.0, metrics.currentMetricValueAsDouble(group.metricGroup(), ""poll-batch-max-time-ms""), 0.001d);
        assertEquals(1450.0, metrics.currentMetricValueAsDouble(group.metricGroup(), ""poll-batch-avg-time-ms""), 0.001d);
        assertEquals(33.333, metrics.currentMetricValueAsDouble(group.metricGroup(), ""source-record-poll-rate""), 0.001d);
        assertEquals(1000, metrics.currentMetricValueAsDouble(group.metricGroup(), ""source-record-poll-total""), 0.001d);
        assertEquals(3.3333, metrics.currentMetricValueAsDouble(group.metricGroup(), ""source-record-write-rate""), 0.001d);
        assertEquals(100, metrics.currentMetricValueAsDouble(group.metricGroup(), ""source-record-write-total""), 0.001d);
        assertEquals(900.0, metrics.currentMetricValueAsDouble(group.metricGroup(), ""source-record-active-count""), 0.001d);

        // Close the group
        group.close();

        for (MetricName metricName : group.metricGroup().metrics().metrics().keySet()) {
            // Metrics for this group should no longer exist
            assertFalse(group.metricGroup().groupId().includes(metricName));
        }
        // Sensors for this group should no longer exist
        assertNull(group.metricGroup().metrics().getSensor(""sink-record-read""));
        assertNull(group.metricGroup().metrics().getSensor(""sink-record-send""));
        assertNull(group.metricGroup().metrics().getSensor(""sink-record-active-count""));
        assertNull(group.metricGroup().metrics().getSensor(""partition-count""));
        assertNull(group.metricGroup().metrics().getSensor(""offset-seq-number""));
        assertNull(group.metricGroup().metrics().getSensor(""offset-commit-completion""));
        assertNull(group.metricGroup().metrics().getSensor(""offset-commit-completion-skip""));
        assertNull(group.metricGroup().metrics().getSensor(""put-batch-time""));

        assertEquals(2900.0, metrics.currentMetricValueAsDouble(group1.metricGroup(), ""poll-batch-max-time-ms""), 0.001d);
        assertEquals(1950.0, metrics.currentMetricValueAsDouble(group1.metricGroup(), ""poll-batch-avg-time-ms""), 0.001d);
        assertEquals(66.667, metrics.currentMetricValueAsDouble(group1.metricGroup(), ""source-record-poll-rate""), 0.001d);
        assertEquals(2000, metrics.currentMetricValueAsDouble(group1.metricGroup(), ""source-record-poll-total""), 0.001d);
        assertEquals(6.667, metrics.currentMetricValueAsDouble(group1.metricGroup(), ""source-record-write-rate""), 0.001d);
        assertEquals(200, metrics.currentMetricValueAsDouble(group1.metricGroup(), ""source-record-write-total""), 0.001d);
        assertEquals(1800.0, metrics.currentMetricValueAsDouble(group1.metricGroup(), ""source-record-active-count""), 0.001d);
    }
",non-flaky,5
70849,apache_kafka,WorkerSourceTaskTest.testHeaders,"    @Test
    public void testHeaders() throws Exception {
        Headers headers = new RecordHeaders();
        headers.add(""header_key"", ""header_value"".getBytes());

        org.apache.kafka.connect.header.Headers connectHeaders = new ConnectHeaders();
        connectHeaders.add(""header_key"", new SchemaAndValue(Schema.STRING_SCHEMA, ""header_value""));

        createWorkerTask();

        List<SourceRecord> records = new ArrayList<>();
        records.add(new SourceRecord(PARTITION, OFFSET, ""topic"", null, KEY_SCHEMA, KEY, RECORD_SCHEMA, RECORD, null, connectHeaders));

        Capture<ProducerRecord<byte[], byte[]>> sent = expectSendRecord(true, false, true, true, true, headers);

        PowerMock.replayAll();

        Whitebox.setInternalState(workerTask, ""toSend"", records);
        Whitebox.invokeMethod(workerTask, ""sendRecords"");
        assertEquals(SERIALIZED_KEY, sent.getValue().key());
        assertEquals(SERIALIZED_RECORD, sent.getValue().value());
        assertEquals(headers, sent.getValue().headers());

        PowerMock.verifyAll();
    }
",non-flaky,5
70850,apache_kafka,WorkerSourceTaskTest.testHeadersWithCustomConverter,"    @Test
    public void testHeadersWithCustomConverter() throws Exception {
        StringConverter stringConverter = new StringConverter();
        TestConverterWithHeaders testConverter = new TestConverterWithHeaders();

        createWorkerTask(TargetState.STARTED, stringConverter, testConverter, stringConverter);

        List<SourceRecord> records = new ArrayList<>();

        String stringA = ""rvztr tkrfrgp"";
        org.apache.kafka.connect.header.Headers headersA = new ConnectHeaders();
        String encodingA = ""latin2"";
        headersA.addString(""encoding"", encodingA);

        records.add(new SourceRecord(PARTITION, OFFSET, ""topic"", null, Schema.STRING_SCHEMA, ""a"", Schema.STRING_SCHEMA, stringA, null, headersA));

        String stringB = "" "";
        org.apache.kafka.connect.header.Headers headersB = new ConnectHeaders();
        String encodingB = ""koi8_r"";
        headersB.addString(""encoding"", encodingB);

        records.add(new SourceRecord(PARTITION, OFFSET, ""topic"", null, Schema.STRING_SCHEMA, ""b"", Schema.STRING_SCHEMA, stringB, null, headersB));

        Capture<ProducerRecord<byte[], byte[]>> sentRecordA = expectSendRecord(false, false, true, true, false, null);
        Capture<ProducerRecord<byte[], byte[]>> sentRecordB = expectSendRecord(false, false, true, true, false, null);

        PowerMock.replayAll();

        Whitebox.setInternalState(workerTask, ""toSend"", records);
        Whitebox.invokeMethod(workerTask, ""sendRecords"");

        assertEquals(ByteBuffer.wrap(""a"".getBytes()), ByteBuffer.wrap(sentRecordA.getValue().key()));
        assertEquals(
            ByteBuffer.wrap(stringA.getBytes(encodingA)),
            ByteBuffer.wrap(sentRecordA.getValue().value())
        );
        assertEquals(encodingA, new String(sentRecordA.getValue().headers().lastHeader(""encoding"").value()));

        assertEquals(ByteBuffer.wrap(""b"".getBytes()), ByteBuffer.wrap(sentRecordB.getValue().key()));
        assertEquals(
            ByteBuffer.wrap(stringB.getBytes(encodingB)),
            ByteBuffer.wrap(sentRecordB.getValue().value())
        );
        assertEquals(encodingB, new String(sentRecordB.getValue().headers().lastHeader(""encoding"").value()));

        PowerMock.verifyAll();
    }
",non-flaky,5
70851,apache_kafka,TransformationConfigTest.testEmbeddedConfigCast,"    @Test
    public void testEmbeddedConfigCast() {
        // Validate that we can construct a Connector config containing the extended config for the transform
        HashMap<String, String> connProps = new HashMap<>();
        connProps.put(""name"", ""foo"");
        connProps.put(""connector.class"", MockConnector.class.getName());
        connProps.put(""transforms"", ""example"");
        connProps.put(""transforms.example.type"", Cast.Value.class.getName());
        connProps.put(""transforms.example.spec"", ""int8"");

        Plugins plugins = null; // Safe when we're only constructing the config
        new ConnectorConfig(plugins, connProps);
    }
",non-flaky,5
70852,apache_kafka,TransformationConfigTest.testEmbeddedConfigExtractField,"    @Test
    public void testEmbeddedConfigExtractField() {
        // Validate that we can construct a Connector config containing the extended config for the transform
        HashMap<String, String> connProps = new HashMap<>();
        connProps.put(""name"", ""foo"");
        connProps.put(""connector.class"", MockConnector.class.getName());
        connProps.put(""transforms"", ""example"");
        connProps.put(""transforms.example.type"", ExtractField.Value.class.getName());
        connProps.put(""transforms.example.field"", ""field"");

        Plugins plugins = null; // Safe when we're only constructing the config
        new ConnectorConfig(plugins, connProps);
    }
",non-flaky,5
70853,apache_kafka,TransformationConfigTest.testEmbeddedConfigFlatten,"    @Test
    public void testEmbeddedConfigFlatten() {
        // Validate that we can construct a Connector config containing the extended config for the transform
        HashMap<String, String> connProps = new HashMap<>();
        connProps.put(""name"", ""foo"");
        connProps.put(""connector.class"", MockConnector.class.getName());
        connProps.put(""transforms"", ""example"");
        connProps.put(""transforms.example.type"", Flatten.Value.class.getName());

        Plugins plugins = null; // Safe when we're only constructing the config
        new ConnectorConfig(plugins, connProps);
    }
",non-flaky,5
70854,apache_kafka,TransformationConfigTest.testEmbeddedConfigHoistField,"    @Test
    public void testEmbeddedConfigHoistField() {
        // Validate that we can construct a Connector config containing the extended config for the transform
        HashMap<String, String> connProps = new HashMap<>();
        connProps.put(""name"", ""foo"");
        connProps.put(""connector.class"", MockConnector.class.getName());
        connProps.put(""transforms"", ""example"");
        connProps.put(""transforms.example.type"", HoistField.Value.class.getName());
        connProps.put(""transforms.example.field"", ""field"");

        Plugins plugins = null; // Safe when we're only constructing the config
        new ConnectorConfig(plugins, connProps);
    }
",non-flaky,5
70855,apache_kafka,TransformationConfigTest.testEmbeddedConfigInsertField,"    @Test
    public void testEmbeddedConfigInsertField() {
        // Validate that we can construct a Connector config containing the extended config for the transform
        HashMap<String, String> connProps = new HashMap<>();
        connProps.put(""name"", ""foo"");
        connProps.put(""connector.class"", MockConnector.class.getName());
        connProps.put(""transforms"", ""example"");
        connProps.put(""transforms.example.type"", InsertField.Value.class.getName());

        Plugins plugins = null; // Safe when we're only constructing the config
        new ConnectorConfig(plugins, connProps);
    }
",non-flaky,5
70856,apache_kafka,TransformationConfigTest.testEmbeddedConfigMaskField,"    @Test
    public void testEmbeddedConfigMaskField() {
        // Validate that we can construct a Connector config containing the extended config for the transform
        HashMap<String, String> connProps = new HashMap<>();
        connProps.put(""name"", ""foo"");
        connProps.put(""connector.class"", MockConnector.class.getName());
        connProps.put(""transforms"", ""example"");
        connProps.put(""transforms.example.type"", MaskField.Value.class.getName());
        connProps.put(""transforms.example.fields"", ""field"");


        Plugins plugins = null; // Safe when we're only constructing the config
        new ConnectorConfig(plugins, connProps);
    }
",non-flaky,5
70857,apache_kafka,TransformationConfigTest.testEmbeddedConfigRegexRouter,"    @Test
    public void testEmbeddedConfigRegexRouter() {
        // Validate that we can construct a Connector config containing the extended config for the transform
        HashMap<String, String> connProps = new HashMap<>();
        connProps.put(""name"", ""foo"");
        connProps.put(""connector.class"", MockConnector.class.getName());
        connProps.put(""transforms"", ""example"");
        connProps.put(""transforms.example.type"", RegexRouter.class.getName());
        connProps.put(""transforms.example.regex"", ""(.*)"");
        connProps.put(""transforms.example.replacement"", ""prefix-$1"");

        Plugins plugins = null; // Safe when we're only constructing the config
        new ConnectorConfig(plugins, connProps);
    }
",non-flaky,5
70858,apache_kafka,TransformationConfigTest.testEmbeddedConfigReplaceField,"    @Test
    public void testEmbeddedConfigReplaceField() {
        // Validate that we can construct a Connector config containing the extended config for the transform
        HashMap<String, String> connProps = new HashMap<>();
        connProps.put(""name"", ""foo"");
        connProps.put(""connector.class"", MockConnector.class.getName());
        connProps.put(""transforms"", ""example"");
        connProps.put(""transforms.example.type"", ReplaceField.Value.class.getName());

        Plugins plugins = null; // Safe when we're only constructing the config
        new ConnectorConfig(plugins, connProps);
    }
",non-flaky,5
70859,apache_kafka,TransformationConfigTest.testEmbeddedConfigSetSchemaMetadata,"    @Test
    public void testEmbeddedConfigSetSchemaMetadata() {
        // Validate that we can construct a Connector config containing the extended config for the transform
        HashMap<String, String> connProps = new HashMap<>();
        connProps.put(""name"", ""foo"");
        connProps.put(""connector.class"", MockConnector.class.getName());
        connProps.put(""transforms"", ""example"");
        connProps.put(""transforms.example.type"", SetSchemaMetadata.Value.class.getName());

        Plugins plugins = null; // Safe when we're only constructing the config
        new ConnectorConfig(plugins, connProps);
    }
",non-flaky,5
70860,apache_kafka,TransformationConfigTest.testEmbeddedConfigTimestampConverter,"    @Test
    public void testEmbeddedConfigTimestampConverter() {
        // Validate that we can construct a Connector config containing the extended config for the transform
        HashMap<String, String> connProps = new HashMap<>();
        connProps.put(""name"", ""foo"");
        connProps.put(""connector.class"", MockConnector.class.getName());
        connProps.put(""transforms"", ""example"");
        connProps.put(""transforms.example.type"", TimestampConverter.Value.class.getName());
        connProps.put(""transforms.example.target.type"", ""unix"");

        Plugins plugins = null; // Safe when we're only constructing the config
        new ConnectorConfig(plugins, connProps);
    }
",non-flaky,5
70861,apache_kafka,TransformationConfigTest.testEmbeddedConfigTimestampRouter,"    @Test
    public void testEmbeddedConfigTimestampRouter() {
        // Validate that we can construct a Connector config containing the extended config for the transform
        HashMap<String, String> connProps = new HashMap<>();
        connProps.put(""name"", ""foo"");
        connProps.put(""connector.class"", MockConnector.class.getName());
        connProps.put(""transforms"", ""example"");
        connProps.put(""transforms.example.type"", TimestampRouter.class.getName());

        Plugins plugins = null; // Safe when we're only constructing the config
        new ConnectorConfig(plugins, connProps);
    }
",non-flaky,5
70862,apache_kafka,TransformationConfigTest.testEmbeddedConfigValueToKey,"    @Test
    public void testEmbeddedConfigValueToKey() {
        // Validate that we can construct a Connector config containing the extended config for the transform
        HashMap<String, String> connProps = new HashMap<>();
        connProps.put(""name"", ""foo"");
        connProps.put(""connector.class"", MockConnector.class.getName());
        connProps.put(""transforms"", ""example"");
        connProps.put(""transforms.example.type"", ValueToKey.class.getName());
        connProps.put(""transforms.example.fields"", ""field"");

        Plugins plugins = null; // Safe when we're only constructing the config
        new ConnectorConfig(plugins, connProps);
    }
",non-flaky,5
70863,apache_kafka,StateTrackerTest.currentStateIsNullWhenNotInitialized,"    @Test
    public void currentStateIsNullWhenNotInitialized() {
        assertNull(tracker.currentState());
    }
",non-flaky,5
70864,apache_kafka,StateTrackerTest.currentState,"    @Test
    public void currentState() {
        for (State state : State.values()) {
            tracker.changeState(state, time.milliseconds());
            assertEquals(state, tracker.currentState());
        }
    }
",non-flaky,5
76672,quarkusio_quarkus,ConfiguredBean.loadConfig,"@TestAnnotation
    public void loadConfig(TestBuildAndRunTimeConfig buildTimeConfig, TestRunTimeConfig runTimeConfig,
            FooRuntimeConfig fooRuntimeConfig) {
        System.out.printf(""loadConfig, buildTimeConfig=%s, runTimeConfig=%s, fooRuntimeConfig=%s%n"", buildTimeConfig,
                runTimeConfig, fooRuntimeConfig);
        this.buildTimeConfig = buildTimeConfig;
        this.runTimeConfig = runTimeConfig;
        this.fooRuntimeConfig = fooRuntimeConfig;
    }
",non-flaky,5
76673,quarkusio_quarkus,UnspecifiedPrefixConfigProperties.testConfiguredValues,"    @Test
    public void testConfiguredValues() {
        assertEquals(""quarkus"", dummyBean.getName());
        assertEquals(""hello"", dummyBean.getMessage());
    }
",non-flaky,5
76674,quarkusio_quarkus,HibernateET.testImport,"    @Test
    public void testImport() {
        RestAssured.when().get(""/my-entity/1"").then().body(is(""MyEntity:TEST ENTITY""));
    }
",non-flaky,5
76675,quarkusio_quarkus,CustomAuthEmbeddedBase.testSecureAccessFailure,"    @Test()
    public void testSecureAccessFailure() {
        RestAssured.when().get(""/secure-test"").then()
                .statusCode(401);
    }
",non-flaky,5
76676,quarkusio_quarkus,CustomAuthEmbeddedBase.testSecureRoleFailure,"    @Test()
    public void testSecureRoleFailure() {
        RestAssured.given().auth().preemptive().basic(""jdoe"", ""p4ssw0rd"")
                .when().get(""/secure-test"").then()
                .statusCode(403);
    }
",non-flaky,5
76677,quarkusio_quarkus,CustomAuthEmbeddedBase.testSecureAccessSuccess,"    @Test()
    public void testSecureAccessSuccess() {
        RestAssured.given().auth().preemptive().basic(""stuart"", ""test"")
                .when().get(""/secure-test"").then()
                .statusCode(200);
    }
",non-flaky,5
76678,quarkusio_quarkus,CustomAuthEmbeddedBase.testJaxrsGetFailure,"    @Test
    public void testJaxrsGetFailure() {
        RestAssured.when().get(""/jaxrs-secured/rolesClass"").then()
                .statusCode(401);
    }
",non-flaky,5
76679,quarkusio_quarkus,CustomAuthEmbeddedBase.testJaxrsGetRoleFailure,"    @Test
    public void testJaxrsGetRoleFailure() {
        RestAssured.given().auth().preemptive().basic(""jdoe"", ""p4ssw0rd"")
                .when().get(""/jaxrs-secured/rolesClass"").then()
                .statusCode(403);
    }
",non-flaky,5
76680,quarkusio_quarkus,CustomAuthEmbeddedBase.testJaxrsGetRoleSuccess,"    @Test
    public void testJaxrsGetRoleSuccess() {
        RestAssured.given().auth().preemptive().basic(""scott"", ""jb0ss"")
                .when().get(""/jaxrs-secured/rolesClass"").then()
                .statusCode(200);
    }
",non-flaky,5
76681,quarkusio_quarkus,CustomAuthEmbeddedBase.testJaxrsPathAdminRoleSuccess,"    @Test
    public void testJaxrsPathAdminRoleSuccess() {
        RestAssured.given().auth().preemptive().basic(""scott"", ""jb0ss"")
                .when().get(""/jaxrs-secured/parameterized-paths/my/banking/admin"").then()
                .statusCode(200);
    }
",non-flaky,5
76682,quarkusio_quarkus,CustomAuthEmbeddedBase.testJaxrsPathAdminRoleFailure,"    @Test
    public void testJaxrsPathAdminRoleFailure() {
        RestAssured.given().auth().preemptive().basic(""noadmin"", ""n0Adm1n"")
                .when().get(""/jaxrs-secured/parameterized-paths/my/banking/admin"").then()
                .statusCode(403);
    }
",non-flaky,5
76683,quarkusio_quarkus,CustomAuthEmbeddedBase.testJaxrsPathUserRoleSuccess,"    @Test
    public void testJaxrsPathUserRoleSuccess() {
        RestAssured.given().auth().preemptive().basic(""stuart"", ""test"")
                .when().get(""/jaxrs-secured/parameterized-paths/my/banking/view"").then()
                .statusCode(200);
    }
",non-flaky,5
76684,quarkusio_quarkus,CustomAuthEmbeddedBase.testJaxrsUserRoleSuccess,"    @Test
    public void testJaxrsUserRoleSuccess() {
        RestAssured.given().auth().preemptive().basic(""scott"", ""jb0ss"")
                .when().get(""/jaxrs-secured/subject/secured"").then()
                .statusCode(200)
                .body(equalTo(""scott""));
    }
",non-flaky,5
76685,quarkusio_quarkus,CustomAuthEmbeddedBase.testJaxrsGetPermitAll,"    @Test
    public void testJaxrsGetPermitAll() {
        RestAssured.when().get(""/jaxrs-secured/subject/unsecured"").then()
                .statusCode(200)
                .body(equalTo(""anonymous""));
    }
",non-flaky,5
76686,quarkusio_quarkus,CustomAuthEmbeddedBase.testJaxrsGetDenyAllWithoutAuth,"    @Test
    public void testJaxrsGetDenyAllWithoutAuth() {
        RestAssured.when().get(""/jaxrs-secured/subject/denied"").then()
                .statusCode(401);
    }
",non-flaky,5
76687,quarkusio_quarkus,CustomAuthEmbeddedBase.testJaxrsGetDenyAllWithAuth,"    @Test
    public void testJaxrsGetDenyAllWithAuth() {
        RestAssured.given().auth().preemptive().basic(""scott"", ""jb0ss"")
                .when().get(""/jaxrs-secured/subject/denied"").then()
                .statusCode(403);
    }
",non-flaky,5
76688,quarkusio_quarkus,TracerRouterUT.testTracer,"    @Test
    public void testTracer() {
        RestAssured.when().get(""/tracer"").then()
                .statusCode(200)
                .body(is(""Hello Tracer!""));
    }
",non-flaky,5
76689,quarkusio_quarkus,SimpleET.testHelloEndpoint,"    @Test
    public void testHelloEndpoint() {
        given()
                .when().get(""/hello"")
                .then()
                .statusCode(200)
                .body(is(""hello""));
    }
",non-flaky,5
76690,quarkusio_quarkus,SimpleET.testGreetingEndpoint,"    @Test
    public void testGreetingEndpoint() {
        String uuid = UUID.randomUUID().toString();
        given()
                .pathParam(""name"", uuid)
                .when().get(""/hello/greeting/{name}"")
                .then()
                .statusCode(200)
                .body(is(""hello "" + uuid));
    }
",non-flaky,5
76691,quarkusio_quarkus,ParamET.testHelloEndpoint,"    @Test
    public void testHelloEndpoint() {
        given()
                .when().get(""/hello"")
                .then()
                .statusCode(200)
                .body(is(""hello""));
    }
",non-flaky,5
76692,quarkusio_quarkus,TaggedET.t1,"    @Test
    public void t1() {
        given()
                .when().get(""/hello/greeting/foo"")
                .then()
                .statusCode(200)
                .body(is(""hello foo""));
    }
",non-flaky,5
76693,quarkusio_quarkus,TaggedET.t2,"    @Test
    public void t2() {
        given()
                .when().get(""/hello/greeting/foo"")
                .then()
                .statusCode(200)
                .body(is(""hello foo""));
    }
",non-flaky,5
76694,quarkusio_quarkus,TaggedET.t3,"    @Test
    public void t3() {
        given()
                .when().get(""/hello/greeting/foo"")
                .then()
                .statusCode(200)
                .body(is(""hello foo""));
    }
",non-flaky,5
76695,quarkusio_quarkus,TaggedET.t4,"    @Test
    public void t4() {
        given()
                .when().get(""/hello/greeting/foo"")
                .then()
                .statusCode(200)
                .body(is(""hello foo""));
    }
",non-flaky,5
76696,quarkusio_quarkus,TaggedET.t5,"    @Test
    public void t5() {
        given()
                .when().get(""/hello/greeting/foo"")
                .then()
                .statusCode(200)
                .body(is(""hello foo""));
    }
",non-flaky,5
76697,quarkusio_quarkus,UnitET.unitStyleTest2,"    @Test
    public void unitStyleTest2() {
        Assertions.assertEquals(""UNIT"", UnitService.service());
    }
",non-flaky,5
76698,quarkusio_quarkus,UnitET.unitStyleTest,"    @Test
    public void unitStyleTest() {
        HelloResource res = new HelloResource();
        Assertions.assertEquals(""Hi"", res.sayHello());
    }
",non-flaky,5
76699,quarkusio_quarkus,DuplicateSimpleET.testHelloEndpoint,"    @Test
    public void testHelloEndpoint() {
        given()
                .when().get(""/hello"")
                .then()
                .statusCode(200)
                .body(is(""hello""));
    }
",non-flaky,5
76700,quarkusio_quarkus,DuplicateSimpleET.testGreetingEndpoint,"    @Test
    public void testGreetingEndpoint() {
        String uuid = UUID.randomUUID().toString();
        given()
                .pathParam(""name"", uuid)
                .when().get(""/hello/greeting/{name}"")
                .then()
                .statusCode(200)
                .body(is(""hello "" + uuid));
    }
",non-flaky,5
76701,quarkusio_quarkus,FooET.foo,"    @Test
    public void foo() {
        given()
                .when().get(""/hello/greeting/foo"")
                .then()
                .statusCode(200)
                .body(is(""hello foo""));
    }
",non-flaky,5
76702,quarkusio_quarkus,BarET.bar,"    @Test
    public void bar() {
        given()
                .when().get(""/hello/greeting/foo"")
                .then()
                .statusCode(200)
                .body(is(""hello foo""));
    }
",non-flaky,5
76703,quarkusio_quarkus,SimpleET.testHelloEndpoint,"    @Test
    public void testHelloEndpoint() {
        given()
                .when().get(""/hello"")
                .then()
                .statusCode(200)
                .body(is(""hello""));
    }
",non-flaky,5
76704,quarkusio_quarkus,SimpleET.testGreetingEndpoint,"    @Test
    public void testGreetingEndpoint() {
        String uuid = UUID.randomUUID().toString();
        given()
                .pathParam(""name"", uuid)
                .when().get(""/hello/greeting/{name}"")
                .then()
                .statusCode(200)
                .body(is(""hello "" + uuid));
    }
",non-flaky,5
76705,quarkusio_quarkus,MongoDbRestDataPanacheIT.testDevServicesProperties,"    @Test
    public void testDevServicesProperties() {
        assertThat(context.devServicesProperties()).hasSize(1).containsKey(""quarkus.mongodb.connection-string"");
    }
",non-flaky,5
76706,quarkusio_quarkus,CoreReflectionInGraalITCase.testFieldAndGetterReflectionOnEntityFromServlet,"    @Test
    public void testFieldAndGetterReflectionOnEntityFromServlet() throws Exception {
        RestAssured.when().get(""/core/reflection"").then()
                .body(is(""OK""));
    }
",non-flaky,5
76707,quarkusio_quarkus,ResourcesITCase.excludedNative,"    @Test
    public void excludedNative() {
        RestAssured.when()
                .get(""/resources/test-resources/file.adoc"")
                .then()
                .statusCode(404);

        RestAssured.when()
                .get(""/resources/test-resources/excluded/unwanted.txt"")
                .then()
                .statusCode(404);

        RestAssured.when()
                .get(""/resources/META-INF/quarkus-native-resources.txt"")
                .then()
                .statusCode(404);
    }
",non-flaky,5
76708,quarkusio_quarkus,CharacterSetSupportITCase.testFieldAndGetterReflectionOnEntityFromServlet,"    @Test
    public void testFieldAndGetterReflectionOnEntityFromServlet() throws Exception {
        RestAssured.when().get(""/core/charsetsupport"").then()
                .body(is(""OK""));
    }
",non-flaky,5
76709,quarkusio_quarkus,RegisterForReflectionITCase.testSelfWithoutNested,"    @Test
    public void testSelfWithoutNested() {
        final String resourceA = BASE_PKG + "".ResourceA"";

        assertRegistration(""ResourceA"", resourceA);
        assertRegistration(""FAILED"", resourceA + ""$InnerClassOfA"");
        assertRegistration(""FAILED"", resourceA + ""$StaticClassOfA"");
        assertRegistration(""FAILED"", resourceA + ""$InterfaceOfA"");
    }
",non-flaky,5
76710,quarkusio_quarkus,RegisterForReflectionITCase.testSelfWithNested,"    @Test
    public void testSelfWithNested() {
        final String resourceB = BASE_PKG + "".ResourceB"";

        assertRegistration(""ResourceB"", resourceB);
        assertRegistration(""InnerClassOfB"", resourceB + ""$InnerClassOfB"");
        assertRegistration(""StaticClassOfB"", resourceB + ""$StaticClassOfB"");
        assertRegistration(""InterfaceOfB"", resourceB + ""$InterfaceOfB"");
        assertRegistration(""InnerInnerOfB"", resourceB + ""$InnerClassOfB$InnerInnerOfB"");
    }
",non-flaky,5
76711,quarkusio_quarkus,RegisterForReflectionITCase.testTargetWithNested,"    @Test
    public void testTargetWithNested() {
        final String resourceC = BASE_PKG + "".ResourceC"";

        assertRegistration(""FAILED"", resourceC);
        assertRegistration(""InaccessibleClassOfC"", resourceC + ""$InaccessibleClassOfC"");
        assertRegistration(""OtherInaccessibleClassOfC"", resourceC + ""$InaccessibleClassOfC$OtherInaccessibleClassOfC"");
    }
",non-flaky,5
76712,quarkusio_quarkus,RegisterForReflectionITCase.testTargetWithoutNested,"    @Test
    public void testTargetWithoutNested() {
        final String resourceD = BASE_PKG + "".ResourceD"";

        assertRegistration(""FAILED"", resourceD);
        assertRegistration(""StaticClassOfD"", resourceD + ""$StaticClassOfD"");
        assertRegistration(""FAILED"", resourceD + ""$StaticClassOfD$OtherAccessibleClassOfD"");
    }
",non-flaky,5
76713,quarkusio_quarkus,CoreSerializationInGraalITCase.testEntitySerializationFromServlet,"    @Test
    public void testEntitySerializationFromServlet() throws Exception {
        RestAssured.when().get(""/core/serialization"").then()
                .body(is(""OK""));
    }
",non-flaky,5
76714,quarkusio_quarkus,JPAReflectionInGraalITCase.testFieldAndGetterReflectionOnEntityFromServlet,"    @Test
    public void testFieldAndGetterReflectionOnEntityFromServlet() throws Exception {
        RestAssured.when().get(""/jpa/testreflection"").then()
                .body(is(""OK""));
    }
",non-flaky,5
76715,quarkusio_quarkus,QuarkusCodestartBuildIT.testRunTogetherCodestartsJava,"    @Test
    public void testRunTogetherCodestartsJava() throws Exception {
        generateProjectRunTests(""maven"", ""java"", getExtensionCodestarts());
    }
",non-flaky,5
76716,quarkusio_quarkus,QuarkusCodestartBuildIT.testRunTogetherCodestartsKotlin,"    @Test
    public void testRunTogetherCodestartsKotlin() throws Exception {
        generateProjectRunTests(""maven"", ""kotlin"", getExtensionCodestarts());
    }
",non-flaky,5
76717,quarkusio_quarkus,QuarkusCodestartBuildIT.testRunTogetherCodestartsScala,"    @Test
    public void testRunTogetherCodestartsScala() throws Exception {
        generateProjectRunTests(""maven"", ""scala"", getExtensionCodestarts());
    }
",non-flaky,5
76718,quarkusio_quarkus,QuarkusCodestartBuildIT.testGradle,"    @ParameterizedTest
    public void testGradle(String language) throws Exception {
        final List<String> codestarts = getExtensionCodestarts();
        generateProjectRunTests(""gradle"", language, codestarts);
    }
",non-flaky,5
76719,quarkusio_quarkus,QuarkusCodestartBuildIT.testGradleKotlinDSL,"    @ParameterizedTest
    public void testGradleKotlinDSL(String language) throws Exception {
        final List<String> codestarts = getExtensionCodestarts();
        generateProjectRunTests(""gradle-kotlin-dsl"", language, codestarts);
    }
",non-flaky,5
76720,quarkusio_quarkus,QuarkusCodestartBuildIT.testRunAloneCodestartsJava,"    @ParameterizedTest
    public void testRunAloneCodestartsJava(String codestart) throws Exception {
        generateProjectRunTests(""maven"", ""java"", singletonList(codestart));
    }
",non-flaky,5
76721,quarkusio_quarkus,QuarkusCodestartBuildIT.testRunAloneCodestartsKotlin,"    @ParameterizedTest
    public void testRunAloneCodestartsKotlin(String codestart) throws Exception {
        generateProjectRunTests(""maven"", ""kotlin"", singletonList(codestart));
    }
",non-flaky,5
76722,quarkusio_quarkus,QuarkusCodestartBuildIT.testRunAloneCodestartsScala,"    @ParameterizedTest
    public void testRunAloneCodestartsScala(String codestart) throws Exception {
        generateProjectRunTests(""maven"", ""scala"", singletonList(codestart));
    }
",non-flaky,5
76723,quarkusio_quarkus,QuarkusCodestartBuildIT.generateAzureFunctionsHttpExampleProjectRun,"    @Test
    public void generateAzureFunctionsHttpExampleProjectRun() throws Exception {
        generateProjectRunTests(""maven"", ""java"", singletonList(""azure-functions-http-example""));
    }
",non-flaky,5
76724,quarkusio_quarkus,JarRunnerIT.testNonAsciiDir,"    @Test
    public void testNonAsciiDir() throws Exception {
        final File testDir = initProject(""projects/classic"", ""projects/"");
        final RunningInvoker running = new RunningInvoker(testDir, false);

        final MavenProcessInvocationResult result = running.execute(Arrays.asList(""install"", ""-DskipTests""),
                Collections.emptyMap());
        await().atMost(1, TimeUnit.MINUTES).until(() -> result.getProcess() != null && !result.getProcess().isAlive());
        assertThat(running.log()).containsIgnoringCase(""BUILD SUCCESS"");
        running.stop();

        File output = new File(testDir, ""target/output.log"");
        output.createNewFile();

        Process process = doLaunch(new File(testDir, ""target/quarkus-app""), Paths.get(""quarkus-run.jar""), output,
                Collections.emptyList()).start();
        try {
            // Wait until server up
            dumpFileContentOnFailure(() -> {
                await().pollDelay(1, TimeUnit.SECONDS)
                        .atMost(1, TimeUnit.MINUTES).until(() -> DevModeTestUtils.getHttpResponse(""/app/hello/package"", 200));
                return null;
            }, output, ConditionTimeoutException.class);
        } finally {
            process.destroy();
        }

    }
",non-flaky,5
76725,quarkusio_quarkus,JarRunnerIT.testThatJarRunnerConsoleOutputWorksCorrectly,"    @Test
    public void testThatJarRunnerConsoleOutputWorksCorrectly() throws MavenInvocationException, IOException {
        File testDir = initProject(""projects/classic"", ""projects/project-classic-console-output"");
        RunningInvoker running = new RunningInvoker(testDir, false);

        MavenProcessInvocationResult result = running.execute(Arrays.asList(""package"", ""-DskipTests""), Collections.emptyMap());
        await().atMost(1, TimeUnit.MINUTES).until(() -> result.getProcess() != null && !result.getProcess().isAlive());
        assertThat(running.log()).containsIgnoringCase(""BUILD SUCCESS"");
        running.stop();

        Path jar = testDir.toPath().toAbsolutePath()
                .resolve(Paths.get(""target/quarkus-app/quarkus-run.jar""));
        File output = new File(testDir, ""target/output.log"");
        output.createNewFile();

        Process process = doLaunch(jar, output).start();
        try {
            // Wait until server up
            await()
                    .pollDelay(1, TimeUnit.SECONDS)
                    .atMost(1, TimeUnit.MINUTES).until(() -> DevModeTestUtils.getHttpResponse(""/app/hello/package"", 200));

            String logs = FileUtils.readFileToString(output, ""UTF-8"");

            assertThatOutputWorksCorrectly(logs);

            // test that the application name and version are properly set
            assertApplicationPropertiesSetCorrectly();
            assertResourceReadingFromClassPathWorksCorrectly("""");
            assertUsingProtectionDomainWorksCorrectly("""");
        } finally {
            process.destroy();
        }

    }
",non-flaky,5
76726,quarkusio_quarkus,JarRunnerIT.testPlatformPropertiesOverridenInApplicationProperties,"    @Test
    public void testPlatformPropertiesOverridenInApplicationProperties() throws Exception {
        final File testDir = initProject(""projects/platform-properties-overrides"",
                ""projects/platform-props-overriden-in-app-props"");
        final RunningInvoker running = new RunningInvoker(testDir, false);

        final MavenProcessInvocationResult result = running.execute(Arrays.asList(""install""),
                Collections.emptyMap());
        await().atMost(1, TimeUnit.MINUTES).until(() -> result.getProcess() != null && !result.getProcess().isAlive());
        assertThat(running.log()).containsIgnoringCase(""BUILD SUCCESS"");
        running.stop();

        File output = new File(testDir, ""app/target/output.log"");
        output.createNewFile();

        Process process = doLaunch(new File(testDir, ""app/target/quarkus-app""), Paths.get(""quarkus-run.jar""), output,
                Collections.emptyList()).start();
        try {
            Assertions.assertEquals(""builder-image is customized"", DevModeTestUtils.getHttpResponse(""/hello""));
        } finally {
            process.destroy();
        }
    }
",non-flaky,5
76727,quarkusio_quarkus,JarRunnerIT.testPlatformPropertiesOverridenOnCommandLine,"    @Test
    public void testPlatformPropertiesOverridenOnCommandLine() throws Exception {
        final File testDir = initProject(""projects/platform-properties-overrides"",
                ""projects/platform-props-overriden-on-cmd-line"");
        final RunningInvoker running = new RunningInvoker(testDir, false);

        final MavenProcessInvocationResult result = running.execute(
                Arrays.asList(""install -Dquarkus.native.builder-image=commandline -DskipTests""),
                Collections.emptyMap());
        await().atMost(1, TimeUnit.MINUTES).until(() -> result.getProcess() != null && !result.getProcess().isAlive());
        assertThat(running.log()).containsIgnoringCase(""BUILD SUCCESS"");
        running.stop();

        File output = new File(testDir, ""app/target/output.log"");
        output.createNewFile();

        Process process = doLaunch(new File(testDir, ""app/target/quarkus-app""), Paths.get(""quarkus-run.jar""), output,
                Collections.emptyList()).start();
        try {
            Assertions.assertEquals(""builder-image is commandline"", DevModeTestUtils.getHttpResponse(""/hello""));
        } finally {
            process.destroy();
        }
    }
",non-flaky,5
76728,quarkusio_quarkus,JarRunnerIT.testThatFastJarFormatWorks,"    @Test
    public void testThatFastJarFormatWorks() throws Exception {
        assertThatFastJarFormatWorks(null);
    }
",non-flaky,5
76729,quarkusio_quarkus,JarRunnerIT.testThatFastJarCustomOutputDirFormatWorks,"    @Test
    public void testThatFastJarCustomOutputDirFormatWorks() throws Exception {
        assertThatFastJarFormatWorks(""custom"");
    }
",non-flaky,5
76730,quarkusio_quarkus,JarRunnerIT.testThatMutableFastJarWorks,"    @Test
    public void testThatMutableFastJarWorks() throws Exception {
        assertThatMutableFastJarWorks(""providers"", ""providers"");
    }
",non-flaky,5
76731,quarkusio_quarkus,JarRunnerIT.testThatMutableFastJarWorksProvidersDirOutsideOutputDir,"    @Test
    public void testThatMutableFastJarWorksProvidersDirOutsideOutputDir() throws Exception {
        assertThatMutableFastJarWorks(""outsidedir"", "".."" + File.separator + ""providers"");
    }
",non-flaky,5
76732,quarkusio_quarkus,JarRunnerIT.testThatLegacyJarFormatWorks,"    @Test
    public void testThatLegacyJarFormatWorks() throws Exception {
        File testDir = initProject(""projects/rr-with-json-logging"", ""projects/rr-with-json-logging-legacy-jar"");
        RunningInvoker running = new RunningInvoker(testDir, false);

        MavenProcessInvocationResult result = running
                .execute(Arrays.asList(""package"",
                        ""-DskipTests"",
                        ""-Dquarkus.package.type=legacy-jar""), Collections.emptyMap());

        await().atMost(1, TimeUnit.MINUTES).until(() -> result.getProcess() != null && !result.getProcess().isAlive());
        assertThat(running.log()).containsIgnoringCase(""BUILD SUCCESS"");
        running.stop();

        Path jar = testDir.toPath().toAbsolutePath()
                .resolve(Paths.get(""target"",
                        JarResultBuildStep.DEFAULT_FAST_JAR_DIRECTORY_NAME,
                        ""quarkus-run.jar""));
        Assertions.assertFalse(Files.exists(jar));

        jar = testDir.toPath().toAbsolutePath()
                .resolve(Paths.get(""target/acme-1.0-SNAPSHOT-runner.jar""));
        Assertions.assertTrue(Files.exists(jar));

        Properties quarkusArtifactProperties = new Properties();
        quarkusArtifactProperties
                .load(new FileInputStream(testDir.toPath().resolve(""target"").resolve(""quarkus-artifact.properties"").toFile()));
        Assertions.assertEquals(""jar"", quarkusArtifactProperties.get(""type""));
        Assertions.assertEquals(""acme-1.0-SNAPSHOT-runner.jar"", quarkusArtifactProperties.get(""path""));

        File output = new File(testDir, ""target/output.log"");
        output.createNewFile();

        Properties properties = new Properties();
        properties
                .load(new FileInputStream(testDir.toPath().resolve(""target"").resolve(""quarkus-artifact.properties"").toFile()));
        Assertions.assertEquals(""jar"", properties.get(""type""));
        Assertions.assertEquals(""acme-1.0-SNAPSHOT-runner.jar"", properties.get(""path""));

        Process process = doLaunch(jar, output).start();
        try {
            // Wait until server up
            dumpFileContentOnFailure(() -> {
                await()
                        .pollDelay(1, TimeUnit.SECONDS)
                        .atMost(1, TimeUnit.MINUTES).until(() -> DevModeTestUtils.getHttpResponse(""/app/hello/package"", 200));
                return null;
            }, output, ConditionTimeoutException.class);

            String logs = FileUtils.readFileToString(output, ""UTF-8"");

            assertThat(logs).isNotEmpty().contains(""resteasy-reactive"");

            // test that the application name and version are properly set
            assertApplicationPropertiesSetCorrectly();
            assertResourceReadingFromClassPathWorksCorrectly("""");
            assertUsingProtectionDomainWorksCorrectly("""");
        } finally {
            process.destroy();
        }
    }
",non-flaky,5
76733,quarkusio_quarkus,JarRunnerIT.testThatAppCDSAreUsable,"    @Test
    public void testThatAppCDSAreUsable() throws Exception {
        File testDir = initProject(""projects/classic"", ""projects/project-classic-console-output-appcds"");
        RunningInvoker running = new RunningInvoker(testDir, false);

        MavenProcessInvocationResult result = running
                .execute(Arrays.asList(""package"", ""-DskipTests"", ""-Dquarkus.package.create-appcds=true""),
                        Collections.emptyMap());

        await().atMost(1, TimeUnit.MINUTES).until(() -> result.getProcess() != null && !result.getProcess().isAlive());
        assertThat(running.log()).containsIgnoringCase(""BUILD SUCCESS"");
        running.stop();

        Path jar = testDir.toPath().toAbsolutePath()
                .resolve(Paths.get(""target/quarkus-app/quarkus-run.jar""));
        File output = new File(testDir, ""target/output.log"");
        output.createNewFile();

        // by using '-Xshare:on' we ensure that the JVM will fail if for any reason is cannot use the AppCDS
        // '-Xlog:class+path=info' will print diagnostic information that is useful for debugging if something goes wrong
        Process process = doLaunch(jar.getFileName(), output,
                Arrays.asList(""-XX:SharedArchiveFile=app-cds.jsa"", ""-Xshare:on"", ""-Xlog:class+path=info""))
                        .directory(jar.getParent().toFile()).start();
        try {
            // Wait until server up
            dumpFileContentOnFailure(() -> {
                await()
                        .pollDelay(1, TimeUnit.SECONDS)
                        .atMost(1, TimeUnit.MINUTES).until(() -> DevModeTestUtils.getHttpResponse(""/app/hello/package"", 200));
                return null;
            }, output, ConditionTimeoutException.class);

            String logs = FileUtils.readFileToString(output, ""UTF-8"");

            assertThatOutputWorksCorrectly(logs);
        } finally {
            process.destroy();
        }

    }
",non-flaky,5
76734,quarkusio_quarkus,JarRunnerIT.testArcExcludeDependencyOnLocalModule,"    @Test
    public void testArcExcludeDependencyOnLocalModule() throws Exception {
        File testDir = initProject(""projects/arc-exclude-dependencies"");
        RunningInvoker running = new RunningInvoker(testDir, false);

        MavenProcessInvocationResult result = running.execute(Arrays.asList(""package"", ""-DskipTests""), Collections.emptyMap());
        await().atMost(1, TimeUnit.MINUTES).until(() -> result.getProcess() != null && !result.getProcess().isAlive());
        assertThat(running.log()).containsIgnoringCase(""BUILD SUCCESS"");
        running.stop();

        File targetDir = new File(testDir.getAbsoluteFile(), ""runner"" + File.separator + ""target"");
        Path jar = targetDir.toPath().toAbsolutePath()
                .resolve(Paths.get(""quarkus-app/quarkus-run.jar""));
        File output = new File(targetDir, ""output.log"");
        output.createNewFile();

        Process process = doLaunch(jar, output).start();
        try {
            // Wait until server up
            AtomicReference<String> response = new AtomicReference<>();
            await()
                    .pollDelay(1, TimeUnit.SECONDS)
                    .atMost(1, TimeUnit.MINUTES).until(() -> {
                        String ret = DevModeTestUtils.getHttpResponse(""/hello"", true);
                        response.set(ret);
                        return ret.contains(""hello:"");
                    });

            // Test that bean is not resolvable
            assertThat(response.get()).containsIgnoringCase(""hello:false"");
        } finally {
            process.destroy();
        }
    }
",non-flaky,5
76735,quarkusio_quarkus,CreateExtensionMojoIT.testCreateCoreExtension,"    @Test
    public void testCreateCoreExtension(TestInfo testInfo) throws Throwable {
        testDir = initProject(""projects/create-extension-quarkus-core"", ""output/create-extension-quarkus-core"");
        assertThat(testDir).isDirectory();
        invoker = initInvoker(testDir);

        Properties properties = new Properties();
        properties.put(""extensionId"", ""my-ext"");
        InvocationResult result = setup(properties);

        assertThat(result.getExitCode()).isZero();

        final Path testDirPath = testDir.toPath();
        assertThatDirectoryTreeMatchSnapshots(testInfo, testDirPath)
                .contains(
                        ""extensions/my-ext/pom.xml"",
                        ""extensions/my-ext/runtime/src/main/resources/META-INF/quarkus-extension.yaml"",
                        ""extensions/my-ext/deployment/src/main/java/org/acme/my/ext/deployment/MyExtProcessor.java"",
                        ""integration-tests/my-ext/pom.xml"",
                        ""integration-tests/my-ext/src/test/java/org/acme/my/ext/it/MyExtResourceTest.java"");
        assertThatMatchSnapshot(testInfo, testDirPath, ""extensions/my-ext/pom.xml"");
        assertThatMatchSnapshot(testInfo, testDirPath,
                ""extensions/my-ext/runtime/src/main/resources/META-INF/quarkus-extension.yaml"");
        assertThatMatchSnapshot(testInfo, testDirPath, ""bom/application/pom.xml"");
        assertThatMatchSnapshot(testInfo, testDirPath, ""integration-tests/pom.xml"");
        assertThatMatchSnapshot(testInfo, testDirPath, ""extensions/pom.xml"");
    }
",non-flaky,5
76736,quarkusio_quarkus,CreateExtensionMojoIT.testCreateCoreExtensionFromExtensionsDir,"    @Test
    public void testCreateCoreExtensionFromExtensionsDir(TestInfo testInfo) throws Throwable {
        testDir = initProject(""projects/create-extension-quarkus-core"", ""output/create-extension-quarkus-core-extensions-dir"");
        assertThat(testDir).isDirectory();
        invoker = initInvoker(testDir.toPath().resolve(""extensions/"").toFile());

        Properties properties = new Properties();
        properties.put(""extensionId"", ""quarkus-my-ext"");
        InvocationResult result = setup(properties);

        assertThat(result.getExitCode()).isZero();

        final Path testDirPath = testDir.toPath();
        assertThatDirectoryTreeMatchSnapshots(testInfo, testDirPath)
                .contains(
                        ""extensions/my-ext/pom.xml"",
                        ""extensions/my-ext/deployment/src/main/java/org/acme/my/ext/deployment/MyExtProcessor.java"",
                        ""integration-tests/my-ext/pom.xml"",
                        ""integration-tests/my-ext/src/test/java/org/acme/my/ext/it/MyExtResourceTest.java"");
        assertThatMatchSnapshot(testInfo, testDirPath, ""extensions/my-ext/pom.xml"");
        assertThatMatchSnapshot(testInfo, testDirPath,
                ""extensions/my-ext/runtime/src/main/resources/META-INF/quarkus-extension.yaml"");
        assertThatMatchSnapshot(testInfo, testDirPath, ""bom/application/pom.xml"");
        assertThatMatchSnapshot(testInfo, testDirPath, ""integration-tests/pom.xml"");
        assertThatMatchSnapshot(testInfo, testDirPath, ""extensions/pom.xml"");
    }
",non-flaky,5
76737,quarkusio_quarkus,CreateExtensionMojoIT.testCreateQuarkiverseExtension,"    @Test
    public void testCreateQuarkiverseExtension(TestInfo testInfo) throws Throwable {
        testDir = initEmptyProject(""output/create-quarkiverse-extension"");
        assertThat(testDir).isDirectory();
        invoker = initInvoker(testDir);

        Properties properties = new Properties();
        properties.put(""groupId"", ""io.quarkiverse.my-quarki-ext"");
        properties.put(""extensionId"", ""my-quarki-ext"");
        properties.put(""quarkusVersion"", ""1.10.5.Final"");
        InvocationResult result = setup(properties);

        assertThat(result.getExitCode()).isZero();

        final Path testDirPath = testDir.toPath();
        assertThatDirectoryTreeMatchSnapshots(testInfo, testDirPath)
                .contains(
                        ""quarkus-my-quarki-ext/pom.xml"",
                        ""quarkus-my-quarki-ext/deployment/src/main/java/io/quarkiverse/my/quarki/ext/deployment/MyQuarkiExtProcessor.java"",
                        ""quarkus-my-quarki-ext/integration-tests/pom.xml"",
                        ""quarkus-my-quarki-ext/integration-tests/src/test/java/io/quarkiverse/my/quarki/ext/it/MyQuarkiExtResourceTest.java"");
        assertThatMatchSnapshot(testInfo, testDirPath, ""quarkus-my-quarki-ext/pom.xml"");
        assertThatMatchSnapshot(testInfo, testDirPath, ""quarkus-my-quarki-ext/runtime/pom.xml"");
    }
",non-flaky,5
76738,quarkusio_quarkus,CreateExtensionMojoIT.testCreateStandaloneExtension,"    @Test
    public void testCreateStandaloneExtension(TestInfo testInfo) throws Throwable {
        testDir = initEmptyProject(""output/create-standalone-extension"");
        assertThat(testDir).isDirectory();
        invoker = initInvoker(testDir);

        Properties properties = new Properties();
        properties.put(""groupId"", ""io.standalone"");
        properties.put(""extensionId"", ""my-own-ext"");
        properties.put(""namespaceId"", ""my-org-"");
        properties.put(""quarkusVersion"", ""1.10.5.Final"");
        InvocationResult result = setup(properties);

        assertThat(result.getExitCode()).isZero();

        final Path testDirPath = testDir.toPath();
        assertThatDirectoryTreeMatchSnapshots(testInfo, testDirPath)
                .contains(
                        ""my-org-my-own-ext/pom.xml"",
                        ""my-org-my-own-ext/deployment/src/main/java/io/standalone/my/own/ext/deployment/MyOwnExtProcessor.java"",
                        ""my-org-my-own-ext/integration-tests/pom.xml"",
                        ""my-org-my-own-ext/integration-tests/src/test/java/io/standalone/my/own/ext/it/MyOwnExtResourceTest.java"");
        assertThatMatchSnapshot(testInfo, testDirPath, ""my-org-my-own-ext/pom.xml"");
        assertThatMatchSnapshot(testInfo, testDirPath, ""my-org-my-own-ext/runtime/pom.xml"");
    }
",non-flaky,5
76739,quarkusio_quarkus,RemoteDevMojoIT.testThatTheApplicationIsReloadedOnJavaChange,"    @Test
    public void testThatTheApplicationIsReloadedOnJavaChange()
            throws MavenInvocationException, IOException, InterruptedException {
        testDir = initProject(""projects/classic-remote-dev"", ""projects/project-classic-run-java-change-remote"");
        agentDir = initProject(""projects/classic-remote-dev"", ""projects/project-classic-run-java-change-local"");
        runAndCheck();

        // Edit the ""Hello"" message.
        File source = new File(agentDir, ""src/main/java/org/acme/HelloResource.java"");
        String uuid = UUID.randomUUID().toString();
        filter(source, Collections.singletonMap(""return \""hello\"";"", ""return \"""" + uuid + ""\"";""));

        // Wait until we get ""uuid""
        await()
                .pollDelay(1, TimeUnit.SECONDS)
                .atMost(1, TimeUnit.MINUTES).until(() -> DevModeTestUtils.getHttpResponse(""/app/hello"").contains(uuid));

        await()
                .pollDelay(1, TimeUnit.SECONDS)
                .pollInterval(1, TimeUnit.SECONDS)
                .until(source::isFile);

        filter(source, Collections.singletonMap(uuid, ""carambar""));

        // Wait until we get ""carambar""
        await()
                .pollDelay(1, TimeUnit.SECONDS)
                .atMost(1, TimeUnit.MINUTES).until(() -> DevModeTestUtils.getHttpResponse(""/app/hello"").contains(""carambar""));

        //also verify that the dev ui console is disabled
        DevModeTestUtils.getHttpResponse(""/q/dev"", 404, 10, TimeUnit.SECONDS);
    }
",non-flaky,5
76740,quarkusio_quarkus,RemoteDevMojoIT.foo,"    @Test
    public void testThatTheApplicationIsReloadedOnNewResource() throws MavenInvocationException, IOException {
        testDir = initProject(""projects/classic-remote-dev"", ""projects/project-classic-run-new-resource-remote"");
        agentDir = initProject(""projects/classic-remote-dev"", ""projects/project-classic-run-new-resource-local"");
        runAndCheck();

        File source = new File(agentDir, ""src/main/java/org/acme/MyNewResource.java"");
        String myNewResource = ""package org.acme;\n"" +
                ""\n"" +
                ""import javax.ws.rs.GET;\n"" +
                ""import javax.ws.rs.Path;\n"" +
                ""import javax.ws.rs.Produces;\n"" +
                ""import javax.ws.rs.core.MediaType;\n"" +
                ""\n"" +
                ""@Path(\""/foo\"")\n"" +
                ""public class MyNewResource {\n"" +

                ""    @GET\n"" +
                ""    @Produces(MediaType.TEXT_PLAIN)\n"" +
                ""    public String foo() {\n"" +
                ""        return \""bar\"";\n"" +
                ""    }\n"" +
",non-flaky,5
76741,quarkusio_quarkus,RemoteDevMojoIT.testThatTheApplicationIsReloadedOnConfigChange,"    @Test
    public void testThatTheApplicationIsReloadedOnConfigChange() throws MavenInvocationException, IOException {
        testDir = initProject(""projects/classic-remote-dev"", ""projects/project-classic-run-config-change-remote"");
        agentDir = initProject(""projects/classic-remote-dev"", ""projects/project-classic-run-config-change-local"");
        assertThat(testDir).isDirectory();
        runAndCheck();

        String resp = DevModeTestUtils.getHttpResponse();
        runningAgent = new RunningInvoker(agentDir, false);
        runningAgent.execute(Arrays.asList(""compile"", ""quarkus:remote-dev""), Collections.emptyMap());

        assertThat(resp).containsIgnoringCase(""ready"").containsIgnoringCase(""application"").containsIgnoringCase(""org.acme"")
                .containsIgnoringCase(""1.0-SNAPSHOT"");

        String greeting = DevModeTestUtils.getHttpResponse(""/app/hello/greeting"");
        assertThat(greeting).containsIgnoringCase(""bonjour"");

        File source = new File(agentDir, ""src/main/resources/application.properties"");
        await()
                .pollDelay(1, TimeUnit.SECONDS)
                .pollInterval(1, TimeUnit.SECONDS)
                .until(source::isFile);

        String uuid = UUID.randomUUID().toString();
        filter(source, Collections.singletonMap(""bonjour"", uuid));

        // Wait until we get ""uuid""
        await()
                .pollDelay(1, TimeUnit.SECONDS)
                .atMost(1, TimeUnit.MINUTES)
                .until(() -> DevModeTestUtils.getHttpResponse(""/app/hello/greeting"").contains(uuid));
    }
",non-flaky,5
76742,quarkusio_quarkus,RemoteDevMojoIT.testThatNewResourcesAreServed,"    @Test
    public void testThatNewResourcesAreServed() throws MavenInvocationException, IOException {
        testDir = initProject(""projects/classic-remote-dev"", ""projects/project-classic-run-resource-change-remote"");
        agentDir = initProject(""projects/classic-remote-dev"", ""projects/project-classic-run-resource-change-local"");
        runAndCheck();

        // Create a new resource
        File source = new File(agentDir, ""src/main/resources/META-INF/resources/lorem.txt"");
        FileUtils.write(source,
                ""Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."",
                ""UTF-8"");
        await()
                .pollDelay(1, TimeUnit.SECONDS)
                .atMost(1, TimeUnit.MINUTES)
                .until(() -> DevModeTestUtils.getHttpResponse(""/lorem.txt"").contains(""Lorem ipsum""));

        // Update the resource
        String uuid = UUID.randomUUID().toString();
        FileUtils.write(source, uuid, ""UTF-8"");
        await()
                .pollDelay(1, TimeUnit.SECONDS)
                .atMost(1, TimeUnit.MINUTES)
                .until(() -> DevModeTestUtils.getHttpResponse(""/lorem.txt"").contains(uuid));

        // Delete the resource
        //TODO: not supported yet in remote dev
        //        source.delete();
        //        await()
        //                .pollDelay(1, TimeUnit.SECONDS)
        //                .atMost(1, TimeUnit.MINUTES)
        //                .until(() -> getHttpResponse(""/lorem.txt"", 404));
    }
",non-flaky,5
76743,quarkusio_quarkus,RemoteDevMojoIT.testThatApplicationRecoversCompilationIssue,"    @Test
    public void testThatApplicationRecoversCompilationIssue() throws MavenInvocationException, IOException {
        testDir = initProject(""projects/classic-remote-dev"", ""projects/project-classic-run-compilation-issue-remote"");
        agentDir = initProject(""projects/classic-remote-dev"", ""projects/project-classic-run-compilation-issue-local"");
        runAndCheck();

        // Edit the ""Hello"" message.
        File source = new File(agentDir, ""src/main/java/org/acme/HelloResource.java"");
        String uuid = UUID.randomUUID().toString();
        filter(source, Collections.singletonMap(""return \""hello\"";"", ""return \"""" + uuid + ""\"""")); // No semi-colon

        // Wait until we get ""uuid""
        AtomicReference<String> last = new AtomicReference<>();
        await()
                .pollDelay(1, TimeUnit.SECONDS)
                .atMost(1, TimeUnit.MINUTES).until(() -> {
                    String content = DevModeTestUtils.getHttpResponse(""/app/hello"", true);
                    last.set(content);
                    return content.contains(uuid);
                });

        assertThat(last.get()).containsIgnoringCase(""error"")
                .containsIgnoringCase(""return \"""" + uuid + ""\"""")
                .containsIgnoringCase(""compile"");

        await()
                .pollDelay(1, TimeUnit.SECONDS)
                .pollInterval(1, TimeUnit.SECONDS)
                .until(source::isFile);
        filter(source, Collections.singletonMap(""\"""" + uuid + ""\"""", ""\""carambar\"";""));

        // Wait until we get ""uuid""
        await()
                .pollDelay(1, TimeUnit.SECONDS)
                .atMost(1, TimeUnit.MINUTES).until(() -> DevModeTestUtils.getHttpResponse(""/app/hello"").contains(""carambar""));
    }
",non-flaky,5
76744,quarkusio_quarkus,RemoteDevMojoIT.get,"    @Test
    public void testThatNewBeanAreDiscovered() throws IOException, MavenInvocationException {
        testDir = initProject(""projects/classic-remote-dev"", ""projects/project-classic-run-new-bean-remote"");
        agentDir = initProject(""projects/classic-remote-dev"", ""projects/project-classic-run-run-new-bean-local"");
        runAndCheck();

        // Edit the ""Hello"" message.
        File source = new File(agentDir, ""src/main/java/org/acme/MyBean.java"");
        String content = ""package org.acme;\n"" +
                ""\n"" +
                ""import javax.enterprise.context.ApplicationScoped;\n"" +
                ""\n"" +
                ""@ApplicationScoped\n"" +
                ""public class MyBean {\n"" +
                ""\n"" +
                ""    public String get() {\n"" +
                ""        return \""message\"";\n"" +
                ""    }\n"" +
",non-flaky,5
76745,quarkusio_quarkus,CreateJBangProjectMojoIT.testProjectGeneration,"    @Test
    public void testProjectGeneration() throws MavenInvocationException, IOException {
        testDir = initEmptyProject(""projects/project-generation"");
        assertThat(testDir).isDirectory();
        invoker = initInvoker(testDir);

        Properties properties = new Properties();
        properties.put(""outputDirectory"", ""jbang"");
        InvocationResult result = setup(properties);

        assertThat(result.getExitCode()).isZero();
    }
",non-flaky,5
76746,quarkusio_quarkus,CreateProjectMojoIT.testProjectGenerationFromScratch,"    @Test
    public void testProjectGenerationFromScratch() throws MavenInvocationException, IOException {
        testDir = initEmptyProject(""projects/project-generation"");
        assertThat(testDir).isDirectory();
        invoker = initInvoker(testDir);

        Properties properties = new Properties();
        properties.put(""projectGroupId"", ""org.acme"");
        properties.put(""projectArtifactId"", ""acme"");
        properties.put(""projectVersion"", ""1.0.0-SNAPSHOT"");

        InvocationResult result = setup(properties);

        assertThat(result.getExitCode()).isZero();

        // As the directory is not empty (log) navigate to the artifactID directory
        testDir = new File(testDir, ""acme"");

        assertThat(new File(testDir, ""pom.xml"")).isFile();
        assertThat(new File(testDir, ""src/main/java"")).isDirectory();
        assertThat(new File(testDir, ""src/main/resources/application.properties"")).isFile();

        String config = Files
                .asCharSource(new File(testDir, ""src/main/resources/application.properties""), Charsets.UTF_8)
                .read();
        assertThat(config).isEmpty();

        assertThat(new File(testDir, ""src/main/docker/Dockerfile.native"")).isFile();
        assertThat(new File(testDir, ""src/main/docker/Dockerfile.jvm"")).isFile();

        Model model = loadPom(testDir);
        final DependencyManagement dependencyManagement = model.getDependencyManagement();
        final List<Dependency> dependencies = dependencyManagement.getDependencies();
        assertThat(dependencies.stream()
                .anyMatch(d -> d.getArtifactId().equals(MojoUtils.TEMPLATE_PROPERTY_QUARKUS_PLATFORM_ARTIFACT_ID_VALUE)
                        && d.getVersion().equals(MojoUtils.TEMPLATE_PROPERTY_QUARKUS_PLATFORM_VERSION_VALUE)
                        && d.getScope().equals(""import"")
                        && d.getType().equals(""pom""))).isTrue();

        assertThat(
                model.getDependencies().stream().anyMatch(d -> d.getArtifactId().equalsIgnoreCase(""quarkus-resteasy"")
                        && d.getVersion() == null)).isTrue();

        assertThat(model.getProfiles()).hasSize(1);
        assertThat(model.getProfiles().get(0).getId()).isEqualTo(""native"");

        Xpp3Dom surefireSystemProperties = Optional.ofNullable(model.getBuild())
                .map(Build::getPlugins)
                .flatMap(plugins -> plugins.stream().filter(p -> p.getArtifactId().equals(""maven-surefire-plugin"")).findFirst())
                .map(Plugin::getConfiguration)
                .map(Xpp3Dom.class::cast)
                .map(cfg -> cfg.getChild(""systemPropertyVariables""))
                .orElse(null);
        assertThat(surefireSystemProperties).isNotNull();
        assertThat(surefireSystemProperties.getChild(""java.util.logging.manager""))
                .returns(LogManager.class.getName(), from(Xpp3Dom::getValue));
        assertThat(surefireSystemProperties.getChild(""maven.home""))
                .returns(""${maven.home}"", from(Xpp3Dom::getValue));
    }
",non-flaky,5
76747,quarkusio_quarkus,CreateProjectMojoIT.testProjectGenerationWithExistingPomFileWithPackagingJarShouldFail,"    @Test
    public void testProjectGenerationWithExistingPomFileWithPackagingJarShouldFail() throws Exception {
        testDir = initProject(""projects/simple-pom-it"", ""projects/project-generation-from-empty-pom"");
        assertThat(testDir).isDirectory();
        invoker = initInvoker(testDir);
        InvocationResult result = setup(new Properties());

        assertThat(result.getExitCode()).isOne();
    }
",non-flaky,5
76748,quarkusio_quarkus,CreateProjectMojoIT.testProjectGenerationWithExistingGradleFileShouldFail,"    @Test
    public void testProjectGenerationWithExistingGradleFileShouldFail() throws Exception {
        testDir = initProject(""projects/parent-gradle-it"", ""projects/project-generation-from-parent-gradle"");
        assertThat(testDir).isDirectory();
        invoker = initInvoker(testDir);
        InvocationResult result = setup(new Properties());

        assertThat(result.getExitCode()).isOne();
    }
",non-flaky,5
76749,quarkusio_quarkus,CreateProjectMojoIT.testGradleProjectGenerationWithExistingGradleFileShouldFail,"    @Test
    public void testGradleProjectGenerationWithExistingGradleFileShouldFail() throws Exception {
        testDir = initProject(""projects/parent-gradle-it"", ""projects/gradle-project-generation-from-parent-gradle"");
        assertThat(testDir).isDirectory();
        invoker = initInvoker(testDir);
        Properties properties = new Properties();
        properties.put(""projectGroupId"", ""org.acme"");
        properties.put(""projectArtifactId"", ""acme"");
        properties.put(""className"", ""org.acme.MyResource"");
        properties.put(""buildTool"", ""gradle"");
        InvocationResult result = setup(properties);

        assertThat(result.getExitCode()).isOne();
    }
",non-flaky,5
76750,quarkusio_quarkus,CreateProjectMojoIT.testGradleProjectGenerationWithExistingPomFileShouldFail,"    @Test
    public void testGradleProjectGenerationWithExistingPomFileShouldFail() throws Exception {
        testDir = initProject(""projects/parent-pom-it"", ""projects/gradle-project-generation-from-parent-pom"");
        assertThat(testDir).isDirectory();
        invoker = initInvoker(testDir);
        Properties properties = new Properties();
        properties.put(""projectGroupId"", ""org.acme"");
        properties.put(""projectArtifactId"", ""acme"");
        properties.put(""className"", ""org.acme.MyResource"");
        properties.put(""buildTool"", ""gradle"");
        InvocationResult result = setup(properties);

        assertThat(result.getExitCode()).isOne();
    }
",non-flaky,5
76751,quarkusio_quarkus,CreateProjectMojoIT.testProjectGenerationAsModuleWithExistingPomFileWithPackagingPom,"    @Test
    public void testProjectGenerationAsModuleWithExistingPomFileWithPackagingPom() throws Exception {
        testDir = initProject(""projects/parent-pom-it"", ""projects/project-generation-from-parent-pom"");
        assertThat(testDir).isDirectory();
        invoker = initInvoker(testDir);

        String projectArtifactId = ""acme"";
        Properties properties = new Properties();
        properties.put(""projectGroupId"", ""io.acme.it"");
        properties.put(""projectArtifactId"", projectArtifactId);
        properties.put(""projectVersion"", ""1.0-SNAPSHOT"");
        InvocationResult result = setup(properties);

        assertThat(result.getExitCode()).isZero();

        Model parentPomModel = loadPom(testDir);
        assertThat(parentPomModel.getModules()).isNotEmpty();
        assertThat(parentPomModel.getModules()).contains(projectArtifactId);

        Model modulePomModel = loadPom(new File(testDir, projectArtifactId));
        assertThat(modulePomModel.getParent()).isNotNull();
        assertThat(modulePomModel.getParent().getGroupId()).isEqualTo(""io.acme.it"");
        assertThat(modulePomModel.getParent().getArtifactId()).isEqualTo(""acme-parent-pom"");
        assertThat(modulePomModel.getParent().getVersion()).isEqualTo(""0.0.1.BUILD-SNAPSHOT"");
    }
",non-flaky,5
76752,quarkusio_quarkus,CreateProjectMojoIT.testProjectGenerationFromScratchWithResource,"    @Test
    public void testProjectGenerationFromScratchWithResource() throws Exception {
        testDir = initEmptyProject(""projects/project-generation-with-resource"");
        assertThat(testDir).isDirectory();
        invoker = initInvoker(testDir);

        Properties properties = new Properties();
        properties.put(""projectGroupId"", ""org.acme"");
        properties.put(""projectArtifactId"", ""acme"");
        properties.put(""className"", ""org.acme.MyResource.java"");
        properties.put(""extensions"", ""resteasy"");
        InvocationResult result = setup(properties);

        assertThat(result.getExitCode()).isZero();

        // As the directory is not empty (log) navigate to the artifactID directory
        testDir = new File(testDir, ""acme"");

        assertThat(new File(testDir, ""pom.xml"")).isFile();
        assertThat(new File(testDir, ""src/main/java"")).isDirectory();

        check(new File(testDir, ""src/main/java/org/acme/MyResource.java""), ""package org.acme;"");
    }
",non-flaky,5
76753,quarkusio_quarkus,CreateProjectMojoIT.testProjectGenerationWithInvalidPackage,"    @Test
    public void testProjectGenerationWithInvalidPackage() throws Exception {
        testDir = initEmptyProject(""projects/project-generation-invalid-package"");
        assertThat(testDir).isDirectory();
        invoker = initInvoker(testDir);

        Properties properties = new Properties();
        properties.put(""projectGroupId"", ""org.acme"");
        properties.put(""projectArtifactId"", ""acme"");
        properties.put(""className"", ""org.acme.invalid-package-name.MyResource"");

        InvocationResult result = setup(properties);

        assertThat(result.getExitCode()).isNotZero();
        assertThat(new File(testDir, ""src/main/java/org/acme"")).doesNotExist();
    }
",non-flaky,5
76754,quarkusio_quarkus,CreateProjectMojoIT.testProjectGenerationFromScratchWithMissingExtensionShouldFail,"    @Test
    public void testProjectGenerationFromScratchWithMissingExtensionShouldFail() throws Exception {
        testDir = initEmptyProject(""projects/project-generation-with-missing-extension"");
        assertThat(testDir).isDirectory();
        invoker = initInvoker(testDir);

        Properties properties = new Properties();
        properties.put(""projectGroupId"", ""org.acme"");
        properties.put(""projectArtifactId"", ""acme"");
        properties.put(""className"", ""org.acme.MyResource"");
        properties.put(""extensions"", ""resteasy,smallrye-metrics,missing"");
        InvocationResult result = setup(properties);

        assertThat(result.getExitCode()).isOne();
    }
",non-flaky,5
76755,quarkusio_quarkus,CreateProjectMojoIT.testProjectGenerationFromScratchWithExtensions,"    @Test
    public void testProjectGenerationFromScratchWithExtensions() throws Exception {
        testDir = initEmptyProject(""projects/project-generation-with-resources-and-extension"");
        assertThat(testDir).isDirectory();
        invoker = initInvoker(testDir);

        Properties properties = new Properties();
        properties.put(""projectGroupId"", ""org.acme"");
        properties.put(""projectArtifactId"", ""acme"");
        properties.put(""className"", ""org.acme.MyResource"");
        properties.put(""extensions"", ""resteasy,smallrye-metrics"");
        InvocationResult result = setup(properties);

        assertThat(result.getExitCode()).isZero();

        // As the directory is not empty (log) navigate to the artifactID directory
        testDir = new File(testDir, ""acme"");

        assertThat(new File(testDir, ""pom.xml"")).isFile();
        assertThat(new File(testDir, ""src/main/java"")).isDirectory();

        check(new File(testDir, ""src/main/java/org/acme/MyResource.java""), ""package org.acme;"");

        assertThat(FileUtils.readFileToString(new File(testDir, ""pom.xml""), ""UTF-8""))
                .contains(""quarkus-resteasy"", ""quarkus-smallrye-metrics"").doesNotContain(""missing"");

        Model model = loadPom(testDir);
        assertThat(model.getDependencyManagement().getDependencies().stream()
                .anyMatch(d -> d.getArtifactId().equals(MojoUtils.TEMPLATE_PROPERTY_QUARKUS_PLATFORM_ARTIFACT_ID_VALUE)
                        && d.getVersion().equals(MojoUtils.TEMPLATE_PROPERTY_QUARKUS_PLATFORM_VERSION_VALUE)
                        && d.getScope().equals(""import"")
                        && d.getType().equals(""pom""))).isTrue();

        assertThat(
                model.getDependencies().stream().anyMatch(d -> d.getArtifactId().equalsIgnoreCase(""quarkus-resteasy"")
                        && d.getVersion() == null)).isTrue();

        assertThat(model.getDependencies().stream()
                .anyMatch(d -> d.getArtifactId().equalsIgnoreCase(""quarkus-smallrye-metrics"")
                        && d.getVersion() == null)).isTrue();
    }
",non-flaky,5
76756,quarkusio_quarkus,CreateProjectMojoIT.testGradleProjectGenerationFromScratchWithExtensions,"    @Test
    public void testGradleProjectGenerationFromScratchWithExtensions() throws Exception {
        testDir = initEmptyProject(""projects/gradle-project-generation-with-extensions"");
        assertThat(testDir).isDirectory();
        invoker = initInvoker(testDir);

        Properties properties = new Properties();
        properties.put(""projectGroupId"", ""org.acme"");
        properties.put(""projectArtifactId"", ""acme"");
        properties.put(""className"", ""org.acme.MyResource"");
        properties.put(""extensions"", ""kotlin,resteasy,jackson"");
        properties.put(""buildTool"", ""gradle"");
        InvocationResult result = setup(properties);

        assertThat(result.getExitCode()).isZero();

        // As the directory is not empty (log) navigate to the artifactID directory
        testDir = new File(testDir, ""acme"");

        assertThat(new File(testDir, ""build.gradle"")).isFile();
        assertThat(new File(testDir, ""gradlew.bat"")).isFile();
        assertThat(new File(testDir, ""gradlew"")).isFile();
        assertThat(new File(testDir, ""gradle/wrapper"")).isDirectory();
        assertThat(new File(testDir, ""src/main/kotlin"")).isDirectory();

        check(new File(testDir, ""src/main/kotlin/org/acme/MyResource.kt""), ""package org.acme"");

        assertThat(FileUtils.readFileToString(new File(testDir, ""build.gradle""), ""UTF-8""))
                .contains(""quarkus-kotlin"", ""quarkus-jackson"").doesNotContain(""missing"");
    }
",non-flaky,5
76757,quarkusio_quarkus,CreateProjectMojoIT.testProjectGenerationFromScratchWithCustomDependencies,"    @Test
    public void testProjectGenerationFromScratchWithCustomDependencies() throws Exception {
        testDir = initEmptyProject(""projects/project-generation-with-resource-and-custom-deps"");
        assertThat(testDir).isDirectory();
        invoker = initInvoker(testDir);

        Properties properties = new Properties();
        properties.put(""projectGroupId"", ""org.acme"");
        properties.put(""projectArtifactId"", ""acme"");
        properties.put(""className"", ""org.acme.MyResource"");
        properties.put(""extensions"", ""resteasy,commons-io:commons-io:2.5"");
        InvocationResult result = setup(properties);

        assertThat(result.getExitCode()).isZero();

        // As the directory is not empty (log) navigate to the artifactID directory
        testDir = new File(testDir, ""acme"");

        assertThat(new File(testDir, ""pom.xml"")).isFile();
        assertThat(new File(testDir, ""src/main/java/org/acme/MyResource.java"")).isFile();
        assertThat(FileUtils.readFileToString(new File(testDir, ""pom.xml""), ""UTF-8""))
                .contains(""commons-io"");

        Model model = loadPom(testDir);
        assertThat(model.getDependencyManagement().getDependencies().stream()
                .anyMatch(d -> d.getArtifactId().equals(MojoUtils.TEMPLATE_PROPERTY_QUARKUS_PLATFORM_ARTIFACT_ID_VALUE)
                        && d.getVersion().equals(MojoUtils.TEMPLATE_PROPERTY_QUARKUS_PLATFORM_VERSION_VALUE)
                        && d.getScope().equals(""import"")
                        && d.getType().equals(""pom""))).isTrue();

        assertThat(
                model.getDependencies().stream().anyMatch(d -> d.getArtifactId().equalsIgnoreCase(""quarkus-resteasy"")
                        && d.getVersion() == null)).isTrue();

        assertThat(model.getDependencies().stream().anyMatch(d -> d.getArtifactId().equalsIgnoreCase(""commons-io"")
                && d.getVersion().equalsIgnoreCase(""2.5""))).isTrue();
    }
",non-flaky,5
76758,quarkusio_quarkus,CreateProjectMojoIT.testProjectGenerationFromScratchWithAppConfigParameter,"    @Test
    public void testProjectGenerationFromScratchWithAppConfigParameter() throws MavenInvocationException, IOException {
        testDir = initEmptyProject(""projects/project-generation-with-config-param"");
        assertThat(testDir).isDirectory();
        invoker = initInvoker(testDir);

        Properties properties = new Properties();
        properties.put(""projectGroupId"", ""org.acme"");
        properties.put(""projectArtifactId"", ""acme"");
        properties.put(""projectVersion"", ""1.0.0-SNAPSHOT"");

        List<String> configs = Arrays.asList(""custom.app.config1=val1"",
                ""custom.app.config2=val2"", ""lib.config=val3"");
        properties.put(""appConfig"", StringUtils.join(configs, "", ""));

        InvocationResult result = setup(properties);

        assertThat(result.getExitCode()).isZero();

        // As the directory is not empty (log) navigate to the artifactID directory
        testDir = new File(testDir, ""acme"");

        assertThat(new File(testDir, ""pom.xml"")).isFile();
        assertThat(new File(testDir, ""src/main/java"")).isDirectory();

        String file = Files
                .asCharSource(new File(testDir, ""src/main/resources/application.properties""), Charsets.UTF_8)
                .read();
        configs.forEach(conf -> Assertions.assertTrue(file.contains(conf)));

    }
",non-flaky,5
76759,quarkusio_quarkus,CreateProjectMojoIT.testThatDefaultPackageAreReplaced,"    @Test
    public void testThatDefaultPackageAreReplaced() throws Exception {
        testDir = initEmptyProject(""projects/default-package-test"");
        assertThat(testDir).isDirectory();
        invoker = initInvoker(testDir);

        Properties properties = new Properties();
        properties.put(""className"", ""MyGreatResource"");
        properties.put(""extensions"", ""resteasy"");
        InvocationResult result = setup(properties);

        assertThat(result.getExitCode()).isZero();
        // As the directory is not empty (log) navigate to the artifactID directory
        testDir = new File(testDir, ""code-with-quarkus"");
        check(new File(testDir, ""src/main/java/org/acme/MyGreatResource.java""),
                ""package org.acme;"");
    }
",non-flaky,5
76760,quarkusio_quarkus,CreateProjectMojoIT.cleanup,"    @AfterEach
    public void cleanup() {
        if (running != null) {
            running.stop();
        }
    }
",non-flaky,5
76761,quarkusio_quarkus,CreateProjectMojoIT.generateNewProjectAndRun,"    @Test
    public void generateNewProjectAndRun() throws Exception {
        testDir = initEmptyProject(""projects/project-generation-and-run"");

        // Scaffold the new project
        assertThat(testDir).isDirectory();
        invoker = initInvoker(testDir);

        Properties properties = new Properties();
        properties.put(""projectGroupId"", ""org.acme"");
        properties.put(""projectArtifactId"", ""acme"");
        properties.put(""extensions"", ""resteasy"");
        properties.put(""className"", ""org.acme.HelloResource"");
        InvocationResult result = setup(properties);

        assertThat(result.getExitCode()).isZero();

        // Run
        // As the directory is not empty (log) navigate to the artifactID directory
        testDir = new File(testDir, ""acme"");
        running = new RunningInvoker(testDir, false);
        final Properties mvnRunProps = new Properties();
        mvnRunProps.setProperty(""debug"", ""false"");
        running.execute(Arrays.asList(""compile"", ""quarkus:dev""), Collections.emptyMap(), mvnRunProps);

        String resp = DevModeTestUtils.getHttpResponse();

        assertThat(resp).containsIgnoringCase(""ready"").containsIgnoringCase(""application"").containsIgnoringCase(""org.acme"")
                .containsIgnoringCase(""1.0.0-SNAPSHOT"");

        String greeting = DevModeTestUtils.getHttpResponse(""/hello"");
        assertThat(greeting).containsIgnoringCase(""hello"");
    }
",non-flaky,5
76762,quarkusio_quarkus,NativeImageIT.testJavaLibraryPathAtRuntime,"    @Test
    public void testJavaLibraryPathAtRuntime() throws Exception {
        final File testDir = initProject(""projects/native-image-app"", ""projects/native-image-app-output"");
        final RunningInvoker running = new RunningInvoker(testDir, false);

        // trigger mvn package -Pnative -Dquarkus.ssl.native=true
        final String[] mvnArgs = new String[] { ""package"", ""-DskipTests"", ""-Pnative"", ""-Dquarkus.ssl.native=true"" };
        final MavenProcessInvocationResult result = running.execute(Arrays.asList(mvnArgs), Collections.emptyMap());
        await().atMost(10, TimeUnit.MINUTES).until(() -> result.getProcess() != null && !result.getProcess().isAlive());
        final String processLog = running.log();
        try {
            assertThat(processLog).containsIgnoringCase(""BUILD SUCCESS"");
        } catch (AssertionError ae) {
            // skip this test (instead of failing), if the native-image command wasn't available.
            // Bit brittle to rely on the log message, but it's OK in the context of this test
            Assumptions.assumeFalse(processLog.contains(""Cannot find the `native-image""),
                    ""Skipping test since native-image tool isn't available"");
            // native-image command was available but the build failed for some reason, throw the original error
            throw ae;
        } finally {
            running.stop();
        }

        // now that the native image is built, run it
        final Path nativeImageRunner = testDir.toPath().toAbsolutePath().resolve(Paths.get(""target/acme-1.0-SNAPSHOT-runner""));
        final Path tmpDir = Files.createTempDirectory(""native-image-test"");
        tmpDir.toFile().deleteOnExit();
        final Process nativeImageRunWithAdditionalLibPath = runNativeImage(nativeImageRunner,
                new String[] { ""-Djava.library.path="" + tmpDir.toString() });
        try {
            final String response = DevModeTestUtils.getHttpResponse(""/hello/javaLibraryPath"");
            Assertions.assertTrue(response.contains(tmpDir.toString()),
                    ""Response "" + response + "" for java.library.path was expected to contain the "" + tmpDir + "", but didn't"");
        } finally {
            nativeImageRunWithAdditionalLibPath.destroy();
        }

    }
",non-flaky,5
76763,quarkusio_quarkus,PackageIT.testUberJarMavenPluginConfiguration,"    @Test
    public void testUberJarMavenPluginConfiguration()
            throws MavenInvocationException, IOException, InterruptedException {
        testDir = initProject(""projects/uberjar-maven-plugin-config"");
        running = new RunningInvoker(testDir, false);
        final MavenProcessInvocationResult result = running.execute(Collections.singletonList(""package""),
                Collections.emptyMap());
        assertThat(result.getProcess().waitFor()).isEqualTo(0);

        verifyUberJar();
    }
",non-flaky,5
76764,quarkusio_quarkus,PackageIT.testQuarkusPackageOutputDirectory,"    @Test
    public void testQuarkusPackageOutputDirectory()
            throws MavenInvocationException, IOException, InterruptedException {
        testDir = initProject(""projects/quarkus.package.output-directory"");

        running = new RunningInvoker(testDir, false);
        // we do want to run the tests too
        final MavenProcessInvocationResult result = running.execute(Collections.singletonList(""package""),
                Collections.emptyMap());

        assertThat(result.getProcess().waitFor()).isEqualTo(0);

        File targetDir = getTargetDir();
        List<File> jars = getFilesEndingWith(targetDir, "".jar"");
        assertThat(jars).hasSize(1);

        targetDir = new File(targetDir, ""custom-output-dir"");
        assertThat(targetDir).exists();
        jars = getFilesEndingWith(targetDir, "".jar"");
        assertThat(jars).hasSize(1);
    }
",non-flaky,5
76765,quarkusio_quarkus,PackageIT.testDependencyOnPomMutableJar,"    @Test
    public void testDependencyOnPomMutableJar()
            throws MavenInvocationException, IOException, InterruptedException {
        testDir = initProject(""projects/dependency-on-pom"");

        running = new RunningInvoker(testDir, false);
        // we do want to run the tests too
        final MavenProcessInvocationResult result = running.execute(Collections.singletonList(""package""),
                Collections.emptyMap());

        assertThat(result.getProcess().waitFor()).isEqualTo(0);

        File targetDir = getTargetDir();
        List<File> jars = getFilesEndingWith(targetDir, "".jar"");
        assertThat(jars).hasSize(1);
    }
",non-flaky,5
76766,quarkusio_quarkus,PackageIT.testPackageWorksWhenUberjarIsTrue,"    @Test
    public void testPackageWorksWhenUberjarIsTrue()
            throws MavenInvocationException, IOException, InterruptedException {
        testDir = initProject(""projects/uberjar-check"");

        createAndVerifyUberJar();
        // ensure that subsequent package without clean also works
        createAndVerifyUberJar();
    }
",non-flaky,5
76767,quarkusio_quarkus,PackageIT.testCustomPackaging,"    @Test
    public void testCustomPackaging()
            throws Exception {
        testDir = getTargetDir(""projects/custom-packaging-plugin"");

        running = new RunningInvoker(testDir, false);
        MavenProcessInvocationResult result = running.execute(Collections.singletonList(""install""),
                Collections.emptyMap());
        assertThat(result.getProcess().waitFor()).isEqualTo(0);

        testDir = getTargetDir(""projects/custom-packaging-app"");

        running = new RunningInvoker(testDir, false);
        result = running.execute(Collections.singletonList(""package""),
                Collections.emptyMap());
        assertThat(result.getProcess().waitFor()).isEqualTo(0);

        final File targetDir = getTargetDir();
        final File[] files = targetDir.listFiles(f -> f.getName().endsWith("".jar""));
        Set<String> jarNames = new HashSet<>(files.length);
        for (File f : files) {
            jarNames.add(f.getName());
        }

        final Path runnerJar = getTargetDir().toPath().resolve(""quarkus-app"").resolve(""quarkus-run.jar"");
        Assertions.assertTrue(Files.exists(runnerJar), ""Runner jar "" + runnerJar + "" is missing"");
        assertZipEntriesCanBeOpenedAndClosed(runnerJar);
    }
",non-flaky,5
76768,quarkusio_quarkus,PackageIT.testRunnerUberJarHasValidCRC,"    @Test
    public void testRunnerUberJarHasValidCRC() throws Exception {
        testDir = initProject(""projects/uberjar-check"", ""projects/project-uberjar-crc"");

        running = new RunningInvoker(testDir, false);

        Properties p = new Properties();
        p.setProperty(""quarkus.package.type"", ""uber-jar"");
        final MavenProcessInvocationResult result = running.execute(Collections.singletonList(""package""),
                Collections.emptyMap(), p);
        assertThat(result.getProcess().waitFor()).isEqualTo(0);

        final File targetDir = getTargetDir();
        assertThat(getNumberOfFilesEndingWith(targetDir, "".jar"")).isEqualTo(1);
        assertThat(getNumberOfFilesEndingWith(targetDir, "".original"")).isEqualTo(1);

        final Path runnerJar = targetDir.toPath().resolve(""acme-1.0-SNAPSHOT-runner.jar"");
        Assertions.assertTrue(Files.exists(runnerJar), ""Runner jar "" + runnerJar + "" is missing"");
        assertZipEntriesCanBeOpenedAndClosed(runnerJar);
    }
",non-flaky,5
76769,quarkusio_quarkus,PackageIT.testLegacyJarHasValidCRC,"    @Test
    public void testLegacyJarHasValidCRC() throws Exception {
        testDir = initProject(""projects/uberjar-check"", ""projects/project-legacyjar-crc"");

        running = new RunningInvoker(testDir, false);
        final MavenProcessInvocationResult result = running.execute(Collections.singletonList(""package""),
                Collections.singletonMap(""QUARKUS_PACKAGE_TYPE"", ""legacy-jar""));

        assertThat(result.getProcess().waitFor()).isEqualTo(0);

        final File targetDir = getTargetDir();
        assertThat(getNumberOfFilesEndingWith(targetDir, "".jar"")).isEqualTo(2);

        final Path runnerJar = targetDir.toPath().resolve(""acme-1.0-SNAPSHOT-runner.jar"");
        Assertions.assertTrue(Files.exists(runnerJar), ""Runner jar "" + runnerJar + "" is missing"");
        assertZipEntriesCanBeOpenedAndClosed(runnerJar);
    }
",non-flaky,5
76770,quarkusio_quarkus,PackageIT.testFastJarHasValidCRC,"    @Test
    public void testFastJarHasValidCRC() throws Exception {
        testDir = initProject(""projects/uberjar-check"", ""projects/project-fastjar-crc"");

        running = new RunningInvoker(testDir, false);
        final MavenProcessInvocationResult result = running.execute(Collections.singletonList(""package""),
                Collections.emptyMap());

        assertThat(result.getProcess().waitFor()).isEqualTo(0);

        final Path runnerJar = getTargetDir().toPath().resolve(""quarkus-app"").resolve(""quarkus-run.jar"");
        Assertions.assertTrue(Files.exists(runnerJar), ""Runner jar "" + runnerJar + "" is missing"");
        assertZipEntriesCanBeOpenedAndClosed(runnerJar);
    }
",non-flaky,5
76771,quarkusio_quarkus,PackageIT.testQuarkusIndexDependencyOnLocalModule,"    @Test
    public void testQuarkusIndexDependencyOnLocalModule() throws Exception {
        testDir = initProject(""projects/quarkus-index-dependencies"");

        running = new RunningInvoker(testDir, false);
        final MavenProcessInvocationResult result = running.execute(Collections.singletonList(""package""),
                Collections.emptyMap());

        assertThat(result.getProcess().waitFor()).isEqualTo(0);

        final File targetDir = new File(testDir.getAbsoluteFile(), ""runner"" + File.separator + ""target"");

        final Path runnerJar = targetDir.toPath().resolve(""quarkus-app"").resolve(""quarkus-run.jar"");
        Assertions.assertTrue(Files.exists(runnerJar), ""Runner jar "" + runnerJar + "" is missing"");
        assertZipEntriesCanBeOpenedAndClosed(runnerJar);
    }
",non-flaky,5
76920,Tencent_Firestorm,RssShuffleUtilsTest.compressionTest,"  @Test
  public void compressionTest() {
    List<Integer> testSizes = Lists.newArrayList(
        1, 1024, 128 * 1024, 512 * 1024, 1024 * 1024, 4 * 1024 * 1024);
    for (int size : testSizes) {
      singleTest(size);
    }
  }
",non-flaky,5
76921,Tencent_Firestorm,RssShuffleUtilsTest.odfsConfigurationTest,"  @Test
  public void odfsConfigurationTest() {
    SparkConf conf = new SparkConf();
    Configuration conf1 = RssShuffleUtils.newHadoopConfiguration(conf);
    assertFalse(conf1.getBoolean(""dfs.namenode.odfs.enable"", false));
    assertEquals(""org.apache.hadoop.fs.Hdfs"", conf1.get(""fs.AbstractFileSystem.hdfs.impl""));

    conf.set(RssClientConfig.RSS_OZONE_DFS_NAMENODE_ODFS_ENABLE, ""true"");
    conf1 = RssShuffleUtils.newHadoopConfiguration(conf);
    assertTrue(conf1.getBoolean(""dfs.namenode.odfs.enable"", false));
    assertEquals(""org.apache.hadoop.odfs.HdfsOdfsFilesystem"", conf1.get(""fs.hdfs.impl""));
    assertEquals(""org.apache.hadoop.odfs.HdfsOdfs"", conf1.get(""fs.AbstractFileSystem.hdfs.impl""));

    conf.set(RssClientConfig.RSS_OZONE_FS_HDFS_IMPL, ""expect_odfs_impl"");
    conf.set(RssClientConfig.RSS_OZONE_FS_ABSTRACT_FILE_SYSTEM_HDFS_IMPL, ""expect_odfs_abstract_impl"");
    conf1 = RssShuffleUtils.newHadoopConfiguration(conf);
    assertEquals(""expect_odfs_impl"", conf1.get(""fs.hdfs.impl""));
    assertEquals(""expect_odfs_abstract_impl"", conf1.get(""fs.AbstractFileSystem.hdfs.impl""));
  }
",non-flaky,5
76922,Tencent_Firestorm,RssShuffleDataIteratorTest.readTest1,"  @Test
  public void readTest1() throws Exception {
    String basePath = HDFS_URI + ""readTest1"";
    HdfsShuffleWriteHandler writeHandler =
        new HdfsShuffleWriteHandler(""appId"", 0, 0, 1, basePath, ""test1"", conf);

    Map<String, String> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0);
    writeTestData(writeHandler, 2, 5, expectedData,
        blockIdBitmap, ""key"", KRYO_SERIALIZER, 0);

    RssShuffleDataIterator rssShuffleDataIterator = getDataIterator(basePath, blockIdBitmap, taskIdBitmap);

    validateResult(rssShuffleDataIterator, expectedData, 10);

    blockIdBitmap.add(ClientUtils.getBlockId(0, 0, Constants.MAX_SEQUENCE_NO));
    rssShuffleDataIterator = getDataIterator(basePath, blockIdBitmap, taskIdBitmap);
    int recNum = 0;
    try {
      // can't find all expected block id, data loss
      while (rssShuffleDataIterator.hasNext()) {
        rssShuffleDataIterator.next();
        recNum++;
      }
      fail(EXPECTED_EXCEPTION_MESSAGE);
    } catch (Exception e) {
      assertTrue(e.getMessage().startsWith(""Blocks read inconsistent:""));
    }
    assertEquals(10, recNum);
  }
",non-flaky,5
76923,Tencent_Firestorm,RssShuffleDataIteratorTest.readTest2,"  @Test
  public void readTest2() throws Exception {
    String basePath = HDFS_URI + ""readTest2"";
    HdfsShuffleWriteHandler writeHandler1 =
        new HdfsShuffleWriteHandler(""appId"", 0, 0, 1, basePath, ""test2_1"", conf);
    HdfsShuffleWriteHandler writeHandler2 =
        new HdfsShuffleWriteHandler(""appId"", 0, 0, 1, basePath, ""test2_2"", conf);

    Map<String, String> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0);
    writeTestData(writeHandler1, 2, 5, expectedData,
        blockIdBitmap, ""key1"", KRYO_SERIALIZER, 0);
    writeTestData(writeHandler2, 2, 5, expectedData,
        blockIdBitmap, ""key2"", KRYO_SERIALIZER, 0);

    RssShuffleDataIterator rssShuffleDataIterator = getDataIterator(basePath, blockIdBitmap, taskIdBitmap);

    validateResult(rssShuffleDataIterator, expectedData, 20);
    assertEquals(20, rssShuffleDataIterator.getShuffleReadMetrics().recordsRead());
    assertEquals(256, rssShuffleDataIterator.getShuffleReadMetrics().remoteBytesRead());
    assertTrue(rssShuffleDataIterator.getShuffleReadMetrics().fetchWaitTime() > 0);
  }
",non-flaky,5
76924,Tencent_Firestorm,RssShuffleDataIteratorTest.readTest3,"  @Test
  public void readTest3() throws Exception {
    String basePath = HDFS_URI + ""readTest3"";
    HdfsShuffleWriteHandler writeHandler1 =
        new HdfsShuffleWriteHandler(""appId"", 0, 0, 1, basePath, ""test3_1"", conf);
    HdfsShuffleWriteHandler writeHandler2 =
        new HdfsShuffleWriteHandler(""appId"", 0, 0, 1, basePath, ""test3_2"", conf);

    Map<String, String> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0);
    writeTestData(writeHandler1, 2, 5, expectedData,
        blockIdBitmap, ""key1"", KRYO_SERIALIZER, 0);
    writeTestData(writeHandler2, 2, 5, expectedData,
        blockIdBitmap, ""key2"", KRYO_SERIALIZER, 0);

    // duplicate file created, it should be used in product environment
    String shuffleFolder = basePath + ""/appId/0/0-1"";
    FileUtil.copy(fs, new Path(shuffleFolder + ""/test3_1_0.data""), fs,
        new Path(shuffleFolder + ""/test3_1_0.cp.data""), false, conf);
    FileUtil.copy(fs, new Path(shuffleFolder + ""/test3_1_0.index""), fs,
        new Path(shuffleFolder + ""/test3_1_0.cp.index""), false, conf);
    FileUtil.copy(fs, new Path(shuffleFolder + ""/test3_2_0.data""), fs,
        new Path(shuffleFolder + ""/test3_2_0.cp.data""), false, conf);
    FileUtil.copy(fs, new Path(shuffleFolder + ""/test3_2_0.index""), fs,
        new Path(shuffleFolder + ""/test3_2_0.cp.index""), false, conf);

    RssShuffleDataIterator rssShuffleDataIterator = getDataIterator(basePath, blockIdBitmap, taskIdBitmap);

    validateResult(rssShuffleDataIterator, expectedData, 20);
  }
",non-flaky,5
76925,Tencent_Firestorm,RssShuffleDataIteratorTest.readTest4,"  @Test
  public void readTest4() throws Exception {
    String basePath = HDFS_URI + ""readTest4"";
    HdfsShuffleWriteHandler writeHandler =
        new HdfsShuffleWriteHandler(""appId"", 0, 0, 1, basePath, ""test1"", conf);

    Map<String, String> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0);
    writeTestData(writeHandler, 2, 5, expectedData,
        blockIdBitmap, ""key"", KRYO_SERIALIZER, 0);

    RssShuffleDataIterator rssShuffleDataIterator = getDataIterator(basePath, blockIdBitmap, taskIdBitmap);
    // data file is deleted after iterator initialization
    Path dataFile = new Path(basePath + ""/appId/0/0-1/test1_0.data"");
    fs.delete(dataFile, true);
    // sleep to wait delete operation
    Thread.sleep(10000);
    try {
      fs.listStatus(dataFile);
      fail(""Index file should be deleted"");
    } catch (Exception e) {
    }

    try {
      while (rssShuffleDataIterator.hasNext()) {
        rssShuffleDataIterator.next();
      }
      fail(EXPECTED_EXCEPTION_MESSAGE);
    } catch (Exception e) {
      assertTrue(e.getMessage().startsWith(""Blocks read inconsistent: expected""));
    }
  }
",non-flaky,5
76926,Tencent_Firestorm,RssShuffleDataIteratorTest.readTest5,"  @Test
  public void readTest5() throws Exception {
    String basePath = HDFS_URI + ""readTest5"";
    HdfsShuffleWriteHandler writeHandler =
        new HdfsShuffleWriteHandler(""appId"", 0, 0, 1, basePath, ""test"", conf);

    Map<String, String> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0);
    writeTestData(writeHandler, 2, 5, expectedData,
        blockIdBitmap, ""key"", KRYO_SERIALIZER, 0);

    RssShuffleDataIterator rssShuffleDataIterator = getDataIterator(basePath, blockIdBitmap, taskIdBitmap);
    // index file is deleted after iterator initialization, it should be ok, all index infos are read already
    Path indexFile = new Path(basePath + ""/appId/0/0-1/test.index"");
    fs.delete(indexFile, true);
    // sleep to wait delete operation
    Thread.sleep(10000);
    try {
      fs.listStatus(indexFile);
      fail(""Index file should be deleted"");
    } catch (Exception e) {
    }
    validateResult(rssShuffleDataIterator, expectedData, 10);
  }
",non-flaky,5
76927,Tencent_Firestorm,RssShuffleDataIteratorTest.readTest7,"  @Test
  public void readTest7() throws Exception {
    String basePath = HDFS_URI + ""readTest7"";
    HdfsShuffleWriteHandler writeHandler =
        new HdfsShuffleWriteHandler(""appId"", 0, 0, 1, basePath, ""test"", conf);

    Map<String, String> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0);
    writeTestData(writeHandler, 2, 5, expectedData,
        blockIdBitmap, ""key"", KRYO_SERIALIZER, 0);

    RssShuffleDataIterator rssShuffleDataIterator = getDataIterator(basePath, blockIdBitmap, taskIdBitmap);

    // crc32 is incorrect
    try (MockedStatic<ChecksumUtils> checksumUtilsMock = Mockito.mockStatic(ChecksumUtils.class)) {
      checksumUtilsMock.when(() -> ChecksumUtils.getCrc32((ByteBuffer) any())).thenReturn(-1L);
      try {
        while (rssShuffleDataIterator.hasNext()) {
          rssShuffleDataIterator.next();
        }
        fail(EXPECTED_EXCEPTION_MESSAGE);
      } catch (Exception e) {
        assertTrue(e.getMessage().startsWith(""Unexpected crc value""));
      }
    }
  }
",non-flaky,5
76928,Tencent_Firestorm,WriteBufferTest.test,"  @Test
  public void test() {
    WriterBuffer wb = new WriterBuffer(32);
    assertEquals(0, wb.getMemoryUsed());
    assertEquals(0, wb.getDataLength());

    serializeData(""key"", ""value"");
    // size of serialized kv is 12
    wb.addRecord(serializedData, serializedDataLength);
    assertEquals(32, wb.getMemoryUsed());
    assertEquals(12, wb.getDataLength());
    wb.addRecord(serializedData, serializedDataLength);
    assertEquals(32, wb.getMemoryUsed());
    // case: data size < output buffer size, when getData(), [] + buffer with 24b = 24b
    assertEquals(24, wb.getData().length);
    wb.addRecord(serializedData, serializedDataLength);
    // case: data size > output buffer size, when getData(), [1 buffer] + buffer with 12 = 36b
    assertEquals(36, wb.getData().length);
    assertEquals(64, wb.getMemoryUsed());
    wb.addRecord(serializedData, serializedDataLength);
    wb.addRecord(serializedData, serializedDataLength);
    // case: data size > output buffer size, when getData(), 2 buffer + output with 12b = 60b
    assertEquals(60, wb.getData().length);
    assertEquals(96, wb.getMemoryUsed());

    wb = new WriterBuffer(32);

    serializeData(""key1111111111111111111111111111"", ""value222222222222222222222222222"");
    wb.addRecord(serializedData, serializedDataLength);
    assertEquals(67, wb.getMemoryUsed());
    assertEquals(67, wb.getDataLength());

    serializeData(""key"", ""value"");
    wb.addRecord(serializedData, serializedDataLength);
    // 67 + 32
    assertEquals(99, wb.getMemoryUsed());
    // 67 + 12
    assertEquals(79, wb.getDataLength());
    assertEquals(79, wb.getData().length);

    wb.addRecord(serializedData, serializedDataLength);
    assertEquals(99, wb.getMemoryUsed());
    assertEquals(91, wb.getDataLength());
    assertEquals(91, wb.getData().length);
  }
",non-flaky,5
76929,Tencent_Firestorm,WriteBufferManagerTest.addRecordTest,"  @Test
  public void addRecordTest() {
    SparkConf conf = getConf();
    WriteBufferManager wbm = createManager(conf);
    wbm.setShuffleWriteMetrics(new ShuffleWriteMetrics());
    String testKey = ""Key"";
    String testValue = ""Value"";
    List<ShuffleBlockInfo> result = wbm.addRecord(0, testKey, testValue);
    // single buffer is not full, there is no data return
    assertEquals(0, result.size());
    assertEquals(512, wbm.getAllocatedBytes());
    assertEquals(32, wbm.getUsedBytes());
    assertEquals(0, wbm.getInSendListBytes());
    assertEquals(1, wbm.getBuffers().size());
    wbm.addRecord(0, testKey, testValue);
    wbm.addRecord(0, testKey, testValue);
    wbm.addRecord(0, testKey, testValue);
    result = wbm.addRecord(0, testKey, testValue);
    // single buffer is full
    assertEquals(1, result.size());
    assertEquals(512, wbm.getAllocatedBytes());
    assertEquals(96, wbm.getUsedBytes());
    assertEquals(96, wbm.getInSendListBytes());
    assertEquals(0, wbm.getBuffers().size());
    wbm.addRecord(0, testKey, testValue);
    wbm.addRecord(1, testKey, testValue);
    wbm.addRecord(2, testKey, testValue);
    // single buffer is not full, and less than spill size
    assertEquals(512, wbm.getAllocatedBytes());
    assertEquals(192, wbm.getUsedBytes());
    assertEquals(96, wbm.getInSendListBytes());
    assertEquals(3, wbm.getBuffers().size());
    // all buffer size > spill size
    wbm.addRecord(3, testKey, testValue);
    wbm.addRecord(4, testKey, testValue);
    result = wbm.addRecord(5, testKey, testValue);
    assertEquals(6, result.size());
    assertEquals(512, wbm.getAllocatedBytes());
    assertEquals(288, wbm.getUsedBytes());
    assertEquals(288, wbm.getInSendListBytes());
    assertEquals(0, wbm.getBuffers().size());
    // free memory
    wbm.freeAllocatedMemory(96);
    assertEquals(416, wbm.getAllocatedBytes());
    assertEquals(192, wbm.getUsedBytes());
    assertEquals(192, wbm.getInSendListBytes());

    assertEquals(11, wbm.getShuffleWriteMetrics().recordsWritten());
    assertTrue(wbm.getShuffleWriteMetrics().bytesWritten() > 0);

    wbm.freeAllocatedMemory(192);
    wbm.addRecord(0, testKey, testValue);
    wbm.addRecord(1, testKey, testValue);
    wbm.addRecord(2, testKey, testValue);
    result = wbm.clear();
    assertEquals(3, result.size());
    assertEquals(224, wbm.getAllocatedBytes());
    assertEquals(96, wbm.getUsedBytes());
    assertEquals(96, wbm.getInSendListBytes());
  }
",non-flaky,5
76930,Tencent_Firestorm,WriteBufferManagerTest.createBlockIdTest,"  @Test
  public void createBlockIdTest() {
    SparkConf conf = getConf();
    WriteBufferManager wbm = createManager(conf);
    WriterBuffer mockWriterBuffer = mock(WriterBuffer.class);
    when(mockWriterBuffer.getData()).thenReturn(new byte[]{});
    when(mockWriterBuffer.getMemoryUsed()).thenReturn(0);
    ShuffleBlockInfo sbi = wbm.createShuffleBlock(0, mockWriterBuffer);
    // seqNo = 0, partitionId = 0, taskId = 0
    assertEquals(0L, sbi.getBlockId());

    // seqNo = 1, partitionId = 0, taskId = 0
    sbi = wbm.createShuffleBlock(0, mockWriterBuffer);
    assertEquals(17592186044416L, sbi.getBlockId());

    // seqNo = 0, partitionId = 1, taskId = 0
    sbi = wbm.createShuffleBlock(1, mockWriterBuffer);
    assertEquals(1048576L, sbi.getBlockId());

    // seqNo = 1, partitionId = 1, taskId = 0
    sbi = wbm.createShuffleBlock(1, mockWriterBuffer);
    assertEquals(17592187092992L, sbi.getBlockId());
  }
",non-flaky,5
76931,Tencent_Firestorm,RssShuffleReaderTest.readTest,"  @Test
  public void readTest() throws Exception {

    String basePath = HDFS_URI + ""readTest1"";
    HdfsShuffleWriteHandler writeHandler =
        new HdfsShuffleWriteHandler(""appId"", 0, 0, 0, basePath, ""test"", conf);
    HdfsShuffleWriteHandler writeHandler1 =
        new HdfsShuffleWriteHandler(""appId"", 0, 1, 1, basePath, ""test"", conf);

    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0);
    Map<String, String> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap1 = Roaring64NavigableMap.bitmapOf();
    writeTestData(writeHandler, 2, 5, expectedData,
        blockIdBitmap, ""key"", KRYO_SERIALIZER, 0);



    TaskContext contextMock = mock(TaskContext.class);
    RssShuffleHandle handleMock = mock(RssShuffleHandle.class);
    ShuffleDependency dependencyMock = mock(ShuffleDependency.class);
    when(handleMock.getAppId()).thenReturn(""appId"");
    when(handleMock.getDependency()).thenReturn(dependencyMock);
    when(handleMock.getShuffleId()).thenReturn(1);
    when(dependencyMock.serializer()).thenReturn(KRYO_SERIALIZER);
    when(contextMock.attemptNumber()).thenReturn(1);
    when(contextMock.taskAttemptId()).thenReturn(1L);
    when(contextMock.taskMetrics()).thenReturn(new TaskMetrics());
    doNothing().when(contextMock).killTaskIfInterrupted();
    when(dependencyMock.aggregator()).thenReturn(Option.empty());
    when(dependencyMock.keyOrdering()).thenReturn(Option.empty());
    when(dependencyMock.mapSideCombine()).thenReturn(false);

    Map<Integer, Roaring64NavigableMap> partitionToExpectBlocks = Maps.newHashMap();
    partitionToExpectBlocks.put(0, blockIdBitmap);
    RssShuffleReader rssShuffleReaderSpy = spy(new RssShuffleReader<String, String>(
        0,
        1,
        0,
        Integer.MAX_VALUE,
        contextMock,
        handleMock,
        basePath,
        1000,
        conf,
        StorageType.HDFS.name(),
        1000,
        1,
        partitionToExpectBlocks,
        taskIdBitmap,
        new ShuffleReadMetrics()));
    validateResult(rssShuffleReaderSpy.read(), expectedData, 10);

    writeTestData(writeHandler1, 2, 4, expectedData,
        blockIdBitmap1, ""another_key"", KRYO_SERIALIZER, 1);
    partitionToExpectBlocks.put(1, blockIdBitmap1);
    RssShuffleReader rssShuffleReaderSpy1 = spy(new RssShuffleReader<String, String>(
        0,
        2,
        0,
        Integer.MAX_VALUE,
        contextMock,
        handleMock,
        basePath,
        1000,
        conf,
        StorageType.HDFS.name(),
        1000,
        2,
        partitionToExpectBlocks,
        taskIdBitmap,
        new ShuffleReadMetrics()));
    validateResult(rssShuffleReaderSpy1.read(), expectedData, 18);

    RssShuffleReader rssShuffleReaderSpy2 = spy(new RssShuffleReader<String, String>(
        0,
        2,
        0,
        Integer.MAX_VALUE,
        contextMock,
        handleMock,
        basePath,
        1000,
        conf,
        StorageType.HDFS.name(),
        1000,
        2,
        partitionToExpectBlocks,
        Roaring64NavigableMap.bitmapOf(),
        new ShuffleReadMetrics()));
    validateResult(rssShuffleReaderSpy2.read(), Maps.newHashMap(), 0);
  }
",non-flaky,5
76932,Tencent_Firestorm,RssShuffleWriterTest.checkBlockSendResultTest,"  @Test
  public void checkBlockSendResultTest() {
    SparkConf conf = new SparkConf();
    conf.setAppName(""testApp"")
        .setMaster(""local[2]"")
        .set(RssClientConfig.RSS_TEST_FLAG, ""true"")
        .set(RssClientConfig.RSS_WRITER_SEND_CHECK_TIMEOUT, ""10000"")
        .set(RssClientConfig.RSS_WRITER_SEND_CHECK_INTERVAL, ""1000"")
        .set(RssClientConfig.RSS_COORDINATOR_QUORUM, ""127.0.0.1:12345,127.0.0.1:12346"");
    // init SparkContext
    SparkContext sc = SparkContext.getOrCreate(conf);
    Map<String, Set<Long>> failBlocks = Maps.newConcurrentMap();
    Map<String, Set<Long>> successBlocks = Maps.newConcurrentMap();
    Serializer kryoSerializer = new KryoSerializer(conf);
    RssShuffleManager manager = TestUtils.createShuffleManager(
        conf,
        false,
        null,
        successBlocks,
        failBlocks);

    ShuffleWriteClient mockShuffleWriteClient = mock(ShuffleWriteClient.class);
    Partitioner mockPartitioner = mock(Partitioner.class);
    RssShuffleHandle mockHandle = mock(RssShuffleHandle.class);
    ShuffleDependency mockDependency = mock(ShuffleDependency.class);
    when(mockHandle.getDependency()).thenReturn(mockDependency);
    when(mockPartitioner.numPartitions()).thenReturn(2);
    TaskMemoryManager mockTaskMemoryManager = mock(TaskMemoryManager.class);
    when(mockHandle.getPartitionToServers()).thenReturn(Maps.newHashMap());
    when(mockDependency.partitioner()).thenReturn(mockPartitioner);

    BufferManagerOptions bufferOptions = new BufferManagerOptions(conf);
    WriteBufferManager bufferManager = new WriteBufferManager(
        0, 0, bufferOptions, kryoSerializer,
        Maps.newHashMap(), mockTaskMemoryManager, new ShuffleWriteMetrics());
    WriteBufferManager bufferManagerSpy = spy(bufferManager);

    RssShuffleWriter rssShuffleWriter = new RssShuffleWriter(""appId"", 0, ""taskId"", 1L,
        bufferManagerSpy, (new TaskMetrics()).shuffleWriteMetrics(),
        manager, conf, mockShuffleWriteClient, mockHandle);
    doReturn(1000000L).when(bufferManagerSpy).acquireMemory(anyLong());

    // case 1: all blocks are sent successfully
    successBlocks.put(""taskId"", Sets.newHashSet(1L, 2L, 3L));
    rssShuffleWriter.checkBlockSendResult(Sets.newHashSet(1L, 2L, 3L));
    successBlocks.clear();

    // case 2: partial blocks aren't sent before spark.rss.writer.send.check.timeout,
    // Runtime exception will be thrown
    successBlocks.put(""taskId"", Sets.newHashSet(1L, 2L));
    thrown.expect(RuntimeException.class);
    thrown.expectMessage(StringStartsWith.startsWith(""Timeout:""));
    rssShuffleWriter.checkBlockSendResult(Sets.newHashSet(1L, 2L, 3L));
    successBlocks.clear();

    // case 3: partial blocks are sent failed, Runtime exception will be thrown
    successBlocks.put(""taskId"", Sets.newHashSet(1L, 2L));
    failBlocks.put(""taskId"", Sets.newHashSet(3L));
    thrown.expect(RuntimeException.class);
    thrown.expectMessage(StringStartsWith.startsWith(""Send failed:""));
    rssShuffleWriter.checkBlockSendResult(Sets.newHashSet(1L, 2L, 3L));
    successBlocks.clear();
    failBlocks.clear();

    sc.stop();
  }
",non-flaky,5
76933,Tencent_Firestorm,RssShuffleWriterTest.onReceive,"  @Test
  public void writeTest() throws Exception {
    SparkConf conf = new SparkConf();
    conf.setAppName(""testApp"").setMaster(""local[2]"")
        .set(RssClientConfig.RSS_WRITER_SERIALIZER_BUFFER_SIZE, ""32"")
        .set(RssClientConfig.RSS_WRITER_BUFFER_SIZE, ""32"")
        .set(RssClientConfig.RSS_TEST_FLAG, ""true"")
        .set(RssClientConfig.RSS_WRITER_BUFFER_SEGMENT_SIZE, ""64"")
        .set(RssClientConfig.RSS_WRITER_SEND_CHECK_TIMEOUT, ""10000"")
        .set(RssClientConfig.RSS_WRITER_SEND_CHECK_INTERVAL, ""1000"")
        .set(RssClientConfig.RSS_WRITER_BUFFER_SPILL_SIZE, ""128"")
        .set(RssClientConfig.RSS_COORDINATOR_QUORUM, ""127.0.0.1:12345,127.0.0.1:12346"");
    // init SparkContext
    List<ShuffleBlockInfo> shuffleBlockInfos = Lists.newArrayList();
    SparkContext sc = SparkContext.getOrCreate(conf);
    Map<String, Set<Long>> successBlockIds = Maps.newConcurrentMap();
    EventLoop<AddBlockEvent> testLoop = new EventLoop<AddBlockEvent>(""test"") {
      @Override
      public void onReceive(AddBlockEvent event) {
        assertEquals(""taskId"", event.getTaskId());
        shuffleBlockInfos.addAll(event.getShuffleDataInfoList());
        Set<Long> blockIds = event.getShuffleDataInfoList().parallelStream()
            .map(sdi -> sdi.getBlockId()).collect(Collectors.toSet());
        successBlockIds.putIfAbsent(event.getTaskId(), Sets.newConcurrentHashSet());
        successBlockIds.get(event.getTaskId()).addAll(blockIds);
      }
",non-flaky,5
76934,Tencent_Firestorm,RssShuffleWriterTest.onReceive,"  @Test
  public void postBlockEventTest() throws Exception {
    WriteBufferManager mockBufferManager = mock(WriteBufferManager.class);
    ShuffleDependency mockDependency = mock(ShuffleDependency.class);
    ShuffleWriteMetrics mockMetrics = mock(ShuffleWriteMetrics.class);
    Partitioner mockPartitioner = mock(Partitioner.class);
    when(mockDependency.partitioner()).thenReturn(mockPartitioner);
    SparkConf sparkConf = new SparkConf();
    when(mockPartitioner.numPartitions()).thenReturn(2);
    List<AddBlockEvent> events = Lists.newArrayList();

    EventLoop<AddBlockEvent> eventLoop = new EventLoop<AddBlockEvent>(""test"") {
      @Override
      public void onReceive(AddBlockEvent event) {
        events.add(event);
      }
",non-flaky,5
76935,Tencent_Firestorm,RssShuffleReaderTest.readTest,"  @Test
  public void readTest() throws Exception {

    String basePath = HDFS_URI + ""readTest1"";
    HdfsShuffleWriteHandler writeHandler =
        new HdfsShuffleWriteHandler(""appId"", 0, 0, 1, basePath, ""test"", conf);

    Map<String, String> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0);
     writeTestData(writeHandler, 2, 5, expectedData,
        blockIdBitmap, ""key"", KRYO_SERIALIZER, 0);

    TaskContext contextMock = mock(TaskContext.class);
    RssShuffleHandle handleMock = mock(RssShuffleHandle.class);
    ShuffleDependency dependencyMock = mock(ShuffleDependency.class);
    when(handleMock.getAppId()).thenReturn(""appId"");
    when(handleMock.getShuffleId()).thenReturn(1);
    when(handleMock.getDependency()).thenReturn(dependencyMock);
    when(dependencyMock.serializer()).thenReturn(KRYO_SERIALIZER);
    when(contextMock.taskAttemptId()).thenReturn(1L);
    when(contextMock.attemptNumber()).thenReturn(1);
    when(contextMock.taskMetrics()).thenReturn(new TaskMetrics());
    doNothing().when(contextMock).killTaskIfInterrupted();
    when(dependencyMock.mapSideCombine()).thenReturn(false);
    when(dependencyMock.aggregator()).thenReturn(Option.empty());
    when(dependencyMock.keyOrdering()).thenReturn(Option.empty());

    RssShuffleReader rssShuffleReaderSpy = spy(new RssShuffleReader<String, String>(0, 1, contextMock,
        handleMock, basePath, 1000, conf, StorageType.HDFS.name(),
        1000, 2, 10, blockIdBitmap, taskIdBitmap));

    validateResult(rssShuffleReaderSpy.read(), expectedData, 10);
  }
",non-flaky,5
76936,Tencent_Firestorm,RssShuffleWriterTest.checkBlockSendResultTest,"  @Test
  public void checkBlockSendResultTest() {
    SparkConf conf = new SparkConf();
    conf.setAppName(""testApp"")
        .setMaster(""local[2]"")
        .set(RssClientConfig.RSS_TEST_FLAG, ""true"")
        .set(RssClientConfig.RSS_WRITER_SEND_CHECK_TIMEOUT, ""10000"")
        .set(RssClientConfig.RSS_WRITER_SEND_CHECK_INTERVAL, ""1000"")
        .set(RssClientConfig.RSS_COORDINATOR_QUORUM, ""127.0.0.1:12345,127.0.0.1:12346"");
    // init SparkContext
    SparkContext sc = SparkContext.getOrCreate(conf);
    RssShuffleManager manager = new RssShuffleManager(conf, false);

    Serializer kryoSerializer = new KryoSerializer(conf);
    ShuffleWriteClient mockShuffleWriteClient = mock(ShuffleWriteClient.class);
    Partitioner mockPartitioner = mock(Partitioner.class);
    ShuffleDependency mockDependency = mock(ShuffleDependency.class);
    RssShuffleHandle mockHandle = mock(RssShuffleHandle.class);
    when(mockHandle.getDependency()).thenReturn(mockDependency);
    when(mockDependency.partitioner()).thenReturn(mockPartitioner);
    when(mockPartitioner.numPartitions()).thenReturn(2);
    when(mockHandle.getPartitionToServers()).thenReturn(Maps.newHashMap());
    TaskMemoryManager mockTaskMemoryManager = mock(TaskMemoryManager.class);

    BufferManagerOptions bufferOptions = new BufferManagerOptions(conf);
    WriteBufferManager bufferManager = new WriteBufferManager(
        0, 0, bufferOptions, kryoSerializer,
        Maps.newHashMap(), mockTaskMemoryManager, new ShuffleWriteMetrics());
    WriteBufferManager bufferManagerSpy = spy(bufferManager);
    doReturn(1000000L).when(bufferManagerSpy).acquireMemory(anyLong());

    RssShuffleWriter rssShuffleWriter = new RssShuffleWriter(""appId"", 0, ""taskId"", 1L,
        bufferManagerSpy, (new TaskMetrics()).shuffleWriteMetrics(),
        manager, conf, mockShuffleWriteClient, mockHandle);

    // case 1: all blocks are sent successfully
    manager.addSuccessBlockIds(""taskId"", Sets.newHashSet(1L, 2L, 3L));
    rssShuffleWriter.checkBlockSendResult(Sets.newHashSet(1L, 2L, 3L));
    manager.clearCachedBlockIds();

    // case 2: partial blocks aren't sent before spark.rss.writer.send.check.timeout,
    // Runtime exception will be thrown
    manager.addSuccessBlockIds(""taskId"", Sets.newHashSet(1L, 2L));
    thrown.expect(RuntimeException.class);
    thrown.expectMessage(StringStartsWith.startsWith(""Timeout:""));
    rssShuffleWriter.checkBlockSendResult(Sets.newHashSet(1L, 2L, 3L));

    manager.clearCachedBlockIds();

    // case 3: partial blocks are sent failed, Runtime exception will be thrown
    manager.addSuccessBlockIds(""taskId"", Sets.newHashSet(1L, 2L));
    manager.addFailedBlockIds(""taskId"", Sets.newHashSet(3L));
    thrown.expect(RuntimeException.class);
    thrown.expectMessage(StringStartsWith.startsWith(""Send failed:""));
    rssShuffleWriter.checkBlockSendResult(Sets.newHashSet(1L, 2L, 3L));
    manager.clearCachedBlockIds();

    sc.stop();
  }
",non-flaky,5
76937,Tencent_Firestorm,RssShuffleWriterTest.onReceive,"  @Test
  public void writeTest() throws Exception {
    SparkConf conf = new SparkConf();
    conf.setAppName(""testApp"").setMaster(""local[2]"")
        .set(RssClientConfig.RSS_TEST_FLAG, ""true"")
        .set(RssClientConfig.RSS_WRITER_BUFFER_SIZE, ""32"")
        .set(RssClientConfig.RSS_WRITER_SERIALIZER_BUFFER_SIZE, ""32"")
        .set(RssClientConfig.RSS_WRITER_BUFFER_SEGMENT_SIZE, ""64"")
        .set(RssClientConfig.RSS_WRITER_BUFFER_SPILL_SIZE, ""128"")
        .set(RssClientConfig.RSS_WRITER_SEND_CHECK_TIMEOUT, ""10000"")
        .set(RssClientConfig.RSS_WRITER_SEND_CHECK_INTERVAL, ""1000"")
        .set(RssClientConfig.RSS_COORDINATOR_QUORUM, ""127.0.0.1:12345,127.0.0.1:12346"");
    // init SparkContext
    SparkContext sc = SparkContext.getOrCreate(conf);
    RssShuffleManager manager = new RssShuffleManager(conf, false);
    List<ShuffleBlockInfo> shuffleBlockInfos = Lists.newArrayList();

    manager.setEventLoop(new EventLoop<AddBlockEvent>(""test"") {
      @Override
      public void onReceive(AddBlockEvent event) {
        assertEquals(""taskId"", event.getTaskId());
        shuffleBlockInfos.addAll(event.getShuffleDataInfoList());
        Set<Long> blockIds = event.getShuffleDataInfoList().parallelStream()
            .map(sdi -> sdi.getBlockId()).collect(Collectors.toSet());
        manager.addSuccessBlockIds(event.getTaskId(), blockIds);
      }
",non-flaky,5
76938,Tencent_Firestorm,RssShuffleWriterTest.onReceive,"  @Test
  public void postBlockEventTest() throws Exception {
    WriteBufferManager mockBufferManager = mock(WriteBufferManager.class);
    ShuffleWriteMetrics mockMetrics = mock(ShuffleWriteMetrics.class);
    ShuffleDependency mockDependency = mock(ShuffleDependency.class);
    Partitioner mockPartitioner = mock(Partitioner.class);
    RssShuffleManager mockShuffleManager = mock(RssShuffleManager.class);
    when(mockDependency.partitioner()).thenReturn(mockPartitioner);
    when(mockPartitioner.numPartitions()).thenReturn(2);
    List<AddBlockEvent> events = Lists.newArrayList();

    EventLoop<AddBlockEvent> eventLoop = new EventLoop<AddBlockEvent>(""test"") {
      @Override
      public void onReceive(AddBlockEvent event) {
        events.add(event);
      }
",non-flaky,5
76939,Tencent_Firestorm,ClientUtilsTest.getBlockIdTest,"  @Test
  public void getBlockIdTest() {
    // max value of blockId
    assertEquals(
        new Long(9223372036854775807L), ClientUtils.getBlockId(16777215, 1048575, 524287));
    // just a random test
    assertEquals(
        new Long(1759218709299300L), ClientUtils.getBlockId(100, 100, 100));
    // min value of blockId
    assertEquals(
        new Long(0L), ClientUtils.getBlockId(0, 0, 0));
    try {
      ClientUtils.getBlockId(16777216, 0, 0);
      fail(EXCEPTION_EXPECTED);
    } catch (Exception e) {
      assertTrue(e.getMessage().contains(""Can't support partitionId[16777216], the max value should be 16777215""));
    }
    try {
      ClientUtils.getBlockId(0, 1048576, 0);
      fail(EXCEPTION_EXPECTED);
    } catch (Exception e) {
      assertTrue(e.getMessage().contains(""Can't support taskAttemptId[1048576], the max value should be 1048575""));
    }
    try {
      ClientUtils.getBlockId(0, 0, 524288);
      fail(EXCEPTION_EXPECTED);
    } catch (Exception e) {
      assertTrue(e.getMessage().contains(""Can't support sequence[524288], the max value should be 524287""));
    }
  }
",non-flaky,5
76940,Tencent_Firestorm,ClientUtilsTest.getBitmapNumTest,"  @Test
  public void getBitmapNumTest() {
    // max value of taskNum, partitionNum, blockNumPerTaskPerPartition, it is unexpected in real job
    assertEquals(
        2147483647, ClientUtils.getBitmapNum(Integer.MAX_VALUE, Integer.MAX_VALUE, 1000000, 100000000L));
    // taskNum * partitionNum * blockNumPerTaskPerPartition / blockNumPerBitmap > 0
    assertEquals(
        5001, ClientUtils.getBitmapNum(100000, 100000, 50, 100000000L));
    // taskNum * partitionNum * blockNumPerTaskPerPartition / blockNumPerBitmap = 0
    assertEquals(
        1, ClientUtils.getBitmapNum(1999, 1999, 50, 100000000L));
    try {
      ClientUtils.getBitmapNum(1, 1, 1, 19999999L);
      fail(EXCEPTION_EXPECTED);
    } catch (Exception e) {
      assertTrue(e.getMessage().contains(""blockNumPerBitmap should be greater than""));
    }
    try {
      ClientUtils.getBitmapNum(1, 1, 1000001, 20000000L);
      fail(EXCEPTION_EXPECTED);
    } catch (Exception e) {
      assertTrue(e.getMessage().contains(""blockNumPerTaskPerPartition should be less than""));
    }
  }
",non-flaky,5
76941,Tencent_Firestorm,ShuffleReadClientImplTest.readTest1,"  @Test
  public void readTest1() throws Exception {
    String basePath = HDFS_URI + ""clientReadTest1"";
    HdfsShuffleWriteHandler writeHandler =
        new HdfsShuffleWriteHandler(""appId"", 0, 1, 1, basePath, ""test1"", conf);

    Map<Long, byte[]> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0);
    writeTestData(writeHandler, 2, 30, 0, expectedData,
        blockIdBitmap);

    ShuffleReadClientImpl readClient = new ShuffleReadClientImpl(StorageType.HDFS.name(), ""appId"", 0, 1, 100, 1,
        10, 1000, basePath, blockIdBitmap, taskIdBitmap, Lists.newArrayList(), new Configuration());

    TestUtils.validateResult(readClient, expectedData);
    readClient.checkProcessedBlockIds();
    readClient.close();

    blockIdBitmap.addLong(Constants.MAX_TASK_ATTEMPT_ID - 1);
    taskIdBitmap.addLong(Constants.MAX_TASK_ATTEMPT_ID - 1);
    readClient = new ShuffleReadClientImpl(StorageType.HDFS.name(), ""appId"", 0, 1, 100, 1,
        10, 1000, basePath, blockIdBitmap, taskIdBitmap, Lists.newArrayList(), new Configuration());
    TestUtils.validateResult(readClient, expectedData);
    try {
      // can't find all expected block id, data loss
      readClient.checkProcessedBlockIds();
      fail(EXPECTED_EXCEPTION_MESSAGE);
    } catch (Exception e) {
      assertTrue(e.getMessage().contains(""Blocks read inconsistent:""));
    } finally {
      readClient.close();
    }
  }
",non-flaky,5
76942,Tencent_Firestorm,ShuffleReadClientImplTest.readTest2,"  @Test
  public void readTest2() throws Exception {
    String basePath = HDFS_URI + ""clientReadTest2"";
    HdfsShuffleWriteHandler writeHandler1 =
        new HdfsShuffleWriteHandler(""appId"", 0, 0, 1, basePath, ""test2_1"", conf);
    HdfsShuffleWriteHandler writeHandler2 =
        new HdfsShuffleWriteHandler(""appId"", 0, 0, 1, basePath, ""test2_2"", conf);

    Map<Long, byte[]> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0);
    writeTestData(writeHandler1, 2, 30, 0, expectedData, blockIdBitmap);
    writeTestData(writeHandler2, 2, 30, 0, expectedData, blockIdBitmap);

    ShuffleReadClientImpl readClient = new ShuffleReadClientImpl(StorageType.HDFS.name(),
        ""appId"", 0, 1, 100, 2, 10, 1000,
        basePath, blockIdBitmap, taskIdBitmap, Lists.newArrayList(), new Configuration());

    TestUtils.validateResult(readClient, expectedData);
    readClient.checkProcessedBlockIds();
    readClient.close();
  }
",non-flaky,5
76943,Tencent_Firestorm,ShuffleReadClientImplTest.readTest3,"  @Test
  public void readTest3() throws Exception {
    String basePath = HDFS_URI + ""clientReadTest3"";
    HdfsShuffleWriteHandler writeHandler1 =
        new HdfsShuffleWriteHandler(""appId"", 0, 0, 1, basePath, ""test3_1"", conf);
    HdfsShuffleWriteHandler writeHandler2 =
        new HdfsShuffleWriteHandler(""appId"", 0, 0, 1, basePath, ""test3_2"", conf);

    Map<Long, byte[]> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0);
    writeTestData(writeHandler1, 2, 30, 0, expectedData, blockIdBitmap);
    writeTestData(writeHandler2, 2, 30, 0, expectedData, blockIdBitmap);

    // duplicate file created, it should be used in product environment
    String shuffleFolder = basePath + ""/appId/0/0-1"";
    FileUtil.copy(fs, new Path(shuffleFolder + ""/test3_1_0.data""), fs,
        new Path(basePath + ""/test3_1.cp.data""), false, conf);
    FileUtil.copy(fs, new Path(shuffleFolder + ""/test3_1_0.index""), fs,
        new Path(basePath + ""/test3_1.cp.index""), false, conf);
    FileUtil.copy(fs, new Path(shuffleFolder + ""/test3_2_0.data""), fs,
        new Path(basePath + ""/test3_2.cp.data""), false, conf);
    FileUtil.copy(fs, new Path(shuffleFolder + ""/test3_2_0.index""), fs,
        new Path(basePath + ""/test3_2.cp.index""), false, conf);

    ShuffleReadClientImpl readClient = new ShuffleReadClientImpl(StorageType.HDFS.name(),
        ""appId"", 0, 1, 100, 2, 10, 1000,
        basePath, blockIdBitmap, taskIdBitmap, Lists.newArrayList(), new Configuration());

    TestUtils.validateResult(readClient, expectedData);
    readClient.checkProcessedBlockIds();
    readClient.close();
  }
",non-flaky,5
76944,Tencent_Firestorm,ShuffleReadClientImplTest.readTest4,"  @Test
  public void readTest4() throws Exception {
    String basePath = HDFS_URI + ""clientReadTest4"";
    HdfsShuffleWriteHandler writeHandler =
        new HdfsShuffleWriteHandler(""appId"", 0, 0, 1, basePath, ""test1"", conf);

    Map<Long, byte[]> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0);
    writeTestData(writeHandler, 2, 30, 0, expectedData, blockIdBitmap);

    ShuffleReadClientImpl readClient = new ShuffleReadClientImpl(StorageType.HDFS.name(),
        ""appId"", 0, 1, 100, 2, 10, 1000,
        basePath, blockIdBitmap, taskIdBitmap, Lists.newArrayList(), new Configuration());
    Path dataFile = new Path(basePath + ""/appId/0/0-1/test1_0.data"");
    // data file is deleted after readClient checkExpectedBlockIds
    fs.delete(new Path(basePath + ""/appId/0/0-1/test1_0.data""), true);
    // sleep to wait delete operation
    Thread.sleep(10000);

    assertNull(readClient.readShuffleBlockData());
    try {
      fs.listStatus(dataFile);
      fail(""Index file should be deleted"");
    } catch (Exception e) {
    }

    try {
      readClient.checkProcessedBlockIds();
      fail(EXPECTED_EXCEPTION_MESSAGE);
    } catch (Exception e) {
      assertTrue(e.getMessage().startsWith(""Blocks read inconsistent: expected""));
    }
    readClient.close();
  }
",non-flaky,5
76945,Tencent_Firestorm,ShuffleReadClientImplTest.readTest5,"  @Test
  public void readTest5() throws Exception {
    String basePath = HDFS_URI + ""clientReadTest5"";
    HdfsShuffleWriteHandler writeHandler =
        new HdfsShuffleWriteHandler(""appId"", 0, 0, 1, basePath, ""test"", conf);

    Map<Long, byte[]> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0);
    writeTestData(writeHandler, 2, 30, 0, expectedData, blockIdBitmap);

    ShuffleReadClientImpl readClient = new ShuffleReadClientImpl(StorageType.HDFS.name(),
        ""appId"", 0, 1, 100, 2, 10, 1000,
        basePath, blockIdBitmap, taskIdBitmap, Lists.newArrayList(), new Configuration());
    // index file is deleted after iterator initialization, it should be ok, all index infos are read already
    Path indexFile = new Path(basePath + ""/appId/0/0-1/test.index"");
    fs.delete(indexFile, true);
    readClient.close();

    assertNull(readClient.readShuffleBlockData());
  }
",non-flaky,5
76946,Tencent_Firestorm,ShuffleReadClientImplTest.readTest7,"  @Test
  public void readTest7() throws Exception {
    String basePath = HDFS_URI + ""clientReadTest7"";
    HdfsShuffleWriteHandler writeHandler =
        new HdfsShuffleWriteHandler(""appId"", 0, 0, 1, basePath, ""test"", conf);

    Map<Long, byte[]> expectedData1 = Maps.newHashMap();
    Map<Long, byte[]> expectedData2 = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap1 = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0);
    writeTestData(writeHandler, 10, 30, 0, expectedData1, blockIdBitmap1);

    Roaring64NavigableMap blockIdBitmap2 = Roaring64NavigableMap.bitmapOf();
    writeTestData(writeHandler, 10, 30, 0, expectedData2, blockIdBitmap2);

    writeTestData(writeHandler, 10, 30, 0, expectedData1, blockIdBitmap1);

    ShuffleReadClientImpl readClient1 = new ShuffleReadClientImpl(StorageType.HDFS.name(),
        ""appId"", 0, 0, 100, 2, 10, 100,
        basePath, blockIdBitmap1, taskIdBitmap, Lists.newArrayList(), new Configuration());
    ShuffleReadClientImpl readClient2 = new ShuffleReadClientImpl(StorageType.HDFS.name(),
        ""appId"", 0, 1, 100, 2, 10, 100,
        basePath, blockIdBitmap2, taskIdBitmap, Lists.newArrayList(), new Configuration());
    TestUtils.validateResult(readClient1, expectedData1);
    readClient1.checkProcessedBlockIds();
    readClient1.close();

    TestUtils.validateResult(readClient2, expectedData2);
    readClient2.checkProcessedBlockIds();
    readClient2.close();
  }
",non-flaky,5
76947,Tencent_Firestorm,ShuffleReadClientImplTest.readTest8,"  @Test
  public void readTest8() throws Exception {
    String basePath = HDFS_URI + ""clientReadTest8"";
    HdfsShuffleWriteHandler writeHandler =
        new HdfsShuffleWriteHandler(""appId"", 0, 0, 1, basePath, ""test"", conf);

    Map<Long, byte[]> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0);
    writeTestData(writeHandler, 2, 30, 0, expectedData, blockIdBitmap);

    ShuffleReadClientImpl readClient = new ShuffleReadClientImpl(StorageType.HDFS.name(),
        ""appId"", 0, 1, 100, 2, 10, 1000,
        basePath, blockIdBitmap, taskIdBitmap, Lists.newArrayList(), new Configuration());
    // crc32 is incorrect
    try (MockedStatic<ChecksumUtils> checksumUtilsMock = Mockito.mockStatic(ChecksumUtils.class)) {
      checksumUtilsMock.when(() -> ChecksumUtils.getCrc32((ByteBuffer) any())).thenReturn(-1L);
      try {
        ByteBuffer bb = readClient.readShuffleBlockData().getByteBuffer();
        while (bb != null) {
          bb = readClient.readShuffleBlockData().getByteBuffer();
        }
        fail(EXPECTED_EXCEPTION_MESSAGE);
      } catch (Exception e) {
        assertTrue(e.getMessage().startsWith(""Unexpected crc value""));
      }
    }
    readClient.close();
  }
",non-flaky,5
76948,Tencent_Firestorm,ShuffleReadClientImplTest.readTest9,"  @Test
  public void readTest9() {
    // empty data
    ShuffleReadClientImpl readClient = new ShuffleReadClientImpl(StorageType.HDFS.name(),
        ""appId"", 0, 1, 100, 2, 10, 1000,
        ""basePath"", Roaring64NavigableMap.bitmapOf(), Roaring64NavigableMap.bitmapOf(),
        Lists.newArrayList(), new Configuration());
    assertNull(readClient.readShuffleBlockData());
    readClient.checkProcessedBlockIds();
  }
",non-flaky,5
76949,Tencent_Firestorm,ShuffleReadClientImplTest.readTest10,"  @Test
  public void readTest10() throws Exception {
    String basePath = HDFS_URI + ""clientReadTest10"";
    HdfsShuffleWriteHandler writeHandler =
        new HdfsShuffleWriteHandler(""appId"", 0, 0, 1, basePath, ""test"", conf);

    Map<Long, byte[]> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0);
    writeTestData(writeHandler, 5, 30, 0, expectedData, blockIdBitmap);
    Roaring64NavigableMap wrongBlockIdBitmap = Roaring64NavigableMap.bitmapOf();
    LongIterator iter = blockIdBitmap.getLongIterator();
    while (iter.hasNext()) {
      wrongBlockIdBitmap.addLong(iter.next() + (1 << Constants.TASK_ATTEMPT_ID_MAX_LENGTH));
    }

    ShuffleReadClientImpl readClient = new ShuffleReadClientImpl(StorageType.HDFS.name(),
        ""appId"", 0, 0, 100, 2, 10, 100,
        basePath, wrongBlockIdBitmap, taskIdBitmap, Lists.newArrayList(), new Configuration());
    assertNull(readClient.readShuffleBlockData());
    try {
      readClient.checkProcessedBlockIds();
      fail(EXPECTED_EXCEPTION_MESSAGE);
    } catch (Exception e) {
      assertTrue(e.getMessage().contains(""Blocks read inconsistent:""));
    }
  }
",non-flaky,5
76950,Tencent_Firestorm,ShuffleReadClientImplTest.readTest11,"  @Test
  public void readTest11() throws Exception {
    String basePath = HDFS_URI + ""clientReadTest11"";
    HdfsShuffleWriteHandler writeHandler =
        new HdfsShuffleWriteHandler(""appId"", 0, 1, 1, basePath, ""test1"", conf);

    Map<Long, byte[]> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0);
    writeTestData(writeHandler, 10, 30, 0, expectedData, blockIdBitmap);

    // test with different indexReadLimit to validate result
    ShuffleReadClientImpl readClient = new ShuffleReadClientImpl(StorageType.HDFS.name(), ""appId"", 0, 1, 1, 1,
        10, 1000, basePath, blockIdBitmap, taskIdBitmap, Lists.newArrayList(), new Configuration());

    TestUtils.validateResult(readClient, expectedData);
    readClient.checkProcessedBlockIds();
    readClient.close();

    readClient = new ShuffleReadClientImpl(StorageType.HDFS.name(), ""appId"", 0, 1, 2, 1,
        10, 1000, basePath, blockIdBitmap, taskIdBitmap, Lists.newArrayList(), new Configuration());

    TestUtils.validateResult(readClient, expectedData);
    readClient.checkProcessedBlockIds();
    readClient.close();

    readClient = new ShuffleReadClientImpl(StorageType.HDFS.name(), ""appId"", 0, 1, 3, 1,
        10, 1000, basePath, blockIdBitmap, taskIdBitmap, Lists.newArrayList(), new Configuration());

    TestUtils.validateResult(readClient, expectedData);
    readClient.checkProcessedBlockIds();
    readClient.close();

    readClient = new ShuffleReadClientImpl(StorageType.HDFS.name(), ""appId"", 0, 1, 10, 1,
        10, 1000, basePath, blockIdBitmap, taskIdBitmap, Lists.newArrayList(), new Configuration());

    TestUtils.validateResult(readClient, expectedData);
    readClient.checkProcessedBlockIds();
    readClient.close();

    readClient = new ShuffleReadClientImpl(StorageType.HDFS.name(), ""appId"", 0, 1, 11, 1,
        10, 1000, basePath, blockIdBitmap, taskIdBitmap, Lists.newArrayList(), new Configuration());

    TestUtils.validateResult(readClient, expectedData);
    readClient.checkProcessedBlockIds();
    readClient.close();
  }
",non-flaky,5
76951,Tencent_Firestorm,ShuffleReadClientImplTest.readTest12,"  @Test
  public void readTest12() throws Exception {
    String basePath = HDFS_URI + ""clientReadTest12"";
    HdfsShuffleWriteHandler writeHandler =
        new HdfsShuffleWriteHandler(""appId"", 0, 1, 1, basePath, ""test1"", conf);

    Map<Long, byte[]> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0, 1);
    writeTestData(writeHandler, 5, 30, 0, expectedData, blockIdBitmap);
    writeTestData(writeHandler, 5, 30, 1, expectedData, blockIdBitmap);
    writeTestData(writeHandler, 5, 30, 2, Maps.newHashMap(), blockIdBitmap);

    // unexpected taskAttemptId should be filtered
    ShuffleReadClientImpl readClient = new ShuffleReadClientImpl(StorageType.HDFS.name(), ""appId"", 0, 1, 100, 1,
        10, 1000, basePath, blockIdBitmap, taskIdBitmap, Lists.newArrayList(), new Configuration());

    TestUtils.validateResult(readClient, expectedData);
    assertEquals(15, readClient.getProcessedBlockIds().getLongCardinality());
    readClient.checkProcessedBlockIds();
    readClient.close();
  }
",non-flaky,5
76952,Tencent_Firestorm,ShuffleReadClientImplTest.readTest13,"  @Test
  public void readTest13() throws Exception {
    String basePath = HDFS_URI + ""clientReadTest13"";
    HdfsShuffleWriteHandler writeHandler =
        new HdfsShuffleWriteHandler(""appId"", 0, 1, 1, basePath, ""test1"", conf);

    Map<Long, byte[]> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0, 3);
    writeTestData(writeHandler, 5, 30, 0, expectedData, blockIdBitmap);
    // test case: data generated by speculation task without report result
    writeTestData(writeHandler, 5, 30, 1, Maps.newHashMap(), Roaring64NavigableMap.bitmapOf());
    // test case: data generated by speculation task with report result
    writeTestData(writeHandler, 5, 30, 2, Maps.newHashMap(), blockIdBitmap);
    writeTestData(writeHandler, 5, 30, 3, expectedData, blockIdBitmap);

    // unexpected taskAttemptId should be filtered
    ShuffleReadClientImpl readClient = new ShuffleReadClientImpl(StorageType.HDFS.name(), ""appId"", 0, 1, 100, 1,
        10, 1000, basePath, blockIdBitmap, taskIdBitmap, Lists.newArrayList(), new Configuration());

    TestUtils.validateResult(readClient, expectedData);
    assertEquals(20, readClient.getProcessedBlockIds().getLongCardinality());
    readClient.checkProcessedBlockIds();
    readClient.close();
  }
",non-flaky,5
76953,Tencent_Firestorm,ShuffleReadClientImplTest.readTest14,"  @Test
  public void readTest14() throws Exception {
    String basePath = HDFS_URI + ""clientReadTest14"";
    HdfsShuffleWriteHandler writeHandler =
        new HdfsShuffleWriteHandler(""appId"", 0, 1, 1, basePath, ""test1"", conf);

    Map<Long, byte[]> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0, 2);
    writeDuplicatedData(writeHandler, 5, 30, 0, expectedData, blockIdBitmap);
    writeTestData(writeHandler, 5, 30, 1, Maps.newHashMap(), Roaring64NavigableMap.bitmapOf());
    writeTestData(writeHandler, 5, 30, 2, expectedData, blockIdBitmap);

    // unexpected taskAttemptId should be filtered
    ShuffleReadClientImpl readClient = new ShuffleReadClientImpl(StorageType.HDFS.name(), ""appId"", 0, 1, 100, 1,
        10, 1000, basePath, blockIdBitmap, taskIdBitmap, Lists.newArrayList(), new Configuration());

    TestUtils.validateResult(readClient, expectedData);
    assertEquals(15, readClient.getProcessedBlockIds().getLongCardinality());
    readClient.checkProcessedBlockIds();
    readClient.close();
  }
",non-flaky,5
76954,Tencent_Firestorm,ShuffleWriteClientImplTest.testSendData,"  @Test
  public void testSendData() {
    ShuffleWriteClientImpl shuffleWriteClient =
        new ShuffleWriteClientImpl(""GRPC"", 3, 2000, 4);
    ShuffleServerClient mockShuffleServerClient = mock(ShuffleServerClient.class);
    ShuffleWriteClientImpl spyClient = spy(shuffleWriteClient);
    doReturn(mockShuffleServerClient).when(spyClient).getShuffleServerClient(any());
    when(mockShuffleServerClient.sendShuffleData(any())).thenReturn(
        new RssSendShuffleDataResponse(ResponseStatusCode.NO_BUFFER));

    List<ShuffleServerInfo> shuffleServerInfoList =
        Lists.newArrayList(new ShuffleServerInfo(""id"", ""host"", 0));
    List<ShuffleBlockInfo> shuffleBlockInfoList = Lists.newArrayList(new ShuffleBlockInfo(
        0, 0, 10, 10, 10, new byte[]{1}, shuffleServerInfoList, 10, 100, 0));
    SendShuffleDataResult result = spyClient.sendShuffleData(""appId"", shuffleBlockInfoList);

    assertTrue(result.getFailedBlockIds().contains(10L));
  }
",non-flaky,5
76955,Tencent_Firestorm,JettyServerTest.jettyServerTest,"  @Test
  public void jettyServerTest() throws FileNotFoundException {
    RssBaseConf conf = new RssBaseConf();
    conf.setString(""rss.jetty.http.port"", ""9527"");
    JettyServer jettyServer = new JettyServer(conf);
    Server server = jettyServer.getServer();

    assertEquals(4, server.getBeans().size());
    assertEquals(30000, server.getStopTimeout());
    assertTrue(server.getThreadPool() instanceof ExecutorThreadPool);

    assertEquals(1, server.getConnectors().length);
    assertEquals(server, server.getHandler().getServer());
    assertTrue(server.getConnectors()[0] instanceof ServerConnector);
    ServerConnector connector = (ServerConnector) server.getConnectors()[0];
    assertEquals(9527, connector.getPort());

    assertEquals(1, server.getHandlers().length);
    Handler handler = server.getHandler();
    assertTrue(handler instanceof ServletContextHandler);
  }
",non-flaky,5
76956,Tencent_Firestorm,JettyServerTest.jettyServerStartTest,"  @Test
  public void jettyServerStartTest() throws Exception {
    try {
      RssBaseConf conf = new RssBaseConf();
      conf.setString(""rss.jetty.http.port"", ""9527"");
      JettyServer jettyServer1 = new JettyServer(conf);
      JettyServer jettyServer2 = new JettyServer(conf);
      jettyServer1.start();

      ExitUtils.disableSystemExit();
      final String expectMessage = ""Fail to start jetty http server"";
      final int expectStatus = 1;
      try {
        jettyServer2.start();
      } catch (Exception e) {
        assertEquals(expectMessage, e.getMessage());
        assertEquals(expectStatus, ((ExitException) e).getStatus());
      }

      final Thread t = new Thread(null, () -> {
        throw new AssertionError(""TestUncaughtException"");
      }, ""testThread"");
      t.start();
      t.join();
    } catch (Exception e) {
      e.printStackTrace();
      fail();
    }

  }
",non-flaky,5
76957,Tencent_Firestorm,ConfigOptionTest.testBasicTypes,"  @Test
  public void testBasicTypes() {
    final ConfigOption<Integer> intConfig = ConfigOptions
        .key(""rss.key1"")
        .intType()
        .defaultValue(1000)
        .withDescription(""Int config key1"");
    assertSame(Integer.class, intConfig.getClazz());
    assertEquals(1000, (int) intConfig.defaultValue());
    assertEquals(""Int config key1"", intConfig.description());

    final ConfigOption<Long> longConfig = ConfigOptions
        .key(""rss.key2"")
        .longType()
        .defaultValue(1999L);
    assertTrue(longConfig.hasDefaultValue());
    assertEquals(1999L, (long) longConfig.defaultValue());

    final ConfigOption<String> stringConfig = ConfigOptions
        .key(""rss.key3"")
        .stringType()
        .noDefaultValue();
    assertFalse(stringConfig.hasDefaultValue());
    assertEquals("""", stringConfig.description());

    final ConfigOption<Boolean> booleanConfig = ConfigOptions
        .key(""key4"")
        .booleanType()
        .defaultValue(false)
        .withDescription(""Boolean config key"");
    assertFalse(booleanConfig.defaultValue());
    assertEquals(""Boolean config key"", booleanConfig.description());

    final ConfigOption<Integer> positiveInt = ConfigOptions
        .key(""key5"")
        .intType()
        .checkValue((v) -> {return v > 0;}, ""The value of key5 must be positive"")
        .defaultValue(1)
        .withDescription(""Positive integer key"");
    RssBaseConf conf = new RssBaseConf();
    conf.set(positiveInt, -1);
    boolean isException = false;
    try {
      conf.get(positiveInt);
    } catch (IllegalArgumentException ie) {
      isException = true;
      assertTrue(ie.getMessage().contains(""The value of key5 must be positive""));
    }
    assertTrue(isException);
    conf.set(positiveInt, 1);
    try {
      conf.get(positiveInt);
    } catch (IllegalArgumentException ie) {
      fail();
    }
  }
",non-flaky,5
76958,Tencent_Firestorm,RssConfTest.testOptionWithDefault,"    @Test
    public void testOptionWithDefault() {
        RssConf cfg = new RssConf();
        cfg.setInteger(""int-key"", 11);
        cfg.setString(""string-key"", ""abc"");

        ConfigOption<String> presentStringOption = ConfigOptions
                .key(""string-key"")
                .stringType()
                .defaultValue(""my-beautiful-default"");
        ConfigOption<Integer> presentIntOption = ConfigOptions
                .key(""int-key"")
                .intType()
                .defaultValue(87);

        assertEquals(""abc"", cfg.getString(presentStringOption));
        assertEquals(""abc"", cfg.getValue(presentStringOption));

        assertEquals(11, cfg.getInteger(presentIntOption));
        assertEquals(""11"", cfg.getValue(presentIntOption));
    }
",non-flaky,5
76959,Tencent_Firestorm,RssConfTest.testSetStringAndGetConcreteType,"    @Test
    public void testSetStringAndGetConcreteType() {
        RssConf conf = new RssConf();
        conf.setString(""boolean-type"", ""true"");
        conf.setString(""int-type"", ""1111"");
        conf.setString(""long-type"", ""1000"");
        assertTrue(conf.getBoolean(""boolean-type"", false));
        assertEquals(conf.getInteger(""int-type"", 100), 1111);
        assertEquals(conf.getLong(""long-type"", 222L), 1000L);
    }
",non-flaky,5
76960,Tencent_Firestorm,RssConfTest.testOptionWithNoDefault,"    @Test
    public void testOptionWithNoDefault() {
        RssConf cfg = new RssConf();
        cfg.setInteger(""int-key"", 11);
        cfg.setString(""string-key"", ""abc"");

        ConfigOption<String> presentStringOption = ConfigOptions
                .key(""string-key"")
                .stringType()
                .noDefaultValue();

        assertEquals(""abc"", cfg.getString(presentStringOption));
        assertEquals(""abc"", cfg.getValue(presentStringOption));

        // test getting default when no value is present

        ConfigOption<String> stringOption = ConfigOptions
                .key(""test"")
                .stringType()
                .noDefaultValue();

        // getting strings for null should work
        assertNull(cfg.getValue(stringOption));
        assertNull(cfg.getString(stringOption));

        // overriding the null default should work
        assertEquals(""override"", cfg.getString(stringOption, ""override""));
    }
",non-flaky,5
76961,Tencent_Firestorm,ChecksumUtilsTest.crc32TestWithByte,"  @Test
  public void crc32TestWithByte() {
    byte[] data = new byte[32 * 1024 * 1024];
    new Random().nextBytes(data);
    CRC32 crc32 = new CRC32();
    crc32.update(data);
    long expected = crc32.getValue();
    assertEquals(expected, ChecksumUtils.getCrc32(data));

    data = new byte[32 * 1024];
    new Random().nextBytes(data);
    crc32 = new CRC32();
    crc32.update(data);
    expected = crc32.getValue();
    assertEquals(expected, ChecksumUtils.getCrc32(data));
  }
",non-flaky,5
76962,Tencent_Firestorm,ChecksumUtilsTest.crc32TestWithByteBuff,"  @Test
  public void crc32TestWithByteBuff() throws Exception {
    int length = 32 * 1024 * 1024;
    byte[] data = new byte[length];
    new Random().nextBytes(data);

    String tempDir = Files.createTempDirectory(""rss"").toString();
    File file = new File(tempDir, ""crc_test.txt"");
    file.createNewFile();
    file.deleteOnExit();

    try (FileOutputStream outputStream = new FileOutputStream(file)) {
      outputStream.write(data);
    }

    long expectedChecksum = ChecksumUtils.getCrc32(data);

    // test direct ByteBuffer
    Path path = Paths.get(file.getAbsolutePath());
    FileChannel fileChannel = FileChannel.open(path);
    ByteBuffer buffer = ByteBuffer.allocateDirect(length);
    int bytesRead = fileChannel.read(buffer);
    fileChannel.close();
    assertEquals(length, bytesRead);
    buffer.flip();
    assertEquals(expectedChecksum, ChecksumUtils.getCrc32(buffer));
    assertEquals(length, buffer.position());

    // test heap ByteBuffer
    path = Paths.get(file.getAbsolutePath());
    fileChannel = FileChannel.open(path);
    buffer = ByteBuffer.allocate(length);
    bytesRead = fileChannel.read(buffer);
    fileChannel.close();
    assertEquals(length, bytesRead);
    buffer.flip();
    assertEquals(expectedChecksum, ChecksumUtils.getCrc32(buffer));

  }
",non-flaky,5
76963,Tencent_Firestorm,RssUtilsTest.testGetPropertiesFromFile,"  @Test
  public void testGetPropertiesFromFile() {
    final String filePath = Objects.requireNonNull(
        getClass().getClassLoader().getResource(""rss-defaults.conf"")).getFile();
    Map<String, String> properties = RssUtils.getPropertiesFromFile(filePath);
    assertEquals(""12121"", properties.get(""rss.coordinator.port""));
    assertEquals(""155"", properties.get(""rss.server.heartbeat.interval""));
    assertEquals(""true"", properties.get(""rss.x.y.z""));
    assertEquals(""-XX:+PrintGCDetails-Dkey=value-Dnumbers=\""one two three\"""",
        properties.get(""rss.a.b.c.extraJavaOptions""));
  }
",non-flaky,5
76964,Tencent_Firestorm,RssUtilsTest.testGetHostIp,"  @Test
  public void testGetHostIp() {
    try {
      String address = InetAddress.getLocalHost().getHostAddress();
      String realIp = RssUtils.getHostIp();
      assertNotEquals(""127.0.0.1"", realIp);
      if (!address.equals(""127.0.0.1"")) {
        assertEquals(address, realIp);
      }
    } catch (Exception e) {
      fail(e.getMessage());
    }
  }
",non-flaky,5
76965,Tencent_Firestorm,RssUtilsTest.testSerializeBitmap,"  @Test
  public void testSerializeBitmap() throws Exception {
    Roaring64NavigableMap bitmap1 = Roaring64NavigableMap.bitmapOf(1, 2, 100, 10000);
    byte[] bytes = RssUtils.serializeBitMap(bitmap1);
    Roaring64NavigableMap bitmap2 = RssUtils.deserializeBitMap(bytes);
    assertEquals(bitmap1, bitmap2);
    assertEquals(Roaring64NavigableMap.bitmapOf(), RssUtils.deserializeBitMap(new byte[]{}));
  }
",non-flaky,5
76966,Tencent_Firestorm,RssUtilsTest.testShuffleIndexSegment,"  @Test
  public void testShuffleIndexSegment() {
    ShuffleIndexResult shuffleIndexResult = new ShuffleIndexResult();
    List<ShuffleDataSegment> shuffleDataSegments =
        RssUtils.transIndexDataToSegments(shuffleIndexResult, 1000);
    assertTrue(shuffleDataSegments.isEmpty());

    int readBufferSize = 32;
    int totalLength = 0;
    List<BufferSegment> bufferSegments = Lists.newArrayList();
    int[] dataSegmentLength = new int[]{32, 16, 10, 32, 6};

    for (int i = 0; i < dataSegmentLength.length; ++i) {
      long offset = totalLength;
      int length = dataSegmentLength[i];
      bufferSegments.add(new BufferSegment(i, offset, length, i, i, i));
      totalLength += length;
    }

    // those 5 segment's data length are [32, 16, 10, 32, 6] so the index should be
    // split into 3 ShuffleDataSegment, which are [32, 16 + 10 + 32, 6]
    int expectedTotalSegmentNum = 3;
    ByteBuffer byteBuffer = ByteBuffer.allocate(5 * 40);

    for (BufferSegment bufferSegment : bufferSegments) {
      byteBuffer.putLong(bufferSegment.getOffset());
      byteBuffer.putInt(bufferSegment.getLength());
      byteBuffer.putInt(bufferSegment.getUncompressLength());
      byteBuffer.putLong(bufferSegment.getCrc());
      byteBuffer.putLong(bufferSegment.getBlockId());
      byteBuffer.putLong(bufferSegment.getTaskAttemptId());
    }

    byte[] data = byteBuffer.array();
    shuffleDataSegments = RssUtils.transIndexDataToSegments(new ShuffleIndexResult(data), readBufferSize);
    assertEquals(expectedTotalSegmentNum, shuffleDataSegments.size());

    assertEquals(0, shuffleDataSegments.get(0).getOffset());
    assertEquals(32, shuffleDataSegments.get(0).getLength());
    assertEquals(1, shuffleDataSegments.get(0).getBufferSegments().size());

    assertEquals(32, shuffleDataSegments.get(1).getOffset());
    assertEquals(58, shuffleDataSegments.get(1).getLength());
    assertEquals(3,shuffleDataSegments.get(1).getBufferSegments().size());

    assertEquals(90, shuffleDataSegments.get(2).getOffset());
    assertEquals(6, shuffleDataSegments.get(2).getLength());
    assertEquals(1, shuffleDataSegments.get(2).getBufferSegments().size());
  }
",non-flaky,5
76967,Tencent_Firestorm,ExitUtilsTest.test,"  @Test
  public void test() {
    try {
    final int status = -1;
    final String testExitMessage = ""testExitMessage"";
    try {
      ExitUtils.disableSystemExit();
      ExitUtils.terminate(status, testExitMessage, null, null);
      fail();
    } catch (ExitException e) {
      assertEquals(status, e.getStatus());
      assertEquals(testExitMessage, e.getMessage());
    }

    final Thread t = new Thread(null, () -> {
      throw new AssertionError(""TestUncaughtException"");
    }, ""testThread"");
    t.start();
    t.join();
  } catch (Exception e) {
      e.printStackTrace();
      fail();
    }

  }
",non-flaky,5
76968,Tencent_Firestorm,UnitConverterTest.testByteString,"  @Test
  public void testByteString() {

    assertEquals(10 * PB, UnitConverter.byteStringAs(""10PB"", ByteUnit.BYTE));
    assertEquals(10 * PB, UnitConverter.byteStringAs(""10pb"", ByteUnit.BYTE));
    assertEquals(10 * PB, UnitConverter.byteStringAs(""10pB"", ByteUnit.BYTE));
    assertEquals(10 * PB, UnitConverter.byteStringAs(""10p"", ByteUnit.BYTE));
    assertEquals(10 * PB, UnitConverter.byteStringAs(""10P"", ByteUnit.BYTE));

    assertEquals(10 * TB, UnitConverter.byteStringAs(""10TB"", ByteUnit.BYTE));
    assertEquals(10 * TB, UnitConverter.byteStringAs(""10tb"", ByteUnit.BYTE));
    assertEquals(10 * TB, UnitConverter.byteStringAs(""10tB"", ByteUnit.BYTE));
    assertEquals(10 * TB, UnitConverter.byteStringAs(""10T"", ByteUnit.BYTE));
    assertEquals(10 * TB, UnitConverter.byteStringAs(""10t"", ByteUnit.BYTE));

    assertEquals(10 * GB, UnitConverter.byteStringAs(""10GB"", ByteUnit.BYTE));
    assertEquals(10 * GB, UnitConverter.byteStringAs(""10gb"", ByteUnit.BYTE));
    assertEquals(10 * GB, UnitConverter.byteStringAs(""10gB"", ByteUnit.BYTE));

    assertEquals(10 * MB, UnitConverter.byteStringAs(""10MB"", ByteUnit.BYTE));
    assertEquals(10 * MB, UnitConverter.byteStringAs(""10mb"", ByteUnit.BYTE));
    assertEquals(10 * MB, UnitConverter.byteStringAs(""10mB"", ByteUnit.BYTE));
    assertEquals(10 * MB, UnitConverter.byteStringAs(""10M"", ByteUnit.BYTE));
    assertEquals(10 * MB, UnitConverter.byteStringAs(""10m"", ByteUnit.BYTE));

    assertEquals(10 * KB, UnitConverter.byteStringAs(""10KB"", ByteUnit.BYTE));
    assertEquals(10 * KB, UnitConverter.byteStringAs(""10kb"", ByteUnit.BYTE));
    assertEquals(10 * KB, UnitConverter.byteStringAs(""10Kb"", ByteUnit.BYTE));
    assertEquals(10 * KB, UnitConverter.byteStringAs(""10K"", ByteUnit.BYTE));
    assertEquals(10 * KB, UnitConverter.byteStringAs(""10k"", ByteUnit.BYTE));

    assertEquals(1111, UnitConverter.byteStringAs(""1111"", ByteUnit.BYTE));
  }
",non-flaky,5
76969,Tencent_Firestorm,ArgumentsTest.argTest,"  @Test
  public void argTest() {
    String[] args = {""-c"", confFile};
    Arguments arguments = new Arguments();
    CommandLine commandLine = new CommandLine(arguments);
    commandLine.parseArgs(args);
    assertEquals(confFile, arguments.getConfigFile());
  }
",non-flaky,5
76970,Tencent_Firestorm,ArgumentsTest.argEmptyTest,"  @Test
  public void argEmptyTest() {
    String[] args = new String[0];
    Arguments arguments = new Arguments();
    CommandLine commandLine = new CommandLine(arguments);
    commandLine.parseArgs(args);
    assertNull(arguments.getConfigFile());
  }
",non-flaky,5
76971,Tencent_Firestorm,MetricsManagerTest.testMetricsManager,"  @Test
  public void testMetricsManager() {
    MetricsManager metricsManager = new MetricsManager();
    assertEquals(CollectorRegistry.defaultRegistry, metricsManager.getCollectorRegistry());

    CollectorRegistry expectedRegistry = new CollectorRegistry();
    metricsManager = new MetricsManager(expectedRegistry);
    assertEquals(expectedRegistry, metricsManager.getCollectorRegistry());

    String expectedName1 = ""counter"";
    String expectedHelp1 = ""Counter "" + expectedName1;
    metricsManager.addCounter(expectedName1);

    String expectedName2 = ""name2"";
    String expectedHelp2 = ""Gauge "" + expectedName2;
    String label = ""gaugeLabel"";
    Gauge gauge = metricsManager.addGauge(expectedName2, label);
    gauge.labels(""lv1"").inc();
    gauge.labels(""lv2"").inc();

    Map<String, MetricFamilySamples> metricsSamples = new HashMap<>();
    Enumeration<MetricFamilySamples> mfs = expectedRegistry.metricFamilySamples();
    while (mfs.hasMoreElements()) {
      MetricFamilySamples cur = mfs.nextElement();
      metricsSamples.put(cur.name, cur);
    }

    assertEquals(expectedHelp1, metricsSamples.get(expectedName1).help);
    assertEquals(1, metricsSamples.get(expectedName1).samples.size());

    assertEquals(expectedHelp2, metricsSamples.get(expectedName2).help);
    List<MetricFamilySamples.Sample> f = metricsSamples.get(expectedName2).samples;
    assertEquals(2, metricsSamples.get(expectedName2).samples.size());
    String[] actualLabelValues = metricsSamples
        .get(expectedName2).samples
        .stream().map(i -> i.labelValues.get(0))
        .collect(Collectors.toList()).toArray(new String[0]);
    Arrays.sort(actualLabelValues);
    assertArrayEquals(new String[]{""lv1"", ""lv2""}, actualLabelValues);
  }
",non-flaky,5
76972,Tencent_Firestorm,ShufflePartitionedBlockTest.shufflePartitionedBlockTest,"  @Test
  public void shufflePartitionedBlockTest() {
    byte[] buf = new byte[3];
    new Random().nextBytes(buf);

    ShufflePartitionedBlock b1 = new ShufflePartitionedBlock(1, 1, 2, 3, 1, buf);
    assertEquals(1, b1.getLength());
    assertEquals(2, b1.getCrc());
    assertEquals(3, b1.getBlockId());

    ShufflePartitionedBlock b3 = new ShufflePartitionedBlock(1, 1, 2, 3, 3, buf);
    assertArrayEquals(buf, b3.getData());
  }
",non-flaky,5
76973,Tencent_Firestorm,SparkClientWithLocalTest.readTest1,"  @Test
  public void readTest1() {
    String testAppId = ""localReadTest1"";
    registerApp(testAppId, Lists.newArrayList(new PartitionRange(0, 0)));
    Map<Long, byte[]> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0);
    createTestData(testAppId, expectedData, blockIdBitmap, taskIdBitmap);
    blockIdBitmap.addLong((1 << Constants.TASK_ATTEMPT_ID_MAX_LENGTH));
    ShuffleReadClientImpl readClient;
    readClient = new ShuffleReadClientImpl(StorageType.LOCALFILE.name(), testAppId, 0, 0, 100, 1,
        10, 1000, """", blockIdBitmap, taskIdBitmap, shuffleServerInfo, null);
    validateResult(readClient, expectedData);
    try {
      // can't find all expected block id, data loss
      readClient.checkProcessedBlockIds();
      fail(EXPECTED_EXCEPTION_MESSAGE);
    } catch (Exception e) {
      assertTrue(e.getMessage().contains(""Blocks read inconsistent:""));
    } finally {
      readClient.close();
    }
  }
",non-flaky,5
76974,Tencent_Firestorm,SparkClientWithLocalTest.readTest2,"  @Test
  public void readTest2() {
    String testAppId = ""localReadTest2"";
    registerApp(testAppId, Lists.newArrayList(new PartitionRange(0, 0)));

    Map<Long, byte[]> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0);
    List<ShuffleBlockInfo> blocks = createShuffleBlockList(
        0, 0, 0, 2, 30, blockIdBitmap, expectedData, mockSSI);
    sendTestData(testAppId, blocks);
    blocks = createShuffleBlockList(
        0, 0, 0, 2, 30, blockIdBitmap, expectedData, mockSSI);
    sendTestData(testAppId, blocks);

    ShuffleReadClientImpl readClient = new ShuffleReadClientImpl(StorageType.LOCALFILE.name(),
        testAppId, 0, 0, 100, 1, 10, 1000,
        """", blockIdBitmap, taskIdBitmap, shuffleServerInfo, null);

    validateResult(readClient, expectedData);
    readClient.checkProcessedBlockIds();
    readClient.close();
  }
",non-flaky,5
76975,Tencent_Firestorm,SparkClientWithLocalTest.readTest3,"  @Test
  public void readTest3() throws Exception {
    String testAppId = ""localReadTest3"";
    registerApp(testAppId, Lists.newArrayList(new PartitionRange(0, 0)));

    Map<Long, byte[]> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0);
    List<ShuffleBlockInfo> blocks = createShuffleBlockList(
        0, 0, 0, 2, 30, blockIdBitmap, expectedData, mockSSI);
    sendTestData(testAppId, blocks);

    ShuffleReadClientImpl readClient = new ShuffleReadClientImpl(StorageType.LOCALFILE.name(),
        testAppId, 0, 0, 100, 1, 10, 1000,
        """", blockIdBitmap, taskIdBitmap, shuffleServerInfo, null);
    FileUtils.deleteDirectory(new File(DATA_DIR1.getAbsolutePath() + ""/"" + testAppId + ""/0/0-0""));
    FileUtils.deleteDirectory(new File(DATA_DIR2.getAbsolutePath() + ""/"" + testAppId + ""/0/0-0""));
    // sleep to wait delete operation
    Thread.sleep(2000);

    try {
      readClient.readShuffleBlockData();
      fail(EXPECTED_EXCEPTION_MESSAGE);
    } catch (Exception e) {
      assertTrue(e.getMessage().contains(""Failed to read shuffle index""));
    }
    readClient.close();
  }
",non-flaky,5
76976,Tencent_Firestorm,SparkClientWithLocalTest.readTest4,"  @Test
  public void readTest4() {
    String testAppId = ""localReadTest4"";
    registerApp(testAppId, Lists.newArrayList(new PartitionRange(0, 1)));

    Map<Long, byte[]> expectedData1 = Maps.newHashMap();
    Map<Long, byte[]> expectedData2 = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap1 = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0);
    List<ShuffleBlockInfo> blocks = createShuffleBlockList(
        0, 0, 0, 10, 30, blockIdBitmap1, expectedData1, mockSSI);
    sendTestData(testAppId, blocks);

    Roaring64NavigableMap blockIdBitmap2 = Roaring64NavigableMap.bitmapOf();
    blocks = createShuffleBlockList(
        0, 1, 0, 10, 30, blockIdBitmap2, expectedData2, mockSSI);
    sendTestData(testAppId, blocks);

    blocks = createShuffleBlockList(
        0, 0, 0, 10, 30, blockIdBitmap1, expectedData1, mockSSI);
    sendTestData(testAppId, blocks);

    ShuffleReadClientImpl readClient1 = new ShuffleReadClientImpl(StorageType.LOCALFILE.name(),
        testAppId, 0, 0, 100, 2, 10, 100,
        """", blockIdBitmap1, taskIdBitmap, shuffleServerInfo, null);
    ShuffleReadClientImpl readClient2 = new ShuffleReadClientImpl(StorageType.LOCALFILE.name(),
        testAppId, 0, 1, 100, 2, 10, 100,
        """", blockIdBitmap2, taskIdBitmap, shuffleServerInfo, null);
    validateResult(readClient1, expectedData1);
    readClient1.checkProcessedBlockIds();
    readClient1.close();

    validateResult(readClient2, expectedData2);
    readClient2.checkProcessedBlockIds();
    readClient2.close();
  }
",non-flaky,5
76977,Tencent_Firestorm,SparkClientWithLocalTest.readTest5,"  @Test
  public void readTest5() {
    String testAppId = ""localReadTest5"";
    ShuffleReadClientImpl readClient = new ShuffleReadClientImpl(StorageType.LOCALFILE.name(),
        testAppId, 0, 1, 100, 2, 10, 1000,
        """", Roaring64NavigableMap.bitmapOf(), Roaring64NavigableMap.bitmapOf(),
        shuffleServerInfo, null);
    assertNull(readClient.readShuffleBlockData());
    readClient.checkProcessedBlockIds();
  }
",non-flaky,5
76978,Tencent_Firestorm,SparkClientWithLocalTest.readTest6,"  @Test
  public void readTest6() {
    String testAppId = ""localReadTest6"";
    registerApp(testAppId, Lists.newArrayList(new PartitionRange(0, 0)));

    Map<Long, byte[]> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0);
    List<ShuffleBlockInfo> blocks = createShuffleBlockList(
        0, 0, 0, 5, 30, blockIdBitmap, expectedData, mockSSI);
    sendTestData(testAppId, blocks);

    Roaring64NavigableMap wrongBlockIdBitmap = Roaring64NavigableMap.bitmapOf();
    LongIterator iter = blockIdBitmap.getLongIterator();
    while (iter.hasNext()) {
      wrongBlockIdBitmap.addLong(iter.next() + (1 << Constants.TASK_ATTEMPT_ID_MAX_LENGTH));
    }

    ShuffleReadClientImpl readClient = new ShuffleReadClientImpl(StorageType.LOCALFILE.name(),
        testAppId, 0, 0, 100, 1, 10, 100,
        """", wrongBlockIdBitmap, taskIdBitmap, shuffleServerInfo, null);
    assertNull(readClient.readShuffleBlockData());
    try {
      readClient.checkProcessedBlockIds();
      fail(EXPECTED_EXCEPTION_MESSAGE);
    } catch (Exception e) {
      assertTrue(e.getMessage().contains(""Blocks read inconsistent:""));
    }
  }
",non-flaky,5
76979,Tencent_Firestorm,SparkClientWithLocalTest.readTest7,"  @Test
  public void readTest7() {
    String testAppId = ""localReadTest7"";
    registerApp(testAppId, Lists.newArrayList(new PartitionRange(0, 0)));

    Map<Long, byte[]> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0, 1);

    List<ShuffleBlockInfo> blocks = createShuffleBlockList(
        0, 0, 0, 5, 30, blockIdBitmap, expectedData, mockSSI);
    sendTestData(testAppId, blocks);

    blocks = createShuffleBlockList(
        0, 0, 1, 5, 30, blockIdBitmap, expectedData, mockSSI);
    sendTestData(testAppId, blocks);

    blocks = createShuffleBlockList(
        0, 0, 2, 5, 30, blockIdBitmap, Maps.newHashMap(), mockSSI);
    sendTestData(testAppId, blocks);

    // unexpected taskAttemptId should be filtered
    ShuffleReadClientImpl readClient = new ShuffleReadClientImpl(StorageType.LOCALFILE.name(), testAppId, 0, 0, 100, 1,
        10, 1000, """", blockIdBitmap, taskIdBitmap, shuffleServerInfo, null);

    validateResult(readClient, expectedData);
    readClient.checkProcessedBlockIds();
    readClient.close();
  }
",non-flaky,5
76980,Tencent_Firestorm,SparkClientWithLocalTest.readTest8,"  @Test
  public void readTest8() {
    String testAppId = ""localReadTest8"";
    registerApp(testAppId, Lists.newArrayList(new PartitionRange(0, 0)));

    Map<Long, byte[]> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0, 3);
    List<ShuffleBlockInfo> blocks = createShuffleBlockList(
        0, 0, 0, 5, 30, blockIdBitmap, expectedData, mockSSI);
    sendTestData(testAppId, blocks);

    // test case: data generated by speculation task without report result
    blocks = createShuffleBlockList(
        0, 0, 1, 5, 30, Roaring64NavigableMap.bitmapOf(), Maps.newHashMap(), mockSSI);
    sendTestData(testAppId, blocks);
    // test case: data generated by speculation task with report result
    blocks = createShuffleBlockList(
        0, 0, 2, 5, 30, blockIdBitmap, Maps.newHashMap(), mockSSI);
    sendTestData(testAppId, blocks);

    blocks = createShuffleBlockList(
        0, 0, 3, 5, 30, Roaring64NavigableMap.bitmapOf(), Maps.newHashMap(), mockSSI);
    sendTestData(testAppId, blocks);

    // unexpected taskAttemptId should be filtered
    ShuffleReadClientImpl readClient = new ShuffleReadClientImpl(StorageType.LOCALFILE.name(), testAppId, 0, 0, 100, 1,
        10, 1000, """", blockIdBitmap, taskIdBitmap, shuffleServerInfo, null);

    validateResult(readClient, expectedData);
    readClient.checkProcessedBlockIds();
    readClient.close();
  }
",non-flaky,5
76981,Tencent_Firestorm,SparkClientWithLocalTest.readTest9,"  @Test
  public void readTest9() throws Exception {
    String testAppId = ""localReadTest9"";
    registerApp(testAppId, Lists.newArrayList(new PartitionRange(0, 0)));
    Map<Long, byte[]> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0);

    List<ShuffleBlockInfo> blocks;
    ShuffleReadClientImpl readClient;

    createTestData(testAppId, expectedData, blockIdBitmap, taskIdBitmap);
    Roaring64NavigableMap beforeAdded = RssUtils.deserializeBitMap(RssUtils.serializeBitMap(blockIdBitmap));
    // write data by another task, read data again, the cache for index file should be updated
    blocks = createShuffleBlockList(
        0, 0, 1, 3, 25, blockIdBitmap, Maps.newHashMap(), mockSSI);
    sendTestData(testAppId, blocks);
    // test with un-changed expected blockId
    readClient = new ShuffleReadClientImpl(StorageType.LOCALFILE.name(), testAppId, 0, 0, 100, 1,
        10, 1000, """", beforeAdded, taskIdBitmap,
        shuffleServerInfo, null);
    validateResult(readClient, expectedData);
    readClient.checkProcessedBlockIds();
    readClient.close();

    // test with changed expected blockId
    readClient = new ShuffleReadClientImpl(StorageType.LOCALFILE.name(), testAppId, 0, 0, 100, 1,
        10, 1000, """", blockIdBitmap, taskIdBitmap,
        shuffleServerInfo, null);
    validateResult(readClient, expectedData);
    readClient.checkProcessedBlockIds();
    readClient.close();
  }
",non-flaky,5
76982,Tencent_Firestorm,CombineByKeyTest.combineByKeyTest,"  @Test
  public void combineByKeyTest() throws Exception {
    run();
  }
",non-flaky,5
76983,Tencent_Firestorm,SparkSQLTest.resultCompareTest,"  @Test
  public void resultCompareTest() throws Exception {
    run();
    checkShuffleData();
  }
",non-flaky,5
76984,Tencent_Firestorm,RepartitionTest.resultCompareTest,"  @Test
  public void resultCompareTest() throws Exception {
    run();
  }
",non-flaky,5
76985,Tencent_Firestorm,RepartitionTest.testMemoryRelease,"  @Test
  public void testMemoryRelease() throws Exception {
    String fileName = generateTextFile(10000, 10000);
    SparkConf sparkConf = createSparkConf();
    updateSparkConfWithRss(sparkConf);
    sparkConf.set(""spark.executor.memory"", ""500m"");
    updateRssStorage(sparkConf);

    // oom if there has no memory release
    runSparkApp(sparkConf, fileName);
  }
",non-flaky,5
76986,Tencent_Firestorm,GroupByKeyTest.groupByTest,"  @Test
  public void groupByTest() throws Exception {
    run();
  }
",non-flaky,5
76987,Tencent_Firestorm,SparkFallbackReadTest.resultCompareTest,"  @Test
  public void resultCompareTest() throws Exception {
    run();
    checkShuffleData();
  }
",non-flaky,5
76988,Tencent_Firestorm,ShuffleWithRssClientTest.rpcFailTest,"  @Test
  public void rpcFailTest() throws Exception {
    String testAppId = ""rpcFailTest"";
    shuffleWriteClientImpl.registerShuffle(shuffleServerInfo1,
        testAppId, 0, Lists.newArrayList(new PartitionRange(0, 0)));
    Map<Long, byte[]> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();

    // simulator a failed server
    ShuffleServerInfo fakeShuffleServerInfo =
        new ShuffleServerInfo(""127.0.0.1-20001"", shuffleServers.get(0).getIp(), SHUFFLE_SERVER_PORT + 100);
    List<ShuffleBlockInfo> blocks = createShuffleBlockList(
        0, 0, 0, 3, 25, blockIdBitmap,
        expectedData, Lists.newArrayList(shuffleServerInfo1, fakeShuffleServerInfo));
    SendShuffleDataResult result = shuffleWriteClientImpl.sendShuffleData(testAppId, blocks);
    Roaring64NavigableMap failedBlockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap succBlockIdBitmap = Roaring64NavigableMap.bitmapOf();
    for (Long blockId : result.getFailedBlockIds()) {
      failedBlockIdBitmap.addLong(blockId);
    }
    for (Long blockId : result.getSuccessBlockIds()) {
      succBlockIdBitmap.addLong(blockId);
    }
    assertEquals(blockIdBitmap, failedBlockIdBitmap);
    assertEquals(blockIdBitmap, succBlockIdBitmap);

    boolean commitResult = shuffleWriteClientImpl.sendCommit(Sets.newHashSet(
        shuffleServerInfo1, fakeShuffleServerInfo), testAppId, 0, 2);
    assertFalse(commitResult);

    Map<Integer, List<Long>> ptb = Maps.newHashMap();
    ptb.put(1, Lists.newArrayList(1L));
    try {
      Map<Integer, List<ShuffleServerInfo>> partitionToServers = Maps.newHashMap();
      partitionToServers.put(1, Lists.newArrayList(
          shuffleServerInfo1, fakeShuffleServerInfo));
      shuffleWriteClientImpl.reportShuffleResult(partitionToServers, testAppId, 0, 0, ptb, 2);
      fail(EXPECTED_EXCEPTION_MESSAGE);
    } catch (Exception e) {
      assertTrue(e.getMessage().contains(""Report shuffle result is failed for""));
    }
  }
",non-flaky,5
76989,Tencent_Firestorm,ShuffleWithRssClientTest.reportMultipleServerTest,"  @Test
  public void reportMultipleServerTest() throws Exception {
    String testAppId = ""reportMultipleServerTest"";

    shuffleWriteClientImpl.registerShuffle(shuffleServerInfo1,
        testAppId, 1, Lists.newArrayList(new PartitionRange(1, 1)));

    shuffleWriteClientImpl.registerShuffle(shuffleServerInfo2,
        testAppId, 1, Lists.newArrayList(new PartitionRange(2, 2)));

    Map<Integer, List<ShuffleServerInfo>> partitionToServers = Maps.newHashMap();
    partitionToServers.putIfAbsent(1, Lists.newArrayList(shuffleServerInfo1));
    partitionToServers.putIfAbsent(2, Lists.newArrayList(shuffleServerInfo2));
    Map<Integer, List<Long>> partitionToBlocks = Maps.newHashMap();
    List<Long> blockIds = Lists.newArrayList();
    for (int i = 0; i < 5; i++ ) {
      blockIds.add(ClientUtils.getBlockId(1, 0, i));
    }
    partitionToBlocks.put(1, blockIds);
    blockIds = Lists.newArrayList();
    for (int i = 0; i < 7; i++ ) {
      blockIds.add(ClientUtils.getBlockId(2, 0, i));
    }
    partitionToBlocks.put(2, blockIds);
    shuffleWriteClientImpl
        .reportShuffleResult(partitionToServers, testAppId, 1, 0, partitionToBlocks, 1);

    Roaring64NavigableMap bitmap = shuffleWriteClientImpl
        .getShuffleResult(""GRPC"", Sets.newHashSet(shuffleServerInfo1), testAppId,
        1, 0);
    assertTrue(bitmap.isEmpty());

    bitmap = shuffleWriteClientImpl
        .getShuffleResult(""GRPC"", Sets.newHashSet(shuffleServerInfo1), testAppId,
        1, 1);
    assertEquals(5, bitmap.getLongCardinality());
    for (int i = 0; i < 5; i++) {
      assertTrue(bitmap.contains(partitionToBlocks.get(1).get(i)));
    }

    bitmap = shuffleWriteClientImpl
        .getShuffleResult(""GRPC"", Sets.newHashSet(shuffleServerInfo1), testAppId,
        1, 2);
    assertTrue(bitmap.isEmpty());

    bitmap = shuffleWriteClientImpl
        .getShuffleResult(""GRPC"", Sets.newHashSet(shuffleServerInfo2), testAppId,
        1, 0);
    assertTrue(bitmap.isEmpty());

    bitmap = shuffleWriteClientImpl
        .getShuffleResult(""GRPC"", Sets.newHashSet(shuffleServerInfo2), testAppId,
        1, 1);
    assertTrue(bitmap.isEmpty());

    bitmap = shuffleWriteClientImpl
        .getShuffleResult(""GRPC"", Sets.newHashSet(shuffleServerInfo2), testAppId,
        1, 2);
    assertEquals(7, bitmap.getLongCardinality());
    for (int i = 0; i < 7; i++) {
      assertTrue(bitmap.contains(partitionToBlocks.get(2).get(i)));
    }
  }
",non-flaky,5
76990,Tencent_Firestorm,ShuffleWithRssClientTest.writeReadTest,"  @Test
  public void writeReadTest() throws Exception {
    String testAppId = ""writeReadTest"";
    shuffleWriteClientImpl.registerShuffle(shuffleServerInfo1,
        testAppId, 0, Lists.newArrayList(new PartitionRange(0, 0)));
    shuffleWriteClientImpl.registerShuffle(shuffleServerInfo2,
        testAppId, 0, Lists.newArrayList(new PartitionRange(0, 0)));
    Map<Long, byte[]> expectedData = Maps.newHashMap();
    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap taskIdBitmap = Roaring64NavigableMap.bitmapOf(0);

    List<ShuffleBlockInfo> blocks = createShuffleBlockList(
        0, 0, 0, 3, 25, blockIdBitmap,
        expectedData, Lists.newArrayList(shuffleServerInfo1, shuffleServerInfo2));
    shuffleWriteClientImpl.sendShuffleData(testAppId, blocks);
    // send 1st commit, finish commit won't be sent to Shuffle server and data won't be persisted to disk
    boolean commitResult = shuffleWriteClientImpl
        .sendCommit(Sets.newHashSet(shuffleServerInfo1, shuffleServerInfo2), testAppId, 0, 2);
    assertTrue(commitResult);

    ShuffleReadClientImpl readClient = new ShuffleReadClientImpl(StorageType.LOCALFILE.name(), testAppId, 0, 0, 100, 1,
        10, 1000, """", blockIdBitmap, taskIdBitmap,
        Lists.newArrayList(shuffleServerInfo1, shuffleServerInfo2), null);

    try {
      readClient.readShuffleBlockData();
      fail(EXPECTED_EXCEPTION_MESSAGE);
    } catch (Exception e) {
      assertTrue(e.getMessage().contains(""Failed to read shuffle index for""));
    }
    readClient.close();

    // send 2nd commit, data will be persisted to disk
    commitResult = shuffleWriteClientImpl
        .sendCommit(Sets.newHashSet(shuffleServerInfo1, shuffleServerInfo2), testAppId, 0, 2);
    assertTrue(commitResult);
    readClient = new ShuffleReadClientImpl(StorageType.LOCALFILE.name(), testAppId, 0, 0, 100, 1,
        10, 1000, """", blockIdBitmap, taskIdBitmap,
        Lists.newArrayList(shuffleServerInfo1, shuffleServerInfo2), null);
    validateResult(readClient, expectedData);
    readClient.checkProcessedBlockIds();
    readClient.close();

    // commit will be failed because of fakeIp
    commitResult = shuffleWriteClientImpl.sendCommit(Sets.newHashSet(new ShuffleServerInfo(
        ""127.0.0.1-20001"", ""fakeIp"", SHUFFLE_SERVER_PORT)), testAppId, 0, 2);
    assertFalse(commitResult);

    // wait resource to be deleted
    Thread.sleep(6000);

    // commit is ok, but finish shuffle rpc will failed because resource was deleted
    commitResult = shuffleWriteClientImpl
        .sendCommit(Sets.newHashSet(shuffleServerInfo1, shuffleServerInfo2), testAppId, 0, 2);
    assertFalse(commitResult);
  }
",non-flaky,5
76991,Tencent_Firestorm,ShuffleWithRssClientTest.emptyTaskTest,"  @Test
  public void emptyTaskTest() {
    String testAppId = ""emptyTaskTest"";
    shuffleWriteClientImpl.registerShuffle(shuffleServerInfo1,
        testAppId, 0, Lists.newArrayList(new PartitionRange(0, 0)));
    boolean commitResult = shuffleWriteClientImpl
        .sendCommit(Sets.newHashSet(shuffleServerInfo1), testAppId, 0, 2);
    assertTrue(commitResult);
    commitResult = shuffleWriteClientImpl
        .sendCommit(Sets.newHashSet(shuffleServerInfo2), testAppId, 0, 2);
    assertFalse(commitResult);
  }
",non-flaky,5
76992,Tencent_Firestorm,CoordinatorGrpcTest.testGetPartitionToServers,"  @Test
  public void testGetPartitionToServers() {
    GetShuffleAssignmentsResponse testResponse = generateShuffleAssignmentsResponse();

    Map<Integer, List<ShuffleServerInfo>> partitionToServers =
        coordinatorClient.getPartitionToServers(testResponse);

    assertEquals(Arrays.asList(new ShuffleServerInfo(""id1"", ""0.0.0.1"", 100),
        new ShuffleServerInfo(""id2"", ""0.0.0.2"", 100)),
        partitionToServers.get(0));
    assertEquals(Arrays.asList(new ShuffleServerInfo(""id1"", ""0.0.0.1"", 100),
        new ShuffleServerInfo(""id2"", ""0.0.0.2"", 100)),
        partitionToServers.get(1));
    assertEquals(Arrays.asList(new ShuffleServerInfo(""id3"", ""0.0.0.3"", 100),
        new ShuffleServerInfo(""id4"", ""0.0.0.4"", 100)),
        partitionToServers.get(2));
    assertEquals(Arrays.asList(new ShuffleServerInfo(""id3"", ""0.0.0.3"", 100),
        new ShuffleServerInfo(""id4"", ""0.0.0.4"", 100)),
        partitionToServers.get(3));
    assertNull(partitionToServers.get(4));
  }
",non-flaky,5
76993,Tencent_Firestorm,CoordinatorGrpcTest.getShuffleRegisterInfoTest,"  @Test
  public void getShuffleRegisterInfoTest() {
    GetShuffleAssignmentsResponse testResponse = generateShuffleAssignmentsResponse();
    Map<ShuffleServerInfo, List<PartitionRange>> serverToPartitionRanges =
        coordinatorClient.getServerToPartitionRanges(testResponse);
    List<ShuffleRegisterInfo> expected = Arrays.asList(
        new ShuffleRegisterInfo(new ShuffleServerInfo(""id1"", ""0.0.0.1"", 100),
            Lists.newArrayList(new PartitionRange(0, 1))),
        new ShuffleRegisterInfo(new ShuffleServerInfo(""id2"", ""0.0.0.2"", 100),
            Lists.newArrayList(new PartitionRange(0, 1))),
        new ShuffleRegisterInfo(new ShuffleServerInfo(""id3"", ""0.0.0.3"", 100),
            Lists.newArrayList(new PartitionRange(2, 3))),
        new ShuffleRegisterInfo(new ShuffleServerInfo(""id4"", ""0.0.0.4"", 100),
            Lists.newArrayList(new PartitionRange(2, 3))));
    assertEquals(4, serverToPartitionRanges.size());
    for (ShuffleRegisterInfo sri : expected) {
      List<PartitionRange> partitionRanges = serverToPartitionRanges.get(sri.getShuffleServerInfo());
      assertEquals(sri.getPartitionRanges(), partitionRanges);
    }
  }
",non-flaky,5
76994,Tencent_Firestorm,CoordinatorGrpcTest.getShuffleAssignmentsTest,"  @Test
  public void getShuffleAssignmentsTest() throws Exception {
    String appId = ""getShuffleAssignmentsTest"";
    CoordinatorTestUtils.waitForRegister(coordinatorClient,2);
    RssGetShuffleAssignmentsRequest request = new RssGetShuffleAssignmentsRequest(
        appId, 1, 10, 4, 1,
        Sets.newHashSet(Constants.SHUFFLE_SERVER_VERSION));
    RssGetShuffleAssignmentsResponse response = coordinatorClient.getShuffleAssignments(request);
    Set<Integer> expectedStart = Sets.newHashSet(0, 4, 8);

    Map<ShuffleServerInfo, List<PartitionRange>> serverToPartitionRanges = response.getServerToPartitionRanges();
    assertEquals(2, serverToPartitionRanges.size());
    List<PartitionRange> partitionRanges = Lists.newArrayList();
    for (List<PartitionRange> ranges : serverToPartitionRanges.values()) {
      partitionRanges.addAll(ranges);
    }
    for (PartitionRange pr : partitionRanges) {
      switch (pr.getStart()) {
        case 0:
          assertEquals(3, pr.getEnd());
          expectedStart.remove(0);
          break;
        case 4:
          assertEquals(7, pr.getEnd());
          expectedStart.remove(4);
          break;
        case 8:
          assertEquals(11, pr.getEnd());
          expectedStart.remove(8);
          break;
        default:
          fail(""Shouldn't be here"");
      }
    }
    assertTrue(expectedStart.isEmpty());

    request = new RssGetShuffleAssignmentsRequest(
        appId, 1, 10, 4, 2,
        Sets.newHashSet(Constants.SHUFFLE_SERVER_VERSION));
    response = coordinatorClient.getShuffleAssignments(request);
    serverToPartitionRanges = response.getServerToPartitionRanges();
    assertEquals(2, serverToPartitionRanges.size());
    partitionRanges = Lists.newArrayList();
    for (List<PartitionRange> ranges : serverToPartitionRanges.values()) {
      partitionRanges.addAll(ranges);
    }
    assertEquals(6, partitionRanges.size());
    int range0To3 = 0;
    int range4To7 = 0;
    int range8To11 = 0;
    for (PartitionRange pr : partitionRanges) {
      switch (pr.getStart()) {
        case 0:
          assertEquals(3, pr.getEnd());
          range0To3++;
          break;
        case 4:
          assertEquals(7, pr.getEnd());
          range4To7++;
          break;
        case 8:
          assertEquals(11, pr.getEnd());
          range8To11++;
          break;
        default:
          fail(""Shouldn't be here"");
      }
    }
    assertEquals(2, range0To3);
    assertEquals(2, range4To7);
    assertEquals(2, range8To11);

    request = new RssGetShuffleAssignmentsRequest(
        appId, 3, 2, 1, 1,
        Sets.newHashSet(""fake_version""));
    try {
      coordinatorClient.getShuffleAssignments(request);
      fail(""Exception should be thrown"");
    } catch (Exception e) {
      assertTrue(e.getMessage().contains(""Empty assignment""));
    }
  }
",non-flaky,5
76995,Tencent_Firestorm,CoordinatorGrpcTest.appHeartbeatTest,"  @Test
  public void appHeartbeatTest() throws Exception {
    RssAppHeartBeatResponse response =
        coordinatorClient.sendAppHeartBeat(new RssAppHeartBeatRequest(""appHeartbeatTest1"", 1000));
    assertEquals(ResponseStatusCode.SUCCESS, response.getStatusCode());
    assertEquals(Sets.newHashSet(""appHeartbeatTest1""),
        coordinators.get(0).getApplicationManager().getAppIds());
    coordinatorClient.sendAppHeartBeat(new RssAppHeartBeatRequest(""appHeartbeatTest2"", 1000));
    assertEquals(Sets.newHashSet(""appHeartbeatTest1"", ""appHeartbeatTest2""),
        coordinators.get(0).getApplicationManager().getAppIds());
    int retry = 0;
    while (retry < 5) {
      coordinatorClient.sendAppHeartBeat(new RssAppHeartBeatRequest(""appHeartbeatTest1"", 1000));
      retry++;
      Thread.sleep(1000);
    }
    // appHeartbeatTest2 was removed because of expired
    assertEquals(Sets.newHashSet(""appHeartbeatTest1""),
        coordinators.get(0).getApplicationManager().getAppIds());
  }
",non-flaky,5
76996,Tencent_Firestorm,CoordinatorGrpcTest.shuffleServerHeartbeatTest,"  @Test
  public void shuffleServerHeartbeatTest() throws Exception {
    CoordinatorTestUtils.waitForRegister(coordinatorClient, 2);
    shuffleServers.get(0).stopServer();
    Thread.sleep(5000);
    SimpleClusterManager scm = (SimpleClusterManager) coordinators.get(0).getClusterManager();
    List<ServerNode> nodes = scm.getServerList(Sets.newHashSet(Constants.SHUFFLE_SERVER_VERSION));
    assertEquals(1, nodes.size());
    ServerNode node = nodes.get(0);
    assertTrue(node.getTags().contains(Constants.SHUFFLE_SERVER_VERSION));
    assertTrue(scm.getTagToNodes().get(Constants.SHUFFLE_SERVER_VERSION).contains(node));
    ShuffleServerConf shuffleServerConf = shuffleServers.get(0).getShuffleServerConf();
    shuffleServerConf.setInteger(""rss.rpc.server.port"", SHUFFLE_SERVER_PORT + 2);
    shuffleServerConf.setInteger(""rss.jetty.http.port"", 18082);
    ShuffleServer ss = new ShuffleServer(shuffleServerConf);
    ss.start();
    shuffleServers.set(0, ss);
    Thread.sleep(3000);
    assertEquals(2, coordinators.get(0).getClusterManager().getNodesNum());
  }
",non-flaky,5
76997,Tencent_Firestorm,CoordinatorGrpcTest.rpcMetricsTest,"  @Test
  public void rpcMetricsTest() throws Exception{
    String appId = ""rpcMetricsTest"";
    double oldValue = coordinators.get(0).getGrpcMetrics().getCounterMap()
        .get(CoordinatorGrpcMetrics.HEARTBEAT_METHOD).get();
    CoordinatorTestUtils.waitForRegister(coordinatorClient,2);
    double newValue = coordinators.get(0).getGrpcMetrics().getCounterMap()
        .get(CoordinatorGrpcMetrics.HEARTBEAT_METHOD).get();
    assertTrue(newValue - oldValue > 1);
    assertEquals(0,
        coordinators.get(0).getGrpcMetrics().getGaugeMap()
            .get(CoordinatorGrpcMetrics.HEARTBEAT_METHOD).get(), 0.5);

    RssGetShuffleAssignmentsRequest request = new RssGetShuffleAssignmentsRequest(
        appId, 1, 10, 4, 1,
        Sets.newHashSet(Constants.SHUFFLE_SERVER_VERSION));
    oldValue = coordinators.get(0).getGrpcMetrics().getCounterMap()
        .get(CoordinatorGrpcMetrics.GET_SHUFFLE_ASSIGNMENTS_METHOD).get();
    coordinatorClient.getShuffleAssignments(request);
    newValue = coordinators.get(0).getGrpcMetrics().getCounterMap()
        .get(CoordinatorGrpcMetrics.GET_SHUFFLE_ASSIGNMENTS_METHOD).get();
    assertEquals(oldValue + 1, newValue, 0.5);
    assertEquals(0,
        coordinators.get(0).getGrpcMetrics().getGaugeMap()
            .get(CoordinatorGrpcMetrics.GET_SHUFFLE_ASSIGNMENTS_METHOD).get(), 0.5);
  }
",non-flaky,5
76998,Tencent_Firestorm,PartitionBalanceCoordinatorGrpcTest.getShuffleAssignmentsTest,"  @Test
  public void getShuffleAssignmentsTest() throws Exception {
    CoordinatorTestUtils.waitForRegister(coordinatorClient, 3);
    RssGetShuffleAssignmentsRequest request = new RssGetShuffleAssignmentsRequest(
        ""app1"",
        1,
        1,
        1,
        1,
        Sets.newHashSet(Constants.SHUFFLE_SERVER_VERSION));
    RssGetShuffleAssignmentsResponse response = coordinatorClient.getShuffleAssignments(request);
    assertEquals(1, response.getPartitionToServers().size());
    for (Map.Entry<Integer, List<ShuffleServerInfo>> entry : response.getPartitionToServers().entrySet()) {
      assertEquals(1, entry.getValue().size());
      assertEquals(SHUFFLE_SERVER_PORT + 1, entry.getValue().get(0).getPort());
    }
    request = new RssGetShuffleAssignmentsRequest(
        ""app1"",
        2,
        1,
        1,
        1,
        Sets.newHashSet(Constants.SHUFFLE_SERVER_VERSION));
    response = coordinatorClient.getShuffleAssignments(request);
    assertEquals(1, response.getPartitionToServers().size());
    for (Map.Entry<Integer, List<ShuffleServerInfo>> entry : response.getPartitionToServers().entrySet()) {
      assertEquals(1, entry.getValue().size());
      assertEquals(SHUFFLE_SERVER_PORT + 1, entry.getValue().get(0).getPort());
    }
    request = new RssGetShuffleAssignmentsRequest(
        ""app1"",
        2,
        1,
        1,
        1,
        Sets.newHashSet(Constants.SHUFFLE_SERVER_VERSION));
    response = coordinatorClient.getShuffleAssignments(request);
    assertEquals(1, response.getPartitionToServers().size());
    for (Map.Entry<Integer, List<ShuffleServerInfo>> entry : response.getPartitionToServers().entrySet()) {
      assertEquals(1, entry.getValue().size());
      assertEquals(SHUFFLE_SERVER_PORT, entry.getValue().get(0).getPort());
    }
  }
",non-flaky,5
76999,Tencent_Firestorm,ShuffleServerWithHdfsTest.hdfsWriteReadTest,"  @Test
  public void hdfsWriteReadTest() {
    String appId = ""app_hdfs_read_write"";
    String dataBasePath = HDFS_URI + ""rss/test"";
    RssRegisterShuffleRequest rrsr = new RssRegisterShuffleRequest(appId, 0,
        Lists.newArrayList(new PartitionRange(0, 1)));
    shuffleServerClient.registerShuffle(rrsr);
    rrsr = new RssRegisterShuffleRequest(appId, 0, Lists.newArrayList(new PartitionRange(2, 3)));
    shuffleServerClient.registerShuffle(rrsr);

    Roaring64NavigableMap[] bitmaps = new Roaring64NavigableMap[4];
    Map<Long, byte[]> expectedData = Maps.newHashMap();
    Map<Integer, List<ShuffleBlockInfo>>  dataBlocks = createTestData(bitmaps, expectedData);
    Map<Integer, List<ShuffleBlockInfo>> partitionToBlocks = Maps.newHashMap();
    partitionToBlocks.put(0, dataBlocks.get(0));
    partitionToBlocks.put(1, dataBlocks.get(1));

    Map<Integer, Map<Integer, List<ShuffleBlockInfo>>> shuffleToBlocks = Maps.newHashMap();
    shuffleToBlocks.put(0, partitionToBlocks);

    RssSendShuffleDataRequest rssdr = new RssSendShuffleDataRequest(appId, 3, 1000, shuffleToBlocks);
    shuffleServerClient.sendShuffleData(rssdr);
    assertEquals(456, shuffleServers.get(0).getShuffleBufferManager().getUsedMemory());
    assertEquals(0, shuffleServers.get(0).getShuffleBufferManager().getPreAllocatedSize());
    RssSendCommitRequest rscr = new RssSendCommitRequest(appId, 0);
    shuffleServerClient.sendCommit(rscr);
    RssFinishShuffleRequest rfsr = new RssFinishShuffleRequest(appId, 0);

    ShuffleReadClientImpl readClient = new ShuffleReadClientImpl(StorageType.HDFS.name(),
        appId, 0, 0, 100, 2, 10, 1000,
        dataBasePath, bitmaps[0], Roaring64NavigableMap.bitmapOf(0), Lists.newArrayList(), new Configuration());
    assertNull(readClient.readShuffleBlockData());
    shuffleServerClient.finishShuffle(rfsr);

    partitionToBlocks.clear();
    partitionToBlocks.put(2, dataBlocks.get(2));
    shuffleToBlocks.clear();
    shuffleToBlocks.put(0, partitionToBlocks);
    rssdr = new RssSendShuffleDataRequest(appId, 3, 1000, shuffleToBlocks);
    shuffleServerClient.sendShuffleData(rssdr);
    assertEquals(0, shuffleServers.get(0).getShuffleBufferManager().getPreAllocatedSize());
    rscr = new RssSendCommitRequest(appId, 0);
    shuffleServerClient.sendCommit(rscr);
    rfsr = new RssFinishShuffleRequest(appId, 0);
    shuffleServerClient.finishShuffle(rfsr);

    partitionToBlocks.clear();
    partitionToBlocks.put(3, dataBlocks.get(3));
    shuffleToBlocks.clear();
    shuffleToBlocks.put(0, partitionToBlocks);
    rssdr = new RssSendShuffleDataRequest(appId, 3, 1000, shuffleToBlocks);
    shuffleServerClient.sendShuffleData(rssdr);
    rscr = new RssSendCommitRequest(appId, 0);
    shuffleServerClient.sendCommit(rscr);
    rfsr = new RssFinishShuffleRequest(appId, 0);
    shuffleServerClient.finishShuffle(rfsr);

    readClient = new ShuffleReadClientImpl(StorageType.HDFS.name(),
        appId, 0, 0, 100, 2, 10, 1000,
        dataBasePath, bitmaps[0], Roaring64NavigableMap.bitmapOf(0), Lists.newArrayList(), new Configuration());
    validateResult(readClient, expectedData, bitmaps[0]);

    readClient = new ShuffleReadClientImpl(StorageType.HDFS.name(),
        appId, 0, 1, 100, 2, 10, 1000,
        dataBasePath, bitmaps[1], Roaring64NavigableMap.bitmapOf(1), Lists.newArrayList(), new Configuration());
    validateResult(readClient, expectedData, bitmaps[1]);

    readClient = new ShuffleReadClientImpl(StorageType.HDFS.name(),
        appId, 0, 2, 100, 2, 10, 1000,
        dataBasePath, bitmaps[2], Roaring64NavigableMap.bitmapOf(2), Lists.newArrayList(), new Configuration());
    validateResult(readClient, expectedData, bitmaps[2]);

    readClient = new ShuffleReadClientImpl(StorageType.HDFS.name(),
        appId, 0, 3, 100, 2, 10, 1000,
        dataBasePath, bitmaps[3], Roaring64NavigableMap.bitmapOf(3), Lists.newArrayList(), new Configuration());
    validateResult(readClient, expectedData, bitmaps[3]);
  }
",non-flaky,5
77000,Tencent_Firestorm,MultiStorageFaultToleranceTest.hdfsFaultTolerance,"  @Test
  public void hdfsFaultTolerance() {
    try {
      String appId = ""app_hdfs_fault_tolerance_data"";
      Map<Long, byte[]> expectedData = Maps.newHashMap();
      Map<Integer, List<Integer>> map = Maps.newHashMap();
      map.put(2, Lists.newArrayList(0, 3));
      map.put(3, Lists.newArrayList(3));
      registerShuffle(appId, map);

      Roaring64NavigableMap blockIdBitmap1 = Roaring64NavigableMap.bitmapOf();
      Roaring64NavigableMap blockIdBitmap2 = Roaring64NavigableMap.bitmapOf();
      Roaring64NavigableMap blockIdBitmap3 = Roaring64NavigableMap.bitmapOf();

      List<ShuffleBlockInfo> blocks1 = createShuffleBlockList(
          2, 0, 1,11, 10 * 1024 * 1024, blockIdBitmap1, expectedData);

      List<ShuffleBlockInfo> blocks2 = createShuffleBlockList(
          3, 3, 2,9, 10 * 1024 * 1024, blockIdBitmap2, expectedData);

      List<ShuffleBlockInfo> blocks3 = createShuffleBlockList(
          2, 3, 2,9, 10 * 1024 * 1024, blockIdBitmap3, expectedData);

      assertEquals(0, ShuffleStorageUtils.getStorageIndex(2, appId, 2, 0));
      assertEquals(0, ShuffleStorageUtils.getStorageIndex(2, appId, 3, 3));
      assertEquals(0, ShuffleStorageUtils.getStorageIndex(2, appId, 2, 3));
      assertEquals(1, cluster.getDataNodes().size());
      cluster.stopDataNode(0);
      assertEquals(0, cluster.getDataNodes().size());

      sendSinglePartitionToShuffleServer(appId, 2, 0, 1, blocks1);
      boolean isException = false;
      try {
        sendSinglePartitionToShuffleServer(appId, 3, 3,2, blocks2);
      } catch (RuntimeException re) {
        isException = true;
        assertTrue(re.getMessage().contains(""Fail to finish""));
      }
      assertTrue(isException);

      cluster.startDataNodes(conf, 1, true, HdfsServerConstants.StartupOption.REGULAR,
          null, null, null, false, true);
      assertEquals(1, cluster.getDataNodes().size());

      sendSinglePartitionToShuffleServer(appId, 2, 3, 2, blocks3);

      validateResult(appId, 2, 0, blockIdBitmap1, Roaring64NavigableMap.bitmapOf(1), expectedData);
      validateResult(appId, 2, 3, blockIdBitmap3, Roaring64NavigableMap.bitmapOf(2), expectedData);
    } catch (Exception e) {
      e.printStackTrace();
      fail();
    }
  }
",non-flaky,5
77001,Tencent_Firestorm,MultiStorageFaultToleranceTest.diskFaultTolerance,"  @Test
  public void diskFaultTolerance() {
    String appId = ""app_disk_fault_tolerance_data"";
    Map<Long, byte[]> expectedData = Maps.newHashMap();

    Map<Integer, List<Integer>> map = Maps.newHashMap();
    map.put(2, Lists.newArrayList(1, 3));
    map.put(3, Lists.newArrayList(1));
    registerShuffle(appId, map);

    Roaring64NavigableMap blockIdBitmap1 = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap blockIdBitmap2 = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap blockIdBitmap3 = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap blockIdBitmap4 = Roaring64NavigableMap.bitmapOf();

    List<ShuffleBlockInfo> blocks1 = createShuffleBlockList(
        2, 1, 1,11, 10 * 1024 * 1024, blockIdBitmap1, expectedData);

    List<ShuffleBlockInfo> blocks2 = createShuffleBlockList(
        3, 1, 2,9, 10 * 1024 * 1024, blockIdBitmap2, expectedData);

    List<ShuffleBlockInfo> blocks3 = createShuffleBlockList(
        2, 3, 2,9, 10 * 1024 * 1024, blockIdBitmap3, expectedData);

    List<ShuffleBlockInfo> blocks4 = createShuffleBlockList(
        2, 1, 1, 11, 10 * 1024 * 1024, blockIdBitmap4, expectedData);

    assertEquals(1, ShuffleStorageUtils.getStorageIndex(2, appId, 2, 1));
    assertEquals(1, ShuffleStorageUtils.getStorageIndex(2, appId, 3, 1));
    assertEquals(1, ShuffleStorageUtils.getStorageIndex(2, appId, 2, 3));
    assertEquals(1, ShuffleStorageUtils.getStorageIndex(2, appId, 2, 1));
    try {
      sendSinglePartitionToShuffleServer(appId, 2, 1, 1, blocks1);
      sendSinglePartitionToShuffleServer(appId, 3, 1,2, blocks2);
      sendSinglePartitionToShuffleServer(appId, 2, 3, 2, blocks3);
      sendSinglePartitionToShuffleServer(appId, 2, 1, 1, blocks4);
    } catch (Exception e) {
      e.printStackTrace();
      fail();
    }
    validateResult(appId, 2, 1, blockIdBitmap1, Roaring64NavigableMap.bitmapOf(1), expectedData);
    validateResult(appId, 3, 1, blockIdBitmap2, Roaring64NavigableMap.bitmapOf(2), expectedData);
    validateResult(appId, 2, 3, blockIdBitmap3, Roaring64NavigableMap.bitmapOf(2), expectedData);
  }
",non-flaky,5
77002,Tencent_Firestorm,ShuffleServerWithLocalTest.localWriteReadTest,"  @Test
  public void localWriteReadTest() throws Exception {
    String testAppId = ""localWriteReadTest"";
    RssRegisterShuffleRequest rrsr = new RssRegisterShuffleRequest(testAppId, 0,
        Lists.newArrayList(new PartitionRange(0, 1)));
    shuffleServerClient.registerShuffle(rrsr);
    rrsr = new RssRegisterShuffleRequest(testAppId, 0, Lists.newArrayList(new PartitionRange(2, 3)));
    shuffleServerClient.registerShuffle(rrsr);

    Map<Long, byte[]> expectedData = Maps.newHashMap();

    Roaring64NavigableMap[] bitmaps = new Roaring64NavigableMap[4];
    Map<Integer, List<ShuffleBlockInfo>> partitionToBlocks = createTestData(bitmaps, expectedData);

    Set<Long> expectedBlockIds1 = transBitmapToSet(bitmaps[0]);
    Set<Long> expectedBlockIds2 = transBitmapToSet(bitmaps[1]);
    Set<Long> expectedBlockIds3 = transBitmapToSet(bitmaps[2]);
    Set<Long> expectedBlockIds4 = transBitmapToSet(bitmaps[3]);

    Map<Integer, Map<Integer, List<ShuffleBlockInfo>>> shuffleToBlocks = Maps.newHashMap();
    shuffleToBlocks.put(0, partitionToBlocks);

    RssSendShuffleDataRequest rssdr = new RssSendShuffleDataRequest(
        testAppId, 3, 1000, shuffleToBlocks);
    shuffleServerClient.sendShuffleData(rssdr);
    RssSendCommitRequest rscr = new RssSendCommitRequest(testAppId, 0);
    shuffleServerClient.sendCommit(rscr);
    RssFinishShuffleRequest rfsr = new RssFinishShuffleRequest(testAppId, 0);
    shuffleServerClient.finishShuffle(rfsr);

    ShuffleDataResult sdr  = readShuffleData(
        shuffleServerClient, testAppId, 0, 0, 2,
        10, 1000, 0);
    validateResult(sdr, expectedBlockIds1, expectedData, 0);
    sdr  = readShuffleData(
        shuffleServerClient, testAppId, 0, 1, 2,
        10, 1000, 0);
    validateResult(sdr, expectedBlockIds2, expectedData, 1);
    sdr  = readShuffleData(
        shuffleServerClient, testAppId, 0, 2, 2,
        10, 1000, 0);
    validateResult(sdr, expectedBlockIds3, expectedData, 2);
    sdr  = readShuffleData(
        shuffleServerClient, testAppId, 0, 3, 2,
        10, 1000, 0);
    validateResult(sdr, expectedBlockIds4, expectedData, 3);

    assertEquals(4, shuffleServers.get(0).getShuffleTaskManager()
        .getServerReadHandlers().get(testAppId).size());
    assertNotNull(shuffleServers.get(0).getShuffleTaskManager()
        .getPartitionsToBlockIds().get(testAppId));
    Thread.sleep(8000);
    assertNull(shuffleServers.get(0).getShuffleTaskManager().getServerReadHandlers().get(testAppId));
    assertNull(shuffleServers.get(0).getShuffleTaskManager().getPartitionsToBlockIds().get(testAppId));
  }
",non-flaky,5
77003,Tencent_Firestorm,ShuffleServerGrpcTest.clearResourceTest,"  @Test
  public void clearResourceTest() throws Exception {
    final ShuffleWriteClient shuffleWriteClient =
        ShuffleClientFactory.getInstance().createShuffleWriteClient(
            ""GRPC"", 2, 10000L, 4);
    shuffleWriteClient.registerCoordinators(""127.0.0.1:19999"");
    shuffleWriteClient.registerShuffle(
        new ShuffleServerInfo(""127.0.0.1-20001"", ""127.0.0.1"", 20001),
        ""clearResourceTest1"",
        0,
        Lists.newArrayList(new PartitionRange(0, 1)));

    shuffleWriteClient.sendAppHeartbeat(""clearResourceTest1"", 1000L);
    shuffleWriteClient.sendAppHeartbeat(""clearResourceTest2"", 1000L);

    RssRegisterShuffleRequest rrsr = new RssRegisterShuffleRequest(""clearResourceTest1"", 0,
        Lists.newArrayList(new PartitionRange(0, 1)));
    shuffleServerClient.registerShuffle(rrsr);
    rrsr = new RssRegisterShuffleRequest(""clearResourceTest2"", 0,
        Lists.newArrayList(new PartitionRange(0, 1)));
    shuffleServerClient.registerShuffle(rrsr);
    assertEquals(Sets.newHashSet(""clearResourceTest1"", ""clearResourceTest2""),
        shuffleServers.get(0).getShuffleTaskManager().getAppIds().keySet());

    // Thread will keep refresh clearResourceTest1 in coordinator
    Thread t = new Thread(() -> {
      int i = 0;
      while (i < 20) {
        shuffleWriteClient.sendAppHeartbeat(""clearResourceTest1"", 1000L);
        i++;
        try {
          Thread.sleep(1000);
        } catch (InterruptedException e) {
          return;
        }
      }
    });
    t.start();

    // Heartbeat is sent to coordinator too]
    Thread.sleep(3000);
    shuffleServerClient.registerShuffle(new RssRegisterShuffleRequest(""clearResourceTest1"", 0,
        Lists.newArrayList(new PartitionRange(0, 1))));
    assertEquals(Sets.newHashSet(""clearResourceTest1""),
        coordinators.get(0).getApplicationManager().getAppIds());
    // clearResourceTest2 will be removed because of rss.server.app.expired.withoutHeartbeat
    Thread.sleep(2000);
    assertEquals(Sets.newHashSet(""clearResourceTest1""),
        shuffleServers.get(0).getShuffleTaskManager().getAppIds().keySet());

    // clearResourceTest1 will be removed because of rss.server.app.expired.withoutHeartbeat
    t.interrupt();
    Thread.sleep(8000);
    assertEquals(0, shuffleServers.get(0).getShuffleTaskManager().getAppIds().size());

  }
",non-flaky,5
77004,Tencent_Firestorm,ShuffleServerGrpcTest.shuffleResultTest,"  @Test
  public void shuffleResultTest() throws Exception {
    Map<Integer, List<Long>> partitionToBlockIds = Maps.newHashMap();
    List<Long> blockIds1 = getBlockIdList(1, 3);
    List<Long> blockIds2 = getBlockIdList(2, 2);
    List<Long> blockIds3 = getBlockIdList(3, 1);
    partitionToBlockIds.put(1, blockIds1);
    partitionToBlockIds.put(2, blockIds2);
    partitionToBlockIds.put(3, blockIds3);

    RssReportShuffleResultRequest request =
        new RssReportShuffleResultRequest(""shuffleResultTest"", 0, 0L, partitionToBlockIds, 1);
    try {
      shuffleServerClient.reportShuffleResult(request);
      fail(""Exception should be thrown"");
    } catch (Exception e) {
      assertTrue(e.getMessage().contains(""error happened when report shuffle result""));
    }

    RssGetShuffleResultRequest req = new RssGetShuffleResultRequest(""shuffleResultTest"", 1, 1);
    try {
      shuffleServerClient.getShuffleResult(req);
      fail(""Exception should be thrown"");
    } catch (Exception e) {
      assertTrue(e.getMessage().contains(""Can't get shuffle result""));
    }

    RssRegisterShuffleRequest rrsr = new RssRegisterShuffleRequest(""shuffleResultTest"", 100,
        Lists.newArrayList(new PartitionRange(0, 1)));
    shuffleServerClient.registerShuffle(rrsr);

    req = new RssGetShuffleResultRequest(""shuffleResultTest"", 0, 1);
    RssGetShuffleResultResponse result = shuffleServerClient.getShuffleResult(req);
    Roaring64NavigableMap blockIdBitmap = result.getBlockIdBitmap();
    assertEquals(Roaring64NavigableMap.bitmapOf(), blockIdBitmap);

    request =
        new RssReportShuffleResultRequest(""shuffleResultTest"", 0, 0L, partitionToBlockIds, 1);
    RssReportShuffleResultResponse response = shuffleServerClient.reportShuffleResult(request);
    assertEquals(ResponseStatusCode.SUCCESS, response.getStatusCode());
    req = new RssGetShuffleResultRequest(""shuffleResultTest"", 0, 1);
    result = shuffleServerClient.getShuffleResult(req);
    blockIdBitmap = result.getBlockIdBitmap();
    Roaring64NavigableMap expectedP1 = Roaring64NavigableMap.bitmapOf();
    addExpectedBlockIds(expectedP1, blockIds1);
    assertEquals(expectedP1, blockIdBitmap);

    req = new RssGetShuffleResultRequest(""shuffleResultTest"", 0, 2);
    result = shuffleServerClient.getShuffleResult(req);
    blockIdBitmap = result.getBlockIdBitmap();
    Roaring64NavigableMap expectedP2 = Roaring64NavigableMap.bitmapOf();
    addExpectedBlockIds(expectedP2, blockIds2);
    assertEquals(expectedP2, blockIdBitmap);

    req = new RssGetShuffleResultRequest(""shuffleResultTest"", 0, 3);
    result = shuffleServerClient.getShuffleResult(req);
    blockIdBitmap = result.getBlockIdBitmap();
    Roaring64NavigableMap expectedP3 = Roaring64NavigableMap.bitmapOf();
    addExpectedBlockIds(expectedP3, blockIds3);
    assertEquals(expectedP3, blockIdBitmap);

    partitionToBlockIds = Maps.newHashMap();
    blockIds1 = getBlockIdList(1, 3);
    blockIds2 = getBlockIdList(2, 2);
    blockIds3 = getBlockIdList(3, 1);
    partitionToBlockIds.put(1, blockIds1);
    partitionToBlockIds.put(2, blockIds2);
    partitionToBlockIds.put(3, blockIds3);

    request =
        new RssReportShuffleResultRequest(""shuffleResultTest"", 0, 1L, partitionToBlockIds, 1);
    shuffleServerClient.reportShuffleResult(request);

    req = new RssGetShuffleResultRequest(""shuffleResultTest"", 0, 1);
    result = shuffleServerClient.getShuffleResult(req);
    blockIdBitmap = result.getBlockIdBitmap();
    addExpectedBlockIds(expectedP1, blockIds1);
    assertEquals(expectedP1, blockIdBitmap);

    req = new RssGetShuffleResultRequest(""shuffleResultTest"", 0, 2);
    result = shuffleServerClient.getShuffleResult(req);
    blockIdBitmap = result.getBlockIdBitmap();
    addExpectedBlockIds(expectedP2, blockIds2);
    assertEquals(expectedP2, blockIdBitmap);

    req = new RssGetShuffleResultRequest(""shuffleResultTest"", 0, 3);
    result = shuffleServerClient.getShuffleResult(req);
    blockIdBitmap = result.getBlockIdBitmap();
    addExpectedBlockIds(expectedP3, blockIds3);
    assertEquals(expectedP3, blockIdBitmap);

    request =
        new RssReportShuffleResultRequest(""shuffleResultTest"", 1, 1L, Maps.newHashMap(), 1);
    shuffleServerClient.reportShuffleResult(request);
    req = new RssGetShuffleResultRequest(""shuffleResultTest"", 1, 1);
    result = shuffleServerClient.getShuffleResult(req);
    blockIdBitmap = result.getBlockIdBitmap();
    assertEquals(Roaring64NavigableMap.bitmapOf(), blockIdBitmap);

    // test with bitmapNum > 1
    partitionToBlockIds = Maps.newHashMap();
    blockIds1 = getBlockIdList(1, 3);
    blockIds2 = getBlockIdList(2, 2);
    blockIds3 = getBlockIdList(3, 1);
    partitionToBlockIds.put(1, blockIds1);
    partitionToBlockIds.put(2, blockIds2);
    partitionToBlockIds.put(3, blockIds3);
    request =
        new RssReportShuffleResultRequest(""shuffleResultTest"", 2, 1L, partitionToBlockIds, 3);
    shuffleServerClient.reportShuffleResult(request);
    // validate bitmap in shuffleTaskManager
    Roaring64NavigableMap[] bitmaps = shuffleServers.get(0).getShuffleTaskManager()
        .getPartitionsToBlockIds().get(""shuffleResultTest"").get(2);
    assertEquals(3, bitmaps.length);

    req = new RssGetShuffleResultRequest(""shuffleResultTest"", 2, 1);
    result = shuffleServerClient.getShuffleResult(req);
    blockIdBitmap = result.getBlockIdBitmap();
    expectedP1 = Roaring64NavigableMap.bitmapOf();
    addExpectedBlockIds(expectedP1, blockIds1);
    assertEquals(expectedP1, blockIdBitmap);

    req = new RssGetShuffleResultRequest(""shuffleResultTest"", 2, 2);
    result = shuffleServerClient.getShuffleResult(req);
    blockIdBitmap = result.getBlockIdBitmap();
    expectedP2 = Roaring64NavigableMap.bitmapOf();
    addExpectedBlockIds(expectedP2, blockIds2);
    assertEquals(expectedP2, blockIdBitmap);

    req = new RssGetShuffleResultRequest(""shuffleResultTest"", 2, 3);
    result = shuffleServerClient.getShuffleResult(req);
    blockIdBitmap = result.getBlockIdBitmap();
    expectedP3 = Roaring64NavigableMap.bitmapOf();
    addExpectedBlockIds(expectedP3, blockIds3);
    assertEquals(expectedP3, blockIdBitmap);

    partitionToBlockIds = Maps.newHashMap();
    blockIds1 = getBlockIdList((int) Constants.MAX_PARTITION_ID, 3);
    blockIds2 = getBlockIdList(2, 2);
    blockIds3 = getBlockIdList(3, 1);
    partitionToBlockIds.put((int) Constants.MAX_PARTITION_ID, blockIds1);
    partitionToBlockIds.put(2, blockIds2);
    partitionToBlockIds.put(3, blockIds3);
    // bimapNum = 2
    request =
        new RssReportShuffleResultRequest(""shuffleResultTest"", 4, 1L, partitionToBlockIds, 2);
    shuffleServerClient.reportShuffleResult(request);

    req = new RssGetShuffleResultRequest(""shuffleResultTest"", 4, (int) Constants.MAX_PARTITION_ID);
    result = shuffleServerClient.getShuffleResult(req);
    blockIdBitmap = result.getBlockIdBitmap();
    expectedP1 = Roaring64NavigableMap.bitmapOf();
    addExpectedBlockIds(expectedP1, blockIds1);
    assertEquals(expectedP1, blockIdBitmap);

    req = new RssGetShuffleResultRequest(""shuffleResultTest"", 4, 2);
    result = shuffleServerClient.getShuffleResult(req);
    blockIdBitmap = result.getBlockIdBitmap();
    expectedP2 = Roaring64NavigableMap.bitmapOf();
    addExpectedBlockIds(expectedP2, blockIds2);
    assertEquals(expectedP2, blockIdBitmap);

    req = new RssGetShuffleResultRequest(""shuffleResultTest"", 4, 3);
    result = shuffleServerClient.getShuffleResult(req);
    blockIdBitmap = result.getBlockIdBitmap();
    expectedP3 = Roaring64NavigableMap.bitmapOf();
    addExpectedBlockIds(expectedP3, blockIds3);
    assertEquals(expectedP3, blockIdBitmap);

    // wait resources are deleted
    Thread.sleep(12000);
    req = new RssGetShuffleResultRequest(""shuffleResultTest"", 1, 1);
    try {
      shuffleServerClient.getShuffleResult(req);
      fail(""Exception should be thrown"");
    } catch (Exception e) {
      assertTrue(e.getMessage().contains(""Can't get shuffle result""));
    }
  }
",non-flaky,5
77005,Tencent_Firestorm,ShuffleServerGrpcTest.registerTest,"  @Test
  public void registerTest() {
    shuffleServerClient.registerShuffle(new RssRegisterShuffleRequest(""registerTest"", 0,
        Lists.newArrayList(new PartitionRange(0, 1))));
    RssGetShuffleResultRequest req = new RssGetShuffleResultRequest(""registerTest"", 0, 0);
    // no exception with getShuffleResult means register successfully
    shuffleServerClient.getShuffleResult(req);
    req = new RssGetShuffleResultRequest(""registerTest"", 0, 1);
    shuffleServerClient.getShuffleResult(req);
    shuffleServerClient.registerShuffle(new RssRegisterShuffleRequest(""registerTest"", 1,
        Lists.newArrayList(new PartitionRange(0, 0), new PartitionRange(1, 1), new PartitionRange(2, 2))));
    req = new RssGetShuffleResultRequest(""registerTest"", 1, 0);
    shuffleServerClient.getShuffleResult(req);
    req = new RssGetShuffleResultRequest(""registerTest"", 1, 1);
    shuffleServerClient.getShuffleResult(req);
    req = new RssGetShuffleResultRequest(""registerTest"", 1, 2);
    shuffleServerClient.getShuffleResult(req);
  }
",non-flaky,5
77006,Tencent_Firestorm,ShuffleServerGrpcTest.sendDataWithoutRegisterTest,"  @Test
  public void sendDataWithoutRegisterTest() throws Exception {
    List<ShuffleBlockInfo> blockInfos = Lists.newArrayList(new ShuffleBlockInfo(0, 0, 0, 100, 0,
        new byte[]{}, Lists.newArrayList(), 0, 100, 0));
    Map<Integer, List<ShuffleBlockInfo>> partitionToBlocks = Maps.newHashMap();
    partitionToBlocks.put(0, blockInfos);
    Map<Integer, Map<Integer, List<ShuffleBlockInfo>>> shuffleToBlocks = Maps.newHashMap();
    shuffleToBlocks.put(0, partitionToBlocks);

    RssSendShuffleDataRequest rssdr = new RssSendShuffleDataRequest(
        ""sendDataWithoutRegisterTest"", 3, 1000, shuffleToBlocks);
    shuffleServerClient.sendShuffleData(rssdr);
    assertEquals(132, shuffleServers.get(0).getPreAllocatedMemory());
    Thread.sleep(10000);
    assertEquals(0, shuffleServers.get(0).getPreAllocatedMemory());
  }
",non-flaky,5
77007,Tencent_Firestorm,ShuffleServerGrpcTest.multipleShuffleResultTest,"  @Test
  public void multipleShuffleResultTest() throws Exception {
    Set<Long> expectedBlockIds = Sets.newConcurrentHashSet();
    RssRegisterShuffleRequest rrsr = new RssRegisterShuffleRequest(""multipleShuffleResultTest"", 100,
        Lists.newArrayList(new PartitionRange(0, 1)));
    shuffleServerClient.registerShuffle(rrsr);

    Runnable r1 = () -> {
      for (int i = 0; i < 100; i++) {
        Map<Integer, List<Long>> ptbs = Maps.newHashMap();
        List<Long> blockIds = Lists.newArrayList();
        Long blockId = ClientUtils.getBlockId(1, 0, i);
        expectedBlockIds.add(blockId);
        blockIds.add(blockId);
        ptbs.put(1, blockIds);
        RssReportShuffleResultRequest req1 =
            new RssReportShuffleResultRequest(""multipleShuffleResultTest"", 1, 0, ptbs, 1);
        shuffleServerClient.reportShuffleResult(req1);
      }
    };
    Runnable r2 = () -> {
      for (int i = 100; i < 200; i++) {
        Map<Integer, List<Long>> ptbs = Maps.newHashMap();
        List<Long> blockIds = Lists.newArrayList();
        Long blockId = ClientUtils.getBlockId(1, 1, i);
        expectedBlockIds.add(blockId);
        blockIds.add(blockId);
        ptbs.put(1, blockIds);
        RssReportShuffleResultRequest req1 =
            new RssReportShuffleResultRequest(""multipleShuffleResultTest"", 1, 1, ptbs, 1);
        shuffleServerClient.reportShuffleResult(req1);
      }
    };
    Runnable r3 = () -> {
      for (int i = 200; i < 300; i++) {
        Map<Integer, List<Long>> ptbs = Maps.newHashMap();
        List<Long> blockIds = Lists.newArrayList();
        Long blockId = ClientUtils.getBlockId(1, 2, i);
        expectedBlockIds.add(blockId);
        blockIds.add(blockId);
        ptbs.put(1, blockIds);
        RssReportShuffleResultRequest req1 =
            new RssReportShuffleResultRequest(""multipleShuffleResultTest"", 1, 2, ptbs, 1);
        shuffleServerClient.reportShuffleResult(req1);
      }
    };
    Thread t1 = new Thread(r1);
    Thread t2 = new Thread(r2);
    Thread t3 = new Thread(r3);
    t1.start();
    t2.start();
    t3.start();
    t1.join();
    t2.join();
    t3.join();

    Roaring64NavigableMap blockIdBitmap = Roaring64NavigableMap.bitmapOf();
    for (Long blockId : expectedBlockIds) {
      blockIdBitmap.addLong(blockId);
    }

    RssGetShuffleResultRequest req = new RssGetShuffleResultRequest(
        ""multipleShuffleResultTest"", 1, 1);
    RssGetShuffleResultResponse result = shuffleServerClient.getShuffleResult(req);
    Roaring64NavigableMap actualBlockIdBitmap = result.getBlockIdBitmap();
    assertEquals(blockIdBitmap, actualBlockIdBitmap);
  }
",non-flaky,5
77008,Tencent_Firestorm,ShuffleServerGrpcTest.rpcMetricsTest,"  @Test
  public void rpcMetricsTest() {
    String appId = ""rpcMetricsTest"";
    int shuffleId = 0;
    double oldGrpcTotal = shuffleServers.get(0).getGrpcMetrics().getCounterGrpcTotal().get();
    double oldValue = shuffleServers.get(0).getGrpcMetrics().getCounterMap().
        get(ShuffleServerGrpcMetrics.REGISTER_SHUFFLE_METHOD).get();
    shuffleServerClient.registerShuffle(new RssRegisterShuffleRequest(appId, shuffleId,
        Lists.newArrayList(new PartitionRange(0, 1))));
    double newValue = shuffleServers.get(0).getGrpcMetrics().getCounterMap()
        .get(ShuffleServerGrpcMetrics.REGISTER_SHUFFLE_METHOD).get();
    assertEquals(oldValue + 1, newValue, 0.5);
    assertEquals(0,
        shuffleServers.get(0).getGrpcMetrics().getGaugeMap().get(
            ShuffleServerGrpcMetrics.REGISTER_SHUFFLE_METHOD).get(), 0.5);

    oldValue = shuffleServers.get(0).getGrpcMetrics().getCounterMap().get(
        ShuffleServerGrpcMetrics.APP_HEARTBEAT_METHOD).get();
    shuffleServerClient.sendHeartBeat(new RssAppHeartBeatRequest(appId, 10000));
    newValue = shuffleServers.get(0).getGrpcMetrics().getCounterMap().get(
        ShuffleServerGrpcMetrics.APP_HEARTBEAT_METHOD).get();
    assertEquals(oldValue + 1, newValue, 0.5);
    assertEquals(0,
        shuffleServers.get(0).getGrpcMetrics().getGaugeMap().get(
            ShuffleServerGrpcMetrics.APP_HEARTBEAT_METHOD).get(), 0.5);

    oldValue = shuffleServers.get(0).getGrpcMetrics().getCounterMap().get(
        ShuffleServerGrpcMetrics.REQUIRE_BUFFER_METHOD).get();
    shuffleServerClient.requirePreAllocation(100, 10, 1000);
    newValue = shuffleServers.get(0).getGrpcMetrics().getCounterMap().get(
        ShuffleServerGrpcMetrics.REQUIRE_BUFFER_METHOD).get();
    assertEquals(oldValue + 1, newValue, 0.5);
    assertEquals(0,
        shuffleServers.get(0).getGrpcMetrics().getGaugeMap().get(
            ShuffleServerGrpcMetrics.REQUIRE_BUFFER_METHOD).get(), 0.5);

    oldValue = shuffleServers.get(0).getGrpcMetrics().getCounterMap().get(
        ShuffleServerGrpcMetrics.SEND_SHUFFLE_DATA_METHOD).get();
    List<ShuffleBlockInfo> blockInfos = Lists.newArrayList(new ShuffleBlockInfo(shuffleId, 0, 0, 100, 0,
        new byte[]{}, Lists.newArrayList(), 0, 100, 0));
    Map<Integer, List<ShuffleBlockInfo>> partitionToBlocks = Maps.newHashMap();
    partitionToBlocks.put(0, blockInfos);
    Map<Integer, Map<Integer, List<ShuffleBlockInfo>>> shuffleToBlocks = Maps.newHashMap();
    shuffleToBlocks.put(0, partitionToBlocks);
    RssSendShuffleDataRequest rssdr = new RssSendShuffleDataRequest(
        appId, 3, 1000, shuffleToBlocks);
    shuffleServerClient.sendShuffleData(rssdr);
    newValue = shuffleServers.get(0).getGrpcMetrics().getCounterMap().get(
        ShuffleServerGrpcMetrics.SEND_SHUFFLE_DATA_METHOD).get();
    assertEquals(oldValue + 1, newValue, 0.5);
    assertEquals(0,
        shuffleServers.get(0).getGrpcMetrics().getGaugeMap().get(
            ShuffleServerGrpcMetrics.SEND_SHUFFLE_DATA_METHOD).get(), 0.5);

    oldValue = shuffleServers.get(0).getGrpcMetrics().getCounterMap().get(
        ShuffleServerGrpcMetrics.COMMIT_SHUFFLE_TASK_METHOD).get();
    shuffleServerClient.sendCommit(new RssSendCommitRequest(appId, shuffleId));
    newValue = shuffleServers.get(0).getGrpcMetrics().getCounterMap().get(
        ShuffleServerGrpcMetrics.COMMIT_SHUFFLE_TASK_METHOD).get();
    assertEquals(oldValue + 1, newValue, 0.5);
    assertEquals(0,
        shuffleServers.get(0).getGrpcMetrics().getGaugeMap().get(
            ShuffleServerGrpcMetrics.COMMIT_SHUFFLE_TASK_METHOD).get(), 0.5);

    oldValue = shuffleServers.get(0).getGrpcMetrics().getCounterMap().get(
        ShuffleServerGrpcMetrics.FINISH_SHUFFLE_METHOD).get();
    shuffleServerClient.finishShuffle(new RssFinishShuffleRequest(appId, shuffleId));
    newValue = shuffleServers.get(0).getGrpcMetrics().getCounterMap().get(
        ShuffleServerGrpcMetrics.FINISH_SHUFFLE_METHOD).get();
    assertEquals(oldValue + 1, newValue, 0.5);
    assertEquals(0,
        shuffleServers.get(0).getGrpcMetrics().getGaugeMap().get(
            ShuffleServerGrpcMetrics.FINISH_SHUFFLE_METHOD).get(), 0.5);

    oldValue = shuffleServers.get(0).getGrpcMetrics().getCounterMap().get(
        ShuffleServerGrpcMetrics.REPORT_SHUFFLE_RESULT_METHOD).get();
    Map<Integer, List<Long>> partitionToBlockIds = Maps.newHashMap();
    List<Long> blockIds1 = getBlockIdList(1, 3);
    List<Long> blockIds2 = getBlockIdList(2, 2);
    List<Long> blockIds3 = getBlockIdList(3, 1);
    partitionToBlockIds.put(1, blockIds1);
    partitionToBlockIds.put(2, blockIds2);
    partitionToBlockIds.put(3, blockIds3);
    RssReportShuffleResultRequest request =
        new RssReportShuffleResultRequest(appId, shuffleId, 0L, partitionToBlockIds, 1);
    shuffleServerClient.reportShuffleResult(request);
    newValue = shuffleServers.get(0).getGrpcMetrics().getCounterMap().get(
        ShuffleServerGrpcMetrics.REPORT_SHUFFLE_RESULT_METHOD).get();
    assertEquals(oldValue + 1, newValue, 0.5);
    assertEquals(0,
        shuffleServers.get(0).getGrpcMetrics().getGaugeMap().get(
            ShuffleServerGrpcMetrics.REPORT_SHUFFLE_RESULT_METHOD).get(), 0.5);

    oldValue = shuffleServers.get(0).getGrpcMetrics().getCounterMap().get(
        ShuffleServerGrpcMetrics.GET_SHUFFLE_RESULT_METHOD).get();
    shuffleServerClient.getShuffleResult(new RssGetShuffleResultRequest(appId, shuffleId, 1));
    newValue = shuffleServers.get(0).getGrpcMetrics().getCounterMap().get(
        ShuffleServerGrpcMetrics.GET_SHUFFLE_RESULT_METHOD).get();
    assertEquals(oldValue + 1, newValue, 0.5);
    assertEquals(0,
        shuffleServers.get(0).getGrpcMetrics().getGaugeMap().get(
            ShuffleServerGrpcMetrics.GET_SHUFFLE_RESULT_METHOD).get(), 0.5);

    oldValue = shuffleServers.get(0).getGrpcMetrics().getCounterMap().get(
        ShuffleServerGrpcMetrics.GET_SHUFFLE_INDEX_METHOD).get();
    try {
      shuffleServerClient.getShuffleIndex(new RssGetShuffleIndexRequest(
          appId, shuffleId, 1, 1, 3));
    } catch (Exception e) {
      // ignore the exception, just test metrics value
    }
    newValue = shuffleServers.get(0).getGrpcMetrics().getCounterMap().get(
        ShuffleServerGrpcMetrics.GET_SHUFFLE_INDEX_METHOD).get();
    assertEquals(oldValue + 1, newValue, 0.5);
    assertEquals(0,
        shuffleServers.get(0).getGrpcMetrics().getGaugeMap().get(
            ShuffleServerGrpcMetrics.GET_SHUFFLE_INDEX_METHOD).get(), 0.5);

    oldValue = shuffleServers.get(0).getGrpcMetrics().getCounterMap().get(
        ShuffleServerGrpcMetrics.GET_SHUFFLE_DATA_METHOD).get();
    try {
      shuffleServerClient.getShuffleData(new RssGetShuffleDataRequest(
          appId, shuffleId, 0, 1, 3,
          0, 100));
    } catch (Exception e) {
      // ignore the exception, just test metrics value
    }
    newValue = shuffleServers.get(0).getGrpcMetrics().getCounterMap().get(
        ShuffleServerGrpcMetrics.GET_SHUFFLE_DATA_METHOD).get();
    assertEquals(oldValue + 1, newValue, 0.5);
    assertEquals(0,
        shuffleServers.get(0).getGrpcMetrics().getGaugeMap().get(
            ShuffleServerGrpcMetrics.GET_SHUFFLE_DATA_METHOD).get(), 0.5);

    double newGrpcTotal = shuffleServers.get(0).getGrpcMetrics().getCounterGrpcTotal().get();
    // require buffer will be called one more time when send data
    assertEquals(oldGrpcTotal + 11, newGrpcTotal, 0.5);
    assertEquals(0, shuffleServers.get(0).getGrpcMetrics().getGaugeGrpcOpen().get(), 0.5);
  }
",non-flaky,5
77009,Tencent_Firestorm,MultiStorageTest.readUploadedDataTest,"  @Test
  public void readUploadedDataTest() {
    String appId = ""ap_read_uploaded_data"";
    RssRegisterShuffleRequest rr1 =  new RssRegisterShuffleRequest(appId, 0,
        Lists.newArrayList(new PartitionRange(0, 0)));
    RssRegisterShuffleRequest rr2 =  new RssRegisterShuffleRequest(appId, 0,
        Lists.newArrayList(new PartitionRange(1, 1)));
    RssRegisterShuffleRequest rr3 =  new RssRegisterShuffleRequest(appId, 0,
        Lists.newArrayList(new PartitionRange(2, 2)));
    RssRegisterShuffleRequest rr4 =  new RssRegisterShuffleRequest(appId, 0,
        Lists.newArrayList(new PartitionRange(4, 4)));
    shuffleServerClient.registerShuffle(rr1);
    shuffleServerClient.registerShuffle(rr2);
    shuffleServerClient.registerShuffle(rr3);
    shuffleServerClient.registerShuffle(rr4);

    Map<Long, byte[]> expectedData = Maps.newHashMap();
    Set<Long> expectedBlock1 = Sets.newHashSet();
    Set<Long> expectedBlock2 = Sets.newHashSet();

    Roaring64NavigableMap blockIdBitmap1 = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap blockIdBitmap2 = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap blockIdBitmap3 = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap blockIdBitmap4 = Roaring64NavigableMap.bitmapOf();

    List<ShuffleBlockInfo> blocks1 = createShuffleBlockList(
        0, 0, 1,3, 25, blockIdBitmap1, expectedData);
    List<ShuffleBlockInfo> blocks2 = createShuffleBlockList(
        0, 1, 1,5,1024 * 1024, blockIdBitmap2, expectedData);
    List<ShuffleBlockInfo> blocks3 = createShuffleBlockList(
        0, 2, 2,4, 25, blockIdBitmap3, expectedData);
    List<ShuffleBlockInfo> blocks4 = createShuffleBlockList(
        0, 4, 3,1, 1024 * 1024, blockIdBitmap4, expectedData);


    blocks1.forEach(b -> expectedBlock1.add(b.getBlockId()));
    blocks2.forEach(b -> expectedBlock2.add(b.getBlockId()));

    Map<Integer, List<ShuffleBlockInfo>> partitionToBlocks = Maps.newHashMap();
    partitionToBlocks.put(0, blocks1);
    partitionToBlocks.put(1, blocks2);
    Map<Integer, Map<Integer, List<ShuffleBlockInfo>>> shuffleToBlocks = Maps.newHashMap();
    shuffleToBlocks.put(0, partitionToBlocks);
    RssSendShuffleDataRequest rs1 = new RssSendShuffleDataRequest(appId, 3, 1000, shuffleToBlocks);
    shuffleServerClient.sendShuffleData(rs1);

    RssSendCommitRequest rc1 = new RssSendCommitRequest(appId, 0);
    shuffleServerClient.sendCommit(rc1);
    RssFinishShuffleRequest rf1 = new RssFinishShuffleRequest(appId, 0);
    shuffleServerClient.finishShuffle(rf1);
    Map<Integer, List<Long>> partitionToBlockIds = Maps.newHashMap();
    partitionToBlockIds.put(0, new ArrayList<>(expectedBlock1));
    partitionToBlockIds.put(1, new ArrayList<>(expectedBlock2));
    RssReportShuffleResultRequest rrp1 = new RssReportShuffleResultRequest(
        appId, 0, 1L, partitionToBlockIds, 2);
    shuffleServerClient.reportShuffleResult(rrp1);

    DiskItem item = shuffleServers.get(0).getMultiStorageManager().getDiskItem(appId, 0, 0);
    assertTrue(item.canWrite());
    assertEquals(3 * 25, item.getNotUploadedSize(appId + ""/"" + 0));
    item = shuffleServers.get(0).getMultiStorageManager().getDiskItem(appId, 0, 1);
    assertTrue(item.canWrite());
    assertEquals(5 * 1024 * 1024, item.getNotUploadedSize(appId + ""/"" + 0));

    sendSinglePartitionToShuffleServer(appId, 0,2, 2L, blocks3);
    sendSinglePartitionToShuffleServer(appId, 0, 4, 3L, blocks4);

    item = shuffleServers.get(0).getMultiStorageManager().getDiskItem(appId, 0, 2);
    assertTrue(item.canWrite());
    assertEquals(3 * 25 + 4 * 25, item.getNotUploadedSize(appId + ""/"" + 0));

    item = shuffleServers.get(0).getMultiStorageManager().getDiskItem(appId, 0, 4);
    assertTrue(item.canWrite());
    assertEquals(5 * 1024 * 1024 + 1024 * 1024, item.getNotUploadedSize(appId + ""/"" + 0));


    RssGetShuffleResultRequest rg1 = new RssGetShuffleResultRequest(appId, 0, 0);
    shuffleServerClient.getShuffleResult(rg1);
    RssGetShuffleResultRequest rg2 = new RssGetShuffleResultRequest(appId, 0, 1);
    shuffleServerClient.getShuffleResult(rg2);
    RssGetShuffleResultRequest rg3 = new RssGetShuffleResultRequest(appId, 0, 2);
    shuffleServerClient.getShuffleResult(rg3);
    RssGetShuffleResultRequest rg4 = new RssGetShuffleResultRequest(appId, 0, 4);
    shuffleServerClient.getShuffleResult(rg4);

    readShuffleData(shuffleServerClient, appId, 0, 0, 1, 10, 100, 0);
    readShuffleData(shuffleServerClient, appId, 0, 1, 1, 10, 100, 0);


    wait(appId);

    item = shuffleServers.get(0).getMultiStorageManager().getDiskItem(appId, 0, 0);
    assertTrue(item.canWrite());
    assertEquals(0, item.getNotUploadedSize(appId + ""/"" + 0));

    item = shuffleServers.get(0).getMultiStorageManager().getDiskItem(appId, 0, 1);
    assertTrue(item.canWrite());
    assertEquals(0, item.getNotUploadedSize(appId + ""/"" + 0));

    boolean isException = false;
    try {
      ShuffleDataResult result = readShuffleData(shuffleServerClient, appId, 0, 0,
          1, 10, 1000,  0);
    } catch (RuntimeException re) {
      isException = true;
      assertTrue(re.getMessage().contains(""Can't get shuffle index""));
    }
    assertTrue(isException);

    ShuffleReadClientImpl readClient = new ShuffleReadClientImpl(""LOCALFILE_AND_HDFS"",
        appId, 0, 0, 100, 1, 10, 1000, HDFS_URI + ""rss/multi_storage"",
        blockIdBitmap1, Roaring64NavigableMap.bitmapOf(1), Lists.newArrayList(), conf);
    validateResult(readClient, expectedData, blockIdBitmap1);

    readClient = new ShuffleReadClientImpl(""LOCALFILE_AND_HDFS"",
        appId, 0, 1, 100, 1, 10, 1000, HDFS_URI + ""rss/multi_storage"",
        blockIdBitmap2, Roaring64NavigableMap.bitmapOf(1), Lists.newArrayList(), conf);
    validateResult(readClient, expectedData, blockIdBitmap2);

    readClient = new ShuffleReadClientImpl(""LOCALFILE_AND_HDFS"",
        appId, 0, 2, 100, 1, 10, 1000, HDFS_URI + ""rss/multi_storage"",
        blockIdBitmap3, Roaring64NavigableMap.bitmapOf(2), Lists.newArrayList(), conf);
    validateResult(readClient, expectedData, blockIdBitmap3);

    readClient = new ShuffleReadClientImpl(""LOCALFILE_AND_HDFS"",
        appId, 0, 4, 100, 1, 10, 1000, HDFS_URI + ""rss/multi_storage"",
        blockIdBitmap4, Roaring64NavigableMap.bitmapOf(3), Lists.newArrayList(), conf);
    validateResult(readClient, expectedData, blockIdBitmap4);
  }
",non-flaky,5
77010,Tencent_Firestorm,MultiStorageTest.readLocalDataTest,"  @Test
  public void readLocalDataTest() {
    String appId = ""app_read_not_uploaded_data"";
    Map<Long, byte[]> expectedData = Maps.newHashMap();
    RssRegisterShuffleRequest rr1 =  new RssRegisterShuffleRequest(appId, 1,
        Lists.newArrayList(new PartitionRange(0, 0)));
    RssRegisterShuffleRequest rr2 =  new RssRegisterShuffleRequest(appId, 1,
        Lists.newArrayList(new PartitionRange(1, 1)));
    RssRegisterShuffleRequest rr3 =  new RssRegisterShuffleRequest(appId, 1,
        Lists.newArrayList(new PartitionRange(2, 2)));
    RssRegisterShuffleRequest rr4 =  new RssRegisterShuffleRequest(appId, 1,
        Lists.newArrayList(new PartitionRange(3, 3)));
    shuffleServerClient.registerShuffle(rr1);
    shuffleServerClient.registerShuffle(rr2);
    shuffleServerClient.registerShuffle(rr3);
    shuffleServerClient.registerShuffle(rr4);

    Roaring64NavigableMap blockIdBitmap1 = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap blockIdBitmap2 = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap blockIdBitmap3 = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap blockIdBitmap4 = Roaring64NavigableMap.bitmapOf();

    List<ShuffleBlockInfo> blocks1 = createShuffleBlockList(
        1, 0, 1,3, 25, blockIdBitmap1, expectedData);
    List<ShuffleBlockInfo> blocks2 = createShuffleBlockList(
        1, 1, 2,5,1024 * 1024, blockIdBitmap2, expectedData);
    List<ShuffleBlockInfo> blocks3 = createShuffleBlockList(
        1, 2, 3,4, 25, blockIdBitmap3, expectedData);
    List<ShuffleBlockInfo> blocks4 = createShuffleBlockList(
        1, 3, 4,1, 1024 * 1024, blockIdBitmap4, expectedData);

    sendSinglePartitionToShuffleServer(appId, 1,0, 1L, blocks1);
    sendSinglePartitionToShuffleServer(appId, 1,1, 2L, blocks2);
    sendSinglePartitionToShuffleServer(appId, 1,2, 3L, blocks3);
    sendSinglePartitionToShuffleServer(appId, 1,3, 4L, blocks4);

    RssGetShuffleResultRequest rg1 = new RssGetShuffleResultRequest(appId, 1, 0);
    shuffleServerClient.getShuffleResult(rg1);
    RssGetShuffleResultRequest rg2 = new RssGetShuffleResultRequest(appId, 1, 1);
    shuffleServerClient.getShuffleResult(rg2);
    RssGetShuffleResultRequest rg3 = new RssGetShuffleResultRequest(appId, 1, 2);
    shuffleServerClient.getShuffleResult(rg3);
    RssGetShuffleResultRequest rg4 = new RssGetShuffleResultRequest(appId, 1, 3);
    shuffleServerClient.getShuffleResult(rg4);

    Uninterruptibles.sleepUninterruptibly(2, TimeUnit.SECONDS);
    validateResult(appId, 1, 0, expectedData, getExpectBlockIds(blocks1));
    Uninterruptibles.sleepUninterruptibly(2, TimeUnit.SECONDS);
    validateResult(appId, 1, 1, expectedData, getExpectBlockIds(blocks2));
    Uninterruptibles.sleepUninterruptibly(2, TimeUnit.SECONDS);
    validateResult(appId, 1, 2, expectedData, getExpectBlockIds(blocks3));
    Uninterruptibles.sleepUninterruptibly(2, TimeUnit.SECONDS);
    validateResult(appId, 1, 3, expectedData, getExpectBlockIds(blocks4));
    Uninterruptibles.sleepUninterruptibly(20, TimeUnit.SECONDS);
    boolean isException = false;
    try {
      readShuffleData(shuffleServerClient, appId, 1, 0,
          1, 10, 1000,  0);
    } catch (RuntimeException re) {
      isException = true;
      assertTrue(re.getMessage().contains(""Can't get shuffle index""));
    }
    assertTrue(isException);
  }
",non-flaky,5
77011,Tencent_Firestorm,MultiStorageTest.readMixedDataTest,"  @Test
  public void readMixedDataTest() {
    String appId = ""app_read_mix_data"";
    RssRegisterShuffleRequest rr1 =  new RssRegisterShuffleRequest(appId, 0,
        Lists.newArrayList(new PartitionRange(0, 0)));
    shuffleServerClient.registerShuffle(rr1);

    Map<Long, byte[]> expectedData = Maps.newHashMap();
    Set<Long> expectedBlock1 = Sets.newHashSet();

    Roaring64NavigableMap blockIdBitmap1 = Roaring64NavigableMap.bitmapOf();

    List<ShuffleBlockInfo> blocks1 = createShuffleBlockList(
        0, 0, 1,15, 1024 * 1024, blockIdBitmap1, expectedData);

    blocks1.forEach(b -> expectedBlock1.add(b.getBlockId()));

    Map<Integer, List<ShuffleBlockInfo>> partitionToBlocks = Maps.newHashMap();
    partitionToBlocks.put(0, blocks1);
    Map<Integer, Map<Integer, List<ShuffleBlockInfo>>> shuffleToBlocks = Maps.newHashMap();
    shuffleToBlocks.put(0, partitionToBlocks);
    RssSendShuffleDataRequest rs1 = new RssSendShuffleDataRequest(appId, 3, 1000, shuffleToBlocks);
    shuffleServerClient.sendShuffleData(rs1);

    RssSendCommitRequest rc1 = new RssSendCommitRequest(appId, 0);
    shuffleServerClient.sendCommit(rc1);
    RssFinishShuffleRequest rf1 = new RssFinishShuffleRequest(appId, 0);
    shuffleServerClient.finishShuffle(rf1);
    Map<Integer, List<Long>> partitionToBlockIds = Maps.newHashMap();
    partitionToBlockIds.put(0, new ArrayList<>(expectedBlock1));
    RssReportShuffleResultRequest rrp1 = new RssReportShuffleResultRequest(
        appId, 0, 1L, partitionToBlockIds, 1);
    shuffleServerClient.reportShuffleResult(rrp1);

    RssGetShuffleResultRequest rg1 = new RssGetShuffleResultRequest(appId, 0, 0);
    shuffleServerClient.getShuffleResult(rg1);

    ShuffleReadClientImpl readClient = new ShuffleReadClientImpl(""LOCALFILE_AND_HDFS"",
        appId, 0, 0, 100, 1, 10, 1000, HDFS_URI + ""rss/multi_storage"",
        blockIdBitmap1, Roaring64NavigableMap.bitmapOf(1), Lists.newArrayList(new ShuffleServerInfo(""test"", LOCALHOST, SHUFFLE_SERVER_PORT)), conf);

    CompressedShuffleBlock csb = readClient.readShuffleBlockData();
    Roaring64NavigableMap matched = Roaring64NavigableMap.bitmapOf();
    assertNotNull(csb);
    assertNotNull(csb.getByteBuffer());
    for (Map.Entry<Long, byte[]> entry : expectedData.entrySet()) {
      if (compareByte(entry.getValue(), csb.getByteBuffer())) {
        matched.addLong(entry.getKey());
      }
    }
    wait(appId);

    csb = readClient.readShuffleBlockData();
    while (csb != null && csb.getByteBuffer() != null) {
      for (Map.Entry<Long, byte[]> entry : expectedData.entrySet()) {
        if (compareByte(entry.getValue(), csb.getByteBuffer())) {
          matched.addLong(entry.getKey());
          break;
        }
      }
      csb = readClient.readShuffleBlockData();
    }
    assertTrue(blockIdBitmap1.equals(matched));

    boolean isException = false;
    try {
      readShuffleData(shuffleServerClient, appId, 0, 0,
          1, 10, 1000, 0);
    } catch (RuntimeException re) {
      isException = true;
      assertTrue(re.getMessage().contains(""Can't get shuffle index""));
    }
    assertTrue(isException);

    List<ShuffleBlockInfo> blocks5 = createShuffleBlockList(
        0, 0, 1,15, 1024 * 1024, blockIdBitmap1, expectedData);
    partitionToBlocks.clear();
    shuffleToBlocks.clear();
    partitionToBlocks.put(0, blocks5);
    shuffleToBlocks.put(0, partitionToBlocks);
    RssSendShuffleDataRequest rs5 = new RssSendShuffleDataRequest(appId, 3, 1000, shuffleToBlocks);
    DiskItem diskItem = shuffleServers.get(0).getMultiStorageManager().getDiskItem(appId, 0, 0);
    String path = ShuffleStorageUtils.getFullShuffleDataFolder(diskItem.getBasePath(),
        ShuffleStorageUtils.getShuffleDataPath(appId, 0, 0, 0));
    File file = new File(path);
    assertFalse(file.exists());
    try {
      shuffleServerClient.sendShuffleData(rs5);
      shuffleServerClient.sendCommit(rc1);
      shuffleServerClient.finishShuffle(rf1);
      shuffleServerClient.reportShuffleResult(rrp1);
    } catch (Exception e) {
      fail();
    }
    assertFalse(file.exists());
  }
",non-flaky,5
77012,Tencent_Firestorm,MultiStorageTest.diskUsageTest,"  @Test
  public void diskUsageTest() {
    String appId = ""app_read_diskusage_data"";
    long originSize = shuffleServers.get(0).getShuffleBufferManager().getCapacity();
    Map<Long, byte[]> expectedData = Maps.newHashMap();

    RssRegisterShuffleRequest rr1 =  new RssRegisterShuffleRequest(appId, 2,
        Lists.newArrayList(new PartitionRange(0, 0)));
    shuffleServerClient.registerShuffle(rr1);

    RssRegisterShuffleRequest rr2 =  new RssRegisterShuffleRequest(appId, 3,
        Lists.newArrayList(new PartitionRange(1, 1)));
    shuffleServerClient.registerShuffle(rr2);

    RssRegisterShuffleRequest rr3 =  new RssRegisterShuffleRequest(appId, 2,
        Lists.newArrayList(new PartitionRange(1, 1)));
    shuffleServerClient.registerShuffle(rr3);

    Roaring64NavigableMap blockIdBitmap1 = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap blockIdBitmap2 = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap blockIdBitmap3 = Roaring64NavigableMap.bitmapOf();

    List<ShuffleBlockInfo> blocks1 = createShuffleBlockList(
        2, 0, 1,30, 10 * 1024 * 1024, blockIdBitmap1, expectedData);

    List<ShuffleBlockInfo> blocks2 = createShuffleBlockList(
        3, 1, 2,9, 10 * 1024 * 1024, blockIdBitmap2, expectedData);

    List<ShuffleBlockInfo> blocks3 = createShuffleBlockList(
        2, 1, 2,9, 10 * 1024 * 1024, blockIdBitmap3, expectedData);

    DiskItem item = shuffleServers.get(0).getMultiStorageManager().getDiskItem(appId, 2, 0);
    item.createMetadataIfNotExist(appId + ""/"" + 2);
    item.getLock(appId + ""/"" + 2).readLock().lock();
    sendSinglePartitionToShuffleServer(appId, 2, 0, 1, blocks1);
    assertFalse(item.canWrite());
    assertEquals(30 * 1024 * 1024 * 10, item.getNotUploadedSize(appId + ""/"" + 2));
    assertEquals(1, item.getNotUploadedPartitions(appId + ""/"" + 2).getCardinality());
    boolean isException = false;
    try {
      sendSinglePartitionToShuffleServer(appId, 2, 1, 2, blocks3);
    } catch (RuntimeException re) {
      isException = true;
      assertTrue(re.getMessage().contains(""Can't finish shuffle process""));
    }
    item.getLock(appId + ""/"" + 2).readLock().unlock();
    Uninterruptibles.sleepUninterruptibly(6, TimeUnit.SECONDS);
    assertEquals(originSize, shuffleServers.get(0).getShuffleBufferManager().getCapacity());
    assertTrue(isException);
    RssGetShuffleResultRequest rg1 = new RssGetShuffleResultRequest(appId, 2, 0);
    shuffleServerClient.getShuffleResult(rg1);
    validateResult(appId, 2, 0, expectedData, Sets.newHashSet());
    ShuffleReadClientImpl readClient = new ShuffleReadClientImpl(""LOCALFILE_AND_HDFS"",
        appId, 2, 0, 100, 1, 10, 1000, HDFS_URI + ""rss/multi_storage"",
        blockIdBitmap1, Roaring64NavigableMap.bitmapOf(1), Lists.newArrayList(new ShuffleServerInfo(""test"", LOCALHOST, SHUFFLE_SERVER_PORT)), conf);
    validateResult(readClient, expectedData, blockIdBitmap1);
    try {
      sendSinglePartitionToShuffleServer(appId, 3, 1,2, blocks2);
    } catch (RuntimeException re) {
      fail();
    }
    RssGetShuffleResultRequest rg2 = new RssGetShuffleResultRequest(appId, 3, 1);
    shuffleServerClient.getShuffleResult(rg2);
    validateResult(appId, 3, 1, expectedData,
        getExpectBlockIds(blocks2));

    Uninterruptibles.sleepUninterruptibly(5, TimeUnit.SECONDS);
  }
",non-flaky,5
77013,Tencent_Firestorm,MultiStorageTest.removeMetaTest,"  @Test
  public void removeMetaTest() {
    String appId = ""app_read_diskusage_data_without_report"";
    Map<Long, byte[]> expectedData = Maps.newHashMap();
    RssRegisterShuffleRequest rr1 =  new RssRegisterShuffleRequest(appId, 2,
        Lists.newArrayList(new PartitionRange(0, 0)));
    shuffleServerClient.registerShuffle(rr1);
    RssRegisterShuffleRequest rr2 =  new RssRegisterShuffleRequest(appId, 3,
        Lists.newArrayList(new PartitionRange(1, 1)));
    shuffleServerClient.registerShuffle(rr2);

    Roaring64NavigableMap blockIdBitmap1 = Roaring64NavigableMap.bitmapOf();
    Roaring64NavigableMap blockIdBitmap2 = Roaring64NavigableMap.bitmapOf();

    List<ShuffleBlockInfo> blocks1 = createShuffleBlockList(
        2, 0, 1,30, 10 * 1024 * 1024, blockIdBitmap1, expectedData);
    List<ShuffleBlockInfo> blocks2 = createShuffleBlockList(
        3, 1, 2,9, 10 * 1024 * 1024, blockIdBitmap2, expectedData);

    sendSinglePartitionToShuffleServerWithoutReport(appId, 2, 2, 2, blocks1);
    sendSinglePartitionToShuffleServerWithoutReport(appId, 3, 1,2, blocks2);
    shuffleServers.get(0).getShuffleTaskManager().removeResources(appId);
    DiskItem item = shuffleServers.get(0).getMultiStorageManager().getDiskItem(appId, 2, 0);
    Uninterruptibles.sleepUninterruptibly(1500, TimeUnit.MILLISECONDS);
    Set<String> keys = item.getShuffleMetaSet();
    assertTrue(keys.isEmpty());
    item = shuffleServers.get(0).getMultiStorageManager().getDiskItem(appId, 3, 1);
    keys = item.getShuffleMetaSet();
    assertTrue(keys.isEmpty());

    appId = ""app_read_diskusage_data_with_report"";
    rr1 =  new RssRegisterShuffleRequest(appId, 0, Lists.newArrayList(new PartitionRange(0, 0)));
    shuffleServerClient.registerShuffle(rr1);
    blocks1 = createShuffleBlockList(
        0, 0, 1,30, 10 * 1024, blockIdBitmap1, expectedData);
    sendSinglePartitionToShuffleServer(appId, 0, 0, 2, blocks1);
    shuffleServers.get(0).getShuffleTaskManager().removeResources(appId);
    item = shuffleServers.get(0).getMultiStorageManager().getDiskItem(appId, 0, 0);
    Uninterruptibles.sleepUninterruptibly(1500, TimeUnit.MILLISECONDS);
    keys = item.getShuffleMetaSet();
    assertTrue(keys.isEmpty());
  }
",non-flaky,5
77014,Tencent_Firestorm,AQESkewedJoinTest.resultCompareTest,"  @Test
  public void resultCompareTest() throws Exception {
    run();
  }
",non-flaky,5
77015,Tencent_Firestorm,AQERepartitionTest.resultCompareTest,"  @Test
  public void resultCompareTest() throws Exception {
    run();
  }
",non-flaky,5
77016,Tencent_Firestorm,ShuffleHdfsStorageUtilsTest.testUploadFile,"  @Test
  public void testUploadFile() {
    FileOutputStream fileOut = null;
    DataOutputStream dataOut = null;
    try {
      TemporaryFolder tmpDir = new TemporaryFolder();
      tmpDir.create();
      File file = tmpDir.newFile(""test"");
      fileOut = new FileOutputStream(file);
      dataOut = new DataOutputStream(fileOut);
      byte[] buf = new byte[2096];
      new Random().nextBytes(buf);
      dataOut.write(buf);
      dataOut.close();
      fileOut.close();
      String path = HDFS_URI + ""test"";
      HdfsFileWriter writer = new HdfsFileWriter(new Path(path), conf);
      long size = ShuffleStorageUtils.uploadFile(file, writer, 1024);
      assertEquals(2096, size);
      size = ShuffleStorageUtils.uploadFile(file, writer, 100);
      assertEquals(2096, size);
      writer.close();
      tmpDir.delete();
    } catch (Exception e) {
      e.printStackTrace();
      fail();
    }
  }
",non-flaky,5
77017,Tencent_Firestorm,ShuffleStorageUtilsTest.mergeSegmentsTest,"  @Test
  public void mergeSegmentsTest() {
    List<FileBasedShuffleSegment> segments = Lists.newArrayList(
        new FileBasedShuffleSegment(1, 0, 40, 0, 0, 0));
    List<DataFileSegment> fileSegments = ShuffleStorageUtils.mergeSegments(""path"", segments, 100);
    assertEquals(1, fileSegments.size());
    for (DataFileSegment seg : fileSegments) {
      assertEquals(0, seg.getOffset());
      assertEquals(40, seg.getLength());
      assertEquals(""path"", seg.getPath());
      List<BufferSegment> bufferSegments = seg.getBufferSegments();
      assertEquals(1, bufferSegments.size());
      assertEquals(new BufferSegment(1, 0, 40, 0, 0, 0), bufferSegments.get(0));
    }

    segments = Lists.newArrayList(
        new FileBasedShuffleSegment(1, 0, 40, 0, 0, 0),
        new FileBasedShuffleSegment(2, 40, 40, 0, 0, 0),
        new FileBasedShuffleSegment(3, 80, 20, 0, 0, 0));
    fileSegments = ShuffleStorageUtils.mergeSegments(""path"", segments, 100);
    assertEquals(1, fileSegments.size());
    for (DataFileSegment seg : fileSegments) {
      assertEquals(0, seg.getOffset());
      assertEquals(100, seg.getLength());
      assertEquals(""path"", seg.getPath());
      List<BufferSegment> bufferSegments = seg.getBufferSegments();
      assertEquals(3, bufferSegments.size());
      Set<Long> testedBlockIds = Sets.newHashSet();
      for (BufferSegment segment : bufferSegments) {
        if (segment.getBlockId() == 1) {
          assertTrue(segment.equals(new BufferSegment(1, 0, 40, 0, 0, 0)));
          testedBlockIds.add(1L);
        } else if (segment.getBlockId() == 2) {
          assertTrue(segment.equals(new BufferSegment(2, 40, 40, 0, 0, 0)));
          testedBlockIds.add(2L);
        } else if (segment.getBlockId() == 3) {
          assertTrue(segment.equals(new BufferSegment(3, 80, 20, 0, 0, 0)));
          testedBlockIds.add(3L);
        }
      }
      assertEquals(3, testedBlockIds.size());
    }

    segments = Lists.newArrayList(
        new FileBasedShuffleSegment(1, 0, 40, 0, 0, 0),
        new FileBasedShuffleSegment(2, 40, 40, 0, 0, 0),
        new FileBasedShuffleSegment(3, 80, 20, 0, 0, 0),
        new FileBasedShuffleSegment(4, 100, 20, 0, 0, 0));
    fileSegments = ShuffleStorageUtils.mergeSegments(""path"", segments, 100);
    assertEquals(2, fileSegments.size());
    boolean tested = false;
    for (DataFileSegment seg : fileSegments) {
      if (seg.getOffset() == 100) {
        tested = true;
        assertEquals(20, seg.getLength());
        assertEquals(""path"", seg.getPath());
        List<BufferSegment> bufferSegments = seg.getBufferSegments();
        assertEquals(1, bufferSegments.size());
        assertTrue(bufferSegments.get(0).equals(new BufferSegment(4, 0, 20, 0, 0, 0)));
      }
    }
    assertTrue(tested);

    segments = Lists.newArrayList(
        new FileBasedShuffleSegment(1, 0, 40, 0, 0, 0),
        new FileBasedShuffleSegment(2, 40, 40, 0, 0, 0),
        new FileBasedShuffleSegment(3, 80, 20, 0, 0, 0),
        new FileBasedShuffleSegment(4, 100, 20, 0, 0, 0),
        new FileBasedShuffleSegment(5, 120, 100, 0, 0, 0));
    fileSegments = ShuffleStorageUtils.mergeSegments(""path"", segments, 100);
    assertEquals(2, fileSegments.size());
    tested = false;
    for (DataFileSegment seg : fileSegments) {
      if (seg.getOffset() == 100) {
        tested = true;
        assertEquals(120, seg.getLength());
        assertEquals(""path"", seg.getPath());
        List<BufferSegment> bufferSegments = seg.getBufferSegments();
        assertEquals(2, bufferSegments.size());
        Set<Long> testedBlockIds = Sets.newHashSet();
        for (BufferSegment segment : bufferSegments) {
          if (segment.getBlockId() == 4) {
            assertTrue(segment.equals(new BufferSegment(4, 0, 20, 0, 0, 0)));
            testedBlockIds.add(4L);
          } else if (segment.getBlockId() == 5) {
            assertTrue(segment.equals(new BufferSegment(5, 20, 100, 0, 0, 0)));
            testedBlockIds.add(5L);
          }
        }
        assertEquals(2, testedBlockIds.size());
      }
    }
    assertTrue(tested);

    segments = Lists.newArrayList(
        new FileBasedShuffleSegment(1, 10, 40, 0, 0, 0),
        new FileBasedShuffleSegment(2, 80, 20, 0, 0, 0),
        new FileBasedShuffleSegment(3, 500, 120, 0, 0, 0),
        new FileBasedShuffleSegment(4, 700, 20, 0, 0, 0));
    fileSegments = ShuffleStorageUtils.mergeSegments(""path"", segments, 100);
    assertEquals(3, fileSegments.size());
    Set<Long> expectedOffset = Sets.newHashSet(10L, 500L, 700L);
    for (DataFileSegment seg : fileSegments) {
      if (seg.getOffset() == 10) {
        validResult(seg, 90, 1, 40, 2, 70);
        expectedOffset.remove(10L);
      }
      if (seg.getOffset() == 500) {
        assertEquals(120, seg.getLength());
        List<BufferSegment> bufferSegments = seg.getBufferSegments();
        assertEquals(1, bufferSegments.size());
        assertTrue(bufferSegments.get(0).equals(new BufferSegment(3, 0, 120, 0, 0, 0)));
        expectedOffset.remove(500L);
      }
      if (seg.getOffset() == 700) {
        assertEquals(20, seg.getLength());
        List<BufferSegment> bufferSegments = seg.getBufferSegments();
        assertEquals(1, bufferSegments.size());
        assertTrue(bufferSegments.get(0).equals(new BufferSegment(4, 0, 20, 0, 0, 0)));
        expectedOffset.remove(700L);
      }
    }
    assertTrue(expectedOffset.isEmpty());

    segments = Lists.newArrayList(
        new FileBasedShuffleSegment(5, 500, 120, 0, 0, 0),
        new FileBasedShuffleSegment(3, 630, 10, 0, 0, 0),
        new FileBasedShuffleSegment(2, 80, 20, 0, 0, 0),
        new FileBasedShuffleSegment(1, 10, 40, 0, 0, 0),
        new FileBasedShuffleSegment(6, 769, 20, 0, 0, 0),
        new FileBasedShuffleSegment(4, 700, 20, 0, 0, 0));
    fileSegments = ShuffleStorageUtils.mergeSegments(""path"", segments, 100);
    assertEquals(4, fileSegments.size());
    expectedOffset = Sets.newHashSet(10L, 500L, 630L, 700L);
    for (DataFileSegment seg : fileSegments) {
      if (seg.getOffset() == 10) {
        validResult(seg, 90, 1, 40, 2, 70);
        expectedOffset.remove(10L);
      }
      if (seg.getOffset() == 500) {
        assertEquals(120, seg.getLength());
        List<BufferSegment> bufferSegments = seg.getBufferSegments();
        assertEquals(1, bufferSegments.size());
        assertTrue(bufferSegments.get(0).equals(new BufferSegment(5, 0, 120, 0, 0, 0)));
        expectedOffset.remove(500L);
      }
      if (seg.getOffset() == 630) {
        assertEquals(10, seg.getLength());
        List<BufferSegment> bufferSegments = seg.getBufferSegments();
        assertEquals(1, bufferSegments.size());
        assertTrue(bufferSegments.get(0).equals(new BufferSegment(3, 0, 10, 0, 0, 0)));
        expectedOffset.remove(630L);
      }
      if (seg.getOffset() == 700) {
        validResult(seg, 89, 4, 20, 6, 69);
        expectedOffset.remove(700L);
      }
    }
    assertTrue(expectedOffset.isEmpty());
  }
",non-flaky,5
77018,Tencent_Firestorm,ShuffleStorageUtilsTest.getShuffleDataPathWithRangeTest,"  @Test
  public void getShuffleDataPathWithRangeTest() {
    String result = ShuffleStorageUtils.getShuffleDataPathWithRange(""appId"", 0, 1, 3, 6);
    assertEquals(""appId/0/0-2"", result);
    result = ShuffleStorageUtils.getShuffleDataPathWithRange(""appId"", 0, 2, 3, 6);
    assertEquals(""appId/0/0-2"", result);
    result = ShuffleStorageUtils.getShuffleDataPathWithRange(""appId"", 0, 3, 3, 6);
    assertEquals(""appId/0/3-5"", result);
    result = ShuffleStorageUtils.getShuffleDataPathWithRange(""appId"", 0, 5, 3, 6);
    assertEquals(""appId/0/3-5"", result);
    try {
      ShuffleStorageUtils.getShuffleDataPathWithRange(""appId"", 0, 6, 3, 6);
      fail(""shouldn't be here"");
    } catch (Exception e) {
      assertTrue(e.getMessage().startsWith(""Can't generate ShuffleData Path""));
    }
    result = ShuffleStorageUtils.getShuffleDataPathWithRange(""appId"", 0, 6, 3, 7);
    assertEquals(""appId/0/6-8"", result);
  }
",non-flaky,5
77019,Tencent_Firestorm,ShuffleStorageUtilsTest.getStorageIndexTest,"  @Test
  public void getStorageIndexTest() {
    int index = ShuffleStorageUtils.getStorageIndex(3, ""abcde"", 3, 1);
    assertEquals(2, index);
    index = ShuffleStorageUtils.getStorageIndex(3, ""abcde"", 3, 4);
    assertEquals(1, index);
  }
",non-flaky,5
77429,opensearch-project_OpenSearch,BwcVersionsTests.testExceptionOnEmpty,"    @Test(expected = IllegalArgumentException.class)
    public void testExceptionOnEmpty() {
        new BwcVersions(asList(""foo"", ""bar""), Version.fromString(""7.0.0""));
    }
",non-flaky,5
77430,opensearch-project_OpenSearch,BwcVersionsTests.testExceptionOnNonCurrent,"    @Test(expected = IllegalStateException.class)
    public void testExceptionOnNonCurrent() {
        new BwcVersions(singletonList(formatVersionToLine(""6.5.0"")), Version.fromString(""7.0.0""));
    }
",non-flaky,5
77431,opensearch-project_OpenSearch,BwcVersionsTests.testExceptionOnTooManyMajors,"    @Test(expected = IllegalStateException.class)
    public void testExceptionOnTooManyMajors() {
        new BwcVersions(
            asList(formatVersionToLine(""5.6.12""), formatVersionToLine(""6.5.0""), formatVersionToLine(""7.0.0"")),
            Version.fromString(""6.5.0"")
        );
    }
",non-flaky,5
77432,opensearch-project_OpenSearch,UpdateShasTaskTests.whenDependencyDoesntExistThenShouldDeleteDependencySha,"    @Test
    public void whenDependencyDoesntExistThenShouldDeleteDependencySha() throws IOException, NoSuchAlgorithmException {

        File unusedSha = createFileIn(getLicensesDir(project), ""test.sha1"", """");
        task.updateShas();

        assertFalse(unusedSha.exists());
    }
",non-flaky,5
77433,opensearch-project_OpenSearch,UpdateShasTaskTests.whenDependencyExistsButShaNotThenShouldCreateNewShaFile,"    @Test
    public void whenDependencyExistsButShaNotThenShouldCreateNewShaFile() throws IOException, NoSuchAlgorithmException {
        project.getDependencies().add(""compile"", dependency);

        getLicensesDir(project).mkdir();
        task.updateShas();

        Path groovySha = Files.list(getLicensesDir(project).toPath()).findFirst().get();

        assertTrue(groovySha.toFile().getName().startsWith(""groovy-all""));
    }
",non-flaky,5
77434,opensearch-project_OpenSearch,UpdateShasTaskTests.whenDependencyAndWrongShaExistsThenShouldNotOverwriteShaFile,"    @Test
    public void whenDependencyAndWrongShaExistsThenShouldNotOverwriteShaFile() throws IOException, NoSuchAlgorithmException {
        project.getDependencies().add(""compile"", dependency);

        File groovyJar = task.getParentTask().getDependencies().getFiles().iterator().next();
        String groovyShaName = groovyJar.getName() + "".sha1"";

        File groovySha = createFileIn(getLicensesDir(project), groovyShaName, ""content"");
        task.updateShas();

        assertThat(FileUtils.readFileToString(groovySha), equalTo(""content""));
    }
",non-flaky,5
77435,opensearch-project_OpenSearch,UpdateShasTaskTests.whenLicensesDirDoesntExistThenShouldThrowException,"    @Test
    public void whenLicensesDirDoesntExistThenShouldThrowException() throws IOException, NoSuchAlgorithmException {
        expectedException.expect(GradleException.class);
        expectedException.expectMessage(containsString(""isn't a valid directory""));

        task.updateShas();
    }
",non-flaky,5
77436,opensearch-project_OpenSearch,DependencyLicensesTaskTests.givenProjectWithLicensesDirButNoDependenciesThenShouldThrowException,"    @Test
    public void givenProjectWithLicensesDirButNoDependenciesThenShouldThrowException() throws Exception {
        expectedException.expect(GradleException.class);
        expectedException.expectMessage(containsString(""exists, but there are no dependencies""));

        getLicensesDir(project).mkdir();
        task.get().checkDependencies();
    }
",non-flaky,5
77437,opensearch-project_OpenSearch,DependencyLicensesTaskTests.givenProjectWithoutLicensesDirButWithDependenciesThenShouldThrowException,"    @Test
    public void givenProjectWithoutLicensesDirButWithDependenciesThenShouldThrowException() throws Exception {
        expectedException.expect(GradleException.class);
        expectedException.expectMessage(containsString(""does not exist, but there are dependencies""));

        project.getDependencies().add(""compile"", dependency);
        task.get().checkDependencies();
    }
",non-flaky,5
77438,opensearch-project_OpenSearch,DependencyLicensesTaskTests.givenProjectWithoutLicensesDirNorDependenciesThenShouldReturnSilently,"    @Test
    public void givenProjectWithoutLicensesDirNorDependenciesThenShouldReturnSilently() throws Exception {
        task.get().checkDependencies();
    }
",non-flaky,5
77439,opensearch-project_OpenSearch,DependencyLicensesTaskTests.givenProjectWithDependencyButNoShaFileThenShouldReturnException,"    @Test
    public void givenProjectWithDependencyButNoShaFileThenShouldReturnException() throws Exception {
        expectedException.expect(GradleException.class);
        expectedException.expectMessage(containsString(""Missing SHA for ""));

        File licensesDir = getLicensesDir(project);
        createFileIn(licensesDir, ""groovy-all-LICENSE.txt"", PERMISSIVE_LICENSE_TEXT);
        createFileIn(licensesDir, ""groovy-all-NOTICE.txt"", """");

        project.getDependencies().add(""compile"", project.getDependencies().localGroovy());
        task.get().checkDependencies();
    }
",non-flaky,5
77440,opensearch-project_OpenSearch,DependencyLicensesTaskTests.givenProjectWithDependencyButNoLicenseFileThenShouldReturnException,"    @Test
    public void givenProjectWithDependencyButNoLicenseFileThenShouldReturnException() throws Exception {
        expectedException.expect(GradleException.class);
        expectedException.expectMessage(containsString(""Missing LICENSE for ""));

        project.getDependencies().add(""compile"", project.getDependencies().localGroovy());

        getLicensesDir(project).mkdir();
        updateShas.updateShas();
        task.get().checkDependencies();
    }
",non-flaky,5
77441,opensearch-project_OpenSearch,DependencyLicensesTaskTests.givenProjectWithDependencyButNoNoticeFileThenShouldReturnException,"    @Test
    public void givenProjectWithDependencyButNoNoticeFileThenShouldReturnException() throws Exception {
        expectedException.expect(GradleException.class);
        expectedException.expectMessage(containsString(""Missing NOTICE for ""));

        project.getDependencies().add(""compile"", dependency);

        createFileIn(getLicensesDir(project), ""groovy-all-LICENSE.txt"", PERMISSIVE_LICENSE_TEXT);

        updateShas.updateShas();
        task.get().checkDependencies();
    }
",non-flaky,5
77442,opensearch-project_OpenSearch,DependencyLicensesTaskTests.givenProjectWithStrictDependencyButNoSourcesFileThenShouldReturnException,"    @Test
    public void givenProjectWithStrictDependencyButNoSourcesFileThenShouldReturnException() throws Exception {
        expectedException.expect(GradleException.class);
        expectedException.expectMessage(containsString(""Missing SOURCES for ""));

        project.getDependencies().add(""compile"", dependency);

        createFileIn(getLicensesDir(project), ""groovy-all-LICENSE.txt"", STRICT_LICENSE_TEXT);
        createFileIn(getLicensesDir(project), ""groovy-all-NOTICE.txt"", """");

        updateShas.updateShas();
        task.get().checkDependencies();
    }
",non-flaky,5
77443,opensearch-project_OpenSearch,DependencyLicensesTaskTests.givenProjectWithStrictDependencyAndEverythingInOrderThenShouldReturnSilently,"    @Test
    public void givenProjectWithStrictDependencyAndEverythingInOrderThenShouldReturnSilently() throws Exception {
        project.getDependencies().add(""compile"", dependency);

        createFileIn(getLicensesDir(project), ""groovy-all-LICENSE.txt"", STRICT_LICENSE_TEXT);
        createFileIn(getLicensesDir(project), ""groovy-all-NOTICE.txt"", """");
        createFileIn(getLicensesDir(project), ""groovy-all-SOURCES.txt"", """");

        updateShas.updateShas();
        task.get().checkDependencies();
    }
",non-flaky,5
77444,opensearch-project_OpenSearch,DependencyLicensesTaskTests.givenProjectWithDependencyAndEverythingInOrderThenShouldReturnSilently,"    @Test
    public void givenProjectWithDependencyAndEverythingInOrderThenShouldReturnSilently() throws Exception {
        project.getDependencies().add(""compile"", dependency);

        File licensesDir = getLicensesDir(project);

        createAllDefaultDependencyFiles(licensesDir, ""groovy-all"");
        task.get().checkDependencies();
    }
",non-flaky,5
77445,opensearch-project_OpenSearch,DependencyLicensesTaskTests.givenProjectWithALicenseButWithoutTheDependencyThenShouldThrowException,"    @Test
    public void givenProjectWithALicenseButWithoutTheDependencyThenShouldThrowException() throws Exception {
        expectedException.expect(GradleException.class);
        expectedException.expectMessage(containsString(""Unused license ""));

        project.getDependencies().add(""compile"", dependency);

        File licensesDir = getLicensesDir(project);
        createAllDefaultDependencyFiles(licensesDir, ""groovy-all"");
        createFileIn(licensesDir, ""non-declared-LICENSE.txt"", """");

        task.get().checkDependencies();
    }
",non-flaky,5
77446,opensearch-project_OpenSearch,DependencyLicensesTaskTests.givenProjectWithANoticeButWithoutTheDependencyThenShouldThrowException,"    @Test
    public void givenProjectWithANoticeButWithoutTheDependencyThenShouldThrowException() throws Exception {
        expectedException.expect(GradleException.class);
        expectedException.expectMessage(containsString(""Unused notice ""));

        project.getDependencies().add(""compile"", dependency);

        File licensesDir = getLicensesDir(project);
        createAllDefaultDependencyFiles(licensesDir, ""groovy-all"");
        createFileIn(licensesDir, ""non-declared-NOTICE.txt"", """");

        task.get().checkDependencies();
    }
",non-flaky,5
77447,opensearch-project_OpenSearch,DependencyLicensesTaskTests.givenProjectWithAShaButWithoutTheDependencyThenShouldThrowException,"    @Test
    public void givenProjectWithAShaButWithoutTheDependencyThenShouldThrowException() throws Exception {
        expectedException.expect(GradleException.class);
        expectedException.expectMessage(containsString(""Unused sha files found: \n""));

        project.getDependencies().add(""compile"", dependency);

        File licensesDir = getLicensesDir(project);
        createAllDefaultDependencyFiles(licensesDir, ""groovy-all"");
        createFileIn(licensesDir, ""non-declared.sha1"", """");

        task.get().checkDependencies();
    }
",non-flaky,5
77448,opensearch-project_OpenSearch,DependencyLicensesTaskTests.givenProjectWithADependencyWithWrongShaThenShouldThrowException,"    @Test
    public void givenProjectWithADependencyWithWrongShaThenShouldThrowException() throws Exception {
        expectedException.expect(GradleException.class);
        expectedException.expectMessage(containsString(""SHA has changed! Expected ""));

        project.getDependencies().add(""compile"", dependency);

        File licensesDir = getLicensesDir(project);
        createAllDefaultDependencyFiles(licensesDir, ""groovy-all"");

        Path groovySha = Files.list(licensesDir.toPath()).filter(file -> file.toFile().getName().contains(""sha"")).findFirst().get();

        Files.write(groovySha, new byte[] { 1 }, StandardOpenOption.CREATE);

        task.get().checkDependencies();
    }
",non-flaky,5
77449,opensearch-project_OpenSearch,DependencyLicensesTaskTests.givenProjectWithADependencyMappingThenShouldReturnSilently,"    @Test
    public void givenProjectWithADependencyMappingThenShouldReturnSilently() throws Exception {
        project.getDependencies().add(""compile"", dependency);

        File licensesDir = getLicensesDir(project);
        createAllDefaultDependencyFiles(licensesDir, ""groovy"");

        Map<String, String> mappings = new HashMap<>();
        mappings.put(""from"", ""groovy-all"");
        mappings.put(""to"", ""groovy"");

        task.get().mapping(mappings);
        task.get().checkDependencies();
    }
",non-flaky,5
77450,opensearch-project_OpenSearch,DependencyLicensesTaskTests.givenProjectWithAIgnoreShaConfigurationAndNoShaFileThenShouldReturnSilently,"    @Test
    public void givenProjectWithAIgnoreShaConfigurationAndNoShaFileThenShouldReturnSilently() throws Exception {
        project.getDependencies().add(""compile"", dependency);

        File licensesDir = getLicensesDir(project);
        createFileIn(licensesDir, ""groovy-all-LICENSE.txt"", PERMISSIVE_LICENSE_TEXT);
        createFileIn(licensesDir, ""groovy-all-NOTICE.txt"", """");

        task.get().ignoreSha(""groovy-all"");
        task.get().checkDependencies();
    }
",non-flaky,5
77451,opensearch-project_OpenSearch,DependencyLicensesTaskTests.givenProjectWithoutLicensesDirWhenAskingForShaFilesThenShouldThrowException,"    @Test
    public void givenProjectWithoutLicensesDirWhenAskingForShaFilesThenShouldThrowException() {
        expectedException.expect(GradleException.class);
        expectedException.expectMessage(containsString(""isn't a valid directory""));

        task.get().getShaFiles();
    }
",non-flaky,5
77452,opensearch-project_OpenSearch,NastyInnerClasses.annotatedTestMethod,"        @Test
        public void annotatedTestMethod() {

        }
",non-flaky,5
77453,opensearch-project_OpenSearch,LooksLikeATestWithoutNamingConvention1.annotatedTestMethod,"    @Test
    public void annotatedTestMethod() {

    }
",non-flaky,5
77454,opensearch-project_OpenSearch,PreBuiltTransportClientTests.testPluginInstalled,"    @Test
    public void testPluginInstalled() {
        try (TransportClient client = new PreBuiltTransportClient(Settings.EMPTY)) {
            Settings settings = client.settings();
            assertEquals(Netty4Plugin.NETTY_TRANSPORT_NAME, NetworkModule.HTTP_DEFAULT_TYPE_SETTING.get(settings));
            assertEquals(Netty4Plugin.NETTY_TRANSPORT_NAME, NetworkModule.TRANSPORT_DEFAULT_TYPE_SETTING.get(settings));
        }
    }
",non-flaky,5
77455,opensearch-project_OpenSearch,PreBuiltTransportClientTests.testInstallPluginTwice,"    @Test
    public void testInstallPluginTwice() {
        for (Class<? extends Plugin> plugin :
                Arrays.asList(ParentJoinPlugin.class, ReindexPlugin.class, PercolatorPlugin.class,
                    MustachePlugin.class)) {
            try {
                new PreBuiltTransportClient(Settings.EMPTY, plugin);
                fail(""exception expected"");
            } catch (IllegalArgumentException ex) {
                assertTrue(""Expected message to start with [plugin already exists: ] but was instead ["" + ex.getMessage() + ""]"",
                        ex.getMessage().startsWith(""plugin already exists: ""));
            }
        }
    }
",non-flaky,5
77456,opensearch-project_OpenSearch,PackagingTestCase.setup,"    @TestGroup(enabled = false, sysProperty = ""tests.awaitsfix"")
    public void setup() throws Exception {
        assumeFalse(failed); // skip rest of tests once one fails

        sh.reset();
        if (distribution().hasJdk == false) {
            Platforms.onLinux(() -> sh.getEnv().put(""JAVA_HOME"", systemJavaHome));
            Platforms.onWindows(() -> sh.getEnv().put(""JAVA_HOME"", systemJavaHome));
        }
    }
",non-flaky,5
77457,opensearch-project_OpenSearch,WildflyIT.testRestClient,"@TestRuleLimitSysouts.Limit(bytes = 14000)
    public void testRestClient() throws URISyntaxException, IOException {
        final String baseUrl = buildBaseUrl();

        try (CloseableHttpClient client = HttpClientBuilder.create().build()) {
            final String endpoint = baseUrl + ""/employees/1"";
            logger.info(""Connecting to uri: "" + baseUrl);

            final HttpPut put = new HttpPut(new URI(endpoint));

            final String body = ""{""
                + ""  \""first_name\"": \""John\"",""
                + ""  \""last_name\"": \""Smith\"",""
                + ""  \""age\"": 25,""
                + ""  \""about\"": \""I love to go rock climbing\"",""
                + ""  \""interests\"": [""
                + ""    \""sports\"",""
                + ""    \""music\""""
                + ""  ]""
                + ""}"";

            put.setEntity(new StringEntity(body, ContentType.APPLICATION_JSON));
            try (CloseableHttpResponse response = client.execute(put)) {
                int status = response.getStatusLine().getStatusCode();
                assertThat(
                    ""expected a 201 response but got: "" + status + "" - body: "" + EntityUtils.toString(response.getEntity()),
                    status,
                    equalTo(201)
                );
            }

            logger.info(""Fetching resource at "" + endpoint);

            final HttpGet get = new HttpGet(new URI(endpoint));
            try (
                CloseableHttpResponse response = client.execute(get);
                XContentParser parser = JsonXContent.jsonXContent.createParser(
                    new NamedXContentRegistry(ClusterModule.getNamedXWriteables()),
                    DeprecationHandler.THROW_UNSUPPORTED_OPERATION,
                    response.getEntity().getContent()
                )
            ) {
                final Map<String, Object> map = parser.map();
                assertThat(map.get(""first_name""), equalTo(""John""));
                assertThat(map.get(""last_name""), equalTo(""Smith""));
                assertThat(map.get(""age""), equalTo(25));
                assertThat(map.get(""about""), equalTo(""I love to go rock climbing""));
                final Object interests = map.get(""interests"");
                assertThat(interests, instanceOf(List.class));
                @SuppressWarnings(""unchecked"")
                final List<String> interestsAsList = (List<String>) interests;
                assertThat(interestsAsList, containsInAnyOrder(""sports"", ""music""));
            }
        }
    }
",non-flaky,5
77458,opensearch-project_OpenSearch,OpenSearchIntegTestCase.clusterService,"    @TestGroup(enabled = false, sysProperty = OpenSearchIntegTestCase.SYSPROP_THIRDPARTY)
    public ClusterService clusterService() {
        return internalCluster().clusterService();
    }
",non-flaky,5
77459,opensearch-project_OpenSearch,AbstractSimpleTransportTestCase.read,"    @TestLogging(
    public void testTracerLog() throws Exception {
        TransportRequestHandler<TransportRequest> handler = (request, channel, task) -> channel.sendResponse(new StringMessageResponse(""""));
        TransportRequestHandler<StringMessageRequest> handlerWithError = (request, channel, task) -> {
            if (request.timeout() > 0) {
                Thread.sleep(request.timeout);
            }
            channel.sendResponse(new RuntimeException(""""));

        };

        TransportResponseHandler<StringMessageResponse> noopResponseHandler = new TransportResponseHandler<StringMessageResponse>() {

            @Override
            public StringMessageResponse read(StreamInput in) throws IOException {
                return new StringMessageResponse(in);
            }
",non-flaky,5
77460,opensearch-project_OpenSearch,SuiteScopeClusterIT.testReproducible,"    @Test
    public void testReproducible() throws IOException {
        if (ITER++ == 0) {
            CLUSTER_SEED = cluster().seed();
            for (int i = 0; i < SEQUENCE.length; i++) {
                SEQUENCE[i] = randomLong();
            }
        } else {
            assertEquals(CLUSTER_SEED, Long.valueOf(cluster().seed()));
            for (int i = 0; i < SEQUENCE.length; i++) {
                assertThat(SEQUENCE[i], equalTo(randomLong()));
            }
        }
    }
",non-flaky,5
77461,opensearch-project_OpenSearch,LoggingListenerTests.annotatedTestMethod,"        @TestLogging(value = ""xyz:TRACE,foo:WARN,foo.bar:ERROR"", reason = ""testing TestLogging method annotations"")
        public void annotatedTestMethod() {

        }
",non-flaky,5
77462,opensearch-project_OpenSearch,LoggingListenerTests.annotatedTestMethod2,"        @TestLogging(value = ""abc:TRACE,xyz:DEBUG"", reason = ""testing TestLogging method annotations"")
        public void annotatedTestMethod2() {

        }
",non-flaky,5
77463,opensearch-project_OpenSearch,LoggingListenerTests.annotatedTestMethod,"        @TestIssueLogging(value = ""xyz:TRACE,foo:WARN,foo.bar:ERROR"", issueUrl = ""https://example.com"")
        public void annotatedTestMethod() {

        }
",non-flaky,5
77464,opensearch-project_OpenSearch,LoggingListenerTests.annotatedTestMethod2,"        @TestIssueLogging(value = ""abc:TRACE,xyz:DEBUG"", issueUrl = ""https://example.com"")
        public void annotatedTestMethod2() {

        }
",non-flaky,5
77465,opensearch-project_OpenSearch,LoggingListenerTests.annotatedTestMethod,"        @TestIssueLogging(value =""foo.bar:ERROR"", issueUrl = ""https://example.com"")
        public void annotatedTestMethod() {

        }
",non-flaky,5
77466,opensearch-project_OpenSearch,LoggingListenerTests.annotatedTestMethod2,"        @TestIssueLogging(value = ""xyz:DEBUG"", issueUrl = ""https://example.com"")
        public void annotatedTestMethod2() {

        }
",non-flaky,5
77467,opensearch-project_OpenSearch,LoggingListenerTests.invalidMethod,"        @TestLogging(value = ""abc:INFO:WARN"", reason = ""testing an invalid TestLogging method annotation"")
        public void invalidMethod() {

        }
",non-flaky,5
77468,opensearch-project_OpenSearch,LoggingListenerTests.invalidMethod,"        @TestIssueLogging(value = ""abc:INFO:WARN"", issueUrl = ""https://example.com"")
        public void invalidMethod() {

        }
",non-flaky,5
77469,opensearch-project_OpenSearch,HandshakingTransportAddressConnectorTests.testLogsFullConnectionFailureAfterSuccessfulHandshake,"    @TestLogging(reason=""ensure logging happens"", value=""org.opensearch.discovery.HandshakingTransportAddressConnector:INFO"")
    public void testLogsFullConnectionFailureAfterSuccessfulHandshake() throws Exception {

        remoteNode = new DiscoveryNode(""remote-node"", buildNewFakeTransportAddress(), Version.CURRENT);
        remoteClusterName = ""local-cluster"";
        discoveryAddress = buildNewFakeTransportAddress();

        fullConnectionFailure = new ConnectTransportException(remoteNode, ""simulated"", new OpenSearchException(""root cause""));

        FailureListener failureListener = new FailureListener();

        MockLogAppender mockAppender = new MockLogAppender();
        mockAppender.start();
        mockAppender.addExpectation(
            new MockLogAppender.SeenEventExpectation(
                ""message"",
                HandshakingTransportAddressConnector.class.getCanonicalName(),
                Level.WARN,
                ""*completed handshake with [*] but followup connection failed*""));
        Logger targetLogger = LogManager.getLogger(HandshakingTransportAddressConnector.class);
        Loggers.addAppender(targetLogger, mockAppender);

        try {
            handshakingTransportAddressConnector.connectToRemoteMasterNode(discoveryAddress, failureListener);
            failureListener.assertFailure();
            mockAppender.assertAllExpectationsMatched();
        } finally {
            Loggers.removeAppender(targetLogger, mockAppender);
            mockAppender.stop();
        }
    }
",non-flaky,5
77470,opensearch-project_OpenSearch,MasterServiceTests.execute,"    @TestLogging(value = ""org.opensearch.cluster.service:TRACE"", reason = ""to ensure that we log cluster state events on TRACE level"")
    public void testClusterStateUpdateLogging() throws Exception {
        MockLogAppender mockAppender = new MockLogAppender();
        mockAppender.start();
        mockAppender.addExpectation(
            new MockLogAppender.SeenEventExpectation(
                ""test1 start"",
                MasterService.class.getCanonicalName(),
                Level.DEBUG,
                ""executing cluster state update for [test1]""));
        mockAppender.addExpectation(
            new MockLogAppender.SeenEventExpectation(
                ""test1 computation"",
                MasterService.class.getCanonicalName(),
                Level.DEBUG,
                ""took [1s] to compute cluster state update for [test1]""));
        mockAppender.addExpectation(
            new MockLogAppender.SeenEventExpectation(
                ""test1 notification"",
                MasterService.class.getCanonicalName(),
                Level.DEBUG,
                ""took [0s] to notify listeners on unchanged cluster state for [test1]""));

        mockAppender.addExpectation(
            new MockLogAppender.SeenEventExpectation(
                ""test2 start"",
                MasterService.class.getCanonicalName(),
                Level.DEBUG,
                ""executing cluster state update for [test2]""));
        mockAppender.addExpectation(
            new MockLogAppender.SeenEventExpectation(
                ""test2 failure"",
                MasterService.class.getCanonicalName(),
                Level.TRACE,
                ""failed to execute cluster state update (on version: [*], uuid: [*]) for [test2]*""));
        mockAppender.addExpectation(
            new MockLogAppender.SeenEventExpectation(
                ""test2 computation"",
                MasterService.class.getCanonicalName(),
                Level.DEBUG,
                ""took [2s] to compute cluster state update for [test2]""));
        mockAppender.addExpectation(
            new MockLogAppender.SeenEventExpectation(
                ""test2 notification"",
                MasterService.class.getCanonicalName(),
                Level.DEBUG,
                ""took [0s] to notify listeners on unchanged cluster state for [test2]""));

        mockAppender.addExpectation(
            new MockLogAppender.SeenEventExpectation(
                ""test3 start"",
                MasterService.class.getCanonicalName(),
                Level.DEBUG,
                ""executing cluster state update for [test3]""));
        mockAppender.addExpectation(
            new MockLogAppender.SeenEventExpectation(
                ""test3 computation"",
                MasterService.class.getCanonicalName(),
                Level.DEBUG,
                ""took [3s] to compute cluster state update for [test3]""));
        mockAppender.addExpectation(
            new MockLogAppender.SeenEventExpectation(
                ""test3 notification"",
                MasterService.class.getCanonicalName(),
                Level.DEBUG,
                ""took [4s] to notify listeners on successful publication of cluster state (version: *, uuid: *) for [test3]""));

        mockAppender.addExpectation(
            new MockLogAppender.SeenEventExpectation(
                ""test4"",
                MasterService.class.getCanonicalName(),
                Level.DEBUG,
                ""executing cluster state update for [test4]""));

        Logger clusterLogger = LogManager.getLogger(MasterService.class);
        Loggers.addAppender(clusterLogger, mockAppender);
        try (MasterService masterService = createMasterService(true)) {
            masterService.submitStateUpdateTask(""test1"", new ClusterStateUpdateTask() {
                @Override
                public ClusterState execute(ClusterState currentState) {
                    relativeTimeInMillis += TimeValue.timeValueSeconds(1).millis();
                    return currentState;
                }
",non-flaky,5
77471,opensearch-project_OpenSearch,MasterServiceTests.execute,"    @TestLogging(value = ""org.opensearch.cluster.service:WARN"", reason = ""to ensure that we log cluster state events on WARN level"")
    public void testLongClusterStateUpdateLogging() throws Exception {
        MockLogAppender mockAppender = new MockLogAppender();
        mockAppender.start();
        mockAppender.addExpectation(
            new MockLogAppender.UnseenEventExpectation(
                ""test1 shouldn't log because it was fast enough"",
                MasterService.class.getCanonicalName(),
                Level.WARN,
                ""*took*test1*""));
        mockAppender.addExpectation(
            new MockLogAppender.SeenEventExpectation(
                ""test2"",
                MasterService.class.getCanonicalName(),
                Level.WARN,
                ""*took [*], which is over [10s], to compute cluster state update for [test2]""));
        mockAppender.addExpectation(
            new MockLogAppender.SeenEventExpectation(
                ""test3"",
                MasterService.class.getCanonicalName(),
                Level.WARN,
                ""*took [*], which is over [10s], to compute cluster state update for [test3]""));
        mockAppender.addExpectation(
            new MockLogAppender.SeenEventExpectation(
                ""test4"",
                MasterService.class.getCanonicalName(),
                Level.WARN,
                ""*took [*], which is over [10s], to compute cluster state update for [test4]""));
        mockAppender.addExpectation(
            new MockLogAppender.UnseenEventExpectation(
                ""test5 should not log despite publishing slowly"",
                MasterService.class.getCanonicalName(),
                Level.WARN,
                ""*took*test5*""));
        mockAppender.addExpectation(
            new MockLogAppender.SeenEventExpectation(
                ""test6 should log due to slow and failing publication"",
                MasterService.class.getCanonicalName(),
                Level.WARN,
                ""took [*] and then failed to publish updated cluster state (version: *, uuid: *) for [test6]:*""));

        Logger clusterLogger = LogManager.getLogger(MasterService.class);
        Loggers.addAppender(clusterLogger, mockAppender);
        try (MasterService masterService = new MasterService(Settings.builder()
            .put(ClusterName.CLUSTER_NAME_SETTING.getKey(), MasterServiceTests.class.getSimpleName())
            .put(Node.NODE_NAME_SETTING.getKey(), ""test_node"")
            .build(), new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS), threadPool)) {

            final DiscoveryNode localNode = new DiscoveryNode(""node1"", buildNewFakeTransportAddress(), emptyMap(),
                emptySet(), Version.CURRENT);
            final ClusterState initialClusterState = ClusterState.builder(new ClusterName(MasterServiceTests.class.getSimpleName()))
                .nodes(DiscoveryNodes.builder().add(localNode).localNodeId(localNode.getId()).masterNodeId(localNode.getId()))
                .blocks(ClusterBlocks.EMPTY_CLUSTER_BLOCK).build();
            final AtomicReference<ClusterState> clusterStateRef = new AtomicReference<>(initialClusterState);
            masterService.setClusterStatePublisher((event, publishListener, ackListener) -> {
                if (event.source().contains(""test5"")) {
                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()
                        + randomLongBetween(1, 1000000);
                }
                if (event.source().contains(""test6"")) {
                    relativeTimeInMillis += MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()
                        + randomLongBetween(1, 1000000);
                    throw new OpenSearchException(""simulated error during slow publication which should trigger logging"");
                }
                clusterStateRef.set(event.state());
                publishListener.onResponse(null);
            });
            masterService.setClusterStateSupplier(clusterStateRef::get);
            masterService.start();

            final CountDownLatch latch = new CountDownLatch(6);
            final CountDownLatch processedFirstTask = new CountDownLatch(1);
            masterService.submitStateUpdateTask(""test1"", new ClusterStateUpdateTask() {
                @Override
                public ClusterState execute(ClusterState currentState) {
                    relativeTimeInMillis += randomLongBetween(0L,
                        MasterService.MASTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis());
                    return currentState;
                }
",non-flaky,5
77472,opensearch-project_OpenSearch,ClusterApplierServiceTests.onSuccess,"    @TestLogging(value = ""org.opensearch.cluster.service:TRACE"", reason = ""to ensure that we log cluster state events on TRACE level"")
    public void testClusterStateUpdateLogging() throws Exception {
        MockLogAppender mockAppender = new MockLogAppender();
        mockAppender.start();
        mockAppender.addExpectation(
                new MockLogAppender.SeenEventExpectation(
                        ""test1"",
                        ClusterApplierService.class.getCanonicalName(),
                        Level.DEBUG,
                        ""*processing [test1]: took [1s] no change in cluster state""));
        mockAppender.addExpectation(
                new MockLogAppender.SeenEventExpectation(
                        ""test2"",
                        ClusterApplierService.class.getCanonicalName(),
                        Level.TRACE,
                        ""*failed to execute cluster state applier in [2s]*""));
        mockAppender.addExpectation(
            new MockLogAppender.SeenEventExpectation(
                ""test3"",
                ClusterApplierService.class.getCanonicalName(),
                Level.DEBUG,
                ""*processing [test3]: took [0s] no change in cluster state*""));

        Logger clusterLogger = LogManager.getLogger(ClusterApplierService.class);
        Loggers.addAppender(clusterLogger, mockAppender);
        try {
            clusterApplierService.currentTimeOverride = threadPool.relativeTimeInMillis();
            clusterApplierService.runOnApplierThread(""test1"",
                currentState -> clusterApplierService.currentTimeOverride += TimeValue.timeValueSeconds(1).millis(),
                new ClusterApplyListener() {
                    @Override
                    public void onSuccess(String source) { }

",non-flaky,5
77473,opensearch-project_OpenSearch,ClusterApplierServiceTests.onSuccess,"    @TestLogging(value = ""org.opensearch.cluster.service:WARN"", reason = ""to ensure that we log cluster state events on WARN level"")
    public void testLongClusterStateUpdateLogging() throws Exception {
        MockLogAppender mockAppender = new MockLogAppender();
        mockAppender.start();
        mockAppender.addExpectation(
                new MockLogAppender.UnseenEventExpectation(
                        ""test1 shouldn't see because setting is too low"",
                        ClusterApplierService.class.getCanonicalName(),
                        Level.WARN,
                        ""*cluster state applier task [test1] took [*] which is above the warn threshold of *""));
        mockAppender.addExpectation(
                new MockLogAppender.SeenEventExpectation(
                        ""test2"",
                        ClusterApplierService.class.getCanonicalName(),
                        Level.WARN,
                        ""*cluster state applier task [test2] took [32s] which is above the warn threshold of [*]: "" +
                            ""[running task [test2]] took [*""));
        mockAppender.addExpectation(
                new MockLogAppender.SeenEventExpectation(
                        ""test4"",
                        ClusterApplierService.class.getCanonicalName(),
                        Level.WARN,
                        ""*cluster state applier task [test3] took [34s] which is above the warn threshold of [*]: "" +
                            ""[running task [test3]] took [*""));

        Logger clusterLogger = LogManager.getLogger(ClusterApplierService.class);
        Loggers.addAppender(clusterLogger, mockAppender);
        try {
            final CountDownLatch latch = new CountDownLatch(4);
            final CountDownLatch processedFirstTask = new CountDownLatch(1);
            clusterApplierService.currentTimeOverride = threadPool.relativeTimeInMillis();
            clusterApplierService.runOnApplierThread(""test1"",
                currentState -> clusterApplierService.currentTimeOverride += TimeValue.timeValueSeconds(1).millis(),
                new ClusterApplyListener() {
                    @Override
                    public void onSuccess(String source) {
                        latch.countDown();
                        processedFirstTask.countDown();
                    }
",non-flaky,5
77474,opensearch-project_OpenSearch,NodeConnectionsServiceTests.testDebugLogging,"    @TestLogging(reason=""testing that DEBUG-level logging is reasonable"", value=""org.opensearch.cluster.NodeConnectionsService:DEBUG"")
    public void testDebugLogging() throws IllegalAccessException {
        final DeterministicTaskQueue deterministicTaskQueue
            = new DeterministicTaskQueue(builder().put(NODE_NAME_SETTING.getKey(), ""node"").build(), random());

        MockTransport transport = new MockTransport(deterministicTaskQueue.getThreadPool());
        TestTransportService transportService = new TestTransportService(transport, deterministicTaskQueue.getThreadPool());
        transportService.start();
        transportService.acceptIncomingRequests();

        final NodeConnectionsService service
            = new NodeConnectionsService(Settings.EMPTY, deterministicTaskQueue.getThreadPool(), transportService);
        service.start();

        final List<DiscoveryNode> allNodes = generateNodes();
        final DiscoveryNodes targetNodes = discoveryNodesFromList(randomSubsetOf(allNodes));
        service.connectToNodes(targetNodes, () -> {});
        deterministicTaskQueue.runAllRunnableTasks();

        // periodic reconnections to unexpectedly-disconnected nodes are logged
        final Set<DiscoveryNode> disconnectedNodes = new HashSet<>(randomSubsetOf(allNodes));
        for (DiscoveryNode disconnectedNode : disconnectedNodes) {
            transportService.disconnectFromNode(disconnectedNode);
        }
        MockLogAppender appender = new MockLogAppender();
        try {
            appender.start();
            Loggers.addAppender(LogManager.getLogger(""org.opensearch.cluster.NodeConnectionsService""), appender);
            for (DiscoveryNode targetNode : targetNodes) {
                if (disconnectedNodes.contains(targetNode)) {
                    appender.addExpectation(new MockLogAppender.SeenEventExpectation(""connecting to "" + targetNode,
                        ""org.opensearch.cluster.NodeConnectionsService"", Level.DEBUG,
                        ""connecting to "" + targetNode));
                    appender.addExpectation(new MockLogAppender.SeenEventExpectation(""connected to "" + targetNode,
                        ""org.opensearch.cluster.NodeConnectionsService"", Level.DEBUG,
                        ""connected to "" + targetNode));
                } else {
                    appender.addExpectation(new MockLogAppender.UnseenEventExpectation(""connecting to "" + targetNode,
                        ""org.opensearch.cluster.NodeConnectionsService"", Level.DEBUG,
                        ""connecting to "" + targetNode));
                    appender.addExpectation(new MockLogAppender.UnseenEventExpectation(""connected to "" + targetNode,
                        ""org.opensearch.cluster.NodeConnectionsService"", Level.DEBUG,
                        ""connected to "" + targetNode));
                }
            }

            runTasksUntil(deterministicTaskQueue, CLUSTER_NODE_RECONNECT_INTERVAL_SETTING.get(Settings.EMPTY).millis());
            appender.assertAllExpectationsMatched();
        } finally {
            Loggers.removeAppender(LogManager.getLogger(""org.opensearch.cluster.NodeConnectionsService""), appender);
            appender.stop();
        }        for (DiscoveryNode disconnectedNode : disconnectedNodes) {
            transportService.disconnectFromNode(disconnectedNode);
        }

        // changes to the expected set of nodes are logged, including reconnections to any unexpectedly-disconnected nodes
        final DiscoveryNodes newTargetNodes = discoveryNodesFromList(randomSubsetOf(allNodes));
        for (DiscoveryNode disconnectedNode : disconnectedNodes) {
            transportService.disconnectFromNode(disconnectedNode);
        }
        appender = new MockLogAppender();
        try {
            appender.start();
            Loggers.addAppender(LogManager.getLogger(""org.opensearch.cluster.NodeConnectionsService""), appender);
            for (DiscoveryNode targetNode : targetNodes) {
                if (disconnectedNodes.contains(targetNode) && newTargetNodes.get(targetNode.getId()) != null) {
                    appender.addExpectation(new MockLogAppender.SeenEventExpectation(""connecting to "" + targetNode,
                        ""org.opensearch.cluster.NodeConnectionsService"", Level.DEBUG,
                        ""connecting to "" + targetNode));
                    appender.addExpectation(new MockLogAppender.SeenEventExpectation(""connected to "" + targetNode,
                        ""org.opensearch.cluster.NodeConnectionsService"", Level.DEBUG,
                        ""connected to "" + targetNode));
                } else {
                    appender.addExpectation(new MockLogAppender.UnseenEventExpectation(""connecting to "" + targetNode,
                        ""org.opensearch.cluster.NodeConnectionsService"", Level.DEBUG,
                        ""connecting to "" + targetNode));
                    appender.addExpectation(new MockLogAppender.UnseenEventExpectation(""connected to "" + targetNode,
                        ""org.opensearch.cluster.NodeConnectionsService"", Level.DEBUG,
                        ""connected to "" + targetNode));
                }
                if (newTargetNodes.get(targetNode.getId()) == null) {
                    appender.addExpectation(new MockLogAppender.SeenEventExpectation(""disconnected from "" + targetNode,
                        ""org.opensearch.cluster.NodeConnectionsService"", Level.DEBUG,
                        ""disconnected from "" + targetNode));
                }
            }
            for (DiscoveryNode targetNode : newTargetNodes) {
                appender.addExpectation(new MockLogAppender.UnseenEventExpectation(""disconnected from "" + targetNode,
                    ""org.opensearch.cluster.NodeConnectionsService"", Level.DEBUG,
                    ""disconnected from "" + targetNode));
                if (targetNodes.get(targetNode.getId()) == null) {
                    appender.addExpectation(new MockLogAppender.SeenEventExpectation(""connecting to "" + targetNode,
                        ""org.opensearch.cluster.NodeConnectionsService"", Level.DEBUG,
                        ""connecting to "" + targetNode));
                    appender.addExpectation(new MockLogAppender.SeenEventExpectation(""connected to "" + targetNode,
                        ""org.opensearch.cluster.NodeConnectionsService"", Level.DEBUG,
                        ""connected to "" + targetNode));
                }
            }

            service.disconnectFromNodesExcept(newTargetNodes);
            service.connectToNodes(newTargetNodes, () -> {});
            deterministicTaskQueue.runAllRunnableTasks();
            appender.assertAllExpectationsMatched();
        } finally {
            Loggers.removeAppender(LogManager.getLogger(""org.opensearch.cluster.NodeConnectionsService""), appender);
            appender.stop();
        }
    }
",non-flaky,5
77475,opensearch-project_OpenSearch,DiskThresholdMonitorTests.getAsLong,"    @TestLogging(value=""org.opensearch.cluster.routing.allocation.DiskThresholdMonitor:INFO"", reason=""testing INFO/WARN logging"")
    public void testDiskMonitorLogging() throws IllegalAccessException {
        final ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY))
            .nodes(DiscoveryNodes.builder().add(newNode(""node1""))).build();
        final AtomicReference<ClusterState> clusterStateRef = new AtomicReference<>(clusterState);
        final AtomicBoolean advanceTime = new AtomicBoolean(randomBoolean());

        final LongSupplier timeSupplier = new LongSupplier() {
            long time;

            @Override
            public long getAsLong() {
                if (advanceTime.get()) {
                    time += DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_REROUTE_INTERVAL_SETTING.get(Settings.EMPTY).getMillis() + 1;
                }
                logger.info(""time: [{}]"", time);
                return time;
            }
",non-flaky,5
77476,opensearch-project_OpenSearch,IncrementalClusterStateWriterTests.testSlowLogging,"    @TestLogging(value = ""org.opensearch.gateway:WARN"", reason = ""to ensure that we log gateway events on WARN level"")
    public void testSlowLogging() throws WriteStateException, IllegalAccessException {
        final long slowWriteLoggingThresholdMillis;
        final Settings settings;
        if (randomBoolean()) {
            slowWriteLoggingThresholdMillis = PersistedClusterStateService.SLOW_WRITE_LOGGING_THRESHOLD.get(Settings.EMPTY).millis();
            settings = Settings.EMPTY;
        } else {
            slowWriteLoggingThresholdMillis = randomLongBetween(2, 100000);
            settings = Settings.builder()
                .put(PersistedClusterStateService.SLOW_WRITE_LOGGING_THRESHOLD.getKey(), slowWriteLoggingThresholdMillis + ""ms"")
                .build();
        }

        final DiscoveryNode localNode = newNode(""node"");
        final ClusterState clusterState = ClusterState.builder(ClusterName.DEFAULT)
            .nodes(DiscoveryNodes.builder().add(localNode).localNodeId(localNode.getId())).build();

        final long startTimeMillis = randomLongBetween(0L, Long.MAX_VALUE - slowWriteLoggingThresholdMillis * 10);
        final AtomicLong currentTime = new AtomicLong(startTimeMillis);
        final AtomicLong writeDurationMillis = new AtomicLong(slowWriteLoggingThresholdMillis);

        final ClusterSettings clusterSettings = new ClusterSettings(settings, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);
        final IncrementalClusterStateWriter incrementalClusterStateWriter
            = new IncrementalClusterStateWriter(settings, clusterSettings, mock(MetaStateService.class),
            new Manifest(randomNonNegativeLong(), randomNonNegativeLong(), randomNonNegativeLong(), Collections.emptyMap()),
            clusterState, () -> currentTime.getAndAdd(writeDurationMillis.get()));

        assertExpectedLogs(clusterState, incrementalClusterStateWriter, new MockLogAppender.SeenEventExpectation(
            ""should see warning at threshold"",
            IncrementalClusterStateWriter.class.getCanonicalName(),
            Level.WARN,
            ""writing cluster state took [*] which is above the warn threshold of [*]; "" +
                ""wrote metadata for [0] indices and skipped [0] unchanged indices""));

        writeDurationMillis.set(randomLongBetween(slowWriteLoggingThresholdMillis, slowWriteLoggingThresholdMillis * 2));
        assertExpectedLogs(clusterState, incrementalClusterStateWriter, new MockLogAppender.SeenEventExpectation(
            ""should see warning above threshold"",
            IncrementalClusterStateWriter.class.getCanonicalName(),
            Level.WARN,
            ""writing cluster state took [*] which is above the warn threshold of [*]; "" +
                ""wrote metadata for [0] indices and skipped [0] unchanged indices""));

        writeDurationMillis.set(randomLongBetween(1, slowWriteLoggingThresholdMillis - 1));
        assertExpectedLogs(clusterState, incrementalClusterStateWriter, new MockLogAppender.UnseenEventExpectation(
            ""should not see warning below threshold"",
            IncrementalClusterStateWriter.class.getCanonicalName(),
            Level.WARN,
            ""*""));

        clusterSettings.applySettings(Settings.builder()
            .put(PersistedClusterStateService.SLOW_WRITE_LOGGING_THRESHOLD.getKey(), writeDurationMillis.get() + ""ms"")
            .build());
        assertExpectedLogs(clusterState, incrementalClusterStateWriter, new MockLogAppender.SeenEventExpectation(
            ""should see warning at reduced threshold"",
            IncrementalClusterStateWriter.class.getCanonicalName(),
            Level.WARN,
            ""writing cluster state took [*] which is above the warn threshold of [*]; "" +
                ""wrote metadata for [0] indices and skipped [0] unchanged indices""));

        assertThat(currentTime.get(), lessThan(startTimeMillis + 10 * slowWriteLoggingThresholdMillis)); // ensure no overflow
    }
",non-flaky,5
77477,opensearch-project_OpenSearch,PersistedClusterStateServiceTests.testSlowLogging,"    @TestLogging(value = ""org.opensearch.gateway:WARN"", reason = ""to ensure that we log gateway events on WARN level"")
    public void testSlowLogging() throws IOException, IllegalAccessException {
        final long slowWriteLoggingThresholdMillis;
        final Settings settings;
        if (randomBoolean()) {
            slowWriteLoggingThresholdMillis = PersistedClusterStateService.SLOW_WRITE_LOGGING_THRESHOLD.get(Settings.EMPTY).millis();
            settings = Settings.EMPTY;
        } else {
            slowWriteLoggingThresholdMillis = randomLongBetween(2, 100000);
            settings = Settings.builder()
                .put(PersistedClusterStateService.SLOW_WRITE_LOGGING_THRESHOLD.getKey(), slowWriteLoggingThresholdMillis + ""ms"")
                .build();
        }

        final DiscoveryNode localNode = new DiscoveryNode(""node"", buildNewFakeTransportAddress(), Version.CURRENT);
        final ClusterState clusterState = ClusterState.builder(ClusterName.DEFAULT)
            .nodes(DiscoveryNodes.builder().add(localNode).localNodeId(localNode.getId())).build();

        final long startTimeMillis = randomLongBetween(0L, Long.MAX_VALUE - slowWriteLoggingThresholdMillis * 10);
        final AtomicLong currentTime = new AtomicLong(startTimeMillis);
        final AtomicLong writeDurationMillis = new AtomicLong(slowWriteLoggingThresholdMillis);

        final ClusterSettings clusterSettings = new ClusterSettings(settings, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);
        try (NodeEnvironment nodeEnvironment = newNodeEnvironment(createDataPaths())) {
            PersistedClusterStateService persistedClusterStateService = new PersistedClusterStateService(nodeEnvironment,
                    xContentRegistry(), getBigArrays(), clusterSettings, () -> currentTime.getAndAdd(writeDurationMillis.get()));

            try (Writer writer = persistedClusterStateService.createWriter()) {
                assertExpectedLogs(1L, null, clusterState, writer, new MockLogAppender.SeenEventExpectation(
                    ""should see warning at threshold"",
                    PersistedClusterStateService.class.getCanonicalName(),
                    Level.WARN,
                    ""writing cluster state took [*] which is above the warn threshold of [*]; "" +
                        ""wrote full state with [0] indices""));

                writeDurationMillis.set(randomLongBetween(slowWriteLoggingThresholdMillis, slowWriteLoggingThresholdMillis * 2));
                assertExpectedLogs(1L, null, clusterState, writer, new MockLogAppender.SeenEventExpectation(
                    ""should see warning above threshold"",
                    PersistedClusterStateService.class.getCanonicalName(),
                    Level.WARN,
                    ""writing cluster state took [*] which is above the warn threshold of [*]; "" +
                        ""wrote full state with [0] indices""));

                writeDurationMillis.set(randomLongBetween(1, slowWriteLoggingThresholdMillis - 1));
                assertExpectedLogs(1L, null, clusterState, writer, new MockLogAppender.UnseenEventExpectation(
                    ""should not see warning below threshold"",
                    PersistedClusterStateService.class.getCanonicalName(),
                    Level.WARN,
                    ""*""));

                clusterSettings.applySettings(Settings.builder()
                    .put(PersistedClusterStateService.SLOW_WRITE_LOGGING_THRESHOLD.getKey(), writeDurationMillis.get() + ""ms"")
                    .build());
                assertExpectedLogs(1L, null, clusterState, writer, new MockLogAppender.SeenEventExpectation(
                    ""should see warning at reduced threshold"",
                    PersistedClusterStateService.class.getCanonicalName(),
                    Level.WARN,
                    ""writing cluster state took [*] which is above the warn threshold of [*]; "" +
                        ""wrote full state with [0] indices""));

                final ClusterState newClusterState = ClusterState.builder(clusterState)
                    .metadata(Metadata.builder(clusterState.metadata())
                        .version(clusterState.version())
                        .put(IndexMetadata.builder(""test"")
                            .settings(Settings.builder()
                                .put(IndexMetadata.INDEX_NUMBER_OF_SHARDS_SETTING.getKey(), 1)
                                .put(IndexMetadata.INDEX_NUMBER_OF_REPLICAS_SETTING.getKey(), 0)
                                .put(IndexMetadata.SETTING_INDEX_VERSION_CREATED.getKey(), Version.CURRENT)
                                .put(IndexMetadata.SETTING_INDEX_UUID, ""test-uuid""))))
                    .incrementVersion().build();

                assertExpectedLogs(1L, clusterState, newClusterState, writer, new MockLogAppender.SeenEventExpectation(
                    ""should see warning at threshold"",
                    PersistedClusterStateService.class.getCanonicalName(),
                    Level.WARN,
                    ""writing cluster state took [*] which is above the warn threshold of [*]; "" +
                        ""wrote global metadata [false] and metadata for [1] indices and skipped [0] unchanged indices""));

                writeDurationMillis.set(randomLongBetween(0, writeDurationMillis.get() - 1));
                assertExpectedLogs(1L, clusterState, newClusterState, writer, new MockLogAppender.UnseenEventExpectation(
                    ""should not see warning below threshold"",
                    PersistedClusterStateService.class.getCanonicalName(),
                    Level.WARN,
                    ""*""));

                assertThat(currentTime.get(), lessThan(startTimeMillis + 14 * slowWriteLoggingThresholdMillis)); // ensure no overflow
            }
        }
    }
",non-flaky,5
77478,opensearch-project_OpenSearch,SettingTests.innerMatch,"    @TestLogging(value=""org.opensearch.common.settings.IndexScopedSettings:INFO"",
    public void testLogSettingUpdate() throws Exception {
        final IndexMetadata metadata = newIndexMeta(""index1"",
            Settings.builder().put(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey(), ""20s"").build());
        final IndexSettings settings = new IndexSettings(metadata, Settings.EMPTY);

        final MockLogAppender mockLogAppender = new MockLogAppender();
        mockLogAppender.addExpectation(new MockLogAppender.SeenEventExpectation(
            ""message"",
            ""org.opensearch.common.settings.IndexScopedSettings"",
            Level.INFO,
            ""updating [index.refresh_interval] from [20s] to [10s]"") {
            @Override
            public boolean innerMatch(LogEvent event) {
                return event.getMarker().getName().equals("" [index1]"");
            }
",non-flaky,5
77479,opensearch-project_OpenSearch,AbstractHttpServerTransportTests.dispatchRequest,"    @TestLogging(
    public void testTracerLog() throws Exception {
        final String includeSettings;
        final String excludeSettings;
        if (randomBoolean()) {
            includeSettings = randomBoolean() ? ""*"" : """";
        } else {
            includeSettings = ""/internal/test"";
        }
        excludeSettings = ""/internal/testNotSeen"";

        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);
        try (AbstractHttpServerTransport transport =
                 new AbstractHttpServerTransport(Settings.EMPTY, networkService, bigArrays, threadPool, xContentRegistry(),
                     new HttpServerTransport.Dispatcher() {
                         @Override
                         public void dispatchRequest(RestRequest request, RestChannel channel, ThreadContext threadContext) {
                             channel.sendResponse(emptyResponse(RestStatus.OK));
                         }
",non-flaky,5
77480,opensearch-project_OpenSearch,TcpTransportTests.testExceptionHandling,"    @TestLogging(reason = ""testing logging"", value = ""org.opensearch.transport.TcpTransport:DEBUG"")
    public void testExceptionHandling() throws IllegalAccessException {
        testExceptionHandling(false, new OpenSearchException(""simulated""), true,
            new MockLogAppender.UnseenEventExpectation(""message"", ""org.opensearch.transport.TcpTransport"", Level.ERROR, ""*""),
            new MockLogAppender.UnseenEventExpectation(""message"", ""org.opensearch.transport.TcpTransport"", Level.WARN, ""*""),
            new MockLogAppender.UnseenEventExpectation(""message"", ""org.opensearch.transport.TcpTransport"", Level.INFO, ""*""),
            new MockLogAppender.UnseenEventExpectation(""message"", ""org.opensearch.transport.TcpTransport"", Level.DEBUG, ""*""));
        testExceptionHandling(new OpenSearchException(""simulated""),
            new MockLogAppender.SeenEventExpectation(""message"", ""org.opensearch.transport.TcpTransport"",
                Level.WARN, ""exception caught on transport layer [*], closing connection""));
        testExceptionHandling(new ClosedChannelException(),
            new MockLogAppender.SeenEventExpectation(""message"", ""org.opensearch.transport.TcpTransport"",
                Level.DEBUG, ""close connection exception caught on transport layer [*], disconnecting from relevant node""));
        testExceptionHandling(new OpenSearchException(""Connection reset""),
            new MockLogAppender.SeenEventExpectation(""message"", ""org.opensearch.transport.TcpTransport"",
                Level.DEBUG, ""close connection exception caught on transport layer [*], disconnecting from relevant node""));
        testExceptionHandling(new BindException(),
            new MockLogAppender.SeenEventExpectation(""message"", ""org.opensearch.transport.TcpTransport"",
                Level.DEBUG, ""bind exception caught on transport layer [*]""));
        testExceptionHandling(new CancelledKeyException(),
            new MockLogAppender.SeenEventExpectation(""message"", ""org.opensearch.transport.TcpTransport"",
                Level.DEBUG, ""cancelled key exception caught on transport layer [*], disconnecting from relevant node""));
        testExceptionHandling(true, new TcpTransport.HttpRequestOnTransportException(""test""), false,
            new MockLogAppender.UnseenEventExpectation(""message"", ""org.opensearch.transport.TcpTransport"", Level.ERROR, ""*""),
            new MockLogAppender.UnseenEventExpectation(""message"", ""org.opensearch.transport.TcpTransport"", Level.WARN, ""*""),
            new MockLogAppender.UnseenEventExpectation(""message"", ""org.opensearch.transport.TcpTransport"", Level.INFO, ""*""),
            new MockLogAppender.UnseenEventExpectation(""message"", ""org.opensearch.transport.TcpTransport"", Level.DEBUG, ""*""));
        testExceptionHandling(new StreamCorruptedException(""simulated""),
            new MockLogAppender.SeenEventExpectation(""message"", ""org.opensearch.transport.TcpTransport"",
                Level.WARN, ""simulated, [*], closing connection""));
    }
",non-flaky,5
77481,opensearch-project_OpenSearch,TransportLoggerTests.setUp,"@TestLogging(value = ""org.opensearch.transport.TransportLogger:trace"", reason = ""to ensure we log network events on TRACE level"")
    public void setUp() throws Exception {
        super.setUp();
        appender = new MockLogAppender();
        Loggers.addAppender(LogManager.getLogger(TransportLogger.class), appender);
        appender.start();
    }
",non-flaky,5
77482,opensearch-project_OpenSearch,RemoteClusterClientTests.testEnsureWeReconnect,"    @TestLogging(
    public void testEnsureWeReconnect() throws Exception {
        Settings remoteSettings = Settings.builder().put(ClusterName.CLUSTER_NAME_SETTING.getKey(), ""foo_bar_cluster"").build();
        try (MockTransportService remoteTransport = startTransport(""remote_node"", Collections.emptyList(), Version.CURRENT, threadPool,
            remoteSettings)) {
            DiscoveryNode remoteNode = remoteTransport.getLocalDiscoNode();
            Settings localSettings = Settings.builder()
                .put(onlyRole(DiscoveryNodeRole.REMOTE_CLUSTER_CLIENT_ROLE))
                .put(""cluster.remote.test.seeds"",
                    remoteNode.getAddress().getAddress() + "":"" + remoteNode.getAddress().getPort()).build();
            try (MockTransportService service = MockTransportService.createNewService(localSettings, Version.CURRENT, threadPool, null)) {
                service.start();
                // this test is not perfect since we might reconnect concurrently but it will fail most of the time if we don't have
                // the right calls in place in the RemoteAwareClient
                service.acceptIncomingRequests();
                RemoteClusterService remoteClusterService = service.getRemoteClusterService();
                assertBusy(() -> assertTrue(remoteClusterService.isRemoteNodeConnected(""test"", remoteNode)));
                for (int i = 0; i < 10; i++) {
                    RemoteClusterConnection remoteClusterConnection = remoteClusterService.getRemoteClusterConnection(""test"");
                    assertBusy(remoteClusterConnection::assertNoRunningConnections);
                    ConnectionManager connectionManager = remoteClusterConnection.getConnectionManager();
                    Transport.Connection connection = connectionManager.getConnection(remoteNode);
                    PlainActionFuture<Void> closeFuture = PlainActionFuture.newFuture();
                    connection.addCloseListener(closeFuture);
                    connectionManager.disconnectFromNode(remoteNode);
                    closeFuture.get();

                    Client client = remoteClusterService.getRemoteClusterClient(threadPool, ""test"");
                    ClusterStateResponse clusterStateResponse = client.admin().cluster().prepareState().execute().get();
                    assertNotNull(clusterStateResponse);
                    assertEquals(""foo_bar_cluster"", clusterStateResponse.getState().getClusterName().value());
                    assertTrue(remoteClusterConnection.isNodeConnected(remoteNode));
                }
            }
        }
    }
",non-flaky,5
77483,opensearch-project_OpenSearch,FsHealthServiceTests.testLoggingOnHungIO,"    @TestLogging(value = ""org.opensearch.monitor.fs:WARN"", reason = ""to ensure that we log on hung IO at WARN level"")
    public void testLoggingOnHungIO() throws Exception {
        long slowLogThreshold = randomLongBetween(100, 200);
        final Settings settings = Settings.builder().put(FsHealthService.SLOW_PATH_LOGGING_THRESHOLD_SETTING.getKey(),
            slowLogThreshold + ""ms"").build();
        FileSystem fileSystem = PathUtils.getDefaultFileSystem();
        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);
        FileSystemFsyncHungProvider disruptFileSystemProvider = new FileSystemFsyncHungProvider(fileSystem,
            randomLongBetween(slowLogThreshold + 1 , 400), testThreadPool);
        fileSystem = disruptFileSystemProvider.getFileSystem(null);
        PathUtilsForTesting.installMock(fileSystem);
        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);

        MockLogAppender mockAppender = new MockLogAppender();
        mockAppender.start();

        Logger logger = LogManager.getLogger(FsHealthService.class);
        Loggers.addAppender(logger, mockAppender);
        try (NodeEnvironment env = newNodeEnvironment()) {
            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);
            int counter = 0;
            for(Path path : env.nodeDataPaths()){
                mockAppender.addExpectation(
                    new MockLogAppender.SeenEventExpectation(
                        ""test"" + ++counter,
                        FsHealthService.class.getCanonicalName(),
                        Level.WARN,
                        ""health check of ["" + path + ""] took [*ms] which is above the warn threshold*""));
            }

            //disrupt file system
            disruptFileSystemProvider.injectIODelay.set(true);
            fsHealthService.new FsHealthMonitor().run();
            assertEquals(env.nodeDataPaths().length, disruptFileSystemProvider.getInjectedPathCount());
            assertBusy(mockAppender::assertAllExpectationsMatched);
        } finally {
            Loggers.removeAppender(logger, mockAppender);
            mockAppender.stop();
            PathUtilsForTesting.teardown();
            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);
        }
    }
",non-flaky,5
86038,graylog2_graylog2-server,NotificationResourceHandlerTest.testExecution,"    @Test
    public void testExecution() throws EventNotificationException {
        notificationResourceHandler.test(getHttpNotification(), ""testUser"");

        ArgumentCaptor<EventNotificationContext> captor = ArgumentCaptor.forClass(EventNotificationContext.class);
        verify(eventNotification, times(1)).execute(captor.capture());

        assertThat(captor.getValue()).satisfies(ctx -> {
            assertThat(ctx.event().message()).isEqualTo(""Notification test message triggered from user <testUser>"");
            assertThat(ctx.notificationId()).isEqualTo(NotificationTestData.TEST_NOTIFICATION_ID);
            assertThat(ctx.notificationConfig().type()).isEqualTo(HTTPEventNotificationConfig.TYPE_NAME);
            assertThat(ctx.eventDefinition().get().title()).isEqualTo(""Event Definition Test Title"");
        });
    }
",non-flaky,5
86039,graylog2_graylog2-server,NotificationDtoTest.testValidateWithEmptyTitle,"    @Test
    public void testValidateWithEmptyTitle() {
        final NotificationDto invalidNotification = getHttpNotification().toBuilder().title("""").build();
        final ValidationResult validationResult = invalidNotification.validate();
        assertThat(validationResult.failed()).isTrue();
        assertThat(validationResult.getErrors()).containsOnlyKeys(""title"");
    }
",non-flaky,5
86040,graylog2_graylog2-server,NotificationDtoTest.testValidateWithEmptyConfig,"    @Test
    public void testValidateWithEmptyConfig() {
        final NotificationDto invalidNotification = NotificationDto.builder()
                .title(""Foo"")
                .description("""")
                .config(new EventNotificationConfig.FallbackNotificationConfig())
                .build();
        final ValidationResult validationResult = invalidNotification.validate();
        assertThat(validationResult.failed()).isTrue();
        assertThat(validationResult.getErrors()).containsOnlyKeys(""config"");
    }
",non-flaky,5
86041,graylog2_graylog2-server,NotificationDtoTest.testValidateHttpWithEmptyConfigParameters,"    @Test
    public void testValidateHttpWithEmptyConfigParameters() {
        final HTTPEventNotificationConfig emptyConfig = HTTPEventNotificationConfig.Builder.create()
                .url("""")
                .build();
        final NotificationDto emptyNotification = getHttpNotification().toBuilder().config(emptyConfig).build();
        final ValidationResult validationResult = emptyNotification.validate();
        assertThat(validationResult.failed()).isTrue();
        assertThat(validationResult.getErrors()).containsOnlyKeys(""url"");
    }
",non-flaky,5
86042,graylog2_graylog2-server,NotificationDtoTest.testValidateEmailWithEmptyConfigParameters,"    @Test
    public void testValidateEmailWithEmptyConfigParameters() {
        final EmailEventNotificationConfig emptyConfig = EmailEventNotificationConfig.Builder.create()
                .sender("""")
                .subject("""")
                .bodyTemplate("""")
                .build();
        final NotificationDto emptyNotification = getEmailNotification().toBuilder().config(emptyConfig).build();
        final ValidationResult validationResult = emptyNotification.validate();
        assertThat(validationResult.failed()).isTrue();
        assertThat(validationResult.getErrors().size()).isEqualTo(4);
        assertThat(validationResult.getErrors()).containsOnlyKeys(""subject"", ""sender"", ""body_template"", ""recipients"");
    }
",non-flaky,5
86043,graylog2_graylog2-server,NotificationDtoTest.testValidateLegacyWithEmptyConfigParameters,"    @Test
    public void testValidateLegacyWithEmptyConfigParameters() {
        final LegacyAlarmCallbackEventNotificationConfig emptyConfig = LegacyAlarmCallbackEventNotificationConfig.Builder.create()
                .callbackType("""")
                .configuration(new HashMap<>())
                .build();
        final NotificationDto emptyNotification = getLegacyNotification().toBuilder().config(emptyConfig).build();
        final ValidationResult validationResult = emptyNotification.validate();
        assertThat(validationResult.failed()).isTrue();
        assertThat(validationResult.getErrors()).containsOnlyKeys(""callback_type"");
    }
",non-flaky,5
86044,graylog2_graylog2-server,NotificationDtoTest.testValidHttpNotification,"    @Test
    public void testValidHttpNotification() {
        final NotificationDto validNotification = getHttpNotification();

        final ValidationResult validationResult = validNotification.validate();
        assertThat(validationResult.failed()).isFalse();
        assertThat(validationResult.getErrors().size()).isEqualTo(0);
    }
",non-flaky,5
86045,graylog2_graylog2-server,NotificationDtoTest.testValidEmailNotification,"    @Test
    public void testValidEmailNotification() {
        final NotificationDto validNotification = getEmailNotification();

        final ValidationResult validationResult = validNotification.validate();
        assertThat(validationResult.failed()).isFalse();
        assertThat(validationResult.getErrors().size()).isEqualTo(0);
    }
",non-flaky,5
86046,graylog2_graylog2-server,NotificationDtoTest.testValidLegacyNotification,"    @Test
    public void testValidLegacyNotification() {
        final NotificationDto validNotification = getLegacyNotification();

        final ValidationResult validationResult = validNotification.validate();
        assertThat(validationResult.failed()).isFalse();
        assertThat(validationResult.getErrors().size()).isEqualTo(0);
    }
",non-flaky,5
86047,graylog2_graylog2-server,EventProcessorDependencyCheckTest.canProcessTimerange,"    @Test
    public void canProcessTimerange() {
        final DateTime now = DateTime.now(DateTimeZone.UTC);

        final EventProcessorStateDto stateDto1 = EventProcessorStateDto.builder()
                .eventDefinitionId(""a"")
                .minProcessedTimestamp(now.minusDays(1))
                .maxProcessedTimestamp(now)
                .build();
        final EventProcessorStateDto stateDto2 = EventProcessorStateDto.builder()
                .eventDefinitionId(""b"")
                .minProcessedTimestamp(now.minusDays(1))
                .maxProcessedTimestamp(now.minusHours(1))
                .build();
        final EventProcessorStateDto stateDto3 = EventProcessorStateDto.builder()
                .eventDefinitionId(""c"")
                .minProcessedTimestamp(now.minusDays(1))
                .maxProcessedTimestamp(now.minusHours(2))
                .build();

        // No state objects yet
        assertThat(dependencyCheck.canProcessTimerange(now, ImmutableSet.of(""a""))).isFalse();

        stateService.setState(stateDto1);
        stateService.setState(stateDto2);
        stateService.setState(stateDto3);

        // No state object has processedTimerageEnd >= now + 1h
        assertThat(dependencyCheck.canProcessTimerange(now.plusHours(1), ImmutableSet.of(""a""))).isFalse();

        // Only processor ""a"" has been processed at ""now""
        assertThat(dependencyCheck.canProcessTimerange(now, ImmutableSet.of(""a""))).isTrue();
        assertThat(dependencyCheck.canProcessTimerange(now, ImmutableSet.of(""a"", ""b""))).isFalse();
        assertThat(dependencyCheck.canProcessTimerange(now, ImmutableSet.of(""a"", ""c""))).isFalse();
        assertThat(dependencyCheck.canProcessTimerange(now, ImmutableSet.of(""a"", ""b"", ""c""))).isFalse();
        assertThat(dependencyCheck.canProcessTimerange(now, ImmutableSet.of(""b""))).isFalse();
        assertThat(dependencyCheck.canProcessTimerange(now, ImmutableSet.of(""c""))).isFalse();

        // Only processors ""a"" and ""b"" have been processed at now - 1h
        assertThat(dependencyCheck.canProcessTimerange(now.minusHours(1), ImmutableSet.of(""a"", ""b""))).isTrue();
        assertThat(dependencyCheck.canProcessTimerange(now.minusHours(1), ImmutableSet.of(""a"", ""c""))).isFalse();

        // Processors ""a"", ""b"" and ""c"" have been processed at now - 2h
        assertThat(dependencyCheck.canProcessTimerange(now.minusHours(2), ImmutableSet.of(""a"", ""b"", ""c""))).isTrue();
        assertThat(dependencyCheck.canProcessTimerange(now.minusHours(2), ImmutableSet.of(""a"", ""b""))).isTrue();
        assertThat(dependencyCheck.canProcessTimerange(now.minusHours(2), ImmutableSet.of(""a"", ""c""))).isTrue();
        assertThat(dependencyCheck.canProcessTimerange(now.minusHours(2), ImmutableSet.of(""a""))).isTrue();
        assertThat(dependencyCheck.canProcessTimerange(now.minusHours(2), ImmutableSet.of(""b""))).isTrue();
        assertThat(dependencyCheck.canProcessTimerange(now.minusHours(2), ImmutableSet.of(""c""))).isTrue();
    }
",non-flaky,5
86048,graylog2_graylog2-server,EventProcessorDependencyCheckTest.hasMessagesIndexedUpTo,"    @Test
    public void hasMessagesIndexedUpTo() {
        final DateTime timestamp = DateTime.now(DateTimeZone.UTC);

        when(dbProcessingStatusService.earliestPostIndexingTimestamp()).thenReturn(Optional.of(timestamp));

        assertThat(dependencyCheck.hasMessagesIndexedUpTo(timestamp)).isTrue();
        assertThat(dependencyCheck.hasMessagesIndexedUpTo(timestamp.minusHours(1))).isTrue();
        assertThat(dependencyCheck.hasMessagesIndexedUpTo(timestamp.plusHours(1))).isFalse();

        // The method should always return false if there is no value for the max indexed timestamp available
        when(dbProcessingStatusService.earliestPostIndexingTimestamp()).thenReturn(Optional.empty());

        assertThat(dependencyCheck.hasMessagesIndexedUpTo(timestamp)).isFalse();
        assertThat(dependencyCheck.hasMessagesIndexedUpTo(timestamp.minusHours(1))).isFalse();
        assertThat(dependencyCheck.hasMessagesIndexedUpTo(timestamp.plusHours(1))).isFalse();
    }
",non-flaky,5
86049,graylog2_graylog2-server,NotificationGracePeriodServiceTest.falseWithDisabledGracePeriod,"    @Test
    public void falseWithDisabledGracePeriod() {
        final NotificationGracePeriodService notificationGracePeriodService = new NotificationGracePeriodService();

        when(settings.gracePeriodMs()).thenReturn(0L);
        when(definition.notificationSettings()).thenReturn(settings);
        when(definition.id()).thenReturn(""1234"");

        final Event event = new TestEvent();
        event.setKeyTuple(ImmutableList.of(""testkey""));
        assertThat(notificationGracePeriodService.inGracePeriod(definition, ""5678"", event)).isFalse();
        assertThat(notificationGracePeriodService.inGracePeriod(definition, ""5678"", event)).isFalse();
    }
",non-flaky,5
86050,graylog2_graylog2-server,NotificationGracePeriodServiceTest.withinGracePeriod,"    @Test
    public void withinGracePeriod() {
        final NotificationGracePeriodService notificationGracePeriodService = new NotificationGracePeriodService();

        when(settings.gracePeriodMs()).thenReturn(10L);
        when(definition.notificationSettings()).thenReturn(settings);
        when(definition.id()).thenReturn(""1234"");

        final Event event = new TestEvent();
        event.setKeyTuple(ImmutableList.of(""testkey""));
        final Event event2 = new TestEvent();
        event2.setKeyTuple(ImmutableList.of(""testkey""));
        event2.setEventTimestamp(event.getEventTimestamp().plus(5L));
        assertThat(notificationGracePeriodService.inGracePeriod(definition, ""5678"", event)).isFalse();
        assertThat(notificationGracePeriodService.inGracePeriod(definition, ""5678"", event2)).isTrue();
    }
",non-flaky,5
86051,graylog2_graylog2-server,NotificationGracePeriodServiceTest.outsideGracePeriod,"    @Test
    public void outsideGracePeriod() {
        final NotificationGracePeriodService notificationGracePeriodService = new NotificationGracePeriodService();

        when(settings.gracePeriodMs()).thenReturn(10L);
        when(definition.notificationSettings()).thenReturn(settings);
        when(definition.id()).thenReturn(""1234"");

        final Event event = new TestEvent();
        event.setKeyTuple(ImmutableList.of(""testkey""));
        final Event event2 = new TestEvent();
        event2.setKeyTuple(ImmutableList.of(""testkey""));
        event2.setEventTimestamp(event.getEventTimestamp().plus(11L));
        assertThat(notificationGracePeriodService.inGracePeriod(definition, ""5678"", event)).isFalse();
        assertThat(notificationGracePeriodService.inGracePeriod(definition, ""5678"", event2)).isFalse();
    }
",non-flaky,5
86052,graylog2_graylog2-server,NotificationGracePeriodServiceTest.insideThenInsideGracePeriod,"    @Test
    public void insideThenInsideGracePeriod() {
        final NotificationGracePeriodService notificationGracePeriodService = new NotificationGracePeriodService();

        when(settings.gracePeriodMs()).thenReturn(10L);
        when(definition.notificationSettings()).thenReturn(settings);
        when(definition.id()).thenReturn(""1234"");

        final Event event = new TestEvent(DateTime.now(UTC), ""testkey"");
        final Event event2 = new TestEvent(event.getEventTimestamp().plus(5L), ""testkey"");
        final Event event3 = new TestEvent(event2.getEventTimestamp().plus(4L), ""testkey"");

        assertThat(notificationGracePeriodService.inGracePeriod(definition, ""5678"", event)).isFalse();
        assertThat(notificationGracePeriodService.inGracePeriod(definition, ""5678"", event2)).isTrue();
        assertThat(notificationGracePeriodService.inGracePeriod(definition, ""5678"", event3)).isTrue();
    }
",non-flaky,5
86053,graylog2_graylog2-server,NotificationGracePeriodServiceTest.insideOutsideInsideGracePeriod,"    @Test
    public void insideOutsideInsideGracePeriod() {
        final NotificationGracePeriodService notificationGracePeriodService = new NotificationGracePeriodService();

        when(settings.gracePeriodMs()).thenReturn(10L);
        when(definition.notificationSettings()).thenReturn(settings);
        when(definition.id()).thenReturn(""1234"");

        final Event event = new TestEvent(DateTime.now(UTC), ""testkey"");
        final Event event2 = new TestEvent(event.getEventTimestamp().plus(5L), ""testkey"");
        final Event event3 = new TestEvent(event2.getEventTimestamp().plus(6L), ""testkey"");
        final Event event4 = new TestEvent(event3.getEventTimestamp().plus(6L), ""testkey"");

        assertThat(notificationGracePeriodService.inGracePeriod(definition, ""5678"", event)).isFalse();
        assertThat(notificationGracePeriodService.inGracePeriod(definition, ""5678"", event2)).isTrue();
        assertThat(notificationGracePeriodService.inGracePeriod(definition, ""5678"", event3)).isFalse();
        assertThat(notificationGracePeriodService.inGracePeriod(definition, ""5678"", event4)).isTrue();
    }
",non-flaky,5
86054,graylog2_graylog2-server,NotificationGracePeriodServiceTest.differentKey,"    @Test
    public void differentKey() {
        final NotificationGracePeriodService notificationGracePeriodService = new NotificationGracePeriodService();

        when(settings.gracePeriodMs()).thenReturn(10L);
        when(definition.notificationSettings()).thenReturn(settings);
        when(definition.id()).thenReturn(""1234"");

        final Event event = new TestEvent();
        event.setKeyTuple(ImmutableList.of(""testkey""));
        final Event event2 = new TestEvent();
        event2.setKeyTuple(ImmutableList.of(""otherkey""));
        event2.setEventTimestamp(event.getEventTimestamp().plus(1L));
        assertThat(notificationGracePeriodService.inGracePeriod(definition, ""5678"", event)).isFalse();
        assertThat(notificationGracePeriodService.inGracePeriod(definition, ""5678"", event2)).isFalse();
    }
",non-flaky,5
86055,graylog2_graylog2-server,NotificationGracePeriodServiceTest.differentNotification,"    @Test
    public void differentNotification() {
        final NotificationGracePeriodService notificationGracePeriodService = new NotificationGracePeriodService();

        when(settings.gracePeriodMs()).thenReturn(10L);
        when(definition.notificationSettings()).thenReturn(settings);
        when(definition.id()).thenReturn(""1234"");

        final Event event = new TestEvent();
        event.setKeyTuple(ImmutableList.of(""testkey""));
        final Event event2 = new TestEvent();
        event2.setKeyTuple(ImmutableList.of(""testkey""));
        event2.setEventTimestamp(event.getEventTimestamp().plus(1L));
        assertThat(notificationGracePeriodService.inGracePeriod(definition, ""5678"", event)).isFalse();
        assertThat(notificationGracePeriodService.inGracePeriod(definition, ""4242"", event2)).isFalse();
    }
",non-flaky,5
86056,graylog2_graylog2-server,NotificationGracePeriodServiceTest.emptyKey,"    @Test
    public void emptyKey() {
        final NotificationGracePeriodService notificationGracePeriodService = new NotificationGracePeriodService();

        when(settings.gracePeriodMs()).thenReturn(10L);
        when(definition.notificationSettings()).thenReturn(settings);
        when(definition.id()).thenReturn(""1234"");

        final Event event = new TestEvent();
        event.setKeyTuple(ImmutableList.of());
        final Event event2 = new TestEvent();
        event.setKeyTuple(ImmutableList.of());
        event2.setEventTimestamp(event.getEventTimestamp().plus(1L));
        assertThat(notificationGracePeriodService.inGracePeriod(definition, ""5678"", event)).isFalse();
        assertThat(notificationGracePeriodService.inGracePeriod(definition, ""5678"", event2)).isTrue();
    }
",non-flaky,5
86057,graylog2_graylog2-server,AggregationFunctionTest.testFunctionMapping,"    @Test
    public void testFunctionMapping() {
        testToSeriesSpec(AggregationFunction.AVG, Average.class);
        testToSeriesSpec(AggregationFunction.CARD, Cardinality.class);
        testToSeriesSpec(AggregationFunction.COUNT, Count.class);
        testToSeriesSpec(AggregationFunction.MAX, Max.class);
        testToSeriesSpec(AggregationFunction.MIN, Min.class);
        testToSeriesSpec(AggregationFunction.STDDEV, StdDev.class);
        testToSeriesSpec(AggregationFunction.SUM, Sum.class);
        testToSeriesSpec(AggregationFunction.SUMOFSQUARES, SumOfSquares.class);
        testToSeriesSpec(AggregationFunction.VARIANCE, Variance.class);
    }
",non-flaky,5
86058,graylog2_graylog2-server,AggregationFunctionTest.fieldRequirements,"    @Test
    public void fieldRequirements() {
        assertThatCode(() -> AggregationFunction.AVG.toSeriesSpec(""a"", null))
                .hasMessageContaining(""<avg>"")
                .isInstanceOf(IllegalArgumentException.class);

        assertThatCode(() -> AggregationFunction.CARD.toSeriesSpec(""a"", null))
                .hasMessageContaining(""<card>"")
                .isInstanceOf(IllegalArgumentException.class);

        assertThatCode(() -> AggregationFunction.COUNT.toSeriesSpec(""a"", null))
                .doesNotThrowAnyException();

        assertThatCode(() -> AggregationFunction.MAX.toSeriesSpec(""a"", null))
                .hasMessageContaining(""<max>"")
                .isInstanceOf(IllegalArgumentException.class);

        assertThatCode(() -> AggregationFunction.MIN.toSeriesSpec(""a"", null))
                .hasMessageContaining(""<min>"")
                .isInstanceOf(IllegalArgumentException.class);

        assertThatCode(() -> AggregationFunction.STDDEV.toSeriesSpec(""a"", null))
                .hasMessageContaining(""<stddev>"")
                .isInstanceOf(IllegalArgumentException.class);

        assertThatCode(() -> AggregationFunction.SUM.toSeriesSpec(""a"", null))
                .hasMessageContaining(""<sum>"")
                .isInstanceOf(IllegalArgumentException.class);

        assertThatCode(() -> AggregationFunction.SUMOFSQUARES.toSeriesSpec(""a"", null))
                .hasMessageContaining(""<sumofsquares>"")
                .isInstanceOf(IllegalArgumentException.class);

        assertThatCode(() -> AggregationFunction.VARIANCE.toSeriesSpec(""a"", null))
                .hasMessageContaining(""<variance>"")
                .isInstanceOf(IllegalArgumentException.class);
    }
",non-flaky,5
86059,graylog2_graylog2-server,AggregationEventProcessorConfigTest.toJobSchedulerConfig,"    @Test
    public void toJobSchedulerConfig() {
        final EventDefinitionDto dto = dbService.get(""54e3deadbeefdeadbeefaffe"").orElse(null);

        assertThat(dto).isNotNull();

        assertThat(dto.config().toJobSchedulerConfig(dto, clock)).isPresent().get().satisfies(schedulerConfig -> {
            assertThat(schedulerConfig.jobDefinitionConfig()).satisfies(jobDefinitionConfig -> {
                assertThat(jobDefinitionConfig).isInstanceOf(EventProcessorExecutionJob.Config.class);

                final EventProcessorExecutionJob.Config config = (EventProcessorExecutionJob.Config) jobDefinitionConfig;

                assertThat(config.eventDefinitionId()).isEqualTo(dto.id());
                assertThat(config.processingWindowSize()).isEqualTo(300000);
                assertThat(config.processingHopSize()).isEqualTo(300000);
                assertThat(config.parameters()).isEqualTo(AggregationEventProcessorParameters.builder()
                        .timerange(AbsoluteRange.create(clock.nowUTC().minus(300000), clock.nowUTC()))
                        .build());
            });

            assertThat(schedulerConfig.schedule()).satisfies(schedule -> {
                assertThat(schedule).isInstanceOf(IntervalJobSchedule.class);

                final IntervalJobSchedule config = (IntervalJobSchedule) schedule;

                assertThat(config.interval()).isEqualTo(300000);
                assertThat(config.unit()).isEqualTo(TimeUnit.MILLISECONDS);
            });
        });
    }
",non-flaky,5
86060,graylog2_graylog2-server,AggregationEventProcessorConfigTest.testValidateWithInvalidTimeRange,"    @Test
    public void testValidateWithInvalidTimeRange() {
        final AggregationEventProcessorConfig invalidConfig1 = getConfig().toBuilder()
            .searchWithinMs(-1)
            .build();

        final ValidationResult validationResult1 = invalidConfig1.validate();
        assertThat(validationResult1.failed()).isTrue();
        assertThat(validationResult1.getErrors()).containsOnlyKeys(""search_within_ms"");

        final AggregationEventProcessorConfig invalidConfig2 = invalidConfig1.toBuilder()
            .searchWithinMs(0)
            .build();

        final ValidationResult validationResult2 = invalidConfig2.validate();
        assertThat(validationResult2.failed()).isTrue();
        assertThat(validationResult2.getErrors()).containsOnlyKeys(""search_within_ms"");
    }
",non-flaky,5
86061,graylog2_graylog2-server,AggregationEventProcessorConfigTest.testValidateWithInvalidExecutionTime,"    @Test
    public void testValidateWithInvalidExecutionTime() {
        final AggregationEventProcessorConfig invalidConfig1 = getConfig().toBuilder()
            .executeEveryMs(-1)
            .build();

        final ValidationResult validationResult1 = invalidConfig1.validate();
        assertThat(validationResult1.failed()).isTrue();
        assertThat(validationResult1.getErrors()).containsOnlyKeys(""execute_every_ms"");

        final AggregationEventProcessorConfig invalidConfig2 = invalidConfig1.toBuilder()
            .executeEveryMs(0)
            .build();

        final ValidationResult validationResult2 = invalidConfig2.validate();
        assertThat(validationResult2.failed()).isTrue();
        assertThat(validationResult2.getErrors()).containsOnlyKeys(""execute_every_ms"");
    }
",non-flaky,5
86062,graylog2_graylog2-server,AggregationEventProcessorConfigTest.testValidateWithIncompleteAggregationOptions,"    @Test
    public void testValidateWithIncompleteAggregationOptions() {
        AggregationEventProcessorConfig invalidConfig = getConfig().toBuilder()
            .groupBy(ImmutableList.of(""foo""))
            .build();

        ValidationResult validationResult = invalidConfig.validate();
        assertThat(validationResult.failed()).isTrue();
        assertThat(validationResult.getErrors()).containsOnlyKeys(""series"", ""conditions"");

        invalidConfig = getConfig().toBuilder()
            .series(ImmutableList.of(this.getSeries()))
            .build();

        validationResult = invalidConfig.validate();
        assertThat(validationResult.failed()).isTrue();
        assertThat(validationResult.getErrors()).containsOnlyKeys(""conditions"");

        invalidConfig = getConfig().toBuilder()
            .conditions(this.getConditions())
            .build();

        validationResult = invalidConfig.validate();
        assertThat(validationResult.failed()).isTrue();
        assertThat(validationResult.getErrors()).containsOnlyKeys(""series"");
    }
",non-flaky,5
86063,graylog2_graylog2-server,AggregationEventProcessorConfigTest.testValidConfiguration,"    @Test
    public void testValidConfiguration() {
        final ValidationResult validationResult = getConfig().validate();
        assertThat(validationResult.failed()).isFalse();
        assertThat(validationResult.getErrors().size()).isEqualTo(0);
    }
",non-flaky,5
86064,graylog2_graylog2-server,AggregationEventProcessorConfigTest.testValidFilterConfiguration,"    @Test
    public void testValidFilterConfiguration() {
        final AggregationEventProcessorConfig config = getConfig().toBuilder()
            .query(""foo"")
            .streams(ImmutableSet.of(""1"", ""2""))
            .build();

        final ValidationResult validationResult = config.validate();
        assertThat(validationResult.failed()).isFalse();
        assertThat(validationResult.getErrors().size()).isEqualTo(0);
    }
",non-flaky,5
86065,graylog2_graylog2-server,AggregationEventProcessorConfigTest.testValidAggregationConfiguration,"    @Test
    public void testValidAggregationConfiguration() {
        final AggregationEventProcessorConfig config = getConfig().toBuilder()
            .groupBy(ImmutableList.of(""bar""))
            .series(ImmutableList.of(this.getSeries()))
            .conditions(this.getConditions())
            .build();

        final ValidationResult validationResult = config.validate();
        assertThat(validationResult.failed()).isFalse();
        assertThat(validationResult.getErrors().size()).isEqualTo(0);
    }
",non-flaky,5
86066,graylog2_graylog2-server,AggregationEventProcessorConfigTest.requiredPermissions,"    @Test
    public void requiredPermissions() {
        assertThat(dbService.get(""54e3deadbeefdeadbeefaffe"")).get().satisfies(definition -> {
            assertThat(definition.config().requiredPermissions()).containsOnly(""streams:read:stream-a"", ""streams:read:stream-b"");
        });
    }
",non-flaky,5
86067,graylog2_graylog2-server,AggregationEventProcessorConfigTest.requiredPermissionsWithEmptyStreams,"    @Test
    public void requiredPermissionsWithEmptyStreams() {
        assertThat(dbService.get(""54e3deadbeefdeadbeefafff"")).get().satisfies(definition -> {
            assertThat(definition.config().requiredPermissions()).containsOnly(""streams:read"");
        });
    }
",non-flaky,5
86068,graylog2_graylog2-server,AggregationEventProcessorTest.testEventsFromAggregationResult,"    @Test
    public void testEventsFromAggregationResult() {
        final DateTime now = DateTime.now(DateTimeZone.UTC);
        final AbsoluteRange timerange = AbsoluteRange.create(now.minusHours(1), now.plusHours(1));

        // We expect to get the end of the aggregation timerange as event time
        final TestEvent event1 = new TestEvent(timerange.to());
        final TestEvent event2 = new TestEvent(timerange.to());
        when(eventFactory.createEvent(any(EventDefinition.class), eq(now), anyString()))
                .thenReturn(event1)  // first invocation return value
                .thenReturn(event2); // second invocation return value

        final EventDefinitionDto eventDefinitionDto = EventDefinitionDto.builder()
                .id(""dto-id-1"")
                .title(""Test Aggregation"")
                .description(""A test aggregation event processors"")
                .priority(1)
                .alert(false)
                .notificationSettings(EventNotificationSettings.withGracePeriod(60000))
                .config(AggregationEventProcessorConfig.builder()
                        .query("""")
                        .streams(ImmutableSet.of(""stream-2""))
                        .groupBy(ImmutableList.of(""group_field_one"", ""group_field_two""))
                        .series(ImmutableList.of())
                        .conditions(null)
                        .searchWithinMs(30000)
                        .executeEveryMs(30000)
                        .build())
                .keySpec(ImmutableList.of())
                .build();
        final AggregationEventProcessorParameters parameters = AggregationEventProcessorParameters.builder()
                .timerange(timerange)
                .build();

        final AggregationEventProcessor eventProcessor = new AggregationEventProcessor(eventDefinitionDto, searchFactory, eventProcessorDependencyCheck, stateService, moreSearch, streamService, messages);

        final AggregationResult result = AggregationResult.builder()
                .effectiveTimerange(timerange)
                .totalAggregatedMessages(1)
                .sourceStreams(ImmutableSet.of(""stream-1"", ""stream-2""))
                .keyResults(ImmutableList.of(
                        AggregationKeyResult.builder()
                                .key(ImmutableList.of(""one"", ""two""))
                                .timestamp(now)
                                .seriesValues(ImmutableList.of(
                                        AggregationSeriesValue.builder()
                                                .key(ImmutableList.of(""a""))
                                                .value(42.0d)
                                                .series(AggregationSeries.builder()
                                                        .id(""abc123"")
                                                        .function(AggregationFunction.COUNT)
                                                        .field(""source"")
                                                        .build())
                                                .build(),
                                        AggregationSeriesValue.builder()
                                                .key(ImmutableList.of(""a""))
                                                .value(23.0d)
                                                .series(AggregationSeries.builder()
                                                        .id(""abc123-no-field"")
                                                        .function(AggregationFunction.COUNT)
                                                        .build())
                                                .build(),
                                        AggregationSeriesValue.builder()
                                                .key(ImmutableList.of(""a""))
                                                .value(1.0d)
                                                .series(AggregationSeries.builder()
                                                        .id(""xyz789"")
                                                        .function(AggregationFunction.CARD)
                                                        .field(""source"")
                                                        .build())
                                                .build()
                                ))
                                .build()
                ))
                .build();

        final ImmutableList<EventWithContext> eventsWithContext = eventProcessor.eventsFromAggregationResult(eventFactory, parameters, result);

        assertThat(eventsWithContext).hasSize(1);

        assertThat(eventsWithContext.get(0)).satisfies(eventWithContext -> {
            final Event event = eventWithContext.event();

            assertThat(event.getId()).isEqualTo(event1.getId());
            assertThat(event.getMessage()).isEqualTo(event1.getMessage());
            assertThat(event.getEventTimestamp()).isEqualTo(timerange.to());
            assertThat(event.getTimerangeStart()).isEqualTo(timerange.from());
            assertThat(event.getTimerangeEnd()).isEqualTo(timerange.to());
            // Should only contain the streams that have been configured in event definition
            assertThat(event.getSourceStreams()).containsOnly(""stream-2"");

            final Message message = eventWithContext.messageContext().orElse(null);

            assertThat(message).isNotNull();
            assertThat(message.getField(""group_field_one"")).isEqualTo(""one"");
            assertThat(message.getField(""group_field_two"")).isEqualTo(""two"");
            assertThat(message.getField(""aggregation_key"")).isEqualTo(""one|two"");
            assertThat(message.getField(""aggregation_value_count_source"")).isEqualTo(42.0d);
            // Make sure that the count with a ""null"" field doesn't include the field in the name
            assertThat(message.getField(""aggregation_value_count"")).isEqualTo(23.0d);
            assertThat(message.getField(""aggregation_value_card_source"")).isEqualTo(1.0d);
        });
    }
",non-flaky,5
86069,graylog2_graylog2-server,AggregationEventProcessorTest.testEventsFromAggregationResultWithConditions,"    @Test
    public void testEventsFromAggregationResultWithConditions() {
        final DateTime now = DateTime.now(DateTimeZone.UTC);
        final AbsoluteRange timerange = AbsoluteRange.create(now.minusHours(1), now.plusHours(1));

        // We expect to get the end of the aggregation timerange as event time
        final TestEvent event1 = new TestEvent(timerange.to());
        final TestEvent event2 = new TestEvent(timerange.to());
        when(eventFactory.createEvent(any(EventDefinition.class), eq(now), anyString()))
                .thenReturn(event1)  // first invocation return value
                .thenReturn(event2); // second invocation return value

        // There should only be one result because the second result's ""abc123"" value is less than 40. (it is 23)
        // See result builder below
        final AggregationConditions conditions = AggregationConditions.builder()
                .expression(Expr.And.create(
                        Expr.Greater.create(Expr.NumberReference.create(""abc123""), Expr.NumberValue.create(40.0d)),
                        Expr.Lesser.create(Expr.NumberReference.create(""xyz789""), Expr.NumberValue.create(2.0d))
                ))
                .build();

        final EventDefinitionDto eventDefinitionDto = EventDefinitionDto.builder()
                .id(""dto-id-1"")
                .title(""Test Aggregation"")
                .description(""A test aggregation event processors"")
                .priority(1)
                .alert(false)
                .notificationSettings(EventNotificationSettings.withGracePeriod(60000))
                .config(AggregationEventProcessorConfig.builder()
                        .query("""")
                        .streams(ImmutableSet.of())
                        .groupBy(ImmutableList.of(""group_field_one"", ""group_field_two""))
                        .series(ImmutableList.of())
                        .conditions(conditions)
                        .searchWithinMs(30000)
                        .executeEveryMs(30000)
                        .build())
                .keySpec(ImmutableList.of())
                .build();
        final AggregationEventProcessorParameters parameters = AggregationEventProcessorParameters.builder()
                .timerange(timerange)
                .build();

        final AggregationEventProcessor eventProcessor = new AggregationEventProcessor(eventDefinitionDto, searchFactory, eventProcessorDependencyCheck, stateService, moreSearch, streamService, messages);

        final AggregationResult result = AggregationResult.builder()
                .effectiveTimerange(timerange)
                .totalAggregatedMessages(1)
                .sourceStreams(ImmutableSet.of(""stream-1"", ""stream-2"", ""stream-3""))
                .keyResults(ImmutableList.of(
                        AggregationKeyResult.builder()
                                .key(ImmutableList.of(""one"", ""two""))
                                .timestamp(now)
                                .seriesValues(ImmutableList.of(
                                        AggregationSeriesValue.builder()
                                                .key(ImmutableList.of(""a""))
                                                .value(42.0d)
                                                .series(AggregationSeries.builder()
                                                        .id(""abc123"")
                                                        .function(AggregationFunction.COUNT)
                                                        .field(""source"")
                                                        .build())
                                                .build(),
                                        AggregationSeriesValue.builder()
                                                .key(ImmutableList.of(""a""))
                                                .value(1.0d)
                                                .series(AggregationSeries.builder()
                                                        .id(""xyz789"")
                                                        .function(AggregationFunction.CARD)
                                                        .field(""source"")
                                                        .build())
                                                .build()
                                ))
                                .build(),
                        AggregationKeyResult.builder()
                                .key(ImmutableList.of(now.toString(), ""one"", ""two""))
                                .seriesValues(ImmutableList.of(
                                        AggregationSeriesValue.builder()
                                                .key(ImmutableList.of(""a""))
                                                .value(23.0d) // Doesn't match condition
                                                .series(AggregationSeries.builder()
                                                        .id(""abc123"")
                                                        .function(AggregationFunction.COUNT)
                                                        .field(""source"")
                                                        .build())
                                                .build(),
                                        AggregationSeriesValue.builder()
                                                .key(ImmutableList.of(""a""))
                                                .value(1.0d)
                                                .series(AggregationSeries.builder()
                                                        .id(""xyz789"")
                                                        .function(AggregationFunction.CARD)
                                                        .field(""source"")
                                                        .build())
                                                .build()
                                ))
                                .build()
                ))
                .build();

        final ImmutableList<EventWithContext> eventsWithContext = eventProcessor.eventsFromAggregationResult(eventFactory, parameters, result);

        assertThat(eventsWithContext).hasSize(1);

        assertThat(eventsWithContext.get(0)).satisfies(eventWithContext -> {
            final Event event = eventWithContext.event();

            assertThat(event.getId()).isEqualTo(event1.getId());
            assertThat(event.getMessage()).isEqualTo(event1.getMessage());
            assertThat(event.getEventTimestamp()).isEqualTo(timerange.to());
            assertThat(event.getTimerangeStart()).isEqualTo(timerange.from());
            assertThat(event.getTimerangeEnd()).isEqualTo(timerange.to());
            // Should contain all streams because when config.streams is empty, we search in all streams
            assertThat(event.getSourceStreams()).containsOnly(""stream-1"", ""stream-2"", ""stream-3"");

            final Message message = eventWithContext.messageContext().orElse(null);

            assertThat(message).isNotNull();
            assertThat(message.getField(""group_field_one"")).isEqualTo(""one"");
            assertThat(message.getField(""group_field_two"")).isEqualTo(""two"");
            assertThat(message.getField(""aggregation_key"")).isEqualTo(""one|two"");
            assertThat(message.getField(""aggregation_value_count_source"")).isEqualTo(42.0d);
            assertThat(message.getField(""aggregation_value_card_source"")).isEqualTo(1.0d);
        });
    }
",non-flaky,5
86070,graylog2_graylog2-server,AggregationEventProcessorTest.createEventsWithFilter,"    @Test
    public void createEventsWithFilter() throws Exception {
        when(eventProcessorDependencyCheck.hasMessagesIndexedUpTo(any(DateTime.class))).thenReturn(true);

        final DateTime now = DateTime.now(DateTimeZone.UTC);
        final AbsoluteRange timerange = AbsoluteRange.create(now.minusHours(1), now.plusHours(1));

        final AggregationEventProcessorConfig config = AggregationEventProcessorConfig.builder()
                .query("""")
                .streams(ImmutableSet.of())
                .groupBy(ImmutableList.of())
                .series(ImmutableList.of())
                .conditions(null)
                .searchWithinMs(30000)
                .executeEveryMs(30000)
                .build();
        final EventDefinitionDto eventDefinitionDto = EventDefinitionDto.builder()
                .id(""dto-id-1"")
                .title(""Test Aggregation"")
                .description(""A test aggregation event processors"")
                .priority(1)
                .alert(false)
                .notificationSettings(EventNotificationSettings.withGracePeriod(60000))
                .config(config)
                .keySpec(ImmutableList.of())
                .build();
        final AggregationEventProcessorParameters parameters = AggregationEventProcessorParameters.builder()
                .timerange(timerange)
                .build();

        final AggregationEventProcessor eventProcessor = new AggregationEventProcessor(eventDefinitionDto, searchFactory, eventProcessorDependencyCheck, stateService, moreSearch, streamService, messages);

        assertThatCode(() -> eventProcessor.createEvents(eventFactory, parameters, (events) -> {})).doesNotThrowAnyException();

        verify(moreSearch, times(1)).scrollQuery(
                eq(config.query()),
                eq(config.streams()),
                eq(config.queryParameters()),
                eq(parameters.timerange()),
                eq(parameters.batchSize()),
                any(MoreSearch.ScrollCallback.class)
        );
        verify(searchFactory, never()).create(eq(config), eq(parameters), any(String.class), eq(eventDefinitionDto));
    }
",non-flaky,5
86071,graylog2_graylog2-server,AggregationEventProcessorTest.createEventsWithoutRequiredMessagesBeingIndexed,"    @Test
    public void createEventsWithoutRequiredMessagesBeingIndexed() throws Exception {
        final DateTime now = DateTime.now(DateTimeZone.UTC);
        final AbsoluteRange timerange = AbsoluteRange.create(now.minusHours(1), now.plusHours(1));

        final AggregationEventProcessorConfig config = AggregationEventProcessorConfig.builder()
                .query("""")
                .streams(ImmutableSet.of())
                .groupBy(ImmutableList.of())
                .series(ImmutableList.of())
                .conditions(null)
                .searchWithinMs(30000)
                .executeEveryMs(30000)
                .build();
        final EventDefinitionDto eventDefinitionDto = EventDefinitionDto.builder()
                .id(""dto-id-1"")
                .title(""Test Aggregation"")
                .description(""A test aggregation event processors"")
                .priority(1)
                .alert(false)
                .notificationSettings(EventNotificationSettings.withGracePeriod(60000))
                .config(config)
                .keySpec(ImmutableList.of())
                .build();
        final AggregationEventProcessorParameters parameters = AggregationEventProcessorParameters.builder()
                .timerange(timerange)
                .build();

        final AggregationEventProcessor eventProcessor = new AggregationEventProcessor(eventDefinitionDto, searchFactory, eventProcessorDependencyCheck, stateService, moreSearch, streamService, messages);

        // If the dependency check returns true, there should be no exception raised and the state service should be called
        when(eventProcessorDependencyCheck.hasMessagesIndexedUpTo(timerange.to())).thenReturn(true);

        assertThatCode(() -> eventProcessor.createEvents(eventFactory, parameters, (events) -> {})).doesNotThrowAnyException();

        verify(stateService, times(1)).setState(""dto-id-1"", timerange.from(), timerange.to());
        verify(moreSearch, times(1)).scrollQuery(
                eq(config.query()),
                eq(config.streams()),
                eq(config.queryParameters()),
                eq(parameters.timerange()),
                eq(parameters.batchSize()),
                any(MoreSearch.ScrollCallback.class)
        );

        reset(stateService, moreSearch, searchFactory); // Rest mocks so we can verify it again

        // If the dependency check returns false, a precondition exception should be raised and the state service not be called
        when(eventProcessorDependencyCheck.hasMessagesIndexedUpTo(timerange.to())).thenReturn(false);

        assertThatCode(() -> eventProcessor.createEvents(eventFactory, parameters, (events) -> {}))
                .hasMessageContaining(eventDefinitionDto.title())
                .hasMessageContaining(eventDefinitionDto.id())
                .hasMessageContaining(timerange.from().toString())
                .hasMessageContaining(timerange.to().toString())
                .isInstanceOf(EventProcessorPreconditionException.class);

        verify(stateService, never()).setState(any(String.class), any(DateTime.class), any(DateTime.class));
        verify(searchFactory, never()).create(any(), any(), any(), any());
        verify(moreSearch, never()).scrollQuery(
                eq(config.query()),
                eq(config.streams()),
                eq(config.queryParameters()),
                eq(parameters.timerange()),
                eq(parameters.batchSize()),
                any(MoreSearch.ScrollCallback.class)
        );
    }
",non-flaky,5
86072,graylog2_graylog2-server,AggregationEventProcessorTest.testEventsFromAggregationResultWithEmptyResultUsesEventDefinitionStreamAsSourceStreams,"    @Test
    public void testEventsFromAggregationResultWithEmptyResultUsesEventDefinitionStreamAsSourceStreams() {
        final DateTime now = DateTime.now(DateTimeZone.UTC);
        final AbsoluteRange timerange = AbsoluteRange.create(now.minusHours(1), now.plusHours(1));

        // We expect to get the end of the aggregation timerange as event time
        final TestEvent event1 = new TestEvent(timerange.to());
        final TestEvent event2 = new TestEvent(timerange.to());
        when(eventFactory.createEvent(any(EventDefinition.class), eq(now), anyString()))
                .thenReturn(event1)  // first invocation return value
                .thenReturn(event2); // second invocation return value

        final EventDefinitionDto eventDefinitionDto = EventDefinitionDto.builder()
                .id(""dto-id-1"")
                .title(""Test Aggregation"")
                .description(""A test aggregation event processors"")
                .priority(1)
                .alert(false)
                .notificationSettings(EventNotificationSettings.withGracePeriod(60000))
                .config(AggregationEventProcessorConfig.builder()
                        .query("""")
                        .streams(ImmutableSet.of(""stream-2""))
                        .groupBy(ImmutableList.of(""group_field_one"", ""group_field_two""))
                        .series(ImmutableList.of())
                        .conditions(null)
                        .searchWithinMs(30000)
                        .executeEveryMs(30000)
                        .build())
                .keySpec(ImmutableList.of())
                .build();
        final AggregationEventProcessorParameters parameters = AggregationEventProcessorParameters.builder()
                .timerange(timerange)
                .build();

        final AggregationEventProcessor eventProcessor = new AggregationEventProcessor(eventDefinitionDto, searchFactory, eventProcessorDependencyCheck, stateService, moreSearch, streamService, messages);

        final AggregationResult result = AggregationResult.builder()
                .effectiveTimerange(timerange)
                .totalAggregatedMessages(0)
                .sourceStreams(ImmutableSet.of()) // No streams in result
                .keyResults(ImmutableList.of(
                        AggregationKeyResult.builder()
                                .key(ImmutableList.of(""one"", ""two""))
                                .timestamp(now)
                                .seriesValues(ImmutableList.of(
                                        AggregationSeriesValue.builder()
                                                .key(ImmutableList.of(""a""))
                                                .value(0.0d)
                                                .series(AggregationSeries.builder()
                                                        .id(""abc123"")
                                                        .function(AggregationFunction.COUNT)
                                                        .build())
                                                .build()
                                ))
                                .build()
                ))
                .build();

        final ImmutableList<EventWithContext> eventsWithContext = eventProcessor.eventsFromAggregationResult(eventFactory, parameters, result);

        assertThat(eventsWithContext).hasSize(1);

        assertThat(eventsWithContext.get(0)).satisfies(eventWithContext -> {
            final Event event = eventWithContext.event();

            assertThat(event.getId()).isEqualTo(event1.getId());
            assertThat(event.getMessage()).isEqualTo(event1.getMessage());
            assertThat(event.getEventTimestamp()).isEqualTo(timerange.to());
            assertThat(event.getTimerangeStart()).isEqualTo(timerange.from());
            assertThat(event.getTimerangeEnd()).isEqualTo(timerange.to());
            // Must contain the stream from the event definition because there is none in the result
            assertThat(event.getSourceStreams()).containsOnly(""stream-2"");

            final Message message = eventWithContext.messageContext().orElse(null);

            assertThat(message).isNotNull();
            assertThat(message.getField(""group_field_one"")).isEqualTo(""one"");
            assertThat(message.getField(""group_field_two"")).isEqualTo(""two"");
            assertThat(message.getField(""aggregation_key"")).isEqualTo(""one|two"");
            assertThat(message.getField(""aggregation_value_count"")).isEqualTo(0.0d);
        });
    }
",non-flaky,5
86073,graylog2_graylog2-server,AggregationEventProcessorTest.testEventsFromAggregationResultWithEmptyResultAndNoConfiguredStreamsUsesAllStreamsAsSourceStreams,"    @Test
    public void testEventsFromAggregationResultWithEmptyResultAndNoConfiguredStreamsUsesAllStreamsAsSourceStreams() {
        final DateTime now = DateTime.now(DateTimeZone.UTC);
        final AbsoluteRange timerange = AbsoluteRange.create(now.minusHours(1), now.plusHours(1));

        // We expect to get the end of the aggregation timerange as event time
        final TestEvent event1 = new TestEvent(timerange.to());
        final TestEvent event2 = new TestEvent(timerange.to());
        when(eventFactory.createEvent(any(EventDefinition.class), eq(now), anyString()))
                .thenReturn(event1)  // first invocation return value
                .thenReturn(event2); // second invocation return value

        when(streamService.loadAll()).thenReturn(ImmutableList.of(
                new StreamMock(Collections.singletonMap(""_id"", ""stream-1""), Collections.emptyList()),
                new StreamMock(Collections.singletonMap(""_id"", ""stream-2""), Collections.emptyList()),
                new StreamMock(Collections.singletonMap(""_id"", ""stream-3""), Collections.emptyList()),
                new StreamMock(Collections.singletonMap(""_id"", StreamImpl.DEFAULT_STREAM_ID), Collections.emptyList()),
                new StreamMock(Collections.singletonMap(""_id"", StreamImpl.DEFAULT_EVENTS_STREAM_ID), Collections.emptyList()),
                new StreamMock(Collections.singletonMap(""_id"", StreamImpl.DEFAULT_SYSTEM_EVENTS_STREAM_ID), Collections.emptyList())
        ));

        final EventDefinitionDto eventDefinitionDto = EventDefinitionDto.builder()
                .id(""dto-id-1"")
                .title(""Test Aggregation"")
                .description(""A test aggregation event processors"")
                .priority(1)
                .alert(false)
                .notificationSettings(EventNotificationSettings.withGracePeriod(60000))
                .config(AggregationEventProcessorConfig.builder()
                        .query("""")
                        .streams(ImmutableSet.of()) // No configured streams!
                        .groupBy(ImmutableList.of(""group_field_one"", ""group_field_two""))
                        .series(ImmutableList.of())
                        .conditions(null)
                        .searchWithinMs(30000)
                        .executeEveryMs(30000)
                        .build())
                .keySpec(ImmutableList.of())
                .build();
        final AggregationEventProcessorParameters parameters = AggregationEventProcessorParameters.builder()
                .timerange(timerange)
                .build();

        final AggregationEventProcessor eventProcessor = new AggregationEventProcessor(eventDefinitionDto, searchFactory, eventProcessorDependencyCheck, stateService, moreSearch, streamService, messages);

        final AggregationResult result = AggregationResult.builder()
                .effectiveTimerange(timerange)
                .totalAggregatedMessages(0)
                .sourceStreams(ImmutableSet.of()) // No streams in result
                .keyResults(ImmutableList.of(
                        AggregationKeyResult.builder()
                                .key(ImmutableList.of(""one"", ""two""))
                                .timestamp(now)
                                .seriesValues(ImmutableList.of(
                                        AggregationSeriesValue.builder()
                                                .key(ImmutableList.of(""a""))
                                                .value(0.0d)
                                                .series(AggregationSeries.builder()
                                                        .id(""abc123"")
                                                        .function(AggregationFunction.COUNT)
                                                        .build())
                                                .build()
                                ))
                                .build()
                ))
                .build();

        final ImmutableList<EventWithContext> eventsWithContext = eventProcessor.eventsFromAggregationResult(eventFactory, parameters, result);

        assertThat(eventsWithContext).hasSize(1);

        assertThat(eventsWithContext.get(0)).satisfies(eventWithContext -> {
            final Event event = eventWithContext.event();

            assertThat(event.getId()).isEqualTo(event1.getId());
            assertThat(event.getMessage()).isEqualTo(event1.getMessage());
            assertThat(event.getEventTimestamp()).isEqualTo(timerange.to());
            assertThat(event.getTimerangeStart()).isEqualTo(timerange.from());
            assertThat(event.getTimerangeEnd()).isEqualTo(timerange.to());
            // Must contain all existing streams but the default event streams!
            assertThat(event.getSourceStreams()).containsOnly(
                    ""stream-1"",
                    ""stream-2"",
                    ""stream-3"",
                    StreamImpl.DEFAULT_STREAM_ID
            );

            final Message message = eventWithContext.messageContext().orElse(null);

            assertThat(message).isNotNull();
            assertThat(message.getField(""group_field_one"")).isEqualTo(""one"");
            assertThat(message.getField(""group_field_two"")).isEqualTo(""two"");
            assertThat(message.getField(""aggregation_key"")).isEqualTo(""one|two"");
            assertThat(message.getField(""aggregation_value_count"")).isEqualTo(0.0d);
        });
    }
",non-flaky,5
86074,graylog2_graylog2-server,PivotAggregationSearchTest.testExtractValuesWithGroupBy,"    @Test
    public void testExtractValuesWithGroupBy() throws Exception {
        final AbsoluteRange timerange = AbsoluteRange.create(DateTime.now(DateTimeZone.UTC).minusSeconds(3600), DateTime.now(DateTimeZone.UTC));
        final AggregationSeries seriesCount = AggregationSeries.create(""abc123"", AggregationFunction.COUNT, ""source"");
        final AggregationSeries seriesCard = AggregationSeries.create(""abc123"", AggregationFunction.CARD, ""source"");
        final AggregationEventProcessorConfig config = AggregationEventProcessorConfig.builder()
                .query("""")
                .streams(Collections.emptySet())
                .groupBy(Collections.emptyList())
                .series(ImmutableList.of(seriesCount, seriesCard))
                .conditions(null)
                .searchWithinMs(30000)
                .executeEveryMs(30000)
                .build();
        final AggregationEventProcessorParameters parameters = AggregationEventProcessorParameters.builder()
                .streams(Collections.emptySet())
                .timerange(timerange)
                .batchSize(500)
                .build();

        final PivotAggregationSearch pivotAggregationSearch = new PivotAggregationSearch(
                config,
                parameters,
                ""test"",
                eventDefinition,
                searchJobService,
                queryEngine,
                EventsConfigurationTestProvider.create(),
                moreSearch,
                permittedStreams);

        final String toString = timerange.getTo().toString();
        final PivotResult pivotResult = PivotResult.builder()
                .id(""test"")
                .effectiveTimerange(timerange)
                .total(1)
                .addRow(PivotResult.Row.builder()
                        .key(ImmutableList.of(toString, ""a"", ""b""))
                        .addValue(PivotResult.Value.create(ImmutableList.of(""metric/count/source/abc123""), 42, true, ""row-leaf""))
                        .addValue(PivotResult.Value.create(ImmutableList.of(""metric/card/source/abc123""), 1, true, ""row-leaf""))
                        .source(""leaf"")
                        .build())
                .addRow(PivotResult.Row.builder()
                        .key(ImmutableList.of(toString, ""a""))
                        .addValue(PivotResult.Value.create(ImmutableList.of(""metric/count/source/abc123""), 84, true, ""row-inner""))
                        .addValue(PivotResult.Value.create(ImmutableList.of(""metric/card/source/abc123""), 1, true, ""row-inner""))
                        .source(""non-leaf"")
                        .build())
                .addRow(PivotResult.Row.builder()
                        .key(ImmutableList.of(toString, ""a"", ""c""))
                        .addValue(PivotResult.Value.create(ImmutableList.of(""metric/count/source/abc123""), 42, true, ""row-leaf""))
                        .addValue(PivotResult.Value.create(ImmutableList.of(""metric/card/source/abc123""), 1, true, ""row-leaf""))
                        .source(""leaf"")
                        .build())
                .build();

        final ImmutableList<AggregationKeyResult> results = pivotAggregationSearch.extractValues(pivotResult);

        assertThat(results.size()).isEqualTo(2);

        assertThat(results.get(0)).isEqualTo(AggregationKeyResult.builder()
                .timestamp(timerange.getTo())
                .key(ImmutableList.of(""a"", ""b""))
                .seriesValues(ImmutableList.of(
                        AggregationSeriesValue.builder()
                                .key(ImmutableList.of(""a"", ""b""))
                                .value(42.0)
                                .series(seriesCount)
                                .build(),
                        AggregationSeriesValue.builder()
                                .key(ImmutableList.of(""a"", ""b""))
                                .value(1.0)
                                .series(seriesCard)
                                .build()
                ))
                .build());

        assertThat(results.get(1)).isEqualTo(AggregationKeyResult.builder()
                .timestamp(timerange.getTo())
                .key(ImmutableList.of(""a"", ""c""))
                .seriesValues(ImmutableList.of(
                        AggregationSeriesValue.builder()
                                .key(ImmutableList.of(""a"", ""c""))
                                .value(42.0)
                                .series(seriesCount)
                                .build(),
                        AggregationSeriesValue.builder()
                                .key(ImmutableList.of(""a"", ""c""))
                                .value(1.0)
                                .series(seriesCard)
                                .build()
                ))
                .build());
    }
",non-flaky,5
86075,graylog2_graylog2-server,PivotAggregationSearchTest.testExtractValuesWithoutGroupBy,"    @Test
    public void testExtractValuesWithoutGroupBy() throws Exception {
        final AbsoluteRange timerange = AbsoluteRange.create(DateTime.now(DateTimeZone.UTC).minusSeconds(3600), DateTime.now(DateTimeZone.UTC));
        final AggregationSeries seriesCount = AggregationSeries.create(""abc123"", AggregationFunction.COUNT, ""source"");
        final AggregationSeries seriesCountNoField = AggregationSeries.create(""abc123"", AggregationFunction.COUNT, """");
        final AggregationSeries seriesCard = AggregationSeries.create(""abc123"", AggregationFunction.CARD, ""source"");
        final AggregationEventProcessorConfig config = AggregationEventProcessorConfig.builder()
                .query("""")
                .streams(Collections.emptySet())
                .groupBy(Collections.emptyList())
                .series(ImmutableList.of(seriesCount, seriesCountNoField, seriesCard))
                .conditions(null)
                .searchWithinMs(30000)
                .executeEveryMs(30000)
                .build();
        final AggregationEventProcessorParameters parameters = AggregationEventProcessorParameters.builder()
                .streams(Collections.emptySet())
                .timerange(timerange)
                .batchSize(500)
                .build();

        final PivotAggregationSearch pivotAggregationSearch = new PivotAggregationSearch(
                config,
                parameters,
                ""test"",
                eventDefinition,
                searchJobService,
                queryEngine,
                EventsConfigurationTestProvider.create(),
                moreSearch,
                permittedStreams);

        final PivotResult pivotResult = PivotResult.builder()
                .id(""test"")
                .effectiveTimerange(timerange)
                .total(1)
                .addRow(PivotResult.Row.builder()
                        .key(ImmutableList.of(timerange.getTo().toString()))
                        .addValue(PivotResult.Value.create(ImmutableList.of(""metric/count/source/abc123""), 42, true, ""row-leaf""))
                        .addValue(PivotResult.Value.create(ImmutableList.of(""metric/count/<no-field>/abc123""), 23, true, ""row-leaf""))
                        .addValue(PivotResult.Value.create(ImmutableList.of(""metric/card/source/abc123""), 1, true, ""row-leaf""))
                        .source(""leaf"")
                        .build())
                .build();

        final ImmutableList<AggregationKeyResult> results = pivotAggregationSearch.extractValues(pivotResult);

        assertThat(results.size()).isEqualTo(1);

        assertThat(results.get(0)).isEqualTo(AggregationKeyResult.builder()
                .key(ImmutableList.of())
                .timestamp(timerange.getTo())
                .seriesValues(ImmutableList.of(
                        AggregationSeriesValue.builder()
                                .key(ImmutableList.of())
                                .value(42.0)
                                .series(seriesCount)
                                .build(),
                        AggregationSeriesValue.builder()
                                .key(ImmutableList.of())
                                .value(23.0)
                                .series(seriesCountNoField)
                                .build(),
                        AggregationSeriesValue.builder()
                                .key(ImmutableList.of())
                                .value(1.0)
                                .series(seriesCard)
                                .build()
                ))
                .build());
    }
",non-flaky,5
86076,graylog2_graylog2-server,PivotAggregationSearchTest.testExtractValuesWithNullValues,"    @Test
    public void testExtractValuesWithNullValues() throws Exception {
        final AbsoluteRange timerange = AbsoluteRange.create(DateTime.now(DateTimeZone.UTC).minusSeconds(3600), DateTime.now(DateTimeZone.UTC));
        final AggregationSeries seriesCount = AggregationSeries.create(""abc123"", AggregationFunction.COUNT, ""source"");
        final AggregationSeries seriesAvg = AggregationSeries.create(""abc123"", AggregationFunction.AVG, ""some_field"");
        final AggregationEventProcessorConfig config = AggregationEventProcessorConfig.builder()
                .query("""")
                .streams(Collections.emptySet())
                .groupBy(Collections.emptyList())
                .series(ImmutableList.of(seriesCount, seriesAvg))
                .conditions(null)
                .searchWithinMs(30000)
                .executeEveryMs(30000)
                .build();
        final AggregationEventProcessorParameters parameters = AggregationEventProcessorParameters.builder()
                .streams(Collections.emptySet())
                .timerange(timerange)
                .batchSize(500)
                .build();

        final PivotAggregationSearch pivotAggregationSearch = new PivotAggregationSearch(
                config,
                parameters,
                ""test"",
                eventDefinition,
                searchJobService,
                queryEngine,
                EventsConfigurationTestProvider.create(),
                moreSearch,
                permittedStreams);

        final PivotResult pivotResult = PivotResult.builder()
                .id(""test"")
                .effectiveTimerange(timerange)
                .total(1)
                .addRow(PivotResult.Row.builder()
                        .key(ImmutableList.of(timerange.getTo().toString()))
                        .addValue(PivotResult.Value.create(ImmutableList.of(""metric/count/source/abc123""), 42, true, ""row-leaf""))
                        // A ""null"" value can happen with some Elasticsearch aggregations (e.g. avg on a non-existent field)
                        .addValue(PivotResult.Value.create(ImmutableList.of(""metric/avg/some_field/abc123""), null, true, ""row-leaf""))
                        .source(""leaf"")
                        .build())
                .build();

        final ImmutableList<AggregationKeyResult> results = pivotAggregationSearch.extractValues(pivotResult);

        assertThat(results.size()).isEqualTo(1);

        assertThat(results.get(0)).isEqualTo(AggregationKeyResult.builder()
                .key(ImmutableList.of())
                .timestamp(timerange.getTo())
                .seriesValues(ImmutableList.of(
                        AggregationSeriesValue.builder()
                                .key(ImmutableList.of())
                                .value(42.0)
                                .series(seriesCount)
                                .build(),
                        AggregationSeriesValue.builder()
                                .key(ImmutableList.of())
                                .value(Double.NaN) // For ""null"" we expect NaN
                                .series(seriesAvg)
                                .build()
                ))
                .build());
    }
",non-flaky,5
86077,graylog2_graylog2-server,PivotAggregationSearchTest.testDateRangeBucketWithOneTumblingWindow,"    @Test
    public void testDateRangeBucketWithOneTumblingWindow() {
        final long processingWindowSize = Duration.standardSeconds(60).getMillis();
        final long processingHopSize = Duration.standardSeconds(60).getMillis();
        final DateTime now = DateTime.now(DateTimeZone.UTC);
        final DateTime from = now;
        final DateTime to = now.plusMillis((int) processingWindowSize);
        TimeRange timeRange = AbsoluteRange.create(from, to);
        final DateRangeBucket rangeBucket = PivotAggregationSearch.buildDateRangeBuckets(timeRange, processingWindowSize, processingHopSize);

        assertThat(rangeBucket.ranges()).containsExactly(DateRange.create(from, to));
    }
",non-flaky,5
86078,graylog2_graylog2-server,PivotAggregationSearchTest.testDateRangeBucketWithCatchUpTumblingWindows,"    @Test
    public void testDateRangeBucketWithCatchUpTumblingWindows() {
        final long processingWindowSize = Duration.standardSeconds(60).getMillis();
        final long processingHopSize = Duration.standardSeconds(60).getMillis();
        final DateTime now = DateTime.now(DateTimeZone.UTC);
        final DateTime from = now;
        // We are 3 full processingWindows behind
        final DateTime to = now.plusMillis((int) processingWindowSize * 3);
        TimeRange timeRange = AbsoluteRange.create(from, to);
        final DateRangeBucket rangeBucket = PivotAggregationSearch.buildDateRangeBuckets(timeRange, processingWindowSize, processingHopSize);

        assertThat(rangeBucket.ranges()).containsExactly(
                DateRange.create(from.plusMillis((int) (processingWindowSize * 0)), from.plusMillis((int) (processingWindowSize * 1))),
                DateRange.create(from.plusMillis((int) (processingWindowSize * 1)), from.plusMillis((int) (processingWindowSize * 2))),
                DateRange.create(from.plusMillis((int) (processingWindowSize * 2)), from.plusMillis((int) (processingWindowSize * 3)))
        );
    }
",non-flaky,5
86079,graylog2_graylog2-server,PivotAggregationSearchTest.testDateRangeBucketWithSlidingWindow,"    @Test
    public void testDateRangeBucketWithSlidingWindow() {
        final long processingWindowSize = Duration.standardSeconds(3600).getMillis();
        final long processingHopSize = Duration.standardSeconds(60).getMillis();
        final DateTime now = DateTime.now(DateTimeZone.UTC);
        final DateTime from = now;
        final DateTime to = now.plusMillis((int) processingWindowSize);
        TimeRange timeRange = AbsoluteRange.create(from, to);
        final DateRangeBucket rangeBucket = PivotAggregationSearch.buildDateRangeBuckets(timeRange, processingWindowSize, processingHopSize);

        assertThat(rangeBucket.ranges()).containsExactly(
                DateRange.create(from, to)
        );
    }
",non-flaky,5
86080,graylog2_graylog2-server,PivotAggregationSearchTest.testDateRangeBucketWithCatchUpSlidingWindows,"    @Test
    public void testDateRangeBucketWithCatchUpSlidingWindows() {
        final int processingWindowSizeSec = 120;
        final int processingHopSizeSec = 60;
        final DateTime now = DateTime.now(DateTimeZone.UTC);
        final DateTime from = now;
        // We are 3 full processingWindows behind
        final DateTime to = now.plusSeconds(processingWindowSizeSec * 3);
        TimeRange timeRange = AbsoluteRange.create(from, to);
        final DateRangeBucket rangeBucket = PivotAggregationSearch.buildDateRangeBuckets(timeRange, processingWindowSizeSec * 1000, processingHopSizeSec * 1000);

        assertThat(rangeBucket.ranges()).containsExactly(
                DateRange.create(from.plusSeconds(processingHopSizeSec * 0), from.plusSeconds(processingWindowSizeSec)),
                DateRange.create(from.plusSeconds(processingHopSizeSec * 1), from.plusSeconds(processingHopSizeSec * 1).plusSeconds(processingWindowSizeSec)),
                DateRange.create(from.plusSeconds(processingHopSizeSec * 2), from.plusSeconds(processingHopSizeSec * 2).plusSeconds(processingWindowSizeSec)),
                DateRange.create(from.plusSeconds(processingHopSizeSec * 3), from.plusSeconds(processingHopSizeSec * 3).plusSeconds(processingWindowSizeSec)),
                DateRange.create(from.plusSeconds(processingHopSizeSec * 4), to)
        );
    }
",non-flaky,5
86081,graylog2_graylog2-server,EventDefinitionHandlerTest.create,"    @Test
    public void create() {
        final EventDefinitionDto newDto = EventDefinitionDto.builder()
                .title(""Test"")
                .description(""A test event definition"")
                .config(TestEventProcessorConfig.builder()
                        .message(""This is a test event processor"")
                        .searchWithinMs(300000)
                        .executeEveryMs(60001)
                        .build())
                .priority(3)
                .alert(false)
                .notificationSettings(EventNotificationSettings.withGracePeriod(60000))
                .keySpec(ImmutableList.of(""a"", ""b""))
                .notifications(ImmutableList.of())
                .build();

        final EventDefinitionDto dto = handler.create(newDto, Optional.empty());

        // Handler should create the event definition
        assertThat(eventDefinitionService.get(dto.id())).isPresent();

        final Optional<JobDefinitionDto> jobDefinition = jobDefinitionService.getByConfigField(""event_definition_id"", dto.id());

        // Handler also should create the job definition for the event definition/processor
        assertThat(jobDefinition).isPresent().get().satisfies(definition -> {
            assertThat(definition.title()).isEqualTo(""Test"");
            assertThat(definition.description()).isEqualTo(""A test event definition"");
            assertThat(definition.config()).isInstanceOf(EventProcessorExecutionJob.Config.class);

            final EventProcessorExecutionJob.Config config = (EventProcessorExecutionJob.Config) definition.config();


            assertThat(config.processingWindowSize()).isEqualTo(300000);
            assertThat(config.processingHopSize()).isEqualTo(60001);
        });

        // And the handler should also create a job trigger for the created job definition
        final Optional<JobTriggerDto> jobTrigger = jobTriggerService.nextRunnableTrigger();

        assertThat(jobTrigger).isPresent().get().satisfies(trigger -> {
            assertThat(trigger.jobDefinitionId()).isEqualTo(jobDefinition.get().id());
            assertThat(trigger.schedule()).isInstanceOf(IntervalJobSchedule.class);

            final IntervalJobSchedule schedule = (IntervalJobSchedule) trigger.schedule();

            assertThat(schedule.interval()).isEqualTo(60001);
            assertThat(schedule.unit()).isEqualTo(TimeUnit.MILLISECONDS);
        });
    }
",non-flaky,5
86082,graylog2_graylog2-server,EventDefinitionHandlerTest.createWithoutSchedule,"    @Test
    public void createWithoutSchedule() {
        final EventDefinitionDto newDto = EventDefinitionDto.builder()
                .title(""Test"")
                .description(""A test event definition"")
                .config(TestEventProcessorConfig.builder()
                        .message(""This is a test event processor"")
                        .searchWithinMs(300000)
                        .executeEveryMs(60001)
                        .build())
                .priority(3)
                .alert(false)
                .notificationSettings(EventNotificationSettings.withGracePeriod(60000))
                .keySpec(ImmutableList.of(""a"", ""b""))
                .notifications(ImmutableList.of())
                .build();

        final EventDefinitionDto dto = handler.createWithoutSchedule(newDto, Optional.empty());

        // Handler should create the event definition
        assertThat(eventDefinitionService.get(dto.id())).isPresent();

        // Handler should NOT create a job definition for the event definition/processor
        assertThat(jobDefinitionService.getByConfigField(""event_definition_id"", dto.id())).isNotPresent();

        // And the handler should also NOT create a job trigger for the created job definition
        assertThat(jobTriggerService.nextRunnableTrigger()).isNotPresent();
    }
",non-flaky,5
86083,graylog2_graylog2-server,EventDefinitionHandlerTest.update,"    @Test
    public void update() {
        final String newTitle = ""A NEW TITLE "" + DateTime.now(DateTimeZone.UTC).toString();
        final String newDescription = ""A NEW DESCRIPTION "" + DateTime.now(DateTimeZone.UTC).toString();

        final EventDefinitionDto existingDto = eventDefinitionService.get(""54e3deadbeefdeadbeef0000"").orElse(null);
        final JobDefinitionDto existingJobDefinition = jobDefinitionService.get(""54e3deadbeefdeadbeef0001"").orElse(null);
        final JobTriggerDto existingTrigger = jobTriggerService.get(""54e3deadbeefdeadbeef0002"").orElse(null);
        final TestEventProcessorConfig existingConfig = (TestEventProcessorConfig) existingDto.config();
        final TestEventProcessorConfig newConfig = existingConfig.toBuilder()
                .executeEveryMs(550000)
                .searchWithinMs(800000)
                .build();
        final EventProcessorExecutionJob.Data existingTriggerData = (EventProcessorExecutionJob.Data) existingTrigger.data().orElseThrow(AssertionError::new);

        assertThat(existingDto).isNotNull();
        assertThat(existingJobDefinition).isNotNull();
        assertThat(existingTrigger).isNotNull();

        final EventDefinitionDto updatedDto = existingDto.toBuilder()
                .title(newTitle)
                .description(newDescription)
                .config(newConfig)
                .build();

        assertThat(handler.update(updatedDto, true)).isNotEqualTo(existingDto);

        assertThat(eventDefinitionService.get(existingDto.id())).isPresent().get().satisfies(dto -> {
            assertThat(dto.id()).isEqualTo(existingDto.id());
            assertThat(dto.title()).isEqualTo(newTitle);
            assertThat(dto.description()).isEqualTo(newDescription);
        });

        // Test that the schedule is updated to the new config
        final JobDefinitionDto newJobDefinition = jobDefinitionService.get(""54e3deadbeefdeadbeef0001"").orElseThrow(AssertionError::new);
        assertThat(newJobDefinition.title()).isEqualTo(newTitle);
        assertThat(newJobDefinition.description()).isEqualTo(newDescription);
        assertThat(((EventProcessorExecutionJob.Config) newJobDefinition.config()).processingHopSize()).isEqualTo(550000);
        assertThat(((EventProcessorExecutionJob.Config) newJobDefinition.config()).processingWindowSize()).isEqualTo(800000);

        // Test if the EventDefinition update removed the old trigger data
        // and reset the job definition timerange to the new parameters
        final EventProcessorExecutionJob.Config newJobConfig = (EventProcessorExecutionJob.Config) newJobDefinition.config();
        final TimeRange newTimeRange = newJobConfig.parameters().timerange();
        assertThat(newTimeRange.getFrom()).isEqualTo(clock.nowUTC().minus(newConfig.searchWithinMs()));
        assertThat(newTimeRange.getTo()).isEqualTo(clock.nowUTC());

        assertThat(jobTriggerService.get(""54e3deadbeefdeadbeef0002"")).isPresent().get().satisfies(trigger -> {
            assertThat(trigger.data()).isEmpty();
            assertThat(trigger.nextTime()).isEqualTo(clock.nowUTC());
        });
    }
",non-flaky,5
86084,graylog2_graylog2-server,EventDefinitionHandlerTest.updateWithSchedulingDisabled,"    @Test
    public void updateWithSchedulingDisabled() {
        final String newTitle = ""A NEW TITLE "" + DateTime.now(DateTimeZone.UTC).toString();
        final String newDescription = ""A NEW DESCRIPTION "" + DateTime.now(DateTimeZone.UTC).toString();

        final EventDefinitionDto existingDto = eventDefinitionService.get(""54e3deadbeefdeadbeef0000"").orElse(null);
        final JobDefinitionDto existingJobDefinition = jobDefinitionService.get(""54e3deadbeefdeadbeef0001"").orElse(null);
        final JobTriggerDto existingTrigger = jobTriggerService.get(""54e3deadbeefdeadbeef0002"").orElse(null);
        final TestEventProcessorConfig existingConfig = (TestEventProcessorConfig) existingDto.config();
        final TestEventProcessorConfig newConfig = existingConfig.toBuilder()
                .executeEveryMs(550000)
                .searchWithinMs(800000)
                .build();

        assertThat(existingDto).isNotNull();
        assertThat(existingJobDefinition).isNotNull();
        assertThat(existingTrigger).isNotNull();

        final EventDefinitionDto updatedDto = existingDto.toBuilder()
                .title(newTitle)
                .description(newDescription)
                .config(newConfig)
                .build();

        assertThat(handler.update(updatedDto, false)).isNotEqualTo(existingDto);

        assertThat(eventDefinitionService.get(existingDto.id())).isPresent().get().satisfies(dto -> {
            assertThat(dto.id()).isEqualTo(existingDto.id());
            assertThat(dto.title()).isEqualTo(newTitle);
            assertThat(dto.description()).isEqualTo(newDescription);
        });

        assertThat(jobDefinitionService.get(""54e3deadbeefdeadbeef0001"")).isNotPresent();
        assertThat(jobTriggerService.get(""54e3deadbeefdeadbeef0002"")).isNotPresent();
    }
",non-flaky,5
86085,graylog2_graylog2-server,EventDefinitionHandlerTest.updateWithSchedulingReEnabled,"    @Test
    public void updateWithSchedulingReEnabled() {
        final String newTitle = ""A NEW TITLE "" + DateTime.now(DateTimeZone.UTC).toString();
        final String newDescription = ""A NEW DESCRIPTION "" + DateTime.now(DateTimeZone.UTC).toString();

        final EventDefinitionDto existingDto = eventDefinitionService.get(""54e3deadbeefdeadbeef0000"").orElse(null);
        final TestEventProcessorConfig existingConfig = (TestEventProcessorConfig) existingDto.config();
        final TestEventProcessorConfig newConfig = existingConfig.toBuilder()
                .executeEveryMs(550000)
                .searchWithinMs(800000)
                .build();

        assertThat(existingDto).isNotNull();

        final EventDefinitionDto updatedDto = existingDto.toBuilder()
                .title(newTitle)
                .description(newDescription)
                .config(newConfig)
                .build();

        assertThat(handler.update(updatedDto, true)).isNotEqualTo(existingDto);

        assertThat(eventDefinitionService.get(existingDto.id())).isPresent().get().satisfies(dto -> {
            assertThat(dto.id()).isEqualTo(existingDto.id());
            assertThat(dto.title()).isEqualTo(newTitle);
            assertThat(dto.description()).isEqualTo(newDescription);
        });

        final JobDefinitionDto newJobDefinition = jobDefinitionService.getByConfigField(""event_definition_id"", existingDto.id())
                .orElseThrow(AssertionError::new);
        assertThat(newJobDefinition.title()).isEqualTo(newTitle);
        assertThat(newJobDefinition.description()).isEqualTo(newDescription);
        assertThat(((EventProcessorExecutionJob.Config) newJobDefinition.config()).processingHopSize()).isEqualTo(550000);

        assertThat(jobTriggerService.getForJob(newJobDefinition.id()).get(0)).satisfies(trigger -> {
            final IntervalJobSchedule schedule = (IntervalJobSchedule) trigger.schedule();
            assertThat(schedule.interval()).isEqualTo(550000);
        });
    }
",non-flaky,5
86086,graylog2_graylog2-server,EventDefinitionHandlerTest.updateWithErrors,"    @Test
    public void updateWithErrors() {
        final String newTitle = ""A NEW TITLE "" + DateTime.now(DateTimeZone.UTC).toString();
        final String newDescription = ""A NEW DESCRIPTION "" + DateTime.now(DateTimeZone.UTC).toString();

        final EventDefinitionDto existingDto = eventDefinitionService.get(""54e3deadbeefdeadbeef0000"").orElse(null);
        final JobDefinitionDto existingJobDefinition = jobDefinitionService.get(""54e3deadbeefdeadbeef0001"").orElse(null);
        final JobTriggerDto existingTrigger = jobTriggerService.get(""54e3deadbeefdeadbeef0002"").orElse(null);

        assertThat(existingDto).isNotNull();
        assertThat(existingJobDefinition).isNotNull();
        assertThat(existingTrigger).isNotNull();

        final EventDefinitionDto updatedDto = existingDto.toBuilder()
                .title(newTitle)
                .description(newDescription)
                .build();

        doThrow(new NullPointerException(""yolo1"")).when(eventDefinitionService).save(any());

        assertThatCode(() -> handler.update(updatedDto, true))
                .isInstanceOf(NullPointerException.class)
                .hasMessageContaining(""yolo1"");

        assertThat(eventDefinitionService.get(existingDto.id())).isPresent().get().satisfies(dto -> {
            assertThat(dto.id()).isEqualTo(existingDto.id());
            assertThat(dto.title()).isEqualTo(existingDto.title());
            assertThat(dto.description()).isEqualTo(existingDto.description());
        });

        assertThat(jobDefinitionService.get(""54e3deadbeefdeadbeef0001"")).isPresent().get().satisfies(definition -> {
            assertThat(definition.title()).isEqualTo(existingJobDefinition.title());
            assertThat(definition.description()).isEqualTo(existingJobDefinition.description());
        });

        // Reset all before doing new stubs
        reset(eventDefinitionService);
        reset(jobDefinitionService);
        reset(jobTriggerService);

        doThrow(new NullPointerException(""yolo2"")).when(jobDefinitionService).save(any());

        assertThatCode(() -> handler.update(updatedDto, true))
                .isInstanceOf(NullPointerException.class)
                .hasMessageContaining(""yolo2"");

        assertThat(eventDefinitionService.get(existingDto.id())).isPresent().get().satisfies(dto -> {
            assertThat(dto.id()).isEqualTo(existingDto.id());
            assertThat(dto.title()).isEqualTo(existingDto.title());
            assertThat(dto.description()).isEqualTo(existingDto.description());
        });

        assertThat(jobDefinitionService.get(""54e3deadbeefdeadbeef0001"")).isPresent().get().satisfies(definition -> {
            assertThat(definition.title()).isEqualTo(existingJobDefinition.title());
            assertThat(definition.description()).isEqualTo(existingJobDefinition.description());
        });

        // Reset all before doing new stubs
        reset(eventDefinitionService);
        reset(jobDefinitionService);
        reset(jobTriggerService);

        doThrow(new NullPointerException(""yolo3"")).when(jobTriggerService).update(any());

        assertThatCode(() -> handler.update(updatedDto, true))
                .isInstanceOf(NullPointerException.class)
                .hasMessageContaining(""yolo3"");

        assertThat(eventDefinitionService.get(existingDto.id())).isPresent().get().satisfies(dto -> {
            assertThat(dto.id()).isEqualTo(existingDto.id());
            assertThat(dto.title()).isEqualTo(existingDto.title());
            assertThat(dto.description()).isEqualTo(existingDto.description());
        });

        assertThat(jobDefinitionService.get(""54e3deadbeefdeadbeef0001"")).isPresent().get().satisfies(definition -> {
            assertThat(definition.title()).isEqualTo(existingJobDefinition.title());
            assertThat(definition.description()).isEqualTo(existingJobDefinition.description());
        });
    }
",non-flaky,5
86087,graylog2_graylog2-server,EventDefinitionHandlerTest.delete,"    @Test
    public void delete() {
        assertThat(eventDefinitionService.get(""54e3deadbeefdeadbeef0000"")).isPresent();
        assertThat(jobDefinitionService.get(""54e3deadbeefdeadbeef0001"")).isPresent();
        assertThat(jobTriggerService.get(""54e3deadbeefdeadbeef0002"")).isPresent();

        assertThat(handler.delete(""54e3deadbeefdeadbeef0000"")).isTrue();

        assertThat(eventDefinitionService.get(""54e3deadbeefdeadbeef0000"")).isNotPresent();
        assertThat(jobDefinitionService.get(""54e3deadbeefdeadbeef0001"")).isNotPresent();
        assertThat(jobTriggerService.get(""54e3deadbeefdeadbeef0002"")).isNotPresent();
    }
",non-flaky,5
86088,graylog2_graylog2-server,EventDefinitionHandlerTest.schedule,"    @Test
    public void schedule() {
        assertThat(eventDefinitionService.get(""54e3deadbeefdeadbeef0000"")).isPresent();
        assertThat(jobDefinitionService.streamAll().count()).isEqualTo(0);
        assertThat(jobTriggerService.all()).isEmpty();

        handler.schedule(""54e3deadbeefdeadbeef0000"");

        assertThat(eventDefinitionService.get(""54e3deadbeefdeadbeef0000"")).isPresent();

        assertThat(jobDefinitionService.getByConfigField(""event_definition_id"", ""54e3deadbeefdeadbeef0000""))
                .get()
                .satisfies(definition -> {
                    assertThat(definition.title()).isEqualTo(""Test"");
                    assertThat(definition.description()).isEqualTo(""A test event definition"");
                    assertThat(definition.config()).isInstanceOf(EventProcessorExecutionJob.Config.class);

                    final EventProcessorExecutionJob.Config config = (EventProcessorExecutionJob.Config) definition.config();


                    assertThat(config.processingWindowSize()).isEqualTo(300000);
                    assertThat(config.processingHopSize()).isEqualTo(60000);

                    assertThat(jobTriggerService.nextRunnableTrigger()).get().satisfies(trigger -> {
                        assertThat(trigger.jobDefinitionId()).isEqualTo(definition.id());
                        assertThat(trigger.schedule()).isInstanceOf(IntervalJobSchedule.class);

                        final IntervalJobSchedule schedule = (IntervalJobSchedule) trigger.schedule();

                        assertThat(schedule.interval()).isEqualTo(60000);
                        assertThat(schedule.unit()).isEqualTo(TimeUnit.MILLISECONDS);
                    });
                });


        assertThat(jobDefinitionService.get(""54e3deadbeefdeadbeef0001"")).isNotPresent();
        assertThat(jobTriggerService.get(""54e3deadbeefdeadbeef0002"")).isNotPresent();
    }
",non-flaky,5
86089,graylog2_graylog2-server,EventDefinitionHandlerTest.scheduleWithMissingEventDefinition,"    @Test
    public void scheduleWithMissingEventDefinition() {
        final String id = ""54e3deadbeefdeadbeef9999"";

        // The event definition should not exist so our test works
        assertThat(eventDefinitionService.get(id)).isNotPresent();

        assertThatThrownBy(() -> handler.schedule(id))
                .hasMessageContaining(""doesn't exist"")
                .isInstanceOf(IllegalArgumentException.class);
    }
",non-flaky,5
86090,graylog2_graylog2-server,EventDefinitionHandlerTest.unschedule,"    @Test
    public void unschedule() {
        assertThat(eventDefinitionService.get(""54e3deadbeefdeadbeef0000"")).isPresent();
        assertThat(jobDefinitionService.get(""54e3deadbeefdeadbeef0001"")).isPresent();
        assertThat(jobTriggerService.get(""54e3deadbeefdeadbeef0002"")).isPresent();

        handler.unschedule(""54e3deadbeefdeadbeef0000"");

        // Unschedule should NOT delete the event definition!
        assertThat(eventDefinitionService.get(""54e3deadbeefdeadbeef0000"")).isPresent();

        // Only the job definition and the trigger
        assertThat(jobDefinitionService.get(""54e3deadbeefdeadbeef0001"")).isNotPresent();
        assertThat(jobTriggerService.get(""54e3deadbeefdeadbeef0002"")).isNotPresent();
    }
",non-flaky,5
86091,graylog2_graylog2-server,EventDefinitionHandlerTest.unscheduleWithMissingEventDefinition,"    @Test
    public void unscheduleWithMissingEventDefinition() {
        final String id = ""54e3deadbeefdeadbeef9999"";

        // The event definition should not exist so our test works
        assertThat(eventDefinitionService.get(id)).isNotPresent();

        assertThatThrownBy(() -> handler.unschedule(id))
                .hasMessageContaining(""doesn't exist"")
                .isInstanceOf(IllegalArgumentException.class);
    }
",non-flaky,5
86092,graylog2_graylog2-server,EventDefinitionDtoTest.testValidateWithEmptyTitle,"    @Test
    public void testValidateWithEmptyTitle() {
        final EventDefinitionDto invalidEventDefinition = testSubject.toBuilder()
            .title("""")
            .build();
        final ValidationResult validationResult = invalidEventDefinition.validate();
        assertThat(validationResult.failed()).isTrue();
        assertThat(validationResult.getErrors()).containsOnlyKeys(""title"");
    }
",non-flaky,5
86093,graylog2_graylog2-server,EventDefinitionDtoTest.testValidateWithEmptyConfigType,"    @Test
    public void testValidateWithEmptyConfigType() {
        final EventDefinitionDto invalidEventDefinition = testSubject.toBuilder()
            .config(new EventProcessorConfig.FallbackConfig())
            .build();
        final ValidationResult validationResult = invalidEventDefinition.validate();
        assertThat(validationResult.failed()).isTrue();
        assertThat(validationResult.getErrors()).containsOnlyKeys(""config"");
    }
",non-flaky,5
86094,graylog2_graylog2-server,EventDefinitionDtoTest.testValidateWithInvalidConfig,"    @Test
    public void testValidateWithInvalidConfig() {
        final AggregationEventProcessorConfig configMock = mock(AggregationEventProcessorConfig.class);
        final ValidationResult mockedValidationResult = new ValidationResult();
        mockedValidationResult.addError(""foo"", ""bar"");
        when(configMock.validate()).thenReturn(mockedValidationResult);

        final EventDefinitionDto invalidEventDefinition = testSubject.toBuilder()
            .config(configMock)
            .build();
        final ValidationResult validationResult = invalidEventDefinition.validate();
        assertThat(validationResult.failed()).isTrue();
        assertThat(validationResult.getErrors()).containsOnlyKeys(""foo"");
    }
",non-flaky,5
86095,graylog2_graylog2-server,EventDefinitionDtoTest.testValidateWithInvalidFieldName,"    @Test
    public void testValidateWithInvalidFieldName() {
        final EventFieldSpec fieldSpecMock = mock(EventFieldSpec.class);
        final EventDefinitionDto invalidEventDefinition = testSubject.toBuilder()
            .fieldSpec(ImmutableMap.of(""foo\\bar"", fieldSpecMock, ""$yo&^a"", fieldSpecMock))
            .build();
        final ValidationResult validationResult = invalidEventDefinition.validate();
        assertThat(validationResult.failed()).isTrue();
        assertThat(validationResult.getErrors()).containsOnlyKeys(""field_spec"");
        final List<String> fieldValidation = (List<String>) validationResult.getErrors().get(""field_spec"");
        assertThat(fieldValidation.size()).isEqualTo(2);
        assertThat(fieldValidation.get(0)).contains(""foo\\bar"");
        assertThat(fieldValidation.get(1)).contains(""$yo&^a"");
    }
",non-flaky,5
86096,graylog2_graylog2-server,EventDefinitionDtoTest.testValidateWithKeySpecNotInFieldSpec,"    @Test
    public void testValidateWithKeySpecNotInFieldSpec() {
        final EventFieldSpec fieldSpecMock = mock(EventFieldSpec.class);
        final EventDefinitionDto invalidEventDefinition = testSubject.toBuilder()
            .fieldSpec(ImmutableMap.of(""bar"", fieldSpecMock, ""baz"", fieldSpecMock))
            .keySpec(ImmutableList.of(""foo""))
            .build();
        final ValidationResult validationResult = invalidEventDefinition.validate();
        assertThat(validationResult.failed()).isTrue();
        assertThat(validationResult.getErrors()).containsOnlyKeys(""key_spec"");
    }
",non-flaky,5
86097,graylog2_graylog2-server,EventDefinitionDtoTest.testValidEventDefinition,"    @Test
    public void testValidEventDefinition() {
        final ValidationResult validationResult = testSubject.validate();
        assertThat(validationResult.failed()).isFalse();
        assertThat(validationResult.getErrors().size()).isEqualTo(0);
    }
",non-flaky,5
86098,graylog2_graylog2-server,EventDefinitionDtoTest.testValidEventDefinitionWithKeySpecInFieldSpec,"    @Test
    public void testValidEventDefinitionWithKeySpecInFieldSpec() {
        final EventFieldSpec fieldSpecMock = mock(EventFieldSpec.class);
        final EventDefinitionDto invalidEventDefinition = testSubject.toBuilder()
            .fieldSpec(ImmutableMap.of(""foo"", fieldSpecMock, ""bar"", fieldSpecMock))
            .keySpec(ImmutableList.of(""foo"", ""bar""))
            .build();
        final ValidationResult validationResult = invalidEventDefinition.validate();
        assertThat(validationResult.failed()).isFalse();
        assertThat(validationResult.getErrors().size()).isEqualTo(0);
    }
",non-flaky,5
86099,graylog2_graylog2-server,EventProcessorDtoTest.type,"    @Test
    public void automaticallyAddsPersistToStreamsStorageHandler() {
        final EventStorageHandler.Config testStorageHandlerConfig = new EventStorageHandler.Config() {
            @Override
            public String type() {
                return ""storage-test"";
            }
",non-flaky,5
86100,graylog2_graylog2-server,DBEventProcessorServiceTest.loadPersisted,"    @Test
    public void loadPersisted() {
        final List<EventDefinitionDto> dtos = dbService.streamAll().collect(Collectors.toList());

        assertThat(dtos).hasSize(1);

        assertThat(dtos.get(0)).satisfies(dto -> {
            assertThat(dto.id()).isNotBlank();
            assertThat(dto.title()).isEqualTo(""Test"");
            assertThat(dto.description()).isEqualTo(""A test event definition"");
            assertThat(dto.priority()).isEqualTo(2);
            assertThat(dto.keySpec()).isEqualTo(ImmutableList.of(""username""));
            assertThat(dto.fieldSpec()).isEmpty();
            assertThat(dto.notifications()).isEmpty();
            assertThat(dto.storage()).hasSize(1);

            assertThat(dto.config()).isInstanceOf(TestEventProcessorConfig.class);
            assertThat(dto.config()).satisfies(abstractConfig -> {
                final TestEventProcessorConfig config = (TestEventProcessorConfig) abstractConfig;

                assertThat(config.type()).isEqualTo(""__test_event_processor_config__"");
                assertThat(config.message()).isEqualTo(""This is a test event processor"");
            });
        });
    }
",non-flaky,5
86101,graylog2_graylog2-server,DBEventProcessorServiceTest.save,"    @Test
    public void save() {
        final EventDefinitionDto newDto = EventDefinitionDto.builder()
                .title(""Test"")
                .description(""A test event definition"")
                .config(TestEventProcessorConfig.builder()
                        .message(""This is a test event processor"")
                        .searchWithinMs(1000)
                        .executeEveryMs(1000)
                        .build())
                .priority(3)
                .alert(false)
                .notificationSettings(EventNotificationSettings.withGracePeriod(60000))
                .keySpec(ImmutableList.of(""a"", ""b""))
                .notifications(ImmutableList.of())
                .build();

        final EventDefinitionDto dto = dbService.save(newDto);

        assertThat(dto.id()).isNotBlank();
        assertThat(dto.title()).isEqualTo(""Test"");
        assertThat(dto.description()).isEqualTo(""A test event definition"");
        assertThat(dto.priority()).isEqualTo(3);
        assertThat(dto.keySpec()).isEqualTo(ImmutableList.of(""a"", ""b""));
        assertThat(dto.fieldSpec()).isEmpty();
        assertThat(dto.notifications()).isEmpty();
        assertThat(dto.storage()).hasSize(1);
        // We will always add a persist-to-streams handler for now
        assertThat(dto.storage()).containsOnly(PersistToStreamsStorageHandler.Config.createWithDefaultEventsStream());
    }
",non-flaky,5
86102,graylog2_graylog2-server,DBEventProcessorStateServiceTest.persistence,"    @Test
    public void persistence() {
        final DateTime now = DateTime.now(DateTimeZone.UTC);
        final DateTime min = now.minusHours(1);
        final DateTime max = now;

        final EventProcessorStateDto stateDto = EventProcessorStateDto.builder()
                .eventDefinitionId(""abc123"")
                .minProcessedTimestamp(min)
                .maxProcessedTimestamp(max)
                .build();

        assertThat(stateService.setState(stateDto)).isPresent().get().satisfies(dto -> {
            assertThat(dto.id()).isNotBlank();
            assertThat(dto.eventDefinitionId()).isEqualTo(""abc123"");
            assertThat(dto.minProcessedTimestamp()).isEqualTo(min);
            assertThat(dto.maxProcessedTimestamp()).isEqualTo(max);
        });

        assertThatThrownBy(() -> stateService.setState("""", min, max))
                .hasMessageContaining(""eventDefinitionId"")
                .isInstanceOf(IllegalArgumentException.class);
        assertThatThrownBy(() -> stateService.setState(null, min, max))
                .hasMessageContaining(""eventDefinitionId"")
                .isInstanceOf(IllegalArgumentException.class);

        assertThatThrownBy(() -> stateService.setState(""a"", null, max))
                .hasMessageContaining(""minProcessedTimestamp"")
                .isInstanceOf(IllegalArgumentException.class);

        assertThatThrownBy(() -> stateService.setState(""a"", min, null))
                .hasMessageContaining(""maxProcessedTimestamp"")
                .isInstanceOf(IllegalArgumentException.class);

        // A max timestamp that is older than the min timestamp is an error! (e.g. mixing up arguments)
        assertThatThrownBy(() -> stateService.setState(""a"", max, min))
                .hasMessageContaining(""minProcessedTimestamp"")
                .hasMessageContaining(""maxProcessedTimestamp"")
                .isInstanceOf(IllegalArgumentException.class);
    }
",non-flaky,5
86103,graylog2_graylog2-server,DBEventProcessorStateServiceTest.loading,"    @Test
    public void loading() {
        final Optional<EventProcessorStateDto> stateDto = stateService.findByEventDefinitionId(""54e3deadbeefdeadbeefaff3"");

        assertThat(stateDto).isPresent().get().satisfies(dto -> {
            assertThat(dto.id()).isEqualTo(""54e3deadbeefdeadbeefaffe"");
            assertThat(dto.eventDefinitionId()).isEqualTo(""54e3deadbeefdeadbeefaff3"");
            assertThat(dto.minProcessedTimestamp()).isEqualTo(DateTime.parse(""2019-01-01T00:00:00.000Z""));
            assertThat(dto.maxProcessedTimestamp()).isEqualTo(DateTime.parse(""2019-01-01T01:00:00.000Z""));
        });
    }
",non-flaky,5
86104,graylog2_graylog2-server,DBEventProcessorStateServiceTest.findByEventProcessorId,"    @Test
    public void findByEventProcessorId() {
        assertThat(stateService.findByEventDefinitionId(""54e3deadbeefdeadbeefaff3"")).isPresent();

        assertThat(stateService.findByEventDefinitionId(""nope"")).isNotPresent();

        assertThatThrownBy(() -> stateService.findByEventDefinitionId(null))
                .hasMessageContaining(""eventDefinitionId"")
                .isInstanceOf(IllegalArgumentException.class);

        assertThatThrownBy(() -> stateService.findByEventDefinitionId(""""))
                .hasMessageContaining(""eventDefinitionId"")
                .isInstanceOf(IllegalArgumentException.class);
    }
",non-flaky,5
86105,graylog2_graylog2-server,DBEventProcessorStateServiceTest.findByEventProcessorsAndMaxTimestamp,"    @Test
    public void findByEventProcessorsAndMaxTimestamp() {
        assertThat(stateService.findByEventDefinitionId(""54e3deadbeefdeadbeefaff3"")).isPresent().get().satisfies(dto -> {
            final DateTime maxTs = dto.maxProcessedTimestamp();
            final String id = dto.eventDefinitionId();

            assertThat(stateService.findByEventDefinitionsAndMaxTimestamp(ImmutableSet.of(id), maxTs))
                    .hasSize(1);
            assertThat(stateService.findByEventDefinitionsAndMaxTimestamp(ImmutableSet.of(id), maxTs.minusHours(1)))
                    .hasSize(1);
            assertThat(stateService.findByEventDefinitionsAndMaxTimestamp(ImmutableSet.of(id), maxTs.plusHours(1)))
                    .hasSize(0);

            assertThatThrownBy(() -> stateService.findByEventDefinitionsAndMaxTimestamp(ImmutableSet.of(), maxTs))
                    .isInstanceOf(IllegalArgumentException.class);
            assertThatThrownBy(() -> stateService.findByEventDefinitionsAndMaxTimestamp(null, maxTs))
                    .isInstanceOf(IllegalArgumentException.class);
            assertThatThrownBy(() -> stateService.findByEventDefinitionsAndMaxTimestamp(ImmutableSet.of(id), null))
                    .isInstanceOf(IllegalArgumentException.class);

            assertThat(stateService.findByEventDefinitionsAndMaxTimestamp(ImmutableSet.of(""nope""), maxTs))
                    .hasSize(0);
            assertThat(stateService.findByEventDefinitionsAndMaxTimestamp(ImmutableSet.of(id, ""nope""), maxTs))
                    .hasSize(1);
        });
    }
",non-flaky,5
86106,graylog2_graylog2-server,DBEventProcessorStateServiceTest.setState,"    @Test
    public void setState() {
        final DateTime now = DateTime.now(DateTimeZone.UTC);

        // Before we set the state, there should be no record
        assertThat(stateService.findByEventDefinitionId(""yolo"")).isNotPresent();

        assertThat(stateService.setState(""yolo"", now.minusHours(1), now))
                .isPresent()
                .get()
                .satisfies(dto1 -> {
                    assertThat(dto1.minProcessedTimestamp()).isEqualTo(now.minusHours(1));
                    assertThat(dto1.maxProcessedTimestamp()).isEqualTo(now);
                    assertThat(dto1.eventDefinitionId()).isEqualTo(""yolo"");

                    assertThat(stateService.setState(""yolo"", now, now.plusHours(1)))
                            .isPresent()
                            .get()
                            .satisfies(dto2 -> {
                                // The second setState call should update the existing one
                                assertThat(dto2.id()).isEqualTo(dto1.id());
                                assertThat(dto2.eventDefinitionId()).isEqualTo(""yolo"");
                                assertThat(dto2.minProcessedTimestamp()).isEqualTo(dto1.minProcessedTimestamp());
                                assertThat(dto2.maxProcessedTimestamp()).isEqualTo(dto1.maxProcessedTimestamp().plusHours(1));
                            });
                });
    }
",non-flaky,5
86107,graylog2_graylog2-server,DBEventProcessorStateServiceTest.setStateKeepsMinMaxTimestamp,"    @Test
    public void setStateKeepsMinMaxTimestamp() {
        final DateTime now = DateTime.now(DateTimeZone.UTC);
        final DateTime min = now.minusHours(1);
        final DateTime max = now;

        // Before we set the state, there should be no record
        assertThat(stateService.findByEventDefinitionId(""yolo"")).isNotPresent();

        // Create state
        stateService.setState(""yolo"", min, now);

        // Check that it has been created
        assertThat(stateService.findByEventDefinitionId(""yolo""))
                .isPresent()
                .get()
                .satisfies(dto -> {
                    assertThat(dto.minProcessedTimestamp()).isEqualTo(min);
                    assertThat(dto.maxProcessedTimestamp()).isEqualTo(now);
                });

        // Overwrite state with an EARLIER max timestamp
        stateService.setState(""yolo"", min, max.minusMinutes(10));

        // Max timestamp should NOT be overwritten by older timestamp
        assertThat(stateService.findByEventDefinitionId(""yolo""))
                .isPresent()
                .get()
                .satisfies(dto -> {
                    assertThat(dto.minProcessedTimestamp()).isEqualTo(min);
                    assertThat(dto.maxProcessedTimestamp()).isEqualTo(max);
                });

        // Overwrite state with a LATER min timestamp
        stateService.setState(""yolo"", min.plusMinutes(5), max);

        // Min timestamp should NOT be overwritten by younger timestamp
        assertThat(stateService.findByEventDefinitionId(""yolo""))
                .isPresent()
                .get()
                .satisfies(dto -> {
                    assertThat(dto.minProcessedTimestamp()).isEqualTo(min);
                    assertThat(dto.maxProcessedTimestamp()).isEqualTo(max);
                });

        // Overwrite state with a NEWER max timestamp
        stateService.setState(""yolo"", min, max.plusDays(10));

        // Max timestamp is now set to the newer one
        assertThat(stateService.findByEventDefinitionId(""yolo""))
                .isPresent()
                .get()
                .satisfies(dto -> {
                    assertThat(dto.minProcessedTimestamp()).isEqualTo(min);
                    assertThat(dto.maxProcessedTimestamp()).isEqualTo(max.plusDays(10));
                });

        // Overwrite state with an OLDER min timestamp
        stateService.setState(""yolo"", min.minusDays(100), max.plusDays(10));

        // Min timestamp is now set to the older one
        assertThat(stateService.findByEventDefinitionId(""yolo""))
                .isPresent()
                .get()
                .satisfies(dto -> {
                    assertThat(dto.minProcessedTimestamp()).isEqualTo(min.minusDays(100));
                    assertThat(dto.maxProcessedTimestamp()).isEqualTo(max.plusDays(10));
                });
    }
",non-flaky,5
86108,graylog2_graylog2-server,DBEventProcessorStateServiceTest.deleteByEventProcessorId,"    @Test
    public void deleteByEventProcessorId() {
        assertThat(stateService.deleteByEventDefinitionId(""54e3deadbeefdeadbeefaff3"")).isEqualTo(1);
        assertThat(stateService.deleteByEventDefinitionId(""nope"")).isEqualTo(0);
    }
",non-flaky,5
86109,graylog2_graylog2-server,NotificationFacadeTest.exportEntity,"    @Test
    public void exportEntity() {
        final ModelId id = ModelId.of(""5d4d33753d27460ad18e0c4d"");
        final EntityDescriptor descriptor = EntityDescriptor.create(id, ModelTypes.NOTIFICATION_V1);
        final EntityDescriptorIds entityDescriptorIds = EntityDescriptorIds.of(descriptor);
        final Optional<Entity> entity = facade.exportEntity(descriptor, entityDescriptorIds);
        assertThat(entity).isPresent();
        final EntityV1 entityV1 = (EntityV1) entity.get();
        final NotificationEntity notificationEntity = objectMapper.convertValue(entityV1.data(),
                NotificationEntity.class);
        assertThat(notificationEntity.title().asString()).isEqualTo(""title"");
        assertThat(notificationEntity.description().asString()).isEqualTo(""description"");
        assertThat(notificationEntity.config().type()).isEqualTo(""email-notification-v1"");
    }
",non-flaky,5
86110,graylog2_graylog2-server,NotificationFacadeTest.createNativeEntity,"    @Test
    public void createNativeEntity() {
        final EntityV1 entityV1 = createTestEntity();
        final JobDefinitionDto jobDefinitionDto = mock(JobDefinitionDto.class);

        when(jobDefinitionService.save(any(JobDefinitionDto.class))).thenReturn(jobDefinitionDto);
        final UserImpl kmerzUser = new UserImpl(mock(PasswordAlgorithmFactory.class), new Permissions(ImmutableSet.of()), ImmutableMap.of(""username"", ""kmerz""));
        when(userService.load(""kmerz"")).thenReturn(kmerzUser);

        final NativeEntity<NotificationDto> nativeEntity = facade.createNativeEntity(
            entityV1,
            ImmutableMap.of(),
            ImmutableMap.of(),
            ""kmerz"");
        assertThat(nativeEntity).isNotNull();

        final NotificationDto notificationDto = nativeEntity.entity();
        assertThat(notificationDto.title()).isEqualTo(""title"");
        assertThat(notificationDto.description()).isEqualTo(""descriptions"");
        assertThat(notificationDto.config().type()).isEqualTo(""http-notification-v1"");
    }
",non-flaky,5
86111,graylog2_graylog2-server,NotificationFacadeTest.loadNativeEntity,"    @Test
    public void loadNativeEntity() {
        final NativeEntityDescriptor nativeEntityDescriptor = NativeEntityDescriptor.create(
                ModelId.of(""content-pack-id""),
                ModelId.of(""5d4d33753d27460ad18e0c4d""),
                ModelTypes.NOTIFICATION_V1,
                ""title"");
        final Optional<NativeEntity<NotificationDto>> optionalNativeEntity = facade.loadNativeEntity(
                nativeEntityDescriptor);
        assertThat(optionalNativeEntity).isPresent();
        final NativeEntity<NotificationDto> nativeEntity = optionalNativeEntity.get();
        assertThat(nativeEntity.entity()).isNotNull();
        final NotificationDto notificationDto = nativeEntity.entity();
        assertThat(notificationDto.id()).isEqualTo(""5d4d33753d27460ad18e0c4d"");
    }
",non-flaky,5
86112,graylog2_graylog2-server,NotificationFacadeTest.createExcerpt,"    @Test
    public void createExcerpt() {
        final Optional<NotificationDto> notificationDto = notificationService.get(
                ""5d4d33753d27460ad18e0c4d"");
        assertThat(notificationDto).isPresent();
        final EntityExcerpt excerpt = facade.createExcerpt(notificationDto.get());
        assertThat(excerpt.title()).isEqualTo(""title"");
        assertThat(excerpt.id()).isEqualTo(ModelId.of(""5d4d33753d27460ad18e0c4d""));
        assertThat(excerpt.type()).isEqualTo(ModelTypes.NOTIFICATION_V1);
    }
",non-flaky,5
86113,graylog2_graylog2-server,NotificationFacadeTest.listExcerpts,"    @Test
    public void listExcerpts() {
        final Set<EntityExcerpt> excerpts = facade.listEntityExcerpts();
        final EntityExcerpt excerpt = excerpts.iterator().next();
        assertThat(excerpt.title()).isEqualTo(""title"");
        assertThat(excerpt.id()).isEqualTo(ModelId.of(""5d4d33753d27460ad18e0c4d""));
        assertThat(excerpt.type()).isEqualTo(ModelTypes.NOTIFICATION_V1);
    }
",non-flaky,5
86114,graylog2_graylog2-server,NotificationFacadeTest.delete,"    @Test
    public void delete() {
        long countBefore = notificationService.streamAll().count();
        assertThat(countBefore).isEqualTo(1);

        final Optional<NotificationDto> notificationDto = notificationService.get(
                ""5d4d33753d27460ad18e0c4d"");
        assertThat(notificationDto).isPresent();
        facade.delete(notificationDto.get());

        long countAfter = notificationService.streamAll().count();
        assertThat(countAfter).isEqualTo(0);
    }
",non-flaky,5
86115,graylog2_graylog2-server,EventDefinitionFacadeTest.exportEntity,"    @Test
    public void exportEntity() {
        final ModelId id = ModelId.of(""5d4032513d2746703d1467f6"");

        when(jobDefinitionService.getByConfigField(eq(""event_definition_id""), eq(id.id())))
                .thenReturn(Optional.of(mock(JobDefinitionDto.class)));

        final EntityDescriptor descriptor = EntityDescriptor.create(id, ModelTypes.EVENT_DEFINITION_V1);
        final EntityDescriptorIds entityDescriptorIds = EntityDescriptorIds.of(descriptor);
        final Optional<Entity> entity = facade.exportEntity(descriptor, entityDescriptorIds);
        assertThat(entity).isPresent();
        final EntityV1 entityV1 = (EntityV1) entity.get();
        final EventDefinitionEntity eventDefinitionEntity = objectMapper.convertValue(entityV1.data(),
                EventDefinitionEntity.class);
        assertThat(eventDefinitionEntity.title().asString()).isEqualTo(""title"");
        assertThat(eventDefinitionEntity.description().asString()).isEqualTo(""description"");
        assertThat(eventDefinitionEntity.config().type()).isEqualTo(AggregationEventProcessorConfigEntity.TYPE_NAME);
        assertThat(eventDefinitionEntity.isScheduled().asBoolean(ImmutableMap.of())).isTrue();
    }
",non-flaky,5
86116,graylog2_graylog2-server,EventDefinitionFacadeTest.exportEntityWithoutScheduling,"    @Test
    public void exportEntityWithoutScheduling() {
        final ModelId id = ModelId.of(""5d4032513d2746703d1467f6"");

        when(jobDefinitionService.getByConfigField(eq(""event_definition_id""), eq(id.id())))
                .thenReturn(Optional.empty());

        final EntityDescriptor descriptor = EntityDescriptor.create(id, ModelTypes.EVENT_DEFINITION_V1);
        final EntityDescriptorIds entityDescriptorIds = EntityDescriptorIds.of(descriptor);
        final Optional<Entity> entity = facade.exportEntity(descriptor, entityDescriptorIds);
        assertThat(entity).isPresent();
        final EntityV1 entityV1 = (EntityV1) entity.get();
        final EventDefinitionEntity eventDefinitionEntity = objectMapper.convertValue(entityV1.data(),
                EventDefinitionEntity.class);
        assertThat(eventDefinitionEntity.title().asString()).isEqualTo(""title"");
        assertThat(eventDefinitionEntity.description().asString()).isEqualTo(""description"");
        assertThat(eventDefinitionEntity.config().type()).isEqualTo(AggregationEventProcessorConfigEntity.TYPE_NAME);
        assertThat(eventDefinitionEntity.isScheduled().asBoolean(ImmutableMap.of())).isFalse();
    }
",non-flaky,5
86117,graylog2_graylog2-server,EventDefinitionFacadeTest.createNativeEntity,"    @Test
    public void createNativeEntity() {
        final EntityV1 entityV1 = createTestEntity();
        final NotificationDto notificationDto = NotificationDto.builder()
                .config(HTTPEventNotificationConfig.builder().url(""https://hulud.net"").build())
                .title(""Notify me Senpai"")
                .description(""A notification for senpai"")
                .id(""dead-beef"")
                .build();
        final EntityDescriptor entityDescriptor = EntityDescriptor.create(""123123"", ModelTypes.NOTIFICATION_V1);
        final ImmutableMap<EntityDescriptor, Object> nativeEntities = ImmutableMap.of(
                entityDescriptor, notificationDto);

        final JobDefinitionDto jobDefinitionDto = mock(JobDefinitionDto.class);
        final JobTriggerDto jobTriggerDto = mock(JobTriggerDto.class);
        when(jobDefinitionDto.id()).thenReturn(""job-123123"");
        when(jobSchedulerClock.nowUTC()).thenReturn(DateTime.now(DateTimeZone.UTC));
        when(jobDefinitionService.save(any(JobDefinitionDto.class))).thenReturn(jobDefinitionDto);
        when(jobTriggerService.create(any(JobTriggerDto.class))).thenReturn(jobTriggerDto);
        final UserImpl kmerzUser = new UserImpl(mock(PasswordAlgorithmFactory.class), new Permissions(ImmutableSet.of()), ImmutableMap.of(""username"", ""kmerz""));
        when(userService.load(""kmerz"")).thenReturn(kmerzUser);


        final NativeEntity<EventDefinitionDto> nativeEntity = facade.createNativeEntity(
                entityV1,
                ImmutableMap.of(),
                nativeEntities,
                ""kmerz"");
        assertThat(nativeEntity).isNotNull();

        final EventDefinitionDto eventDefinitionDto = nativeEntity.entity();
        assertThat(eventDefinitionDto.title()).isEqualTo(""title"");
        assertThat(eventDefinitionDto.description()).isEqualTo(""description"");
        assertThat(eventDefinitionDto.config().type()).isEqualTo(""aggregation-v1"");
        // verify that ownership was registered for this entity
        verify(entityOwnershipService, times(1)).registerNewEventDefinition(nativeEntity.entity().id(), kmerzUser);
    }
",non-flaky,5
86118,graylog2_graylog2-server,EventDefinitionFacadeTest.loadNativeEntity,"    @Test
    public void loadNativeEntity() {
        final NativeEntityDescriptor nativeEntityDescriptor = NativeEntityDescriptor
                .create(ModelId.of(""content-pack-id""),
                        ModelId.of(""5d4032513d2746703d1467f6""),
                        ModelTypes.EVENT_DEFINITION_V1,
                        ""title"");
        final Optional<NativeEntity<EventDefinitionDto>> optionalNativeEntity = facade.loadNativeEntity(nativeEntityDescriptor);
        assertThat(optionalNativeEntity).isPresent();
        final NativeEntity<EventDefinitionDto> nativeEntity = optionalNativeEntity.get();
        assertThat(nativeEntity.entity()).isNotNull();
        final EventDefinitionDto eventDefinition = nativeEntity.entity();
        assertThat(eventDefinition.id()).isEqualTo(""5d4032513d2746703d1467f6"");
    }
",non-flaky,5
86119,graylog2_graylog2-server,EventDefinitionFacadeTest.createExcerpt,"    @Test
    public void createExcerpt() {
        final Optional<EventDefinitionDto> eventDefinitionDto = eventDefinitionService.get(
                ""5d4032513d2746703d1467f6"");
        assertThat(eventDefinitionDto).isPresent();
        final EntityExcerpt excerpt = facade.createExcerpt(eventDefinitionDto.get());
        assertThat(excerpt.title()).isEqualTo(""title"");
        assertThat(excerpt.id()).isEqualTo(ModelId.of(""5d4032513d2746703d1467f6""));
        assertThat(excerpt.type()).isEqualTo(ModelTypes.EVENT_DEFINITION_V1);
    }
",non-flaky,5
86120,graylog2_graylog2-server,EventDefinitionFacadeTest.listExcerpts,"    @Test
    public void listExcerpts() {
        final Set<EntityExcerpt> excerpts = facade.listEntityExcerpts();
        final EntityExcerpt excerpt = excerpts.iterator().next();
        assertThat(excerpt.title()).isEqualTo(""title"");
        assertThat(excerpt.id()).isEqualTo(ModelId.of(""5d4032513d2746703d1467f6""));
        assertThat(excerpt.type()).isEqualTo(ModelTypes.EVENT_DEFINITION_V1);
    }
",non-flaky,5
86121,graylog2_graylog2-server,EventDefinitionFacadeTest.delete,"    @Test
    public void delete() {
        long countBefore = eventDefinitionService.streamAll().count();
        assertThat(countBefore).isEqualTo(1);

        final Optional<EventDefinitionDto> eventDefinitionDto = eventDefinitionService.get(
                ""5d4032513d2746703d1467f6"");
        assertThat(eventDefinitionDto).isPresent();
        facade.delete(eventDefinitionDto.get());

        long countAfter = eventDefinitionService.streamAll().count();
        assertThat(countAfter).isEqualTo(0);
    }
",non-flaky,5
86122,graylog2_graylog2-server,EventDefinitionFacadeTest.resolveNativeEntity,"    @Test
    public void resolveNativeEntity() {
        EntityDescriptor eventDescriptor = EntityDescriptor
                .create(""5d4032513d2746703d1467f6"", ModelTypes.EVENT_DEFINITION_V1);
        EntityDescriptor streamDescriptor = EntityDescriptor
                .create(""5cdab2293d27467fbe9e8a72"", ModelTypes.STREAM_V1);
        Set<EntityDescriptor> expectedNodes = ImmutableSet.of(eventDescriptor, streamDescriptor);
        Graph<EntityDescriptor> graph = facade.resolveNativeEntity(eventDescriptor);
        assertThat(graph).isNotNull();
        Set<EntityDescriptor> nodes = graph.nodes();
        assertThat(nodes).isEqualTo(expectedNodes);
    }
",non-flaky,5
86123,graylog2_graylog2-server,EventDefinitionFacadeTest.resolveForInstallation,"    @Test
    public void resolveForInstallation() {
        EntityV1 eventEntityV1 = createTestEntity();

        final NotificationEntity notificationEntity = NotificationEntity.builder()
                .title(ValueReference.of(""title""))
                .description(ValueReference.of(""description""))
                .config(HttpEventNotificationConfigEntity.builder()
                        .url(ValueReference.of(""http://url"")).build())
                .build();
        final JsonNode data = objectMapper.convertValue(notificationEntity, JsonNode.class);
        final EntityV1 notificationV1 = EntityV1.builder()
                .data(data)
                .id(ModelId.of(""123123""))
                .type(ModelTypes.EVENT_DEFINITION_V1)
                .build();

        final EntityDescriptor entityDescriptor = EntityDescriptor.create(""123123"", ModelTypes.NOTIFICATION_V1);

        Map<String, ValueReference> parameters = ImmutableMap.of();
        Map<EntityDescriptor, Entity> entities = ImmutableMap.of(entityDescriptor, notificationV1);

        Graph<Entity> graph = facade.resolveForInstallation(eventEntityV1, parameters, entities);
        assertThat(graph).isNotNull();
        Set<Entity> expectedNodes = ImmutableSet.of(eventEntityV1, notificationV1);
        assertThat(graph.nodes()).isEqualTo(expectedNodes);
    }
",non-flaky,5
86124,graylog2_graylog2-server,LegacyAlertConditionMigratorTest.run,"    @Test
    public void run() {
        final int migratedConditions = 10;
        final int migratedCallbacks = 4;

        assertThat(migrator.run(Collections.emptySet(), Collections.emptySet())).satisfies(result -> {
            assertThat(result.completedAlertConditions()).containsOnly(
                    ""00000000-0000-0000-0000-000000000001"",
                    ""00000000-0000-0000-0000-000000000002"",
                    ""00000000-0000-0000-0000-000000000003"",
                    ""00000000-0000-0000-0000-000000000004"",
                    ""00000000-0000-0000-0000-000000000005"",
                    ""00000000-0000-0000-0000-000000000006"",
                    ""00000000-0000-0000-0000-000000000007"",
                    ""00000000-0000-0000-0000-000000000008"",
                    ""00000000-0000-0000-0000-000000000009"",
                    ""00000000-0000-0000-0000-000000000010""
            );
            assertThat(result.completedAlarmCallbacks()).containsOnly(
                    ""54e3deadbeefdeadbeef0001"",
                    ""54e3deadbeefdeadbeef0002"",
                    ""54e3deadbeefdeadbeef0003"",
                    ""54e3deadbeefdeadbeef0004""
            );
        });

        // Make sure we use the EventDefinitionHandler to create the event definitions
        verify(eventDefinitionHandler, times(migratedConditions)).create(any(EventDefinitionDto.class), any(Optional.class));

        // Make sure we use the NotificationResourceHandler to create the notifications
        verify(notificationResourceHandler, times(migratedCallbacks)).create(any(NotificationDto.class), any(Optional.class));

        assertThat(eventDefinitionService.streamAll().count()).isEqualTo(migratedConditions);
        assertThat(notificationService.streamAll().count()).isEqualTo(migratedCallbacks);

        final NotificationDto httpNotification = notificationService.streamAll()
                .filter(n -> n.title().equals(""HTTP Callback Test""))
                .findFirst()
                .orElse(null);

        assertThat(httpNotification).isNotNull();
        assertThat(httpNotification.title()).isEqualTo(""HTTP Callback Test"");
        assertThat(httpNotification.description()).isEqualTo(""Migrated legacy alarm callback"");
        assertThat(httpNotification.config()).isInstanceOf(LegacyAlarmCallbackEventNotificationConfig.class);
        assertThat((LegacyAlarmCallbackEventNotificationConfig) httpNotification.config()).satisfies(config -> {
            assertThat(config.callbackType()).isEqualTo(""org.graylog2.alarmcallbacks.HTTPAlarmCallback"");
            assertThat(config.configuration().get(""url"")).isEqualTo(""http://localhost:11000/"");
        });

        final NotificationDto httpNotificationWithoutTitle = notificationService.streamAll()
                .filter(n -> n.title().equals(""Untitled""))
                .findFirst()
                .orElse(null);

        assertThat(httpNotificationWithoutTitle).isNotNull();
        assertThat(httpNotificationWithoutTitle.title()).isEqualTo(""Untitled"");
        assertThat(httpNotificationWithoutTitle.description()).isEqualTo(""Migrated legacy alarm callback"");
        assertThat(httpNotificationWithoutTitle.config()).isInstanceOf(LegacyAlarmCallbackEventNotificationConfig.class);
        assertThat((LegacyAlarmCallbackEventNotificationConfig) httpNotificationWithoutTitle.config()).satisfies(config -> {
            assertThat(config.callbackType()).isEqualTo(""org.graylog2.alarmcallbacks.HTTPAlarmCallback"");
            assertThat(config.configuration().get(""url"")).isEqualTo(""http://localhost:11000/"");
        });

        final NotificationDto emailNotification = notificationService.streamAll()
                .filter(n -> n.title().equals(""Email Callback Test""))
                .findFirst()
                .orElse(null);

        assertThat(emailNotification).isNotNull();
        assertThat(emailNotification.title()).isEqualTo(""Email Callback Test"");
        assertThat(emailNotification.description()).isEqualTo(""Migrated legacy alarm callback"");
        assertThat(emailNotification.config()).isInstanceOf(LegacyAlarmCallbackEventNotificationConfig.class);
        assertThat((LegacyAlarmCallbackEventNotificationConfig) emailNotification.config()).satisfies(config -> {
            assertThat(config.callbackType()).isEqualTo(""org.graylog2.alarmcallbacks.EmailAlarmCallback"");
            assertThat(config.configuration().get(""sender"")).isEqualTo(""graylog@example.org"");
            assertThat(config.configuration().get(""subject"")).isEqualTo(""Graylog alert for stream: ${stream.title}: ${check_result.resultDescription}"");
            assertThat((String) config.configuration().get(""body"")).contains(""Alert Description: ${check_result.resultDescription}\nDate: "");
            assertThat(config.configuration().get(""user_receivers"")).isEqualTo(Collections.emptyList());
            assertThat(config.configuration().get(""email_receivers"")).isEqualTo(Collections.singletonList(""jane@example.org""));
        });

        final NotificationDto slackNotification = notificationService.streamAll()
                .filter(n -> n.title().equals(""Slack Callback Test""))
                .findFirst()
                .orElse(null);

        assertThat(slackNotification).isNotNull();
        assertThat(slackNotification.title()).isEqualTo(""Slack Callback Test"");
        assertThat(slackNotification.description()).isEqualTo(""Migrated legacy alarm callback"");
        assertThat(slackNotification.config()).isInstanceOf(LegacyAlarmCallbackEventNotificationConfig.class);
        assertThat((LegacyAlarmCallbackEventNotificationConfig) slackNotification.config()).satisfies(config -> {
            assertThat(config.callbackType()).isEqualTo(""org.graylog2.plugins.slack.callback.SlackAlarmCallback"");
            assertThat(config.configuration().get(""icon_url"")).isEqualTo("""");
            assertThat(config.configuration().get(""graylog2_url"")).isEqualTo("""");
            assertThat(config.configuration().get(""link_names"")).isEqualTo(true);
            assertThat(config.configuration().get(""webhook_url"")).isEqualTo(""http://example.com/slack-hook"");
            assertThat(config.configuration().get(""color"")).isEqualTo(""#FF0000"");
            assertThat(config.configuration().get(""icon_emoji"")).isEqualTo("""");
            assertThat(config.configuration().get(""user_name"")).isEqualTo(""Graylog"");
            assertThat(config.configuration().get(""backlog_items"")).isEqualTo(5);
            assertThat(config.configuration().get(""custom_fields"")).isEqualTo("""");
            assertThat(config.configuration().get(""proxy_address"")).isEqualTo("""");
            assertThat(config.configuration().get(""channel"")).isEqualTo(""#channel"");
            assertThat(config.configuration().get(""notify_channel"")).isEqualTo(false);
            assertThat(config.configuration().get(""add_attachment"")).isEqualTo(true);
            assertThat(config.configuration().get(""short_mode"")).isEqualTo(false);
        });

        assertThat(eventDefinitionService.streamAll().filter(ed -> ed.title().equals(""Message Count - MORE"")).findFirst())
                .get()
                .satisfies(eventDefinition -> {
                    assertThat(eventDefinition.alert()).isTrue();
                    assertThat(eventDefinition.priority()).isEqualTo(2);
                    assertThat(eventDefinition.keySpec()).isEmpty();
                    assertThat(eventDefinition.notificationSettings().gracePeriodMs()).isEqualTo(120000);
                    assertThat(eventDefinition.notificationSettings().backlogSize()).isEqualTo(10);

                    assertThat(eventDefinition.notifications()).hasSize(2);
                    assertThat(eventDefinition.notifications().stream().map(EventNotificationHandler.Config::notificationId).collect(Collectors.toList()))
                            .containsOnly(httpNotification.id(), httpNotificationWithoutTitle.id());

                    assertThat((AggregationEventProcessorConfig) eventDefinition.config()).satisfies(config -> {
                        assertThat(config.streams()).containsExactly(""54e3deadbeefdeadbeef0001"");
                        assertThat(config.query()).isEqualTo(""hello:world"");
                        assertThat(config.groupBy()).isEmpty();
                        assertThat(config.searchWithinMs()).isEqualTo(10 * 60 * 1000);
                        assertThat(config.executeEveryMs()).isEqualTo(CHECK_INTERVAL * 1000);

                        assertThat(config.series()).hasSize(1);
                        assertThat(config.series().get(0).id()).isNotBlank();
                        assertThat(config.series().get(0).function()).isEqualTo(AggregationFunction.COUNT);
                        assertThat(config.series().get(0).field()).isNotPresent();

                        assertThat(config.conditions()).get().satisfies(conditions -> {
                            assertThat(conditions.expression()).get().satisfies(expression -> {
                                assertThat(expression).isInstanceOf(Expr.Greater.class);

                                final Expr.Greater greater = (Expr.Greater) expression;

                                assertThat(greater.left()).isEqualTo(Expr.NumberReference.create(config.series().get(0).id()));
                                assertThat(greater.right()).isEqualTo(Expr.NumberValue.create(1));
                            });
                        });
                    });
                });

        assertThat(eventDefinitionService.streamAll().filter(ed -> ed.title().equals(""Message Count - LESS"")).findFirst())
                .get()
                .satisfies(eventDefinition -> {
                    assertThat(eventDefinition.alert()).isTrue();
                    assertThat(eventDefinition.priority()).isEqualTo(2);
                    assertThat(eventDefinition.keySpec()).isEmpty();
                    assertThat(eventDefinition.notificationSettings().gracePeriodMs()).isEqualTo(0);
                    assertThat(eventDefinition.notificationSettings().backlogSize()).isEqualTo(0);

                    assertThat(eventDefinition.notifications()).hasSize(2);
                    assertThat(eventDefinition.notifications().stream().map(EventNotificationHandler.Config::notificationId).collect(Collectors.toList()))
                            .containsOnly(httpNotification.id(), httpNotificationWithoutTitle.id());

                    assertThat((AggregationEventProcessorConfig) eventDefinition.config()).satisfies(config -> {
                        assertThat(config.streams()).containsExactly(""54e3deadbeefdeadbeef0001"");
                        assertThat(config.query()).isEmpty();
                        assertThat(config.groupBy()).isEmpty();
                        assertThat(config.searchWithinMs()).isEqualTo(4 * 60 * 1000);
                        assertThat(config.executeEveryMs()).isEqualTo(CHECK_INTERVAL * 1000);

                        assertThat(config.series()).hasSize(1);
                        assertThat(config.series().get(0).id()).isNotBlank();
                        assertThat(config.series().get(0).function()).isEqualTo(AggregationFunction.COUNT);
                        assertThat(config.series().get(0).field()).isNotPresent();

                        assertThat(config.conditions()).get().satisfies(conditions -> {
                            assertThat(conditions.expression()).get().satisfies(expression -> {
                                assertThat(expression).isInstanceOf(Expr.Lesser.class);

                                final Expr.Lesser lesser = (Expr.Lesser) expression;

                                assertThat(lesser.left()).isEqualTo(Expr.NumberReference.create(config.series().get(0).id()));
                                assertThat(lesser.right()).isEqualTo(Expr.NumberValue.create(42));
                            });
                        });
                    });
                });

        assertThat(eventDefinitionService.streamAll().filter(ed -> ed.title().equals(""Field Value - HIGHER - MEAN"")).findFirst())
                .get()
                .satisfies(eventDefinition -> {
                    assertThat(eventDefinition.alert()).isTrue();
                    assertThat(eventDefinition.priority()).isEqualTo(2);
                    assertThat(eventDefinition.keySpec()).isEmpty();
                    assertThat(eventDefinition.notificationSettings().gracePeriodMs()).isEqualTo(60000);
                    assertThat(eventDefinition.notificationSettings().backlogSize()).isEqualTo(15);
                    assertThat(eventDefinition.notifications()).isEmpty();

                    assertThat((AggregationEventProcessorConfig) eventDefinition.config()).satisfies(config -> {
                        assertThat(config.streams()).containsExactly(""54e3deadbeefdeadbeef0002"");
                        assertThat(config.query()).isEqualTo(""*"");
                        assertThat(config.groupBy()).isEmpty();
                        assertThat(config.searchWithinMs()).isEqualTo(5 * 60 * 1000);
                        assertThat(config.executeEveryMs()).isEqualTo(CHECK_INTERVAL * 1000);

                        assertThat(config.series()).hasSize(1);
                        assertThat(config.series().get(0).id()).isNotBlank();
                        assertThat(config.series().get(0).function()).isEqualTo(AggregationFunction.AVG);
                        assertThat(config.series().get(0).field()).get().isEqualTo(""test_field_1"");

                        assertThat(config.conditions()).get().satisfies(conditions -> {
                            assertThat(conditions.expression()).get().satisfies(expression -> {
                                assertThat(expression).isInstanceOf(Expr.Greater.class);

                                final Expr.Greater greater = (Expr.Greater) expression;

                                assertThat(greater.left()).isEqualTo(Expr.NumberReference.create(config.series().get(0).id()));
                                assertThat(greater.right()).isEqualTo(Expr.NumberValue.create(23));
                            });
                        });
                    });
                });

        assertThat(eventDefinitionService.streamAll().filter(ed -> ed.title().equals(""Field Value - LOWER - SUM"")).findFirst())
                .get()
                .satisfies(eventDefinition -> {
                    assertThat(eventDefinition.alert()).isTrue();
                    assertThat(eventDefinition.priority()).isEqualTo(2);
                    assertThat(eventDefinition.keySpec()).isEmpty();
                    assertThat(eventDefinition.notificationSettings().gracePeriodMs()).isEqualTo(60000);
                    assertThat(eventDefinition.notificationSettings().backlogSize()).isEqualTo(15);
                    assertThat(eventDefinition.notifications()).isEmpty();

                    assertThat((AggregationEventProcessorConfig) eventDefinition.config()).satisfies(config -> {
                        assertThat(config.streams()).containsExactly(""54e3deadbeefdeadbeef0002"");
                        assertThat(config.query()).isEqualTo(""*"");
                        assertThat(config.groupBy()).isEmpty();
                        assertThat(config.searchWithinMs()).isEqualTo(5 * 60 * 1000);
                        assertThat(config.executeEveryMs()).isEqualTo(CHECK_INTERVAL * 1000);

                        assertThat(config.series()).hasSize(1);
                        assertThat(config.series().get(0).id()).isNotBlank();
                        assertThat(config.series().get(0).function()).isEqualTo(AggregationFunction.SUM);
                        assertThat(config.series().get(0).field()).get().isEqualTo(""test_field_1"");

                        assertThat(config.conditions()).get().satisfies(conditions -> {
                            assertThat(conditions.expression()).get().satisfies(expression -> {
                                assertThat(expression).isInstanceOf(Expr.Lesser.class);

                                final Expr.Lesser lesser = (Expr.Lesser) expression;

                                assertThat(lesser.left()).isEqualTo(Expr.NumberReference.create(config.series().get(0).id()));
                                assertThat(lesser.right()).isEqualTo(Expr.NumberValue.create(23));
                            });
                        });
                    });
                });

        assertThat(eventDefinitionService.streamAll().filter(ed -> ed.title().equals(""Field Value - LOWER - MIN"")).findFirst())
                .get()
                .satisfies(eventDefinition -> {
                    assertThat(eventDefinition.alert()).isTrue();
                    assertThat(eventDefinition.priority()).isEqualTo(2);
                    assertThat(eventDefinition.keySpec()).isEmpty();
                    assertThat(eventDefinition.notificationSettings().gracePeriodMs()).isEqualTo(60000);
                    assertThat(eventDefinition.notificationSettings().backlogSize()).isEqualTo(15);
                    assertThat(eventDefinition.notifications()).isEmpty();

                    assertThat((AggregationEventProcessorConfig) eventDefinition.config()).satisfies(config -> {
                        assertThat(config.streams()).containsExactly(""54e3deadbeefdeadbeef0002"");
                        assertThat(config.query()).isEqualTo(""*"");
                        assertThat(config.groupBy()).isEmpty();
                        assertThat(config.searchWithinMs()).isEqualTo(5 * 60 * 1000);
                        assertThat(config.executeEveryMs()).isEqualTo(CHECK_INTERVAL * 1000);

                        assertThat(config.series()).hasSize(1);
                        assertThat(config.series().get(0).id()).isNotBlank();
                        assertThat(config.series().get(0).function()).isEqualTo(AggregationFunction.MIN);
                        assertThat(config.series().get(0).field()).get().isEqualTo(""test_field_1"");

                        assertThat(config.conditions()).get().satisfies(conditions -> {
                            assertThat(conditions.expression()).get().satisfies(expression -> {
                                assertThat(expression).isInstanceOf(Expr.Lesser.class);

                                final Expr.Lesser lesser = (Expr.Lesser) expression;

                                assertThat(lesser.left()).isEqualTo(Expr.NumberReference.create(config.series().get(0).id()));
                                assertThat(lesser.right()).isEqualTo(Expr.NumberValue.create(23));
                            });
                        });
                    });
                });

        assertThat(eventDefinitionService.streamAll().filter(ed -> ed.title().equals(""Field Value - LOWER - MAX"")).findFirst())
                .get()
                .satisfies(eventDefinition -> {
                    assertThat(eventDefinition.alert()).isTrue();
                    assertThat(eventDefinition.priority()).isEqualTo(2);
                    assertThat(eventDefinition.keySpec()).isEmpty();
                    assertThat(eventDefinition.notificationSettings().gracePeriodMs()).isEqualTo(60000);
                    assertThat(eventDefinition.notificationSettings().backlogSize()).isEqualTo(15);
                    assertThat(eventDefinition.notifications()).isEmpty();

                    assertThat((AggregationEventProcessorConfig) eventDefinition.config()).satisfies(config -> {
                        assertThat(config.streams()).containsExactly(""54e3deadbeefdeadbeef0002"");
                        assertThat(config.query()).isEqualTo(""*"");
                        assertThat(config.groupBy()).isEmpty();
                        assertThat(config.searchWithinMs()).isEqualTo(5 * 60 * 1000);
                        assertThat(config.executeEveryMs()).isEqualTo(CHECK_INTERVAL * 1000);

                        assertThat(config.series()).hasSize(1);
                        assertThat(config.series().get(0).id()).isNotBlank();
                        assertThat(config.series().get(0).function()).isEqualTo(AggregationFunction.MAX);
                        assertThat(config.series().get(0).field()).get().isEqualTo(""test_field_1"");

                        assertThat(config.conditions()).get().satisfies(conditions -> {
                            assertThat(conditions.expression()).get().satisfies(expression -> {
                                assertThat(expression).isInstanceOf(Expr.Lesser.class);

                                final Expr.Lesser lesser = (Expr.Lesser) expression;

                                assertThat(lesser.left()).isEqualTo(Expr.NumberReference.create(config.series().get(0).id()));
                                assertThat(lesser.right()).isEqualTo(Expr.NumberValue.create(23));
                            });
                        });
                    });
                });

        assertThat(eventDefinitionService.streamAll().filter(ed -> ed.title().equals(""Field Value - LOWER - STDDEV"")).findFirst())
                .get()
                .satisfies(eventDefinition -> {
                    assertThat(eventDefinition.alert()).isTrue();
                    assertThat(eventDefinition.priority()).isEqualTo(2);
                    assertThat(eventDefinition.keySpec()).isEmpty();
                    assertThat(eventDefinition.notificationSettings().gracePeriodMs()).isEqualTo(60000);
                    assertThat(eventDefinition.notificationSettings().backlogSize()).isEqualTo(15);
                    assertThat(eventDefinition.notifications()).isEmpty();

                    assertThat((AggregationEventProcessorConfig) eventDefinition.config()).satisfies(config -> {
                        assertThat(config.streams()).containsExactly(""54e3deadbeefdeadbeef0002"");
                        assertThat(config.query()).isEqualTo(""*"");
                        assertThat(config.groupBy()).isEmpty();
                        assertThat(config.searchWithinMs()).isEqualTo(5 * 60 * 1000);
                        assertThat(config.executeEveryMs()).isEqualTo(CHECK_INTERVAL * 1000);

                        assertThat(config.series()).hasSize(1);
                        assertThat(config.series().get(0).id()).isNotBlank();
                        assertThat(config.series().get(0).function()).isEqualTo(AggregationFunction.STDDEV);
                        assertThat(config.series().get(0).field()).get().isEqualTo(""test_field_1"");

                        assertThat(config.conditions()).get().satisfies(conditions -> {
                            assertThat(conditions.expression()).get().satisfies(expression -> {
                                assertThat(expression).isInstanceOf(Expr.Greater.class);

                                final Expr.Greater greater = (Expr.Greater) expression;

                                assertThat(greater.left()).isEqualTo(Expr.NumberReference.create(config.series().get(0).id()));
                                assertThat(greater.right()).isEqualTo(Expr.NumberValue.create(23));
                            });
                        });
                    });
                });

        assertThat(eventDefinitionService.streamAll().filter(ed -> ed.title().equals(""Field Content - WITHOUT QUERY"")).findFirst())
                .get()
                .satisfies(eventDefinition -> {
                    assertThat(eventDefinition.alert()).isTrue();
                    assertThat(eventDefinition.priority()).isEqualTo(2);
                    assertThat(eventDefinition.keySpec()).isEmpty();
                    assertThat(eventDefinition.notificationSettings().gracePeriodMs()).isEqualTo(120000);
                    assertThat(eventDefinition.notificationSettings().backlogSize()).isEqualTo(100);

                    assertThat(eventDefinition.notifications()).hasSize(2);
                    assertThat(eventDefinition.notifications().stream().map(EventNotificationHandler.Config::notificationId).collect(Collectors.toSet()))
                            .containsOnly(emailNotification.id(), slackNotification.id());

                    assertThat((AggregationEventProcessorConfig) eventDefinition.config()).satisfies(config -> {
                        assertThat(config.streams()).containsExactly(""54e3deadbeefdeadbeef0003"");
                        assertThat(config.query()).isEqualTo(""test_field_2:\""hello\"""");
                        assertThat(config.groupBy()).isEmpty();
                        assertThat(config.searchWithinMs()).isEqualTo(CHECK_INTERVAL * 1000);
                        assertThat(config.executeEveryMs()).isEqualTo(CHECK_INTERVAL * 1000);

                        assertThat(config.series()).hasSize(1);
                        assertThat(config.series().get(0).id()).isNotBlank();
                        assertThat(config.series().get(0).function()).isEqualTo(AggregationFunction.COUNT);
                        assertThat(config.series().get(0).field()).isNotPresent();

                        assertThat(config.conditions()).get().satisfies(conditions -> {
                            assertThat(conditions.expression()).get().satisfies(expression -> {
                                assertThat(expression).isInstanceOf(Expr.Greater.class);

                                final Expr.Greater greater = (Expr.Greater) expression;

                                assertThat(greater.left()).isEqualTo(Expr.NumberReference.create(config.series().get(0).id()));
                                assertThat(greater.right()).isEqualTo(Expr.NumberValue.create(0));
                            });
                        });
                    });
                });

        assertThat(eventDefinitionService.streamAll().filter(ed -> ed.title().equals(""Field Content - WITH QUERY"")).findFirst())
                .get()
                .satisfies(eventDefinition -> {
                    assertThat(eventDefinition.alert()).isTrue();
                    assertThat(eventDefinition.priority()).isEqualTo(2);
                    assertThat(eventDefinition.keySpec()).isEmpty();
                    assertThat(eventDefinition.notificationSettings().gracePeriodMs()).isEqualTo(0);
                    assertThat(eventDefinition.notificationSettings().backlogSize()).isEqualTo(0);

                    assertThat(eventDefinition.notifications()).hasSize(2);
                    assertThat(eventDefinition.notifications().stream().map(EventNotificationHandler.Config::notificationId).collect(Collectors.toSet()))
                            .containsOnly(emailNotification.id(), slackNotification.id());

                    assertThat((AggregationEventProcessorConfig) eventDefinition.config()).satisfies(config -> {
                        assertThat(config.streams()).containsExactly(""54e3deadbeefdeadbeef0003"");
                        assertThat(config.query()).isEqualTo(""test_field_3:\""foo\"" AND foo:bar"");
                        assertThat(config.groupBy()).isEmpty();
                        assertThat(config.searchWithinMs()).isEqualTo(CHECK_INTERVAL * 1000);
                        assertThat(config.executeEveryMs()).isEqualTo(CHECK_INTERVAL * 1000);

                        assertThat(config.series()).hasSize(1);
                        assertThat(config.series().get(0).id()).isNotBlank();
                        assertThat(config.series().get(0).function()).isEqualTo(AggregationFunction.COUNT);
                        assertThat(config.series().get(0).field()).isNotPresent();

                        assertThat(config.conditions()).get().satisfies(conditions -> {
                            assertThat(conditions.expression()).get().satisfies(expression -> {
                                assertThat(expression).isInstanceOf(Expr.Greater.class);

                                final Expr.Greater greater = (Expr.Greater) expression;

                                assertThat(greater.left()).isEqualTo(Expr.NumberReference.create(config.series().get(0).id()));
                                assertThat(greater.right()).isEqualTo(Expr.NumberValue.create(0));
                            });
                        });
                    });
                });

        assertThat(eventDefinitionService.streamAll().filter(ed -> ed.title().equals(""Untitled"")).findFirst())
                .get()
                .satisfies(eventDefinition -> {
                    assertThat(eventDefinition.alert()).isTrue();
                    assertThat(eventDefinition.priority()).isEqualTo(2);
                    assertThat(eventDefinition.keySpec()).isEmpty();
                    assertThat(eventDefinition.notificationSettings().gracePeriodMs()).isEqualTo(0);
                    assertThat(eventDefinition.notificationSettings().backlogSize()).isEqualTo(0);

                    assertThat(eventDefinition.notifications()).hasSize(2);
                    assertThat(eventDefinition.notifications().stream().map(EventNotificationHandler.Config::notificationId).collect(Collectors.toSet()))
                            .containsOnly(emailNotification.id(), slackNotification.id());

                    assertThat((AggregationEventProcessorConfig) eventDefinition.config()).satisfies(config -> {
                        assertThat(config.streams()).containsExactly(""54e3deadbeefdeadbeef0003"");
                        assertThat(config.query()).isEqualTo(""test_field_3:\""foo\"" AND foo:bar"");
                        assertThat(config.groupBy()).isEmpty();
                        assertThat(config.searchWithinMs()).isEqualTo(CHECK_INTERVAL * 1000);
                        assertThat(config.executeEveryMs()).isEqualTo(CHECK_INTERVAL * 1000);

                        assertThat(config.series()).hasSize(1);
                        assertThat(config.series().get(0).id()).isNotBlank();
                        assertThat(config.series().get(0).function()).isEqualTo(AggregationFunction.COUNT);
                        assertThat(config.series().get(0).field()).isNotPresent();

                        assertThat(config.conditions()).get().satisfies(conditions -> {
                            assertThat(conditions.expression()).get().satisfies(expression -> {
                                assertThat(expression).isInstanceOf(Expr.Greater.class);

                                final Expr.Greater greater = (Expr.Greater) expression;

                                assertThat(greater.left()).isEqualTo(Expr.NumberReference.create(config.series().get(0).id()));
                                assertThat(greater.right()).isEqualTo(Expr.NumberValue.create(0));
                            });
                        });
                    });
                });
    }
",non-flaky,5
86125,graylog2_graylog2-server,LegacyAlertConditionMigratorTest.runWithMigrationStatus,"    @Test
    public void runWithMigrationStatus() {
        final int migratedConditions = 9; // Only 8 because we pass one migrated condition in
        final int migratedCallbacks = 3;  // Only 2 because we pass one migrated callback in

        assertThat(migrator.run(Collections.singleton(""00000000-0000-0000-0000-000000000002""), Collections.singleton(""54e3deadbeefdeadbeef0001""))).satisfies(result -> {
            assertThat(result.completedAlertConditions()).containsOnly(
                    ""00000000-0000-0000-0000-000000000001"",
                    ""00000000-0000-0000-0000-000000000002"",
                    ""00000000-0000-0000-0000-000000000003"",
                    ""00000000-0000-0000-0000-000000000004"",
                    ""00000000-0000-0000-0000-000000000005"",
                    ""00000000-0000-0000-0000-000000000006"",
                    ""00000000-0000-0000-0000-000000000007"",
                    ""00000000-0000-0000-0000-000000000008"",
                    ""00000000-0000-0000-0000-000000000009"",
                    ""00000000-0000-0000-0000-000000000010""
            );
            assertThat(result.completedAlarmCallbacks()).containsOnly(
                    ""54e3deadbeefdeadbeef0001"",
                    ""54e3deadbeefdeadbeef0002"",
                    ""54e3deadbeefdeadbeef0003"",
                    ""54e3deadbeefdeadbeef0004""
            );
        });

        // Make sure we use the EventDefinitionHandler to create the event definitions
        verify(eventDefinitionHandler, times(migratedConditions)).create(any(EventDefinitionDto.class), any(Optional.class));

        // Make sure we use the NotificationResourceHandler to create the notifications
        verify(notificationResourceHandler, times(migratedCallbacks)).create(any(NotificationDto.class), any(Optional.class));

        assertThat(eventDefinitionService.streamAll().count()).isEqualTo(migratedConditions);
        assertThat(notificationService.streamAll().count()).isEqualTo(migratedCallbacks);
    }
",non-flaky,5
86126,graylog2_graylog2-server,LookupTableFieldValueProviderTest.testWithMessageContext,"    @Test
    public void testWithMessageContext() {
        final String fieldValueString = ""world"";
        final String expectedLookupValue = ""lookup-world"";

        final TestEvent event = new TestEvent();
        final Message message = newMessage(ImmutableMap.of(""hello"", fieldValueString));
        final EventWithContext eventWithContext = EventWithContext.create(event, message);

        final LookupTableFieldValueProvider.Config config = newConfig(""test"", ""hello"");

        setupMocks(""test"");
        when(lookupTableFunction.lookup(""world"")).thenReturn(LookupResult.single(""lookup-"" + message.getField(""hello"")));

        final FieldValue fieldValue = newProvider(config).doGet(""test"", eventWithContext);

        assertThat(fieldValue.value()).isEqualTo(expectedLookupValue);
    }
",non-flaky,5
86127,graylog2_graylog2-server,LookupTableFieldValueProviderTest.testWithEventContext,"    @Test
    public void testWithEventContext() {
        final String fieldValueString = ""event"";
        final String expectedLookupValue = ""lookup-event"";

        final TestEvent event = new TestEvent();
        final TestEvent eventContext = new TestEvent();

        eventContext.setField(""hello"", FieldValue.string(fieldValueString));

        final EventWithContext eventWithContext = EventWithContext.create(event, eventContext);

        final LookupTableFieldValueProvider.Config config = newConfig(""test"", ""hello"");

        setupMocks(""test"");
        when(lookupTableFunction.lookup(fieldValueString)).thenReturn(LookupResult.single(""lookup-"" + eventContext.getField(""hello"").value()));

        final FieldValue fieldValue = newProvider(config).doGet(""test"", eventWithContext);

        assertThat(fieldValue.value()).isEqualTo(expectedLookupValue);
    }
",non-flaky,5
86128,graylog2_graylog2-server,LookupTableFieldValueProviderTest.testWithMissingLookupTable,"    @Test
    public void testWithMissingLookupTable() {
        final TestEvent event = new TestEvent();
        final EventWithContext eventWithContext = EventWithContext.create(event, newMessage(ImmutableMap.of(""hello"", ""world"")));

        final LookupTableFieldValueProvider.Config config = newConfig(""test-doesntexist"", ""hello"");

        setupMocks(""test"");
        when(lookupTableFunction.lookup(""world"")).thenReturn(LookupResult.single(""lookup-world""));

        assertThatThrownBy(() -> newProvider(config).doGet(""test"", eventWithContext))
                .hasMessageContaining(""test-doesntexist"")
                .isInstanceOf(IllegalArgumentException.class);
    }
",non-flaky,5
86129,graylog2_graylog2-server,TemplateFieldValueProviderTest.templateWithMessageContext,"    @Test
    public void templateWithMessageContext() {
        final TestEvent event = new TestEvent();
        final EventWithContext eventWithContext = EventWithContext.create(event, newMessage(ImmutableMap.of(""hello"", ""world"")));

        final FieldValue fieldValue = newTemplate(""hello: ${source.hello}"").doGet(""test"", eventWithContext);

        assertThat(fieldValue.value()).isEqualTo(""hello: world"");
    }
",non-flaky,5
86130,graylog2_graylog2-server,TemplateFieldValueProviderTest.templateWithEventContext,"    @Test
    public void templateWithEventContext() {
        final TestEvent event = new TestEvent();
        final TestEvent eventContext = new TestEvent();

        eventContext.setField(""hello"", FieldValue.string(""event""));

        final EventWithContext eventWithContext = EventWithContext.create(event, eventContext);

        final FieldValue fieldValue = newTemplate(""hello: ${source.hello}"").doGet(""test"", eventWithContext);

        assertThat(fieldValue.value()).isEqualTo(""hello: event"");
    }
",non-flaky,5
86131,graylog2_graylog2-server,TemplateFieldValueProviderTest.templateWithError,"    @Test
    public void templateWithError() {
        final TestEvent event = new TestEvent();
        final EventWithContext eventWithContext = EventWithContext.create(event, newMessage(ImmutableMap.of(""hello"", ""world"")));

        final FieldValue fieldValue = newTemplate(""hello: ${source.yolo}"", true).doGet(""test"", eventWithContext);

        assertThat(fieldValue.dataType()).isEqualTo(FieldValueType.ERROR);
    }
",non-flaky,5
86132,graylog2_graylog2-server,TemplateFieldValueProviderTest.templateCalculation,"    @Test
    @Ignore(""template engine doesn't support expressions"")
    public void templateCalculation() {
        final TestEvent event = new TestEvent();
        final EventWithContext eventWithContext = EventWithContext.create(event, newMessage(ImmutableMap.of(""bytes"", 1024)));

        final FieldValue fieldValue = newTemplate(""${source.bytes / 1024}"").doGet(""test"", eventWithContext);

        assertThat(fieldValue.value()).isEqualTo(""1"");
    }
",non-flaky,5
86133,graylog2_graylog2-server,TemplateFieldValueProviderTest.templateNumberFormatting,"    @Test
    public void templateNumberFormatting() {
        final TestEvent event = new TestEvent();
        final EventWithContext eventWithContext = EventWithContext.create(event, newMessage(ImmutableMap.of(""count"", 10241234, ""avg"", 1024.42)));

        final FieldValue fieldValue = newTemplate(""count: ${source.count} avg: ${source.avg}"").doGet(""test"", eventWithContext);

        assertThat(fieldValue.value()).isEqualTo(""count: 10241234 avg: 1024.42"");
    }
",non-flaky,5
86134,graylog2_graylog2-server,TemplateFieldValueProviderTest.templateDateFormatting,"    @Test
    public void templateDateFormatting() {
        final TestEvent event = new TestEvent();
        final EventWithContext eventWithContext = EventWithContext.create(event, newMessage(ImmutableMap.of(""timestamp"", DateTime.parse(""2019-07-02T12:21:00.123Z""))));

        final FieldValue fieldValue = newTemplate(""timestamp: ${source.timestamp}"").doGet(""test"", eventWithContext);

        assertThat(fieldValue.value()).isEqualTo(""timestamp: 2019-07-02T12:21:00.123Z"");
    }
",non-flaky,5
86135,graylog2_graylog2-server,TemplateFieldValueProviderTest.templateBooleanFormatting,"    @Test
    public void templateBooleanFormatting() {
        final TestEvent event = new TestEvent();
        final EventWithContext eventWithContext = EventWithContext.create(event, newMessage(ImmutableMap.of(""success"", true)));

        final FieldValue fieldValue = newTemplate(""success: ${source.success}"").doGet(""test"", eventWithContext);

        assertThat(fieldValue.value()).isEqualTo(""success: true"");
    }
",non-flaky,5
86136,graylog2_graylog2-server,ESMongoDateTimeDeserializerTest.deserializeDateTime,"    @Test
    public void deserializeDateTime() throws Exception {
        final String json = ""{\""date_time\"":\""2016-12-13 14:00:00.000\""}"";
        final DTO value = objectMapper.readValue(json, DTO.class);
        assertThat(value.dateTime).isEqualTo(new DateTime(2016, 12, 13, 14, 0, DateTimeZone.UTC));
    }
",non-flaky,5
86137,graylog2_graylog2-server,ESMongoDateTimeDeserializerTest.deserializeIsoDateTime,"    @Test
    public void deserializeIsoDateTime() throws Exception {
        final String json = ""{\""date_time\"":\""2016-12-13T14:00:00.000\""}"";
        final DTO value = objectMapper.readValue(json, DTO.class);
        assertThat(value.dateTime).isEqualTo(new DateTime(2016, 12, 13, 14, 0, DateTimeZone.UTC));
    }
",non-flaky,5
94601,square_okhttp,UrlConnectionCacheTest.gzip,"  @Test public void testGoldenCacheResponse() throws Exception {
  public Buffer gzip(String data) throws IOException {
    Buffer result = new Buffer();
    BufferedSink sink = Okio.buffer(new GzipSink(result));
    sink.writeUtf8(data);
    sink.close();
    return result;
  }
",non-flaky,5
94602,square_okhttp,OkUrlFactoryTest.setInstanceFollowRedirectsFalse,"  @Test
  public void setInstanceFollowRedirectsFalse() throws Exception {
    server.enqueue(new MockResponse()
        .setResponseCode(302)
        .addHeader(""Location: /b"")
        .setBody(""A""));
    server.enqueue(new MockResponse()
        .setBody(""B""));

    HttpURLConnection connection = factory.open(server.url(""/a"").url());
    connection.setInstanceFollowRedirects(false);
    assertResponseBody(connection, ""A"");
    assertResponseCode(connection, 302);
  }
",non-flaky,5
94603,square_okhttp,OkUrlFactoryTest.checkURLPermitted,"  @Test
  public void testURLFilter() throws Exception {
    server.enqueue(new MockResponse()
        .setBody(""B""));
    final URL blockedURL = server.url(""/a"").url();
    factory.setUrlFilter(new URLFilter() {
      @Override
      public void checkURLPermitted(URL url) throws IOException {
        if (blockedURL.equals(url)) {
          throw new IOException(""Blocked"");
        }
      }
",non-flaky,5
94604,square_okhttp,OkUrlFactoryTest.checkURLPermitted,"  @Test
  public void testURLFilterRedirect() throws Exception {
    MockWebServer cleartextServer = new MockWebServer();
    cleartextServer.enqueue(new MockResponse()
        .setBody(""Blocked!""));
    final URL blockedURL = cleartextServer.url(""/"").url();

    SslClient contextBuilder = SslClient.localhost();
    server.useHttps(contextBuilder.socketFactory, false);
    factory.setClient(factory.client().newBuilder()
        .sslSocketFactory(contextBuilder.socketFactory, contextBuilder.trustManager)
        .followSslRedirects(true)
        .build());
    factory.setUrlFilter(new URLFilter() {
      @Override
      public void checkURLPermitted(URL url) throws IOException {
        if (blockedURL.equals(url)) {
          throw new IOException(""Blocked"");
        }
      }
",non-flaky,5
94605,square_okhttp,URLEncodingTest.get,"  @Test @Ignore public void lenientUrlToUriNul() throws Exception {
      @Override public Response get(Request request) throws IOException {
        uriReference.set(request.url().uri());
        throw new UnsupportedOperationException();
      }
",non-flaky,5
94606,square_okhttp,CookiesTest.testNetscapeResponse,"  @Test
  public void testNetscapeResponse() throws Exception {
    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
    client = client.newBuilder()
        .cookieJar(new JavaNetCookieJar(cookieManager))
        .build();
    MockWebServer server = new MockWebServer();
    server.start();

    HttpUrl urlWithIpAddress = urlWithIpAddress(server, ""/path/foo"");
    server.enqueue(new MockResponse().addHeader(""Set-Cookie: a=android; ""
        + ""expires=Fri, 31-Dec-9999 23:59:59 GMT; ""
        + ""path=/path; ""
        + ""domain="" + urlWithIpAddress.host() + ""; ""
        + ""secure""));
    get(urlWithIpAddress);

    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
    assertEquals(1, cookies.size());
    HttpCookie cookie = cookies.get(0);
    assertEquals(""a"", cookie.getName());
    assertEquals(""android"", cookie.getValue());
    assertEquals(null, cookie.getComment());
    assertEquals(null, cookie.getCommentURL());
    assertEquals(false, cookie.getDiscard());
    assertTrue(cookie.getMaxAge() > 100000000000L);
    assertEquals(""/path"", cookie.getPath());
    assertEquals(true, cookie.getSecure());
    assertEquals(0, cookie.getVersion());
  }
",non-flaky,5
94607,square_okhttp,CookiesTest.put,"  @Test public void cookieHandlerLikeAndroid() throws Exception {
      @Override public void put(URI uri, Map<String, List<String>> map) throws IOException {
      }
",non-flaky,5
94608,square_okhttp,CacheTest.assertCookies,"  @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
  public void assertCookies(HttpUrl url, String... expectedCookies) throws Exception {
    List<String> actualCookies = new ArrayList<>();
    for (HttpCookie cookie : cookieManager.getCookieStore().get(url.uri())) {
      actualCookies.add(cookie.toString());
    }
    assertEquals(Arrays.asList(expectedCookies), actualCookies);
  }
",non-flaky,5
94609,square_okhttp,CacheTest.intercept,"  @Test public void networkInterceptorInvokedForConditionalGet() throws Exception {
          @Override public Response intercept(Chain chain) throws IOException {
            ifNoneMatch.compareAndSet(null, chain.request().header(""If-None-Match""));
            return chain.proceed(chain.request());
          }
",non-flaky,5
94610,square_okhttp,CacheTest.intercept,"  @Test public void networkInterceptorNotInvokedForFullyCached() throws Exception {
          @Override public Response intercept(Chain chain) throws IOException {
            throw new AssertionError();
          }
",non-flaky,5
94611,square_okhttp,CacheTest.gzip,"  @Test public void etagConditionCanBeNonAscii() throws Exception {
  public Buffer gzip(String data) throws IOException {
    Buffer result = new Buffer();
    BufferedSink sink = Okio.buffer(new GzipSink(result));
    sink.writeUtf8(data);
    sink.close();
    return result;
  }
",non-flaky,5
94612,square_okhttp,MultipartBodyTest.contentType,"  @Test public void streamingPartHasNoLength() throws Exception {
      @Override public MediaType contentType() {
        return null;
      }
",non-flaky,5
94613,square_okhttp,URLConnectionTest.createSocket,"  @Test public void contentDisagreesWithContentLengthHeaderBodyTooShort() throws IOException {
  public void testConnectViaSocketFactory(boolean useHttps) throws IOException {
    SocketFactory uselessSocketFactory = new SocketFactory() {
      public Socket createSocket() {
        throw new IllegalArgumentException(""useless"");
      }
",non-flaky,5
94614,square_okhttp,URLConnectionTest.select,"  @Test public void redirectWithProxySelector() throws Exception {
          @Override public List<Proxy> select(URI uri) {
            proxySelectionRequests.add(uri);
            MockWebServer proxyServer = (uri.getPort() == server.getPort())
                ? server
                : server2;
            return Arrays.asList(proxyServer.toProxyAddress());
          }
",non-flaky,5
94615,square_okhttp,URLConnectionTest.intercept,"  @Test public void interceptorsNotInvoked() throws Exception {
      @Override public Response intercept(Chain chain) throws IOException {
        throw new AssertionError();
      }
",non-flaky,5
94616,square_okhttp,URLConnectionTest.lookup,"  @Test public void unexpectedExceptionSync() throws Exception {
          @Override public List<InetAddress> lookup(String hostname) {
            throw new RuntimeException(""boom!"");
          }
",non-flaky,5
94617,square_okhttp,URLConnectionTest.lookup,"  @Test public void unexpectedExceptionAsync() throws Exception {
          @Override public List<InetAddress> lookup(String hostname) {
            throw new RuntimeException(""boom!"");
          }
",non-flaky,5
94618,square_okhttp,URLConnectionTest.gzip,"  @Test public void callsNotManagedByDispatcher() throws Exception {
  public Buffer gzip(String data) throws IOException {
    Buffer result = new Buffer();
    BufferedSink gzipSink = Okio.buffer(new GzipSink(result));
    gzipSink.writeUtf8(data);
    gzipSink.close();
    return result;
  }
",non-flaky,5
94619,square_okhttp,InterceptorTest.intercept,"  @Test public void applicationInterceptorsCanShortCircuitResponses() throws Exception {
          @Override public Response intercept(Chain chain) throws IOException {
            return interceptorResponse;
          }
",non-flaky,5
94620,square_okhttp,InterceptorTest.intercept,"  @Test public void networkInterceptorsCannotShortCircuitResponses() throws Exception {
      @Override public Response intercept(Chain chain) throws IOException {
        return new Response.Builder()
            .request(chain.request())
            .protocol(Protocol.HTTP_1_1)
            .code(200)
            .message(""Intercepted!"")
            .body(ResponseBody.create(MediaType.parse(""text/plain; charset=utf-8""), ""abc""))
            .build();
      }
",non-flaky,5
94621,square_okhttp,InterceptorTest.intercept,"  @Test public void networkInterceptorsCannotCallProceedMultipleTimes() throws Exception {
      @Override public Response intercept(Chain chain) throws IOException {
        chain.proceed(chain.request());
        return chain.proceed(chain.request());
      }
",non-flaky,5
94622,square_okhttp,InterceptorTest.intercept,"  @Test public void networkInterceptorsCannotChangeServerAddress() throws Exception {
      @Override public Response intercept(Chain chain) throws IOException {
        Address address = chain.connection().route().address();
        String sameHost = address.url().host();
        int differentPort = address.url().port() + 1;
        return chain.proceed(chain.request().newBuilder()
            .url(HttpUrl.parse(""http://"" + sameHost + "":"" + differentPort + ""/""))
            .build());
      }
",non-flaky,5
94623,square_okhttp,InterceptorTest.intercept,"  @Test public void networkInterceptorsHaveConnectionAccess() throws Exception {
      @Override public Response intercept(Chain chain) throws IOException {
        Connection connection = chain.connection();
        assertNotNull(connection);
        return chain.proceed(chain.request());
      }
",non-flaky,5
94624,square_okhttp,InterceptorTest.intercept,"  @Test public void networkInterceptorsObserveNetworkHeaders() throws Exception {
      @Override public Response intercept(Chain chain) throws IOException {
        // The network request has everything: User-Agent, Host, Accept-Encoding.
        Request networkRequest = chain.request();
        assertNotNull(networkRequest.header(""User-Agent""));
        assertEquals(server.getHostName() + "":"" + server.getPort(),
            networkRequest.header(""Host""));
        assertNotNull(networkRequest.header(""Accept-Encoding""));

        // The network response also has everything, including the raw gzipped content.
        Response networkResponse = chain.proceed(networkRequest);
        assertEquals(""gzip"", networkResponse.header(""Content-Encoding""));
        return networkResponse;
      }
",non-flaky,5
94625,square_okhttp,InterceptorTest.intercept,"  @Test public void networkInterceptorsCanChangeRequestMethodFromGetToPost() throws Exception {
      @Override public Response intercept(Chain chain) throws IOException {
        Request originalRequest = chain.request();
        MediaType mediaType = MediaType.parse(""text/plain"");
        RequestBody body = RequestBody.create(mediaType, ""abc"");
        return chain.proceed(originalRequest.newBuilder()
            .method(""POST"", body)
            .header(""Content-Type"", mediaType.toString())
            .header(""Content-Length"", Long.toString(body.contentLength()))
            .build());
      }
",non-flaky,5
94626,square_okhttp,InterceptorTest.intercept,"  @Test public void networkInterceptorsRewriteRequestToServer() throws Exception {
      @Override public Response intercept(Chain chain) throws IOException {
        Request originalRequest = chain.request();
        return chain.proceed(originalRequest.newBuilder()
            .method(""POST"", uppercase(originalRequest.body()))
            .addHeader(""OkHttp-Intercepted"", ""yep"")
            .build());
      }
",non-flaky,5
94627,square_okhttp,InterceptorTest.intercept,"  @Test public void networkInterceptorsRewriteResponseFromServer() throws Exception {
      @Override public Response intercept(Chain chain) throws IOException {
        Response originalResponse = chain.proceed(chain.request());
        return originalResponse.newBuilder()
            .body(uppercase(originalResponse.body()))
            .addHeader(""OkHttp-Intercepted"", ""yep"")
            .build();
      }
",non-flaky,5
94628,square_okhttp,InterceptorTest.intercept,"  @Test public void multipleNetworkInterceptors() throws Exception {
      @Override public Response intercept(Chain chain) throws IOException {
        Request originalRequest = chain.request();
        Response originalResponse = chain.proceed(originalRequest.newBuilder()
            .addHeader(""Request-Interceptor"", ""Android"") // 1. Added first.
            .build());
        return originalResponse.newBuilder()
            .addHeader(""Response-Interceptor"", ""Donut"") // 4. Added last.
            .build();
      }
",non-flaky,5
94629,square_okhttp,InterceptorTest.intercept,"  @Test public void asyncNetworkInterceptors() throws Exception {
      @Override public Response intercept(Chain chain) throws IOException {
        Response originalResponse = chain.proceed(chain.request());
        return originalResponse.newBuilder()
            .addHeader(""OkHttp-Intercepted"", ""yep"")
            .build();
      }
",non-flaky,5
94630,square_okhttp,InterceptorTest.intercept,"  @Test public void applicationInterceptorsCanMakeMultipleRequestsToServer() throws Exception {
          @Override public Response intercept(Chain chain) throws IOException {
            Response response1 = chain.proceed(chain.request());
            response1.body().close();
            return chain.proceed(chain.request());
          }
",non-flaky,5
94631,square_okhttp,InterceptorTest.intercept,"  @Test public void interceptorMakesAnUnrelatedRequest() throws Exception {
          @Override public Response intercept(Chain chain) throws IOException {
            if (chain.request().url().encodedPath().equals(""/b"")) {
              Request requestA = new Request.Builder()
                  .url(server.url(""/a""))
                  .build();
              Response responseA = client.newCall(requestA).execute();
              assertEquals(""a"", responseA.body().string());
            }

            return chain.proceed(chain.request());
          }
",non-flaky,5
94632,square_okhttp,InterceptorTest.intercept,"  @Test public void interceptorMakesAnUnrelatedAsyncRequest() throws Exception {
          @Override public Response intercept(Chain chain) throws IOException {
            if (chain.request().url().encodedPath().equals(""/b"")) {
              Request requestA = new Request.Builder()
                  .url(server.url(""/a""))
                  .build();

              try {
                RecordingCallback callbackA = new RecordingCallback();
                client.newCall(requestA).enqueue(callbackA);
                callbackA.await(requestA.url()).assertBody(""a"");
              } catch (Exception e) {
                throw new RuntimeException(e);
              }
            }

            return chain.proceed(chain.request());
          }
",non-flaky,5
94633,square_okhttp,InterceptorTest.intercept,"  @Test public void networkInterceptorThrowsRuntimeExceptionSynchronous() throws Exception {
      @Override public Response intercept(Chain chain) throws IOException {
        throw new RuntimeException(""boom!"");
      }
",non-flaky,5
94634,square_okhttp,InterceptorTest.intercept,"  @Test public void networkInterceptorModifiedRequestIsReturned() throws IOException {
      @Override public Response intercept(Chain chain) throws IOException {
        return chain.proceed(chain.request().newBuilder()
            .header(""User-Agent"", ""intercepted request"")
            .build());
      }
",non-flaky,5
94635,square_okhttp,InterceptorTest.intercept,"  @Test public void networkInterceptorThrowsRuntimeExceptionAsynchronous() throws Exception {
      @Override public Response intercept(Chain chain) throws IOException {
        throw new RuntimeException(""boom!"");
      }
",non-flaky,5
94636,square_okhttp,InterceptorTest.intercept,"  @Test public void applicationInterceptorReturnsNull() throws Exception {
      @Override public Response intercept(Chain chain) throws IOException {
        chain.proceed(chain.request());
        return null;
      }
",non-flaky,5
94637,square_okhttp,InterceptorTest.intercept,"  @Test public void networkInterceptorReturnsNull() throws Exception {
      @Override public Response intercept(Chain chain) throws IOException {
        chain.proceed(chain.request());
        return null;
      }
",non-flaky,5
94638,square_okhttp,InterceptorTest.intercept,"  @Test public void networkInterceptorReturnsConnectionOnEmptyBody() throws Exception {
      @Override public Response intercept(Chain chain) throws IOException {
        Response response = chain.proceed(chain.request());
        assertNotNull(chain.connection());
        return response;
      }
",non-flaky,5
94639,square_okhttp,ResponseTest.close,"  @Test public void eachPeakIsIndependent() throws Exception {
      @Override public void close() throws IOException {
        closed = true;
      }
",non-flaky,5
94640,square_okhttp,SocksProxyTest.select,"  @Test public void proxySelector() throws Exception {
      @Override public List<Proxy> select(URI uri) {
        return Collections.singletonList(socksProxy.proxy());
      }
",non-flaky,5
94641,square_okhttp,DispatcherTest.intercept,"  @Test public void synchronousCallAccessors() throws Exception {
              @Override public Response intercept(Chain chain) throws IOException {
                try {
                  ready.countDown();
                  waiting.await();
                } catch (InterruptedException e) {
                  throw new AssertionError();
                }
                throw new IOException();
              }
",non-flaky,5
94642,square_okhttp,DispatcherTest.run,"  @Test public void idleCallbackInvokedWhenIdle() throws InterruptedException {
      @Override public void run() {
        idle.set(true);
      }
",non-flaky,5
94643,square_okhttp,OkHttpClientTest.intercept,"  @Test public void clonedInterceptorsListsAreIndependent() throws Exception {
      @Override public Response intercept(Chain chain) throws IOException {
        return chain.proceed(chain.request());
      }
",non-flaky,5
94644,square_okhttp,ConnectionReuseTest.intercept,"  @Test public void connectionsAreNotReusedIfNetworkInterceptorInterferes() throws Exception {
      @Override public Response intercept(Chain chain) throws IOException {
        Response response = chain.proceed(chain.request());
        return response.newBuilder()
            .body(ResponseBody.create(null, ""unrelated response body!""))
            .build();
      }
",non-flaky,5
94645,square_okhttp,ConnectionSpecSelectorTest.nonRetryableIOException,"  @Test
  public void nonRetryableIOException() throws Exception {
    ConnectionSpecSelector connectionSpecSelector =
        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
    connectionSpecSelector.configureSecureSocket(socket);

    boolean retry = connectionSpecSelector.connectionFailed(
        new IOException(""Non-handshake exception""));
    assertFalse(retry);
    socket.close();
  }
",non-flaky,5
94646,square_okhttp,ConnectionSpecSelectorTest.nonRetryableSSLHandshakeException,"  @Test
  public void nonRetryableSSLHandshakeException() throws Exception {
    ConnectionSpecSelector connectionSpecSelector =
        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
    connectionSpecSelector.configureSecureSocket(socket);

    SSLHandshakeException trustIssueException =
        new SSLHandshakeException(""Certificate handshake exception"");
    trustIssueException.initCause(new CertificateException());
    boolean retry = connectionSpecSelector.connectionFailed(trustIssueException);
    assertFalse(retry);
    socket.close();
  }
",non-flaky,5
94647,square_okhttp,ConnectionSpecSelectorTest.retryableSSLHandshakeException,"  @Test
  public void retryableSSLHandshakeException() throws Exception {
    ConnectionSpecSelector connectionSpecSelector =
        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
    connectionSpecSelector.configureSecureSocket(socket);

    boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
    assertTrue(retry);
    socket.close();
  }
",non-flaky,5
94648,square_okhttp,ConnectionSpecSelectorTest.someFallbacksSupported,"  @Test
  public void someFallbacksSupported() throws Exception {
    ConnectionSpec sslV3 =
        new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
            .tlsVersions(TlsVersion.SSL_3_0)
            .build();

    ConnectionSpecSelector connectionSpecSelector = createConnectionSpecSelector(
        ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, sslV3);

    TlsVersion[] enabledSocketTlsVersions = {TlsVersion.TLS_1_1, TlsVersion.TLS_1_0};
    SSLSocket socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);

    // MODERN_TLS is used here.
    connectionSpecSelector.configureSecureSocket(socket);
    assertEnabledProtocols(socket, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);

    boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
    assertTrue(retry);
    socket.close();

    // COMPATIBLE_TLS is used here.
    socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
    connectionSpecSelector.configureSecureSocket(socket);
    assertEnabledProtocols(socket, TlsVersion.TLS_1_0);

    retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
    assertFalse(retry);
    socket.close();

    // sslV3 is not used because SSLv3 is not enabled on the socket.
  }
",non-flaky,5
94649,square_okhttp,RouteSelectorTest.select,"  @Test public void proxySelectorReturnsNull() throws Exception {
      @Override public List<Proxy> select(URI uri) {
        assertEquals(uriHost, uri.getHost());
        return null;
      }
",non-flaky,5
94650,square_okhttp,RelayTest.call,"  @Test public void racingReaders() throws Exception {
      @Override public ByteString call() throws Exception {
        Buffer buffer = new Buffer();
        while (source.read(buffer, 16384) != -1) {
        }
        source.close();
        return buffer.readByteString();
      }
",non-flaky,5
94651,square_okhttp,Jdk9PlatformTest.buildsWhenJdk9,"  @Test
  public void buildsWhenJdk9() {
    assumeTrue(getPlatform().equals(""jdk9""));

    assertNotNull(Jdk9Platform.buildIfSupported());
  }
",non-flaky,5
94652,square_okhttp,Jdk9PlatformTest.findsAlpnMethods,"  @Test
  public void findsAlpnMethods() {
    assumeTrue(getPlatform().equals(""jdk9""));

    Jdk9Platform platform = Jdk9Platform.buildIfSupported();

    assertEquals(""getApplicationProtocol"", platform.getProtocolMethod.getName());
    assertEquals(""setApplicationProtocols"", platform.setProtocolMethod.getName());
  }
",non-flaky,5
94653,square_okhttp,JdkWithJettyBootPlatformTest.testBuildsWithJettyBoot,"  @Test
  public void testBuildsWithJettyBoot() {
    assumeTrue(getPlatform().equals(""jdk-with-jetty-boot""));

    assertNotNull(JdkWithJettyBootPlatform.buildIfSupported());
  }
",non-flaky,5
94654,square_okhttp,OptionalMethodTest.isSupported,"  @Test
  public void isSupported() throws Exception {
    {
      BaseClass base = new BaseClass();
      assertTrue(STRING_METHOD_RETURNS_ANY.isSupported(base));
      assertTrue(STRING_METHOD_RETURNS_STRING.isSupported(base));
      assertFalse(STRING_METHOD_RETURNS_INT.isSupported(base));
      assertTrue(VOID_METHOD_RETURNS_ANY.isSupported(base));
      assertTrue(VOID_METHOD_RETURNS_VOID.isSupported(base));
      assertFalse(SUBCLASS_METHOD_RETURNS_ANY.isSupported(base));
      assertFalse(SUBCLASS_METHOD_RETURNS_STRING.isSupported(base));
      assertFalse(SUBCLASS_METHOD_RETURNS_INT.isSupported(base));
      assertFalse(METHOD_WITH_ARGS_WRONG_PARAMS.isSupported(base));
      assertFalse(METHOD_WITH_ARGS_CORRECT_PARAMS.isSupported(base));
    }
    {
      SubClass1 subClass1 = new SubClass1();
      assertTrue(STRING_METHOD_RETURNS_ANY.isSupported(subClass1));
      assertTrue(STRING_METHOD_RETURNS_STRING.isSupported(subClass1));
      assertFalse(STRING_METHOD_RETURNS_INT.isSupported(subClass1));
      assertTrue(VOID_METHOD_RETURNS_ANY.isSupported(subClass1));
      assertTrue(VOID_METHOD_RETURNS_VOID.isSupported(subClass1));
      assertTrue(SUBCLASS_METHOD_RETURNS_ANY.isSupported(subClass1));
      assertTrue(SUBCLASS_METHOD_RETURNS_STRING.isSupported(subClass1));
      assertFalse(SUBCLASS_METHOD_RETURNS_INT.isSupported(subClass1));
      assertFalse(METHOD_WITH_ARGS_WRONG_PARAMS.isSupported(subClass1));
      assertTrue(METHOD_WITH_ARGS_CORRECT_PARAMS.isSupported(subClass1));
    }
    {
      SubClass2 subClass2 = new SubClass2();
      assertTrue(STRING_METHOD_RETURNS_ANY.isSupported(subClass2));
      assertTrue(STRING_METHOD_RETURNS_STRING.isSupported(subClass2));
      assertFalse(STRING_METHOD_RETURNS_INT.isSupported(subClass2));
      assertTrue(VOID_METHOD_RETURNS_ANY.isSupported(subClass2));
      assertTrue(VOID_METHOD_RETURNS_VOID.isSupported(subClass2));
      assertTrue(SUBCLASS_METHOD_RETURNS_ANY.isSupported(subClass2));
      assertFalse(SUBCLASS_METHOD_RETURNS_STRING.isSupported(subClass2));
      assertTrue(SUBCLASS_METHOD_RETURNS_INT.isSupported(subClass2));
      assertFalse(METHOD_WITH_ARGS_WRONG_PARAMS.isSupported(subClass2));
      assertTrue(METHOD_WITH_ARGS_CORRECT_PARAMS.isSupported(subClass2));
    }
  }
",non-flaky,5
94655,square_okhttp,OptionalMethodTest.invoke,"  @Test
  public void invoke() throws Exception {
    {
      BaseClass base = new BaseClass();
      assertEquals(""string"", STRING_METHOD_RETURNS_STRING.invoke(base));
      assertEquals(""string"", STRING_METHOD_RETURNS_ANY.invoke(base));
      assertErrorOnInvoke(STRING_METHOD_RETURNS_INT, base);
      assertNull(VOID_METHOD_RETURNS_ANY.invoke(base));
      assertNull(VOID_METHOD_RETURNS_VOID.invoke(base));
      assertErrorOnInvoke(SUBCLASS_METHOD_RETURNS_ANY, base);
      assertErrorOnInvoke(SUBCLASS_METHOD_RETURNS_STRING, base);
      assertErrorOnInvoke(SUBCLASS_METHOD_RETURNS_INT, base);
      assertErrorOnInvoke(METHOD_WITH_ARGS_WRONG_PARAMS, base);
      assertErrorOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, base);
    }
    {
      SubClass1 subClass1 = new SubClass1();
      assertEquals(""string"", STRING_METHOD_RETURNS_STRING.invoke(subClass1));
      assertEquals(""string"", STRING_METHOD_RETURNS_ANY.invoke(subClass1));
      assertErrorOnInvoke(STRING_METHOD_RETURNS_INT, subClass1);
      assertNull(VOID_METHOD_RETURNS_ANY.invoke(subClass1));
      assertNull(VOID_METHOD_RETURNS_VOID.invoke(subClass1));
      assertEquals(""subclassMethod1"", SUBCLASS_METHOD_RETURNS_ANY.invoke(subClass1));
      assertEquals(""subclassMethod1"", SUBCLASS_METHOD_RETURNS_STRING.invoke(subClass1));
      assertErrorOnInvoke(SUBCLASS_METHOD_RETURNS_INT, subClass1);
      assertErrorOnInvoke(METHOD_WITH_ARGS_WRONG_PARAMS, subClass1);
      assertEquals(""arg"", METHOD_WITH_ARGS_CORRECT_PARAMS.invoke(subClass1, ""arg""));
    }

    {
      SubClass2 subClass2 = new SubClass2();
      assertEquals(""string"", STRING_METHOD_RETURNS_STRING.invoke(subClass2));
      assertEquals(""string"", STRING_METHOD_RETURNS_ANY.invoke(subClass2));
      assertErrorOnInvoke(STRING_METHOD_RETURNS_INT, subClass2);
      assertNull(VOID_METHOD_RETURNS_ANY.invoke(subClass2));
      assertNull(VOID_METHOD_RETURNS_VOID.invoke(subClass2));
      assertEquals(1234, SUBCLASS_METHOD_RETURNS_ANY.invoke(subClass2));
      assertErrorOnInvoke(SUBCLASS_METHOD_RETURNS_STRING, subClass2);
      assertEquals(1234, SUBCLASS_METHOD_RETURNS_INT.invoke(subClass2));
      assertErrorOnInvoke(METHOD_WITH_ARGS_WRONG_PARAMS, subClass2);
      assertEquals(""arg"", METHOD_WITH_ARGS_CORRECT_PARAMS.invoke(subClass2, ""arg""));
    }
  }
",non-flaky,5
94656,square_okhttp,OptionalMethodTest.invokeBadArgs,"  @Test
  public void invokeBadArgs() throws Exception {
    SubClass1 subClass1 = new SubClass1();
    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1); // no args
    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, 123);
    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, true);
    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
        new Object());
    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, ""one"",
        ""two"");
  }
",non-flaky,5
94657,square_okhttp,OptionalMethodTest.invokeWithException,"  @Test
  public void invokeWithException() throws Exception {
    SubClass2 subClass2 = new SubClass2();
    try {
      THROWS_EXCEPTION.invoke(subClass2);
    } catch (InvocationTargetException expected) {
      assertTrue(expected.getTargetException() instanceof IOException);
    }

    try {
      THROWS_RUNTIME_EXCEPTION.invoke(subClass2);
    } catch (InvocationTargetException expected) {
      assertTrue(expected.getTargetException() instanceof NumberFormatException);
    }
  }
",non-flaky,5
94658,square_okhttp,OptionalMethodTest.invokeNonPublic,"  @Test
  public void invokeNonPublic() throws Exception {
    SubClass2 subClass2 = new SubClass2();
    assertFalse(NON_PUBLIC.isSupported(subClass2));
    assertErrorOnInvoke(NON_PUBLIC, subClass2);
  }
",non-flaky,5
94659,square_okhttp,OptionalMethodTest.invokeOptional,"  @Test
  public void invokeOptional() throws Exception {
    {
      BaseClass base = new BaseClass();
      assertEquals(""string"", STRING_METHOD_RETURNS_STRING.invokeOptional(base));
      assertEquals(""string"", STRING_METHOD_RETURNS_ANY.invokeOptional(base));
      assertNull(STRING_METHOD_RETURNS_INT.invokeOptional(base));
      assertNull(VOID_METHOD_RETURNS_ANY.invokeOptional(base));
      assertNull(VOID_METHOD_RETURNS_VOID.invokeOptional(base));
      assertNull(SUBCLASS_METHOD_RETURNS_ANY.invokeOptional(base));
      assertNull(SUBCLASS_METHOD_RETURNS_STRING.invokeOptional(base));
      assertNull(SUBCLASS_METHOD_RETURNS_INT.invokeOptional(base));
      assertNull(METHOD_WITH_ARGS_WRONG_PARAMS.invokeOptional(base));
      assertNull(METHOD_WITH_ARGS_CORRECT_PARAMS.invokeOptional(base));
    }
    {
      SubClass1 subClass1 = new SubClass1();
      assertEquals(""string"", STRING_METHOD_RETURNS_STRING.invokeOptional(subClass1));
      assertEquals(""string"", STRING_METHOD_RETURNS_ANY.invokeOptional(subClass1));
      assertNull(STRING_METHOD_RETURNS_INT.invokeOptional(subClass1));
      assertNull(VOID_METHOD_RETURNS_ANY.invokeOptional(subClass1));
      assertNull(VOID_METHOD_RETURNS_VOID.invokeOptional(subClass1));
      assertEquals(""subclassMethod1"", SUBCLASS_METHOD_RETURNS_ANY.invokeOptional(subClass1));
      assertEquals(""subclassMethod1"", SUBCLASS_METHOD_RETURNS_STRING.invokeOptional(subClass1));
      assertNull(SUBCLASS_METHOD_RETURNS_INT.invokeOptional(subClass1));
      assertNull(METHOD_WITH_ARGS_WRONG_PARAMS.invokeOptional(subClass1));
      assertEquals(""arg"", METHOD_WITH_ARGS_CORRECT_PARAMS.invokeOptional(subClass1, ""arg""));
    }

    {
      SubClass2 subClass2 = new SubClass2();
      assertEquals(""string"", STRING_METHOD_RETURNS_STRING.invokeOptional(subClass2));
      assertEquals(""string"", STRING_METHOD_RETURNS_ANY.invokeOptional(subClass2));
      assertNull(STRING_METHOD_RETURNS_INT.invokeOptional(subClass2));
      assertNull(VOID_METHOD_RETURNS_ANY.invokeOptional(subClass2));
      assertNull(VOID_METHOD_RETURNS_VOID.invokeOptional(subClass2));
      assertEquals(1234, SUBCLASS_METHOD_RETURNS_ANY.invokeOptional(subClass2));
      assertNull(SUBCLASS_METHOD_RETURNS_STRING.invokeOptional(subClass2));
      assertEquals(1234, SUBCLASS_METHOD_RETURNS_INT.invokeOptional(subClass2));
      assertNull(METHOD_WITH_ARGS_WRONG_PARAMS.invokeOptional(subClass2));
      assertEquals(""arg"", METHOD_WITH_ARGS_CORRECT_PARAMS.invokeOptional(subClass2, ""arg""));
    }
  }
",non-flaky,5
94660,square_okhttp,OptionalMethodTest.invokeOptionalBadArgs,"  @Test
  public void invokeOptionalBadArgs() throws Exception {
    SubClass1 subClass1 = new SubClass1();
    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS,
        subClass1); // no args
    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, 123);
    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
        true);
    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
        new Object());
    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
        ""one"", ""two"");
  }
",non-flaky,5
94661,square_okhttp,OptionalMethodTest.invokeOptionalWithException,"  @Test
  public void invokeOptionalWithException() throws Exception {
    SubClass2 subClass2 = new SubClass2();
    try {
      THROWS_EXCEPTION.invokeOptional(subClass2);
    } catch (InvocationTargetException expected) {
      assertTrue(expected.getTargetException() instanceof IOException);
    }

    try {
      THROWS_RUNTIME_EXCEPTION.invokeOptional(subClass2);
    } catch (InvocationTargetException expected) {
      assertTrue(expected.getTargetException() instanceof NumberFormatException);
    }
  }
",non-flaky,5
94662,square_okhttp,OptionalMethodTest.invokeOptionalNonPublic,"  @Test
  public void invokeOptionalNonPublic() throws Exception {
    SubClass2 subClass2 = new SubClass2();
    assertFalse(NON_PUBLIC.isSupported(subClass2));
    assertErrorOnInvokeOptional(NON_PUBLIC, subClass2);
  }
",non-flaky,5
94663,square_okhttp,Http2Test.headers,"  @Test public void onlyOneLiteralHeadersFrame() throws IOException {
      @Override public void headers(boolean inFinished, int streamId,
          int associatedStreamId, List<Header> headerBlock) {
        assertTrue(inFinished);
        assertEquals(expectedStreamId, streamId);
        assertEquals(-1, associatedStreamId);
        assertEquals(sentHeaders, headerBlock);
      }
",non-flaky,5
94664,square_okhttp,Http2Test.priority,"  @Test public void headersWithPriority() throws IOException {
      @Override public void priority(int streamId, int streamDependency, int weight,
          boolean exclusive) {
        assertEquals(0, streamDependency);
        assertEquals(256, weight);
        assertFalse(exclusive);
      }
",non-flaky,5
94665,square_okhttp,Http2Test.headers,"  @Test public void headersFrameThenContinuation() throws IOException {
      @Override public void headers(boolean inFinished, int streamId,
          int associatedStreamId, List<Header> headerBlock) {
        assertFalse(inFinished);
        assertEquals(expectedStreamId, streamId);
        assertEquals(-1, associatedStreamId);
        assertEquals(sentHeaders, headerBlock);
      }
",non-flaky,5
94666,square_okhttp,Http2Test.pushPromise,"  @Test public void pushPromise() throws IOException {
      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
        assertEquals(expectedStreamId, streamId);
        assertEquals(expectedPromisedStreamId, promisedStreamId);
        assertEquals(pushPromise, headerBlock);
      }
",non-flaky,5
94667,square_okhttp,Http2Test.pushPromise,"  @Test public void pushPromiseThenContinuation() throws IOException {
      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
        assertEquals(expectedStreamId, streamId);
        assertEquals(expectedPromisedStreamId, promisedStreamId);
        assertEquals(pushPromise, headerBlock);
      }
",non-flaky,5
94668,square_okhttp,Http2Test.rstStream,"  @Test public void readRstStreamFrame() throws IOException {
      @Override public void rstStream(int streamId, ErrorCode errorCode) {
        assertEquals(expectedStreamId, streamId);
        assertEquals(ErrorCode.PROTOCOL_ERROR, errorCode);
      }
",non-flaky,5
94669,square_okhttp,Http2Test.settings,"  @Test public void readSettingsFrame() throws IOException {
      @Override public void settings(boolean clearPrevious, Settings settings) {
        assertFalse(clearPrevious); // No clearPrevious in HTTP/2.
        assertEquals(reducedTableSizeBytes, settings.getHeaderTableSize());
        assertEquals(false, settings.getEnablePush(true));
      }
",non-flaky,5
94670,square_okhttp,Http2Test.settings,"  @Test public void readSettingsFrameUnknownSettingId() throws IOException {
      @Override public void settings(boolean clearPrevious, Settings settings) {
        settingValue.set(settings.get(7));
      }
",non-flaky,5
94671,square_okhttp,Http2Test.ping,"  @Test public void pingRoundTrip() throws IOException {
      @Override public void ping(boolean ack, int payload1, int payload2) {
        assertTrue(ack);
        assertEquals(expectedPayload1, payload1);
        assertEquals(expectedPayload2, payload2);
      }
",non-flaky,5
94672,square_okhttp,Http2Test.data,"  @Test public void maxLengthDataFrame() throws IOException {
      @Override public void data(boolean inFinished, int streamId, BufferedSource source,
          int length) throws IOException {
        assertFalse(inFinished);
        assertEquals(expectedStreamId, streamId);
        assertEquals(Http2.INITIAL_MAX_FRAME_SIZE, length);
        ByteString data = source.readByteString(length);
        for (byte b : data.toByteArray()) {
          assertEquals(2, b);
        }
      }
",non-flaky,5
94673,square_okhttp,Http2Test.windowUpdate,"  @Test public void windowUpdateRoundTrip() throws IOException {
      @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
        assertEquals(expectedStreamId, streamId);
        assertEquals(expectedWindowSizeIncrement, windowSizeIncrement);
      }
",non-flaky,5
94674,square_okhttp,Http2Test.goAway,"  @Test public void goAwayWithoutDebugDataRoundTrip() throws IOException {
      @Override public void goAway(
          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
        assertEquals(expectedStreamId, lastGoodStreamId);
        assertEquals(expectedError, errorCode);
        assertEquals(0, debugData.size());
      }
",non-flaky,5
94675,square_okhttp,Http2Test.goAway,"  @Test public void goAwayWithDebugDataRoundTrip() throws IOException {
      @Override public void goAway(
          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
        assertEquals(0, lastGoodStreamId);
        assertEquals(expectedError, errorCode);
        assertEquals(expectedData, debugData);
      }
",non-flaky,5
94676,square_okhttp,Http2Test.headers,"  @Test public void streamIdHasReservedBit() throws IOException {
      @Override public void headers(boolean inFinished, int streamId,
          int associatedStreamId, List<Header> headerBlock) {
        assertFalse(inFinished);
        assertEquals(expectedStreamId, streamId);
        assertEquals(-1, associatedStreamId);
        assertEquals(headerEntries(""foo"", ""barrr"", ""baz"", ""qux""), headerBlock);
      }
",non-flaky,5
94677,square_okhttp,Http2ConnectionTest.onStream,"  @Test public void serverSendsSettingsToClient() throws Exception {
      @Override public void onStream(Http2Stream stream) throws IOException {
        throw new AssertionError();
      }
",non-flaky,5
94678,square_okhttp,Http2ConnectionTest.onRequest,"  @Test public void blockedStreamDoesntStarveNewStream() throws Exception {
    @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
      return false;
    }
",non-flaky,5
94679,square_okhttp,DisconnectTest.run,"  @Test public void interruptReadingResponseBody() throws Exception {
      @Override public void run() {
        try {
          sleep(delayMillis);
          connection.disconnect();
        } catch (InterruptedException e) {
          throw new RuntimeException(e);
        }
      }
",non-flaky,5
94680,square_okhttp,ThreadInterruptTest.run,"  @Test public void interruptReadingResponseBody() throws Exception {
      @Override public void run() {
        try {
          sleep(delayMillis);
          toInterrupt.interrupt();
        } catch (InterruptedException e) {
          throw new RuntimeException(e);
        }
      }
",non-flaky,5
94681,square_okhttp,ClientAuthTest.buildClient,"  @Test public void invalidClientAuthFails() throws Throwable {
  public OkHttpClient buildClient(HeldCertificate cert, HeldCertificate... chain) {
    SslClient.Builder sslClientBuilder = new SslClient.Builder()
        .addTrustedCertificate(serverRootCa.certificate);

    if (cert != null) {
      sslClientBuilder.certificateChain(cert, chain);
    }

    SslClient sslClient = sslClientBuilder.build();
    return new OkHttpClient.Builder()
        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
        .build();
  }
",non-flaky,5
94682,square_okhttp,DiskLruCacheTest.writeFile,"  @Test public void abortAfterDetach() throws Exception {
  public void writeFile(File file, String content) throws Exception {
    BufferedSink sink = Okio.buffer(fileSystem.sink(file));
    sink.writeUtf8(content);
    sink.close();
  }
",non-flaky,5
94683,square_okhttp,HttpResponseCacheTest.get,"  @Test public void getInstalledWithWrongTypeInstalled() {
      public CacheResponse get(URI uri, String requestMethod,
          Map<String, List<String>> requestHeaders) {
        return null;
      }
",non-flaky,5
94684,square_okhttp,CacheAdapterTest.get,"  @Test public void get_httpGet() throws Exception {
      @Override public CacheResponse get(
          URI uri, String method, Map<String, List<String>> headers) throws IOException {
        try {
          assertEquals(toUri(serverUrl), uri);
          assertEquals(""GET"", method);
          assertTrue(""Arbitrary standard header not present"", headers.containsKey(""User-Agent""));
          assertEquals(Collections.singletonList(""value1""), headers.get(""key1""));
          return null;
        } catch (Throwable t) {
          throw new IOException(""unexpected cache failure"", t);
        }
      }
",non-flaky,5
94685,square_okhttp,CacheAdapterTest.get,"  @Test public void get_httpsGet() throws Exception {
      @Override public CacheResponse get(URI uri, String method, Map<String, List<String>> headers)
          throws IOException {
        try {
          assertEquals(""https"", uri.getScheme());
          assertEquals(toUri(serverUrl), uri);
          assertEquals(""GET"", method);
          assertTrue(""Arbitrary standard header not present"", headers.containsKey(""User-Agent""));
          assertEquals(Collections.singletonList(""value1""), headers.get(""key1""));
          return null;
        } catch (Throwable t) {
          throw new IOException(""unexpected cache failure"", t);
        }
      }
",non-flaky,5
94686,square_okhttp,CacheAdapterTest.put,"  @Test public void put_httpGet() throws Exception {
      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
        try {
          assertTrue(connection instanceof HttpURLConnection);
          assertFalse(connection instanceof HttpsURLConnection);

          assertEquals(response.length, connection.getContentLength());

          HttpURLConnection httpUrlConnection = (HttpURLConnection) connection;
          assertEquals(""GET"", httpUrlConnection.getRequestMethod());
          assertTrue(httpUrlConnection.getDoInput());
          assertFalse(httpUrlConnection.getDoOutput());

          assertEquals(""Fantastic"", httpUrlConnection.getResponseMessage());
          assertEquals(toUri(serverUrl), uri);
          assertEquals(serverUrl, connection.getURL());
          assertEquals(""value"", connection.getRequestProperty(""key""));

          // Check retrieval by string key.
          assertEquals(statusLine, httpUrlConnection.getHeaderField(null));
          assertEquals(""c"", httpUrlConnection.getHeaderField(""A""));
          // The RI and OkHttp supports case-insensitive matching for this method.
          assertEquals(""c"", httpUrlConnection.getHeaderField(""a""));
          return null;
        } catch (Throwable t) {
          throw new IOException(""unexpected cache failure"", t);
        }
      }
",non-flaky,5
94687,square_okhttp,CacheAdapterTest.put,"  @Test public void put_httpPost() throws Exception {
      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
        try {
          assertTrue(connection instanceof HttpURLConnection);
          assertFalse(connection instanceof HttpsURLConnection);

          assertEquals(0, connection.getContentLength());

          HttpURLConnection httpUrlConnection = (HttpURLConnection) connection;
          assertEquals(""POST"", httpUrlConnection.getRequestMethod());
          assertTrue(httpUrlConnection.getDoInput());
          assertTrue(httpUrlConnection.getDoOutput());

          assertEquals(""Fantastic"", httpUrlConnection.getResponseMessage());
          assertEquals(toUri(serverUrl), uri);
          assertEquals(serverUrl, connection.getURL());
          assertEquals(""value"", connection.getRequestProperty(""key""));

          // Check retrieval by string key.
          assertEquals(statusLine, httpUrlConnection.getHeaderField(null));
          assertEquals(""c"", httpUrlConnection.getHeaderField(""A""));
          // The RI and OkHttp supports case-insensitive matching for this method.
          assertEquals(""c"", httpUrlConnection.getHeaderField(""a""));
          return null;
        } catch (Throwable t) {
          throw new IOException(""unexpected cache failure"", t);
        }
      }
",non-flaky,5
94688,square_okhttp,CacheAdapterTest.put,"  @Test public void put_httpsGet() throws Exception {
      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
        try {
          assertTrue(connection instanceof HttpsURLConnection);
          assertEquals(toUri(serverUrl), uri);
          assertEquals(serverUrl, connection.getURL());

          HttpsURLConnection cacheHttpsUrlConnection = (HttpsURLConnection) connection;
          HttpsURLConnection realHttpsUrlConnection =
              (HttpsURLConnection) CacheAdapterTest.this.connection;
          assertEquals(realHttpsUrlConnection.getCipherSuite(),
              cacheHttpsUrlConnection.getCipherSuite());
          assertEquals(realHttpsUrlConnection.getPeerPrincipal(),
              cacheHttpsUrlConnection.getPeerPrincipal());
          assertArrayEquals(realHttpsUrlConnection.getLocalCertificates(),
              cacheHttpsUrlConnection.getLocalCertificates());
          assertArrayEquals(realHttpsUrlConnection.getServerCertificates(),
              cacheHttpsUrlConnection.getServerCertificates());
          assertEquals(realHttpsUrlConnection.getLocalPrincipal(),
              cacheHttpsUrlConnection.getLocalPrincipal());
          return null;
        } catch (Throwable t) {
          throw new IOException(""unexpected cache failure"", t);
        }
      }
",non-flaky,5
94689,square_okhttp,ResponseCacheTest.assertCookies,"  @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
  public void assertCookies(URL url, String... expectedCookies) throws Exception {
    List<String> actualCookies = new ArrayList<>();
    for (HttpCookie cookie : cookieManager.getCookieStore().get(url.toURI())) {
      actualCookies.add(cookie.toString());
    }
    assertEquals(Arrays.asList(expectedCookies), actualCookies);
  }
",non-flaky,5
94690,square_okhttp,ResponseCacheTest.gzip,"  @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
  public Buffer gzip(String data) throws IOException {
    Buffer result = new Buffer();
    BufferedSink sink = Okio.buffer(new GzipSink(result));
    sink.writeUtf8(data);
    sink.close();
    return result;
  }
",non-flaky,5
94691,square_okhttp,ResponseCacheTest.put,"  @Test public void responseCacheCallbackApis() throws Exception {
      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
        HttpURLConnection httpURLConnection = (HttpURLConnection) connection;
        assertEquals(server.url(""/"").url(), uri.toURL());
        assertEquals(200, httpURLConnection.getResponseCode());
        InputStream is = httpURLConnection.getInputStream();
        try {
          is.read();
          fail();
        } catch (UnsupportedOperationException expected) {
        }
        assertEquals(""5"", connection.getHeaderField(""Content-Length""));
        assertEquals(""text/plain"", connection.getHeaderField(""Content-Type""));
        assertEquals(""ijk"", connection.getHeaderField(""fgh""));
        cacheCount.incrementAndGet();
        return null;
      }
",non-flaky,5
94692,square_okhttp,ResponseCacheTest.abort,"  @Test public void responseCacheReturnsNullOutputStream() throws Exception {
      @Override public CacheRequest put(URI uri, URLConnection connection) {
        return new CacheRequest() {
          @Override public void abort() {
            aborted.set(true);
          }
",non-flaky,5
94693,square_okhttp,ResponseCacheTest.get,"  @Test public void responseCacheReturnsNullStatusLine() throws Exception {
      public CacheResponse get(URI uri, String requestMethod,
          Map<String, List<String>> requestHeaders)
",non-flaky,5
94694,square_okhttp,ResponseCacheTest.get,"  @Test public void responseCacheRequestHeaders() throws IOException, URISyntaxException {
      @Override public CacheResponse get(URI uri, String requestMethod,
          Map<String, List<String>> requestHeaders) throws IOException {
        requestHeadersRef.set(requestHeaders);
        return null;
      }
",non-flaky,5
94695,square_okhttp,JavaApiConverterTest.getBody,"  @Test public void createOkResponseForCacheGet() throws Exception {
      @Override public InputStream getBody() throws IOException {
        return new ByteArrayInputStream(""HelloWorld"".getBytes(StandardCharsets.UTF_8));
      }
",non-flaky,5
94696,square_okhttp,JavaApiConverterTest.getBody,"  @Test public void createOkResponseForCacheGet_withMissingStatusLine() throws Exception {
      @Override public InputStream getBody() throws IOException {
        return null; // Should never be called
      }
",non-flaky,5
94697,square_okhttp,JavaApiConverterTest.getBody,"  @Test public void createOkResponseForCacheGet_secure() throws Exception {
      @Override public InputStream getBody() throws IOException {
        return new ByteArrayInputStream(""HelloWorld"".getBytes(StandardCharsets.UTF_8));
      }
",non-flaky,5
94698,square_okhttp,JavaApiConverterTest.contentType,"  @Test public void extractStatusLine() throws Exception {
      @Override public MediaType contentType() {
        return MediaType.parse(""text/plain; charset=utf-8"");
      }
",non-flaky,5
94699,square_okhttp,RealWebSocketTest.contentType,"  @Test public void streamingMessage() throws IOException {
      @Override public MediaType contentType() {
        return TEXT;
      }
",non-flaky,5
94700,square_okhttp,RealWebSocketTest.contentType,"  @Test public void streamingMessageCanInterleavePing() throws IOException, InterruptedException {
      @Override public MediaType contentType() {
        return TEXT;
      }
",non-flaky,5
95643,togglz_togglz,JSFMapTest.testJSFFeatureMap,"    @Test
    public void testJSFFeatureMap() throws IOException, Exception {

        WebClient client = new WebClient();
        HtmlPage page = client.getPage(url + ""index.jsf"");

        // this part of the page is rendered
        assertTrue(page.asText().contains(""Text for ENABLED feature!""));

        // this part is disabled
        assertFalse(page.asText().contains(""Text for DISABLED feature!""));

        // one div can be found the other not
        assertNotNull(page.getElementById(""enabledDiv""));
        assertNull(page.getElementById(""disabledDiv""));

    }
",non-flaky,5
95644,togglz_togglz,DeviceActivationStrategyTest.shouldBeInactiveForEmptyParams,"    @Test
    public void shouldBeInactiveForEmptyParams() throws Exception {
        String[] emptyArguments = new String[]{"""", """", """"};
        assertThat(requestFrom(NORMAL)).isInactiveWithParams(emptyArguments);
        cleanup();
        assertThat(requestFrom(TABLET)).isInactiveWithParams(emptyArguments);
        cleanup();
        assertThat(requestFrom(MOBILE)).isInactiveWithParams(emptyArguments);
        cleanup();
    }
",non-flaky,5
95645,togglz_togglz,DeviceActivationStrategyTest.shouldBeActiveForDesktop,"    @Test
    public void shouldBeActiveForDesktop() throws Exception {
        String[] desktopOn = new String[]{""YES"", ""NO"", ""NO""};
        assertThat(requestFrom(NORMAL)).isActiveWithParams(desktopOn);
        cleanup();
        assertThat(requestFrom(TABLET)).isInactiveWithParams(desktopOn);
        cleanup();
        assertThat(requestFrom(MOBILE)).isInactiveWithParams(desktopOn);
        cleanup();
    }
",non-flaky,5
95646,togglz_togglz,DeviceActivationStrategyTest.shouldBeActiveForTablet,"    @Test
    public void shouldBeActiveForTablet() throws Exception {
        String[] tabletOn = new String[]{""NO"", ""YES"", ""NO""};
        assertThat(requestFrom(NORMAL)).isInactiveWithParams(tabletOn);
        cleanup();
        assertThat(requestFrom(TABLET)).isActiveWithParams(tabletOn);
        cleanup();
        assertThat(requestFrom(MOBILE)).isInactiveWithParams(tabletOn);
        cleanup();
    }
",non-flaky,5
95647,togglz_togglz,DeviceActivationStrategyTest.shouldBeActiveForMobile,"    @Test
    public void shouldBeActiveForMobile() throws Exception {
        String[] mobileOn = new String[]{""NO"", ""NO"", ""YES""};
        assertThat(requestFrom(NORMAL)).isInactiveWithParams(mobileOn);
        cleanup();
        assertThat(requestFrom(TABLET)).isInactiveWithParams(mobileOn);
        cleanup();
        assertThat(requestFrom(MOBILE)).isActiveWithParams(mobileOn);
        cleanup();
    }
",non-flaky,5
95648,togglz_togglz,DeviceActivationStrategyTest.shouldBeAccurateForLowerCaseParams,"    @Test
    public void shouldBeAccurateForLowerCaseParams() throws Exception {
        String[] desktopOn = new String[]{""yes"", ""no"", ""yes""};
        assertThat(requestFrom(NORMAL)).isActiveWithParams(desktopOn);
        cleanup();
        String[] tabletOn = new String[]{""no"", ""yes"", ""NO""};
        assertThat(requestFrom(TABLET)).isActiveWithParams(tabletOn);
        cleanup();
        String[] mobileOn = new String[]{""no"", ""no"", ""yes""};
        assertThat(requestFrom(MOBILE)).isActiveWithParams(mobileOn);
        cleanup();
    }
",non-flaky,5
95649,togglz_togglz,ShiroUsersTest.testShiroAsAnonymousUser,"    @Test
    public void testShiroAsAnonymousUser() throws Exception {

        WebClient client = new WebClient();
        TextPage page = client.getPage(url + ""features"");
        assertTrue(page.getContent().contains(""DISABLED = false""));
        assertTrue(page.getContent().contains(""ENABLED_FOR_ALL = true""));
        assertTrue(page.getContent().contains(""ENABLED_FOR_CK = false""));

        TextPage userPage = client.getPage(url + ""user"");
        assertTrue(userPage.getContent().contains(""USER = null""));
        assertTrue(userPage.getContent().contains(""ADMIN = null""));

    }
",non-flaky,5
95650,togglz_togglz,ShiroUsersTest.testShiroLoginAsFeatureAdmin,"    @Test
    public void testShiroLoginAsFeatureAdmin() throws Exception {

        WebClient client = new WebClient();

        TextPage beforeLogin = client.getPage(url + ""user"");
        assertTrue(beforeLogin.getContent().contains(""USER = null""));
        assertTrue(beforeLogin.getContent().contains(""ADMIN = null""));

        TextPage loginPage = client.getPage(url + ""login?user=ck"");
        assertTrue(loginPage.getContent().contains(""SUCCESS""));

        TextPage afterLogin = client.getPage(url + ""user"");
        assertTrue(afterLogin.getContent().contains(""USER = ck""));
        assertTrue(afterLogin.getContent().contains(""ADMIN = true""));

        TextPage logoutPage = client.getPage(url + ""logout"");
        assertTrue(logoutPage.getContent().contains(""SUCCESS""));

        TextPage afterLogout = client.getPage(url + ""user"");
        assertTrue(afterLogout.getContent().contains(""USER = null""));
        assertTrue(afterLogout.getContent().contains(""ADMIN = null""));

    }
",non-flaky,5
95651,togglz_togglz,ShiroUsersTest.testShiroLoginAsNormalUser,"    @Test
    public void testShiroLoginAsNormalUser() throws Exception {

        WebClient client = new WebClient();

        TextPage beforeLogin = client.getPage(url + ""user"");
        assertTrue(beforeLogin.getContent().contains(""USER = null""));
        assertTrue(beforeLogin.getContent().contains(""ADMIN = null""));

        TextPage loginPage = client.getPage(url + ""login?user=somebody"");
        assertTrue(loginPage.getContent().contains(""SUCCESS""));

        TextPage afterLogin = client.getPage(url + ""user"");
        assertTrue(afterLogin.getContent().contains(""USER = somebody""));
        assertTrue(afterLogin.getContent().contains(""ADMIN = false""));

        TextPage logoutPage = client.getPage(url + ""logout"");
        assertTrue(logoutPage.getContent().contains(""SUCCESS""));

        TextPage afterLogout = client.getPage(url + ""user"");
        assertTrue(afterLogout.getContent().contains(""USER = null""));
        assertTrue(afterLogout.getContent().contains(""ADMIN = null""));

    }
",non-flaky,5
95652,togglz_togglz,ShiroUsersTest.testShiroWithCorrectUser,"    @Test
    public void testShiroWithCorrectUser() throws Exception {

        WebClient client = new WebClient();

        TextPage beforeLogin = client.getPage(url + ""features"");
        assertTrue(beforeLogin.getContent().contains(""DISABLED = false""));
        assertTrue(beforeLogin.getContent().contains(""ENABLED_FOR_ALL = true""));
        assertTrue(beforeLogin.getContent().contains(""ENABLED_FOR_CK = false""));

        TextPage loginPage = client.getPage(url + ""login?user=ck"");
        assertTrue(loginPage.getContent().contains(""SUCCESS""));

        TextPage afterLogin = client.getPage(url + ""features"");
        assertTrue(afterLogin.getContent().contains(""DISABLED = false""));
        assertTrue(afterLogin.getContent().contains(""ENABLED_FOR_ALL = true""));
        assertTrue(afterLogin.getContent().contains(""ENABLED_FOR_CK = true""));

        TextPage logoutPage = client.getPage(url + ""logout"");
        assertTrue(logoutPage.getContent().contains(""SUCCESS""));

        TextPage afterLogout = client.getPage(url + ""features"");
        assertTrue(afterLogout.getContent().contains(""DISABLED = false""));
        assertTrue(afterLogout.getContent().contains(""ENABLED_FOR_ALL = true""));
        assertTrue(afterLogout.getContent().contains(""ENABLED_FOR_CK = false""));

    }
",non-flaky,5
95653,togglz_togglz,ShiroUsersTest.testShiroWithSomeOtherUser,"    @Test
    public void testShiroWithSomeOtherUser() throws Exception {

        WebClient client = new WebClient();

        TextPage beforeLogin = client.getPage(url + ""features"");
        assertTrue(beforeLogin.getContent().contains(""DISABLED = false""));
        assertTrue(beforeLogin.getContent().contains(""ENABLED_FOR_ALL = true""));
        assertTrue(beforeLogin.getContent().contains(""ENABLED_FOR_CK = false""));

        TextPage loginPage = client.getPage(url + ""login?user=somebody"");
        assertTrue(loginPage.getContent().contains(""SUCCESS""));

        TextPage afterLogin = client.getPage(url + ""features"");
        assertTrue(afterLogin.getContent().contains(""DISABLED = false""));
        assertTrue(afterLogin.getContent().contains(""ENABLED_FOR_ALL = true""));
        assertTrue(afterLogin.getContent().contains(""ENABLED_FOR_CK = false""));

        TextPage logoutPage = client.getPage(url + ""logout"");
        assertTrue(logoutPage.getContent().contains(""SUCCESS""));

        TextPage afterLogout = client.getPage(url + ""features"");
        assertTrue(afterLogout.getContent().contains(""DISABLED = false""));
        assertTrue(afterLogout.getContent().contains(""ENABLED_FOR_ALL = true""));
        assertTrue(afterLogout.getContent().contains(""ENABLED_FOR_CK = false""));

    }
",non-flaky,5
95654,togglz_togglz,DefaultFeatureStateTest.testFeaturesActiveByDefault,"    @Test
    public void testFeaturesActiveByDefault() {
        assertTrue(MyFeatures.FEATURE_ONE.isActive());
    }
",non-flaky,5
95655,togglz_togglz,DefaultFeatureStateTest.testFeatureManagerImmutable,"    @Test(expected = UnsupportedOperationException.class)
    public void testFeatureManagerImmutable() {
        FeatureContext.getFeatureManager().setFeatureState(new FeatureState(MyFeatures.FEATURE_ONE, false));
    }
",non-flaky,5
95656,togglz_togglz,TestFeatureManagerTest.featureShouldBeInactiveByDefault,"    @Test
    public void featureShouldBeInactiveByDefault() {
        assertFalse(manager.isActive(MyFeatures.ONE));
    }
",non-flaky,5
95657,togglz_togglz,TestFeatureManagerTest.shouldToggleIndividualFeature,"    @Test
    public void shouldToggleIndividualFeature() {

        // enable
        manager.enable(MyFeatures.ONE);
        assertTrue(manager.isActive(MyFeatures.ONE));

        // disable
        manager.disable(MyFeatures.ONE);
        assertFalse(manager.isActive(MyFeatures.ONE));

    }
",non-flaky,5
95658,togglz_togglz,TestFeatureManagerTest.shouldToggleAllFeatures,"    @Test
    public void shouldToggleAllFeatures() {

        // enable
        manager.enableAll();
        assertTrue(manager.isActive(MyFeatures.ONE));
        assertTrue(manager.isActive(MyFeatures.TWO));

        // disable
        manager.disableAll();
        assertFalse(manager.isActive(MyFeatures.ONE));
        assertFalse(manager.isActive(MyFeatures.TWO));

    }
",non-flaky,5
95659,togglz_togglz,TestFeatureManagerTest.shouldSupportTogglingUntypedFeature,"    @Test
    public void shouldSupportTogglingUntypedFeature() {

        // enable
        manager.enable(new NamedFeature(""ONE""));
        assertTrue(manager.isActive(MyFeatures.ONE));

        // disable
        manager.disable(new NamedFeature(""ONE""));
        assertFalse(manager.isActive(MyFeatures.ONE));

    }
",non-flaky,5
95660,togglz_togglz,TestFeatureManagerTest.shouldSupportReadingWithNamedFeature,"    @Test
    public void shouldSupportReadingWithNamedFeature() {

        // enable
        manager.enable(MyFeatures.ONE);
        assertTrue(manager.isActive(new NamedFeature(""ONE"")));

        // disable
        manager.disable(MyFeatures.ONE);
        assertFalse(manager.isActive(new NamedFeature(""ONE"")));

    }
",non-flaky,5
95661,togglz_togglz,TogglzApplicationContextBinderApplicationListenerTest.contextRefreshed,"    @Test
    public void contextRefreshed() {
        ContextRefreshedEvent contextRefreshedEvent = mock(ContextRefreshedEvent.class);
        when(contextRefreshedEvent.getApplicationContext()).thenReturn(applicationContext);
        // Invoke context refreshed event
        applicationListener.onApplicationEvent(contextRefreshedEvent);
        // Assert application context bound
        assertSame(applicationContext, ContextClassLoaderApplicationContextHolder.get());
    }
",non-flaky,5
95662,togglz_togglz,TogglzApplicationContextBinderApplicationListenerTest.contextRefreshedWhileContextAlreadyBound,"    @Test
    public void contextRefreshedWhileContextAlreadyBound() {
        // Bind application context before context refreshed event invoked
        ContextClassLoaderApplicationContextHolder.bind(mock(ApplicationContext.class));
        applicationContext = mock(ApplicationContext.class);
        ContextRefreshedEvent contextRefreshedEvent = mock(ContextRefreshedEvent.class);
        when(contextRefreshedEvent.getApplicationContext()).thenReturn(applicationContext);
        // Invoke context refreshed application event
        applicationListener.onApplicationEvent(contextRefreshedEvent);
        // Assert application context bound
        assertSame(applicationContext, ContextClassLoaderApplicationContextHolder.get());
    }
",non-flaky,5
95663,togglz_togglz,TogglzApplicationContextBinderApplicationListenerTest.contextClosed,"    @Test
    public void contextClosed() {
        // Bind application context before context closed event invoked
        ContextClassLoaderApplicationContextHolder.bind(applicationContext);
        ContextClosedEvent contextClosedEvent = mock(ContextClosedEvent.class);
        // Invoke context closed event
        applicationListener.onApplicationEvent(contextClosedEvent);
        // Assert application context released
        assertNull(ContextClassLoaderApplicationContextHolder.get());
    }
",non-flaky,5
95664,togglz_togglz,SpringEnvironmentPropertyActivationStrategyTest.testGetId,"    @Test
    public void testGetId() {
        assertEquals(SpringEnvironmentPropertyActivationStrategy.ID, strategy.getId());
    }
",non-flaky,5
95665,togglz_togglz,SpringEnvironmentPropertyActivationStrategyTest.testGetName,"    @Test
    public void testGetName() {
        assertTrue(Strings.isNotBlank(strategy.getName()));
    }
",non-flaky,5
95666,togglz_togglz,SpringEnvironmentPropertyActivationStrategyTest.testIsActiveThrowsWhenNoApplicationContext,"    @Test(expected = IllegalStateException.class)
    public void testIsActiveThrowsWhenNoApplicationContext() {
        FeatureState featureState = new FeatureState(TestFeatures.FEATURE_ONE, true);

        strategy.isActive(featureState, null);
    }
",non-flaky,5
95667,togglz_togglz,SpringEnvironmentPropertyActivationStrategyTest.testGetParameters,"    @Test
    public void testGetParameters() {
        Parameter[] parameters = strategy.getParameters();

        assertEquals(1, parameters.length);

        Parameter parameter = parameters[0];

        assertNotNull(parameter);
        assertEquals(SpringEnvironmentPropertyActivationStrategy.PARAM_NAME, parameter.getName());
        assertTrue(parameter.isOptional());
        assertTrue(Strings.isNotBlank(parameter.getLabel()));
        assertTrue(Strings.isNotBlank(parameter.getDescription()));
    }
",non-flaky,5
95668,togglz_togglz,SpringProfileActivationStrategyTest.testGetId,"    @Test
    public void testGetId() {
        assertEquals(SpringProfileActivationStrategy.ID, strategy.getId());
    }
",non-flaky,5
95669,togglz_togglz,SpringProfileActivationStrategyTest.testGetName,"    @Test
    public void testGetName() {
        assertTrue(Strings.isNotBlank(strategy.getName()));
    }
",non-flaky,5
95670,togglz_togglz,SpringProfileActivationStrategyTest.testIsActiveThrowsWhenNoApplicationContext,"    @Test(expected = IllegalStateException.class)
    public void testIsActiveThrowsWhenNoApplicationContext() {
        FeatureState featureState = new FeatureState(TestFeatures.FEATURE_ONE, true);

        ContextClassLoaderApplicationContextHolder.release();

        strategy.isActive(featureState, null);
    }
",non-flaky,5
95671,togglz_togglz,SpringProfileActivationStrategyTest.testGetParameters,"    @Test
    public void testGetParameters() {
        Parameter[] parameters = strategy.getParameters();

        assertEquals(1, parameters.length);

        Parameter parameter = parameters[0];

        assertNotNull(parameter);
        assertEquals(SpringProfileActivationStrategy.PARAM_PROFILES, parameter.getName());
        assertTrue(Strings.isNotBlank(parameter.getLabel()));
        assertTrue(Strings.isNotBlank(parameter.getDescription()));
    }
",non-flaky,5
95672,togglz_togglz,SpringProfileActivationStrategyTest.testGetTokenParameterName,"    @Test
    public void testGetTokenParameterName() {
        assertEquals(SpringProfileActivationStrategy.PARAM_PROFILES, strategy.getTokenParameterName());
    }
",non-flaky,5
95673,togglz_togglz,SpringProfileActivationStrategyTest.testGetTokenParameterTransformer,"    @Test
    public void testGetTokenParameterTransformer() {
        TokenTransformer transformer = strategy.getTokenParameterTransformer();

        assertNotNull(transformer);
        assertEquals(""foo"", transformer.transform(""FOO""));
    }
",non-flaky,5
95674,togglz_togglz,TogglzRuleAllDisabledTest.testActiveByDefault,"    @Test
    public void testActiveByDefault() {

        // should be true by default
        assertFalse(MyFeatures.FEATURE_ONE.isActive());

        // second result should be the same
        assertFalse(MyFeatures.FEATURE_ONE.isActive());

    }
",non-flaky,5
95675,togglz_togglz,TogglzRuleAllDisabledTest.testToggleFeature,"    @Test
    public void testToggleFeature() {

        // initially false
        assertFalse(MyFeatures.FEATURE_ONE.isActive());

        // enable and check result
        togglzRule.enable(MyFeatures.FEATURE_ONE);
        assertTrue(MyFeatures.FEATURE_ONE.isActive());

        // disable and check result
        togglzRule.disable(MyFeatures.FEATURE_ONE);
        assertFalse(MyFeatures.FEATURE_ONE.isActive());

    }
",non-flaky,5
95676,togglz_togglz,TogglzRuleWithAnnotationTest.featureShouldBeInactiveByDefault,"    @Test
    public void featureShouldBeInactiveByDefault()
    {
        assertFalse(MyFeatures.ONE.isActive());
        assertFalse(MyFeatures.TWO.isActive());
    }
",non-flaky,5
95677,togglz_togglz,TogglzRuleWithAnnotationTest.featureShouldBeActiveWithAnnotation,"    @Test
    public void featureShouldBeActiveWithAnnotation()
    {
        assertTrue(MyFeatures.ONE.isActive());
        assertFalse(MyFeatures.TWO.isActive());
    }
",non-flaky,5
95678,togglz_togglz,TogglzRuleWithAnnotationTest.shouldActivateMultipleFeatures,"    @Test
    public void shouldActivateMultipleFeatures()
    {
        assertTrue(MyFeatures.ONE.isActive());
        assertTrue(MyFeatures.TWO.isActive());
    }
",non-flaky,5
95679,togglz_togglz,TogglzRuleAllEnabledTest.testActiveByDefault,"    @Test
    public void testActiveByDefault() {

        // should be true by default
        assertTrue(MyFeatures.FEATURE_ONE.isActive());

        // second result should be the same
        assertTrue(MyFeatures.FEATURE_ONE.isActive());

    }
",non-flaky,5
95680,togglz_togglz,TogglzRuleAllEnabledTest.testToggleFeature,"    @Test
    public void testToggleFeature() {

        // initially true
        assertTrue(MyFeatures.FEATURE_ONE.isActive());

        // disable and check result
        togglzRule.disable(MyFeatures.FEATURE_ONE);
        assertFalse(MyFeatures.FEATURE_ONE.isActive());

        // enable and check result
        togglzRule.enable(MyFeatures.FEATURE_ONE);
        assertTrue(MyFeatures.FEATURE_ONE.isActive());

    }
",non-flaky,5
95681,togglz_togglz,TogglzRuleWithVariations_HappyCase_Test.test,"    @Test
    public void test() {
        assertTrue(MyFeatures.F1.isActive());
        assertTrue(MyFeatures.F2.isActive() || !MyFeatures.F2.isActive());
        assertTrue(MyFeatures.F3.isActive() || !MyFeatures.F3.isActive());
    }
",non-flaky,5
95682,togglz_togglz,FeatureVariationsTest.test,"    @Test
    public void test() {
        assertTrue(MyFeatures.F1.isActive());
        assertTrue(MyFeatures.F2.isActive() || !MyFeatures.F2.isActive());
        assertTrue(MyFeatures.F3.isActive() || !MyFeatures.F3.isActive());
    }
",non-flaky,5
95683,togglz_togglz,TogglzRuleWithVariations_CalledMultipleTimes_Test.test,"    @Test
    public void test() {

        counter++;

        switch (counter) {
            case 1:
                assertEquals(""C1, F1"", false, MyFeatures.F1.isActive());
                assertEquals(""C1, F2"", false, MyFeatures.F2.isActive());
                assertEquals(""C1, F3"", false, MyFeatures.F3.isActive());
                break;

            case 2:
                assertEquals(""C2, F1"", false, MyFeatures.F1.isActive());
                assertEquals(""C2, F2"", true, MyFeatures.F2.isActive());
                assertEquals(""C2, F3"", false, MyFeatures.F3.isActive());
                break;
            case 3:
                assertEquals(""C3, F1"", false, MyFeatures.F1.isActive());
                assertEquals(""C3, F2"", false, MyFeatures.F2.isActive());
                assertEquals(""C3, F3"", true, MyFeatures.F3.isActive());
                break;

            case 4:
                assertEquals(""C4, F1"", false, MyFeatures.F1.isActive());
                assertEquals(""C4, F2"", true, MyFeatures.F2.isActive());
                assertEquals(""C4, F3"", true, MyFeatures.F3.isActive());
                break;

            default:
                fail(""Incorrect execution cound"");

        }
    }
",non-flaky,5
95684,togglz_togglz,TogglzRuleWithVariations_EnableSadCase_Test.test,"    @Test
    public void test() {
        expectedException.expect(AssertionError.class);

        assertFalse(MyFeatures.F1.isActive());
    }
",non-flaky,5
95685,togglz_togglz,TogglzRuleWithVariations_DisableSadCase_Test.test,"    @Test
    public void test() {
        expectedException.expect(AssertionError.class);

        assertTrue(MyFeatures.F1.isActive());
    }
",non-flaky,5
95686,togglz_togglz,GuiceIntegrationTest.testGuiceIntegration,"    @Test
    public void testGuiceIntegration() throws IOException {

        FeatureManager featureManager = FeatureContext.getFeatureManagerOrNull();

        assertThat(featureManager).isNotNull();
        assertThat(featureManager.getFeatures())
            .containsExactly(GuiceFeatures.FEATURE1, GuiceFeatures.FEATURE2);

    }
",non-flaky,5
95687,togglz_togglz,ArchaiusStateRepositoryTest.shouldReturnNullWhenStateDoesntExist,"    @Test
    public void shouldReturnNullWhenStateDoesntExist() {

        final FeatureState state = repository.getFeatureState(TestFeature.F1);

        assertNull(state);
    }
",non-flaky,5
95688,togglz_togglz,ArchaiusStateRepositoryTest.shouldReadFalseStateWithoutStrategyAndParameters,"    @Test
    public void shouldReadFalseStateWithoutStrategyAndParameters() {

        addState(TestFeature.F1.name(), false);

        FeatureState state = repository.getFeatureState(TestFeature.F1);

        assertNotNull(state);
        assertEquals(TestFeature.F1, state.getFeature());
        assertEquals(false, state.isEnabled());
        assertEquals(null, state.getStrategyId());
        assertEquals(0, state.getParameterNames().size());
    }
",non-flaky,5
95689,togglz_togglz,ArchaiusStateRepositoryTest.shouldReadTrueStateWithoutStrategyAndParameters,"    @Test
    public void shouldReadTrueStateWithoutStrategyAndParameters() {

        addState(TestFeature.F1.name(), true);

        FeatureState state = repository.getFeatureState(TestFeature.F1);

        /*
         * THEN the properties should be set like expected
         */
        assertNotNull(state);
        assertEquals(TestFeature.F1, state.getFeature());
        assertEquals(true, state.isEnabled());
        assertEquals(null, state.getStrategyId());
        assertEquals(0, state.getParameterNames().size());
    }
",non-flaky,5
95690,togglz_togglz,ArchaiusStateRepositoryTest.withStrategyNoParameters,"    @Test
    public void withStrategyNoParameters() {

        addState(TestFeature.F1.name(), true, ""S1"");
        
        FeatureState state = repository.getFeatureState(TestFeature.F1);

        assertNotNull(state);
        assertEquals(""S1"", state.getStrategyId());
        assertEquals(0, state.getParameterNames().size());
    }
",non-flaky,5
95691,togglz_togglz,ArchaiusStateRepositoryTest.withStrategyParameters,"    @Test
    public void withStrategyParameters() {

        addState(TestFeature.F1.name(), true, ""S1"", new Param(""one"", ""A""), new Param(""two"", ""B""));

        FeatureState state = repository.getFeatureState(TestFeature.F1);

        assertEquals(2, state.getParameterNames().size());
        assertEquals(""A"", state.getParameter(""one""));
        assertEquals(""B"", state.getParameter(""two""));
    }
",non-flaky,5
95692,togglz_togglz,ArchaiusStateRepositoryTest.setState,"    @Test(expected=UnsupportedOperationException.class)
    public void setState() {
        
        repository.setFeatureState(new FeatureState(TestFeature.F1, true));
    }
",non-flaky,5
95693,togglz_togglz,SingleUserProviderTest.canProvideNamedUser,"    @Test
    public void canProvideNamedUser() {
        String username = ""named-user"";
        boolean featureAdmin = true;
        UserProvider userProvider = new SingleUserProvider(username, featureAdmin);
        FeatureUser user = userProvider.getCurrentUser();
        assertThat(user.getName(), equalTo(username));
        assertThat(user.isFeatureAdmin(), equalTo(featureAdmin));
    }
",non-flaky,5
95694,togglz_togglz,AnnotationFeatureGroupTest.buildWillReturnNullWhenFeatureGroupAnnotationIsNotPresent,"    @Test
    public void buildWillReturnNullWhenFeatureGroupAnnotationIsNotPresent() throws Exception {
        FeatureGroup result = AnnotationFeatureGroup.build(Label.class);

        assertThat(result, nullValue());
    }
",non-flaky,5
95695,togglz_togglz,AnnotationFeatureGroupTest.buildWillReturnFeatureGroupWhenFeatureGroupAnnotationIsPresentForFieldLevelGroup,"    @Test
    public void buildWillReturnFeatureGroupWhenFeatureGroupAnnotationIsPresentForFieldLevelGroup() throws Exception {
        FeatureGroup result = AnnotationFeatureGroup.build(FieldLevelGroup.class);

        assertThat(result, notNullValue());
        assertThat(result.getLabel(), is(FIELD_LEVEL_GROUP_LABEL));
        assertThat(result.contains(TestFeatures.FEATURE), is(true));
    }
",non-flaky,5
95696,togglz_togglz,AnnotationFeatureGroupTest.buildWillReturnFeatureGroupWhenFeatureGroupAnnotationIsPresentForClassLevelGroup,"    @Test
    public void buildWillReturnFeatureGroupWhenFeatureGroupAnnotationIsPresentForClassLevelGroup() throws Exception {
        FeatureGroup result = AnnotationFeatureGroup.build(ClassLevelGroup.class);

        assertThat(result, notNullValue());
        assertThat(result.getLabel(), is(CLASS_LEVEL_GROUP_LABEL));
        assertThat(result.contains(TestFeatures.FEATURE), is(true));
    }
",non-flaky,5
95697,togglz_togglz,EnumFeatureMetaDataTest.constructorWillPopulateGroupsFromAnnotations,"    @Test
    public void constructorWillPopulateGroupsFromAnnotations() throws Exception {
        // act
        EnumFeatureMetaData metaData = new EnumFeatureMetaData(TestFeatures.FEATURE);

        // assert
        Set<FeatureGroup> groups = metaData.getGroups();

        assertThat(groups, notNullValue());
        assertThat(groups.size(), is(2));

        // verify field level group is there
        FeatureGroup group1 = Iterables.find(groups, createFeatureGroupLabelPredicate(FIELD_LEVEL_GROUP_LABEL));
        assertThat(group1.contains(TestFeatures.FEATURE), is(true));

        // verify class level group is there
        FeatureGroup group2 = Iterables.find(groups, createFeatureGroupLabelPredicate(CLASS_LEVEL_GROUP_LABEL));
        assertThat(group2.contains(TestFeatures.FEATURE), is(true));
    }
",non-flaky,5
95698,togglz_togglz,EnumFeatureMetaDataTest.constructorWillPopulateDefaultActivationStrategyFromAnnotations,"    @Test
    public void constructorWillPopulateDefaultActivationStrategyFromAnnotations() throws Exception {
        // act
        EnumFeatureMetaData metaData = new EnumFeatureMetaData(TestFeatures.FEATURE_WITH_DEFAULT_STATE);

        FeatureState featureState = metaData.getDefaultFeatureState();

        assertThat(featureState, notNullValue());
        assertThat(featureState.isEnabled(), is(true));
        assertThat(featureState.getStrategyId(), is(""SomeActivationId""));
        assertThat(featureState.getParameter(""SomeParameterName""), is(""someValue1,someValue2""));
        assertThat(featureState.getParameter(""SomeParameterName2""), is(""someValue3,someValue4""));
    }
",non-flaky,5
95699,togglz_togglz,CompositeFeatureProviderTest.empty,"	@Test
	public void empty() {
		CompositeFeatureProvider provider = new CompositeFeatureProvider();
		assertThat(provider.getFeatures()).isEmpty();
		assertThat(provider.getMetaData(new NamedFeature(""FOO""))).isNull();
	}
",non-flaky,5
95700,togglz_togglz,CompositeFeatureProviderTest.oneProvider,"	@Test
	public void oneProvider() {
		@SuppressWarnings(""unchecked"")
		CompositeFeatureProvider provider = new CompositeFeatureProvider(new EnumBasedFeatureProvider(TestFeatures.class));
		assertThat(provider.getFeatures()).hasSize(2);
		assertThat(provider.getMetaData(new NamedFeature(""FOO""))).isNotNull();
	}
",non-flaky,5
95701,togglz_togglz,PropertyFeatureProviderTest.shouldSupportDefinitionWithoutLabel,"    @Test
    public void shouldSupportDefinitionWithoutLabel() {

        Properties properties = new Properties();
        properties.setProperty(""F1"", """");

        PropertyFeatureProvider provider = new PropertyFeatureProvider(properties);

        Set<Feature> features = provider.getFeatures();
        assertThat(features)
            .hasSize(1)
            .areExactly(1, featureNamed(""F1""));

        FeatureMetaData metadata = provider.getMetaData(new NamedFeature(""F1""));
        assertThat(metadata).isNotNull();
        assertThat(metadata.getLabel()).isEqualTo(""F1"");
        FeatureState defaultFeatureState = metadata.getDefaultFeatureState();
        assertThat(defaultFeatureState.isEnabled()).isFalse();
        assertThat(metadata.getGroups()).isEmpty();

    }
",non-flaky,5
95702,togglz_togglz,PropertyFeatureProviderTest.shouldSupportDefinitionWithOnlyLabel,"    @Test
    public void shouldSupportDefinitionWithOnlyLabel() {

        Properties properties = new Properties();
        properties.setProperty(""F1"", ""My Feature"");

        PropertyFeatureProvider provider = new PropertyFeatureProvider(properties);

        Set<Feature> features = provider.getFeatures();
        assertThat(features)
            .hasSize(1)
            .areExactly(1, featureNamed(""F1""));

        FeatureMetaData metadata = provider.getMetaData(new NamedFeature(""F1""));
        assertThat(metadata).isNotNull();
        assertThat(metadata.getLabel()).isEqualTo(""My Feature"");
        FeatureState defaultFeatureState = metadata.getDefaultFeatureState();
        assertThat(defaultFeatureState.isEnabled()).isFalse();
        assertThat(metadata.getGroups()).isEmpty();

    }
",non-flaky,5
95703,togglz_togglz,PropertyFeatureProviderTest.shouldSupportDefinitionWithLabelAndDefault,"    @Test
    public void shouldSupportDefinitionWithLabelAndDefault() {

        Properties properties = new Properties();
        properties.setProperty(""F1"", ""My Feature;true"");

        PropertyFeatureProvider provider = new PropertyFeatureProvider(properties);

        Set<Feature> features = provider.getFeatures();
        assertThat(features)
            .hasSize(1)
            .areExactly(1, featureNamed(""F1""));

        FeatureMetaData metadata = provider.getMetaData(new NamedFeature(""F1""));
        assertThat(metadata).isNotNull();
        assertThat(metadata.getLabel()).isEqualTo(""My Feature"");
        FeatureState defaultFeatureState = metadata.getDefaultFeatureState();
        assertThat(defaultFeatureState.isEnabled()).isTrue();
        assertThat(metadata.getGroups()).isEmpty();

    }
",non-flaky,5
95704,togglz_togglz,PropertyFeatureProviderTest.shouldSupportDefinitionWithLabelAndDefaultAndTrailingSemicolon,"    @Test
    public void shouldSupportDefinitionWithLabelAndDefaultAndTrailingSemicolon() {

        Properties properties = new Properties();
        properties.setProperty(""F1"", ""My Feature;true;"");

        PropertyFeatureProvider provider = new PropertyFeatureProvider(properties);

        Set<Feature> features = provider.getFeatures();
        assertThat(features)
            .hasSize(1)
            .areExactly(1, featureNamed(""F1""));

        FeatureMetaData metadata = provider.getMetaData(new NamedFeature(""F1""));
        assertThat(metadata).isNotNull();
        assertThat(metadata.getLabel()).isEqualTo(""My Feature"");
        FeatureState defaultFeatureState = metadata.getDefaultFeatureState();
        assertThat(defaultFeatureState.isEnabled()).isTrue();
        assertThat(metadata.getGroups()).isEmpty();

    }
",non-flaky,5
95705,togglz_togglz,PropertyFeatureProviderTest.shouldSupportDefinitionWithSingleGroup,"    @Test
    public void shouldSupportDefinitionWithSingleGroup() {

        Properties properties = new Properties();
        properties.setProperty(""F1"", ""My Feature;true;Group1"");

        PropertyFeatureProvider provider = new PropertyFeatureProvider(properties);

        Set<Feature> features = provider.getFeatures();
        assertThat(features)
            .hasSize(1)
            .areExactly(1, featureNamed(""F1""));

        FeatureMetaData metadata = provider.getMetaData(new NamedFeature(""F1""));
        assertThat(metadata).isNotNull();
        assertThat(metadata.getLabel()).isEqualTo(""My Feature"");
        FeatureState defaultFeatureState = metadata.getDefaultFeatureState();
        assertThat(defaultFeatureState.isEnabled()).isTrue();
        assertThat(metadata.getGroups())
            .hasSize(1)
            .areExactly(1, groupNamed(""Group1""));

    }
",non-flaky,5
95706,togglz_togglz,PropertyFeatureProviderTest.canInitializeFromProperties,"    @Test
    public void canInitializeFromProperties() {

        Properties properties = new Properties();
        properties.setProperty(""ID_1"", ""ID 1;true;Group 1,Group Other"");
        properties.setProperty(""ID_2"", ""ID 2;false;Group 2"");

        PropertyFeatureProvider provider = new PropertyFeatureProvider(properties);

        Set<Feature> features = provider.getFeatures();

        assertThat(features)
            .hasSize(2)
            .areExactly(1, featureNamed(""ID_1""))
            .areExactly(1, featureNamed(""ID_2""));

        FeatureMetaData metadata1 = provider.getMetaData(new NamedFeature(""ID_1""));
        assertThat(metadata1).isNotNull();
        assertThat(metadata1.getLabel()).isEqualTo(""ID 1"");
        FeatureState defaultFeatureState1 = metadata1.getDefaultFeatureState();
        assertThat(defaultFeatureState1.isEnabled()).isTrue();
        assertThat(metadata1.getGroups())
            .hasSize(2)
            .areExactly(1, groupNamed(""Group 1""))
            .areExactly(1, groupNamed(""Group Other""));

        FeatureMetaData metadata2 = provider.getMetaData(new NamedFeature(""ID_2""));
        assertThat(metadata2).isNotNull();
        assertThat(metadata2.getLabel()).isEqualTo(""ID 2"");
        FeatureState defaultFeatureState2 = metadata2.getDefaultFeatureState();
        assertThat(defaultFeatureState2.isEnabled()).isFalse();
        assertThat(metadata2.getGroups())
            .hasSize(1)
            .areExactly(1, groupNamed(""Group 2""));

    }
",non-flaky,5
95707,togglz_togglz,EnumBasedFeatureProviderTest.shouldFailForNull,"    @Test(expected = IllegalArgumentException.class)
    public void shouldFailForNull() {
        new EnumBasedFeatureProvider(null);
    }
",non-flaky,5
95708,togglz_togglz,EnumBasedFeatureProviderTest.shouldFailForArrayWithNull,"    @Test(expected = IllegalArgumentException.class)
    public void shouldFailForArrayWithNull() {
        new EnumBasedFeatureProvider(ValidFeatureEnum.class, null);
    }
",non-flaky,5
95709,togglz_togglz,EnumBasedFeatureProviderTest.shouldFailForNonEnumType,"    @Test(expected = IllegalArgumentException.class)
    public void shouldFailForNonEnumType() {
        new EnumBasedFeatureProvider(NotAnEnum.class);
    }
",non-flaky,5
95710,togglz_togglz,EnumBasedFeatureProviderTest.shouldFailForDuplicateFeatureName,"    @Test(expected = IllegalStateException.class)
    public void shouldFailForDuplicateFeatureName() {
        
        EnumBasedFeatureProvider provider = new EnumBasedFeatureProvider();
        provider.addFeatureEnum(ValidFeatureEnum.class);
        provider.addFeatureEnum(DuplicateNameFeatureEnum.class); // should throw IllegalStateException
    }
",non-flaky,5
95711,togglz_togglz,EnumBasedFeatureProviderTest.shouldReturnCorrectListOfFeaturesForEnum,"    @Test
    public void shouldReturnCorrectListOfFeaturesForEnum() {

        FeatureProvider provider = new EnumBasedFeatureProvider(ValidFeatureEnum.class);
        assertThat(provider.getFeatures())
            .containsSequence(ValidFeatureEnum.FEATURE1, ValidFeatureEnum.FEATURE2);

    }
",non-flaky,5
95712,togglz_togglz,EnumBasedFeatureProviderTest.shouldReturnMetaDataWithCorrectLabel,"    @Test
    public void shouldReturnMetaDataWithCorrectLabel() {

        FeatureProvider provider = new EnumBasedFeatureProvider(ValidFeatureEnum.class);
        FeatureMetaData metaData = provider.getMetaData(ValidFeatureEnum.FEATURE1);
        assertThat(metaData.getLabel()).isEqualTo(""First feature"");

    }
",non-flaky,5
95713,togglz_togglz,EnumBasedFeatureProviderTest.shouldReturnMetaDataWhenRequestedWithOtherFeatureImplementation,"    @Test
    public void shouldReturnMetaDataWhenRequestedWithOtherFeatureImplementation() {

        FeatureProvider provider = new EnumBasedFeatureProvider(ValidFeatureEnum.class);
        FeatureMetaData metaData =
            provider.getMetaData(new OtherFeatureImpl(ValidFeatureEnum.FEATURE1.name()));
        assertThat(metaData.getLabel()).isEqualTo(""First feature"");

    }
",non-flaky,5
95714,togglz_togglz,EnumBasedFeatureProviderTest.shouldReturnOwnerNameIfAnnotationPresent,"    @Test
    public void shouldReturnOwnerNameIfAnnotationPresent() {
        FeatureProvider provider = new EnumBasedFeatureProvider(ValidFeatureEnum.class);
        FeatureMetaData metaData = provider.getMetaData(ValidFeatureEnum.WITH_OWNER);
        assertThat(metaData.getAttributes())
            .containsValue(""Christian"");
    }
",non-flaky,5
95715,togglz_togglz,EnumBasedFeatureProviderTest.shouldReturnNullForOwnerNameByDefault,"    @Test
    public void shouldReturnNullForOwnerNameByDefault() {
        FeatureProvider provider = new EnumBasedFeatureProvider(ValidFeatureEnum.class);
        FeatureMetaData metaData = provider.getMetaData(ValidFeatureEnum.FEATURE1);
        assertThat(metaData.getAttributes())
            .doesNotContainValue(""Christian"");
    }
",non-flaky,5
95716,togglz_togglz,EnumBasedFeatureProviderTest.shouldReturnInfoLinkIfAnnotationPresent,"    @Test
    public void shouldReturnInfoLinkIfAnnotationPresent() {
        FeatureProvider provider = new EnumBasedFeatureProvider(ValidFeatureEnum.class);
        FeatureMetaData metaData = provider.getMetaData(ValidFeatureEnum.WITH_LINK);
        assertThat(metaData.getAttributes())
            .containsValue(""https://github.com/togglz/togglz/pull/33"");
    }
",non-flaky,5
95717,togglz_togglz,EnumBasedFeatureProviderTest.shouldReturnNullForInfoLinkByDefault,"    @Test
    public void shouldReturnNullForInfoLinkByDefault() {
        FeatureProvider provider = new EnumBasedFeatureProvider(ValidFeatureEnum.class);
        FeatureMetaData metaData = provider.getMetaData(ValidFeatureEnum.FEATURE1);
        assertThat(metaData.getAttributes())
            .doesNotContainValue(""https://github.com/togglz/togglz/pull/33"");
    }
",non-flaky,5
95718,togglz_togglz,EnumBasedFeatureProviderTest.shouldReturnCombinedFeatureListForMultipleEnums,"    @Test
    public void shouldReturnCombinedFeatureListForMultipleEnums() {

        FeatureProvider provider = new EnumBasedFeatureProvider()
            .addFeatureEnum(ValidFeatureEnum.class)
            .addFeatureEnum(OtherFeatureEnum.class);

        // all feature are in the list
        assertThat(provider.getFeatures())
            .hasSize(ValidFeatureEnum.values().length + OtherFeatureEnum.values().length)
            .contains(ValidFeatureEnum.FEATURE1)
            .contains(OtherFeatureEnum.ADDITIONAL_FEATURE);

    }
",non-flaky,5
95719,togglz_togglz,EnumBasedFeatureProviderTest.shouldBuildMetadataForMultipleEnums,"    @Test
    public void shouldBuildMetadataForMultipleEnums() {

        FeatureProvider provider = new EnumBasedFeatureProvider()
            .addFeatureEnum(ValidFeatureEnum.class)
            .addFeatureEnum(OtherFeatureEnum.class);

        assertThat(provider.getMetaData(ValidFeatureEnum.FEATURE1).getLabel())
            .isEqualTo(""First feature"");
        assertThat(provider.getMetaData(OtherFeatureEnum.ADDITIONAL_FEATURE).getLabel())
            .isEqualTo(""Additional Feature"");

    }
",non-flaky,5
95720,togglz_togglz,EnumBasedFeatureProviderTest.shouldReturnCombinedFeatureListForMultipleEnumsViaConstructor,"    @Test
        public void shouldReturnCombinedFeatureListForMultipleEnumsViaConstructor() {

            FeatureProvider provider = new EnumBasedFeatureProvider(ValidFeatureEnum.class, OtherFeatureEnum.class);

            // all feature are in the list
            assertThat(provider.getFeatures())
                .hasSize(ValidFeatureEnum.values().length + OtherFeatureEnum.values().length)
                .contains(ValidFeatureEnum.FEATURE1)
                .contains(OtherFeatureEnum.ADDITIONAL_FEATURE);

        }
",non-flaky,5
95721,togglz_togglz,EnumBasedFeatureProviderTest.shouldBuildMetadataForMultipleEnumsViaConstructor,"        @Test
        public void shouldBuildMetadataForMultipleEnumsViaConstructor() {

            FeatureProvider provider = new EnumBasedFeatureProvider(ValidFeatureEnum.class, OtherFeatureEnum.class);

            assertThat(provider.getMetaData(ValidFeatureEnum.FEATURE1).getLabel())
                .isEqualTo(""First feature"");
            assertThat(provider.getMetaData(OtherFeatureEnum.ADDITIONAL_FEATURE).getLabel())
                .isEqualTo(""Additional Feature"");

        }
",non-flaky,5
95722,togglz_togglz,FeatureManagerBuilderTest.shouldAddStrategyIfUsingDefaultProvider,"    @Test
    public void shouldAddStrategyIfUsingDefaultProvider() {

        DefaultActivationStrategyProvider provider = new DefaultActivationStrategyProvider();

        FeatureManagerBuilder.begin()
            .featureEnum(Features.class)
            .activationStrategyProvider(provider)
            .activationStrategy(new CustomActivationStrategy())
            .build();

        assertThat(provider.getActivationStrategies())
            .extracting(""id"")
            .contains(CustomActivationStrategy.class.getSimpleName());

    }
",non-flaky,5
95723,togglz_togglz,FeatureManagerBuilderTest.shouldFailIfAddingStrategyWithCustomProvider,"    @Test(expected = IllegalStateException.class)
    public void shouldFailIfAddingStrategyWithCustomProvider() {

        CustomStrategyProvider provider = new CustomStrategyProvider();

        FeatureManagerBuilder.begin()
            .featureEnum(Features.class)
            .activationStrategyProvider(provider)
            .activationStrategy(new CustomActivationStrategy())
            .build();

    }
",non-flaky,5
95724,togglz_togglz,DefaultFeatureManagerTest.testGetFeatures,"    @Test
    public void testGetFeatures() {
        assertThat(manager.getFeatures())
            .contains(MyFeatures.DELETE_USERS, MyFeatures.EXPERIMENTAL, MyFeatures.MISSING_STRATEGY);
    }
",non-flaky,5
95725,togglz_togglz,DefaultFeatureManagerTest.testIsActive,"    @Test
    public void testIsActive() {

        // DELETE_USERS disabled for unknown user
        featureUserProvider.setFeatureUser(null);
        assertEquals(false, manager.isActive(MyFeatures.DELETE_USERS));

        // DELETE_USERS enabled for admin user
        featureUserProvider.setFeatureUser(new SimpleFeatureUser(""admin"", false));
        assertEquals(true, manager.isActive(MyFeatures.DELETE_USERS));

        // DELETE_USERS enabled for other user
        featureUserProvider.setFeatureUser(new SimpleFeatureUser(""somebody"", false));
        assertEquals(false, manager.isActive(MyFeatures.DELETE_USERS));

        // EXPERIMENTAL disabled for all
        featureUserProvider.setFeatureUser(null);
        assertEquals(false, manager.isActive(MyFeatures.EXPERIMENTAL));

        // MISSING_STRATEGY disabled for all
        assertEquals(false, manager.isActive(MyFeatures.MISSING_STRATEGY));

        // EMPTY_STRATEGY enabled for all
        assertEquals(true, manager.isActive(MyFeatures.EMPTY_STRATEGY));
    }
",non-flaky,5
95726,togglz_togglz,DefaultFeatureManagerTest.testIsActiveUsingDefaultFeatureState,"    @Test
    public void testIsActiveUsingDefaultFeatureState() {
        FeatureProvider featureProvider = mock(FeatureProvider.class);
        FeatureMetaData featureMetaData = mock(FeatureMetaData.class);
        when(featureMetaData.getDefaultFeatureState()).thenReturn(new FeatureState(MyFeatures.NOT_STORED_FEATURE, true));
        when(featureProvider.getMetaData(MyFeatures.NOT_STORED_FEATURE)).thenReturn(featureMetaData);

        FeatureManager manager = new FeatureManagerBuilder()
            .featureEnum(MyFeatures.class)
            .stateRepository(repository)
            .featureProvider(featureProvider)
            .userProvider(featureUserProvider)
            .build();

        assertEquals(true, manager.isActive(MyFeatures.NOT_STORED_FEATURE));

    }
",non-flaky,5
95727,togglz_togglz,DefaultFeatureManagerTest.testShouldHandleEnabledFlagCorrectlyWithCustomStrategy,"    @Test
    public void testShouldHandleEnabledFlagCorrectlyWithCustomStrategy() {

        // enabled for admin
        featureUserProvider.setFeatureUser(new SimpleFeatureUser(""admin"", false));
        assertEquals(true, manager.isActive(MyFeatures.DELETE_USERS));

        // disable feature, but keep configuration
        FeatureState state = repository.getFeatureState(MyFeatures.DELETE_USERS);
        state.setEnabled(false);
        repository.setFeatureState(state);

        // enabled for admin
        assertEquals(false, manager.isActive(MyFeatures.DELETE_USERS));

    }
",non-flaky,5
95728,togglz_togglz,DefaultFeatureManagerTest.testGetFeatureState,"    @Test
    public void testGetFeatureState() {

        FeatureState state = manager.getFeatureState(MyFeatures.DELETE_USERS);
        assertEquals(MyFeatures.DELETE_USERS, state.getFeature());
        assertEquals(true, state.isEnabled());
        assertEquals(""admin"", state.getParameter(UsernameActivationStrategy.PARAM_USERS));

    }
",non-flaky,5
95729,togglz_togglz,DefaultFeatureManagerTest.testGetFeatureStateUsingDefaultFeatureState,"    @Test
    public void testGetFeatureStateUsingDefaultFeatureState() {
        FeatureProvider featureProvider = mock(FeatureProvider.class);
        FeatureMetaData featureMetaData = mock(FeatureMetaData.class);
        when(featureMetaData.getDefaultFeatureState()).thenReturn(new FeatureState(MyFeatures.NOT_STORED_FEATURE, true));
        when(featureProvider.getMetaData(MyFeatures.NOT_STORED_FEATURE)).thenReturn(featureMetaData);

        FeatureManager manager = new FeatureManagerBuilder()
            .featureEnum(MyFeatures.class)
            .stateRepository(repository)
            .featureProvider(featureProvider)
            .userProvider(featureUserProvider)
            .build();


        FeatureState state = manager.getFeatureState(MyFeatures.NOT_STORED_FEATURE);
        assertEquals(MyFeatures.NOT_STORED_FEATURE, state.getFeature());
        assertEquals(true, state.isEnabled());

    }
",non-flaky,5
95730,togglz_togglz,JDBCStateRepositoryTest.testShouldSaveStateWithoutStrategyOrParameters,"    @Test
    public void testShouldSaveStateWithoutStrategyOrParameters() throws SQLException {

        /*
         * WHEN a feature without strategy is persisted
         */
        FeatureState state = new FeatureState(TestFeature.F1).disable();
        repository.setFeatureState(state);

        /*
         * THEN there should be a corresponding entry in the database
         */
        assertEquals(1l, query(dataSource, ""SELECT COUNT(*) FROM TOGGLZ WHERE FEATURE_NAME = 'F1'""));
        assertEquals(0, query(dataSource, ""SELECT FEATURE_ENABLED FROM TOGGLZ WHERE FEATURE_NAME = 'F1'""));
        assertEquals(null, query(dataSource, ""SELECT STRATEGY_ID FROM TOGGLZ WHERE FEATURE_NAME = 'F1'""));
        assertEquals(null, query(dataSource, ""SELECT STRATEGY_PARAMS FROM TOGGLZ WHERE FEATURE_NAME = 'F1'""));

    }
",non-flaky,5
95731,togglz_togglz,JDBCStateRepositoryTest.testShouldSaveStateStrategyAndParameters,"    @Test
    public void testShouldSaveStateStrategyAndParameters() throws SQLException {

        /*
         * WHEN a feature without strategy is persisted
         */
        FeatureState state = new FeatureState(TestFeature.F1)
            .enable()
            .setStrategyId(""someId"")
            .setParameter(""param"", ""foo"");
        repository.setFeatureState(state);

        /*
         * THEN there should be a corresponding entry in the database
         */
        assertEquals(1l, query(dataSource, ""SELECT COUNT(*) FROM TOGGLZ WHERE FEATURE_NAME = 'F1'""));
        assertEquals(1, query(dataSource, ""SELECT FEATURE_ENABLED FROM TOGGLZ WHERE FEATURE_NAME = 'F1'""));
        assertEquals(""someId"", query(dataSource, ""SELECT STRATEGY_ID FROM TOGGLZ WHERE FEATURE_NAME = 'F1'""));
        assertEquals(""param=foo"", query(dataSource, ""SELECT STRATEGY_PARAMS FROM TOGGLZ WHERE FEATURE_NAME = 'F1'""));

    }
",non-flaky,5
95732,togglz_togglz,JDBCStateRepositoryTest.testShouldReadStateWithoutStrategyAndParameters,"    @Test
    public void testShouldReadStateWithoutStrategyAndParameters() throws SQLException {

        /*
         * GIVEN a database row containing a simple feature state
         */
        update(dataSource, ""INSERT INTO TOGGLZ VALUES ('F1', 0, NULL, NULL)"");

        /*
         * WHEN the repository reads the state
         */
        FeatureState state = repository.getFeatureState(TestFeature.F1);

        /*
         * THEN the properties should be set like expected
         */
        assertNotNull(state);
        assertEquals(TestFeature.F1, state.getFeature());
        assertEquals(false, state.isEnabled());
        assertEquals(null, state.getStrategyId());
        assertEquals(0, state.getParameterNames().size());

    }
",non-flaky,5
95733,togglz_togglz,JDBCStateRepositoryTest.testShouldReadStateWithStrategyAndParameters,"    @Test
    public void testShouldReadStateWithStrategyAndParameters() throws SQLException {

        /*
         * GIVEN a database row containing a simple feature state
         */
        update(dataSource, ""INSERT INTO TOGGLZ VALUES ('F1', 1, 'myStrategy', 'param23=foobar')"");

        /*
         * WHEN the repository reads the state
         */
        FeatureState state = repository.getFeatureState(TestFeature.F1);

        /*
         * THEN the properties should be set like expected
         */
        assertNotNull(state);
        assertEquals(TestFeature.F1, state.getFeature());
        assertEquals(true, state.isEnabled());
        assertEquals(""myStrategy"", state.getStrategyId());
        assertEquals(1, state.getParameterNames().size());
        assertEquals(""foobar"", state.getParameter(""param23""));

    }
",non-flaky,5
95734,togglz_togglz,JDBCStateRepositoryTest.testShouldUpdateExistingDatabaseEntry,"    @Test
    public void testShouldUpdateExistingDatabaseEntry() throws SQLException {

        /*
         * GIVEN a database row containing a simple feature state
         */
        update(dataSource, ""INSERT INTO TOGGLZ VALUES ('F1', 1, 'myStrategy', 'param23=foobar')"");

        /*
         * AND the database entries are like expected
         */
        assertEquals(1l, query(dataSource, ""SELECT COUNT(*) FROM TOGGLZ WHERE FEATURE_NAME = 'F1'""));
        assertEquals(1, query(dataSource, ""SELECT FEATURE_ENABLED FROM TOGGLZ WHERE FEATURE_NAME = 'F1'""));
        assertEquals(""myStrategy"", query(dataSource, ""SELECT STRATEGY_ID FROM TOGGLZ WHERE FEATURE_NAME = 'F1'""));
        assertEquals(""param23=foobar"", query(dataSource, ""SELECT STRATEGY_PARAMS FROM TOGGLZ WHERE FEATURE_NAME = 'F1'""));

        /*
         * WHEN the repository writes new state
         */
        FeatureState state = new FeatureState(TestFeature.F1)
            .disable()
            .setStrategyId(""someId"")
            .setParameter(""param"", ""foo"");
        repository.setFeatureState(state);

        /*
         * THEN the properties should be set like expected
         */
        assertEquals(1l, query(dataSource, ""SELECT COUNT(*) FROM TOGGLZ WHERE FEATURE_NAME = 'F1'""));
        assertEquals(0, query(dataSource, ""SELECT FEATURE_ENABLED FROM TOGGLZ WHERE FEATURE_NAME = 'F1'""));
        assertEquals(""someId"", query(dataSource, ""SELECT STRATEGY_ID FROM TOGGLZ WHERE FEATURE_NAME = 'F1'""));
        assertEquals(""param=foo"", query(dataSource, ""SELECT STRATEGY_PARAMS FROM TOGGLZ WHERE FEATURE_NAME = 'F1'""));

	}
",non-flaky,5
95735,togglz_togglz,JDBCStateRepositoryTest.testShouldPropagateTheExceptionWhenReadFails,"	@Test(expected = IllegalStateException.class)
	public void testShouldPropagateTheExceptionWhenReadFails() throws SQLException {

		/*
		 * GIVEN a database row containing a simple feature state
		 */
		update(dataSource, ""INSERT INTO TOGGLZ VALUES ('F1', 0, NULL, NULL)"");

		/**
		 * AND the datasource throws an exception when we try to get a
		 * connection
		 */
		DataSource spyedDataSource = Mockito.spy(dataSource);
		repository = new JDBCStateRepository(spyedDataSource, ""TOGGLZ"", true, DefaultMapSerializer.multiline());
		Mockito.when(spyedDataSource.getConnection()).thenThrow(new SQLException(""Failed to get a connection""));

		/*
		 * WHEN the repository reads the state
		 */
		repository.getFeatureState(TestFeature.F1);

		/*
		 * THEN an IllegalStateException is thrown
		 */
	}
",non-flaky,5
95736,togglz_togglz,JDBCStateRepositoryTest.testShouldPropagateTheExceptionWhenWriteFails,"	@Test(expected = IllegalStateException.class)
	public void testShouldPropagateTheExceptionWhenWriteFails() throws SQLException {

		/*
		 * GIVEN a feature state to persist
		 */
		FeatureState state = new FeatureState(TestFeature.F1).enable();

		/**
		 * AND the datasource throws an exception when we try to get a
		 * connection
		 */
		DataSource spyedDataSource = Mockito.spy(dataSource);
		repository = new JDBCStateRepository(spyedDataSource, ""TOGGLZ"", true, DefaultMapSerializer.multiline());
		Mockito.when(spyedDataSource.getConnection()).thenThrow(new SQLException(""Failed to get a connection""));

		/*
		 * WHEN the feature state is persisted
		 */
		repository.setFeatureState(state);

		/*
		 * THEN an IllegalStateException is thrown
		 */
    }
",non-flaky,5
95737,togglz_togglz,JDBCRepositoryAutoCommitTest.shouldUpdateWithAutoCommitEnabled,"    @Test
    public void shouldUpdateWithAutoCommitEnabled() {
        givenSomeDataSourceWithAutoCommitSetTo(true);
        whenTheFeatureIsEnabled();
        thenTheDatabaseShouldBeUpdated();
    }
",non-flaky,5
95738,togglz_togglz,JDBCRepositoryAutoCommitTest.shouldUpdateWithAutoCommitDisabled,"    @Test
    public void shouldUpdateWithAutoCommitDisabled() {
        givenSomeDataSourceWithAutoCommitSetTo(false);
        whenTheFeatureIsEnabled();
        thenTheDatabaseShouldBeUpdated();
    }
",non-flaky,5
95739,togglz_togglz,SchemaUpdaterTest.shouldDetectMissingTable,"    @Test
    public void shouldDetectMissingTable() throws SQLException {

        Connection connection = createConnection();
        try {

            SchemaUpdater updater = new SchemaUpdater(connection, ""TOGGLZ"", DefaultMapSerializer.multiline());
            assertFalse(updater.doesTableExist());

        } finally {
            DbUtils.closeQuietly(connection);
        }

    }
",non-flaky,5
95740,togglz_togglz,SchemaUpdaterTest.shouldMigrateToVersion1,"    @Test
    public void shouldMigrateToVersion1() throws SQLException {

        Connection connection = createConnection();
        try {

            SchemaUpdater updater = new SchemaUpdater(connection, ""TOGGLZ"", DefaultMapSerializer.multiline());
            assertFalse(updater.doesTableExist());

            updater.migrateToVersion1();

            assertTrue(updater.doesTableExist());
            assertTrue(querySucceeds(connection, ""SELECT FEATURE_NAME FROM TOGGLZ""));

        } finally {
            DbUtils.closeQuietly(connection);
        }

    }
",non-flaky,5
95741,togglz_togglz,SchemaUpdaterTest.shouldDetectVersion1,"    @Test
    public void shouldDetectVersion1() throws SQLException {

        Connection connection = createConnection();
        try {

            SchemaUpdater updater = new SchemaUpdater(connection, ""TOGGLZ"", DefaultMapSerializer.multiline());
            assertFalse(updater.doesTableExist());

            assertFalse(updater.isSchemaVersion1());

            updater.migrateToVersion1();

            assertTrue(updater.isSchemaVersion1());

        } finally {
            DbUtils.closeQuietly(connection);
        }

    }
",non-flaky,5
95742,togglz_togglz,SchemaUpdaterTest.shouldMigrateToVersion2,"    @Test
    public void shouldMigrateToVersion2() throws SQLException {

        Connection connection = createConnection();
        try {

            // create schema version 1
            SchemaUpdater updater = new SchemaUpdater(connection, ""TOGGLZ"", DefaultMapSerializer.multiline());
            assertFalse(updater.doesTableExist());
            updater.migrateToVersion1();
            assertTrue(updater.isSchemaVersion1());

            // insert two feature states
            update(connection, ""INSERT INTO TOGGLZ VALUES ('F1', 1, 'ck, admin')"");
            update(connection, ""INSERT INTO TOGGLZ VALUES ('F2', 1, '')"");
            update(connection, ""INSERT INTO TOGGLZ VALUES ('F3', 1, NULL)"");

            List<Object[]> dataBefore = query(connection,
                ""SELECT FEATURE_NAME, FEATURE_USERS FROM TOGGLZ ORDER BY FEATURE_NAME"");
            assertEquals(3, dataBefore.size());
            assertEquals(""F1"", dataBefore.get(0)[0]);
            assertEquals(""ck, admin"", dataBefore.get(0)[1]);

            // migrate the schema
            updater.migrateToVersion2();

            // check the new columns are present
            assertTrue(querySucceeds(connection, ""SELECT FEATURE_NAME,STRATEGY_ID,STRATEGY_PARAMS FROM TOGGLZ""));

            // check the old users column is deleted
            assertFalse(querySucceeds(connection, ""SELECT FEATURE_USERS FROM TOGGLZ""));

            // check 3 features are there after the migration
            List<Object[]> dataAfter = query(connection,
                ""SELECT FEATURE_NAME, STRATEGY_ID, STRATEGY_PARAMS FROM TOGGLZ ORDER BY FEATURE_NAME"");
            assertEquals(3, dataBefore.size());

            // first feature is migrated
            assertEquals(""F1"", dataAfter.get(0)[0]);
            assertEquals(UsernameActivationStrategy.ID, dataAfter.get(0)[1]);
            assertEquals(""users=ck, admin"", dataAfter.get(0)[2].toString().trim());

            // second feature didn't change
            assertEquals(""F2"", dataAfter.get(1)[0]);
            assertEquals(null, dataAfter.get(1)[1]);
            assertEquals(null, dataAfter.get(1)[2]);

            // second feature didn't change
            assertEquals(""F3"", dataAfter.get(2)[0]);
            assertEquals(null, dataAfter.get(2)[1]);
            assertEquals(null, dataAfter.get(2)[2]);

        } finally {
            DbUtils.closeQuietly(connection);
        }

    }
",non-flaky,5
97949,ReactiveX_RxJava,ZipTests.call,"    @Test
    public void testZipObservableOfObservables() {
        EventStream.getEventStream(""HTTP-ClusterB"", 20)
                .groupBy(new Func1<Event, String>() {

                    @Override
                    public String call(Event e) {
                        return e.instanceId;
                    }
",non-flaky,5
97950,ReactiveX_RxJava,ZipTests.testCovarianceOfZip,"    @Test
    public void testCovarianceOfZip() {
        Observable<HorrorMovie> horrors = Observable.from(new HorrorMovie());
        Observable<CoolRating> ratings = Observable.from(new CoolRating());

        Observable.<Movie, CoolRating, Result> zip(horrors, ratings, combine).toBlockingObservable().forEach(action);
        Observable.<Movie, CoolRating, Result> zip(horrors, ratings, combine).toBlockingObservable().forEach(action);
        Observable.<Media, Rating, ExtendedResult> zip(horrors, ratings, combine).toBlockingObservable().forEach(extendedAction);
        Observable.<Media, Rating, Result> zip(horrors, ratings, combine).toBlockingObservable().forEach(action);
        Observable.<Media, Rating, ExtendedResult> zip(horrors, ratings, combine).toBlockingObservable().forEach(action);

        Observable.<Movie, CoolRating, Result> zip(horrors, ratings, combine);
    }
",non-flaky,5
97951,ReactiveX_RxJava,CovarianceTest.testCovarianceOfFrom,"    @Test
    public void testCovarianceOfFrom() {
        Observable.<Movie> from(new HorrorMovie());
        Observable.<Movie> from(new ArrayList<HorrorMovie>());
        // Observable.<HorrorMovie>from(new Movie()); // may not compile
    }
",non-flaky,5
97952,ReactiveX_RxJava,CovarianceTest.call,"    @Test
    public void testSortedList() {
        Func2<Media, Media, Integer> SORT_FUNCTION = new Func2<Media, Media, Integer>() {

            @Override
            public Integer call(Media t1, Media t2) {
                return 1;
            }
",non-flaky,5
97953,ReactiveX_RxJava,ObservableWindowTests.call,"    @Test
    public void testWindow() {
        final ArrayList<List<Integer>> lists = new ArrayList<List<Integer>>();
        Observable.from(1, 2, 3, 4, 5, 6)
                .window(3).map(new Func1<Observable<Integer>, List<Integer>>() {

                    @Override
                    public List<Integer> call(Observable<Integer> o) {
                        return o.toList().toBlockingObservable().single();
                    }
",non-flaky,5
97954,ReactiveX_RxJava,ConcatTests.testConcatSimple,"    @Test
    public void testConcatSimple() {
        Observable<String> o1 = Observable.from(""one"", ""two"");
        Observable<String> o2 = Observable.from(""three"", ""four"");

        List<String> values = Observable.concat(o1, o2).toList().toBlockingObservable().single();

        assertEquals(""one"", values.get(0));
        assertEquals(""two"", values.get(1));
        assertEquals(""three"", values.get(2));
        assertEquals(""four"", values.get(3));
    }
",non-flaky,5
97955,ReactiveX_RxJava,ConcatTests.testConcatWithObservableOfObservable,"    @Test
    public void testConcatWithObservableOfObservable() {
        Observable<String> o1 = Observable.from(""one"", ""two"");
        Observable<String> o2 = Observable.from(""three"", ""four"");
        Observable<String> o3 = Observable.from(""five"", ""six"");

        Observable<Observable<String>> os = Observable.from(o1, o2, o3);

        List<String> values = Observable.concat(os).toList().toBlockingObservable().single();

        assertEquals(""one"", values.get(0));
        assertEquals(""two"", values.get(1));
        assertEquals(""three"", values.get(2));
        assertEquals(""four"", values.get(3));
    }
",non-flaky,5
97956,ReactiveX_RxJava,ConcatTests.testConcatWithIterableOfObservable,"    @Test
    public void testConcatWithIterableOfObservable() {
        Observable<String> o1 = Observable.from(""one"", ""two"");
        Observable<String> o2 = Observable.from(""three"", ""four"");
        Observable<String> o3 = Observable.from(""five"", ""six"");

        @SuppressWarnings(""unchecked"")
        Iterable<Observable<String>> is = Arrays.asList(o1, o2, o3);

        List<String> values = Observable.concat(Observable.from(is)).toList().toBlockingObservable().single();

        assertEquals(""one"", values.get(0));
        assertEquals(""two"", values.get(1));
        assertEquals(""three"", values.get(2));
        assertEquals(""four"", values.get(3));
    }
",non-flaky,5
97957,ReactiveX_RxJava,ConcatTests.testConcatCovariance,"    @Test
    public void testConcatCovariance() {
        Observable<Media> o1 = Observable.<Media> from(new HorrorMovie(), new Movie());
        Observable<Media> o2 = Observable.from(new Media(), new HorrorMovie());

        Observable<Observable<Media>> os = Observable.from(o1, o2);

        List<Media> values = Observable.concat(os).toList().toBlockingObservable().single();
    }
",non-flaky,5
97958,ReactiveX_RxJava,ConcatTests.testConcatCovariance2,"    @Test
    public void testConcatCovariance2() {
        Observable<Media> o1 = Observable.from(new HorrorMovie(), new Movie(), new Media());
        Observable<Media> o2 = Observable.from(new Media(), new HorrorMovie());

        Observable<Observable<Media>> os = Observable.from(o1, o2);

        List<Media> values = Observable.concat(os).toList().toBlockingObservable().single();
    }
",non-flaky,5
97959,ReactiveX_RxJava,ConcatTests.testConcatCovariance3,"    @Test
    public void testConcatCovariance3() {
        Observable<Movie> o1 = Observable.from(new HorrorMovie(), new Movie());
        Observable<Media> o2 = Observable.from(new Media(), new HorrorMovie());

        List<Media> values = Observable.concat(o1, o2).toList().toBlockingObservable().single();
        
        assertTrue(values.get(0) instanceof HorrorMovie);
        assertTrue(values.get(1) instanceof Movie);
        assertTrue(values.get(2) instanceof Media);
        assertTrue(values.get(3) instanceof HorrorMovie);
    }
",non-flaky,5
97960,ReactiveX_RxJava,ConcatTests.onSubscribe,"    @Test
    public void testConcatCovariance4() {

        Observable<Movie> o1 = Observable.create(new OnSubscribeFunc<Movie>() {

            @Override
            public Subscription onSubscribe(Observer<? super Movie> o) {
                o.onNext(new HorrorMovie());
                o.onNext(new Movie());
                //                o.onNext(new Media()); // correctly doesn't compile
                o.onCompleted();
                return Subscriptions.empty();
            }
",non-flaky,5
97961,ReactiveX_RxJava,IntervalDemo.call,"	@Test public void demoInterval() throws Exception {
	public void testLongObservable(Observable<Long> o, final String testname) throws Exception {
		final List<Long> l = new ArrayList<Long>();
		Action1<Long> onNext = new Action1<Long>() {
			public void call(Long i) { 
				l.add(i);
				System.out.println(testname + "" got "" + i);
			}
",non-flaky,5
97962,ReactiveX_RxJava,ObservableTests.fromArray,"    @Test
    public void fromArray() {
        String[] items = new String[] { ""one"", ""two"", ""three"" };
        assertEquals(new Integer(3), Observable.from(items).count().toBlockingObservable().single());
        assertEquals(""two"", Observable.from(items).skip(1).take(1).toBlockingObservable().single());
        assertEquals(""three"", Observable.from(items).takeLast(1).toBlockingObservable().single());
    }
",non-flaky,5
97963,ReactiveX_RxJava,ObservableTests.fromIterable,"    @Test
    public void fromIterable() {
        ArrayList<String> items = new ArrayList<String>();
        items.add(""one"");
        items.add(""two"");
        items.add(""three"");

        assertEquals(new Integer(3), Observable.from(items).count().toBlockingObservable().single());
        assertEquals(""two"", Observable.from(items).skip(1).take(1).toBlockingObservable().single());
        assertEquals(""three"", Observable.from(items).takeLast(1).toBlockingObservable().single());
    }
",non-flaky,5
97964,ReactiveX_RxJava,ObservableTests.fromArityArgs3,"    @Test
    public void fromArityArgs3() {
        Observable<String> items = Observable.from(""one"", ""two"", ""three"");

        assertEquals(new Integer(3), items.count().toBlockingObservable().single());
        assertEquals(""two"", items.skip(1).take(1).toBlockingObservable().single());
        assertEquals(""three"", items.takeLast(1).toBlockingObservable().single());
    }
",non-flaky,5
97965,ReactiveX_RxJava,ObservableTests.fromArityArgs1,"    @Test
    public void fromArityArgs1() {
        Observable<String> items = Observable.from(""one"");

        assertEquals(new Integer(1), items.count().toBlockingObservable().single());
        assertEquals(""one"", items.takeLast(1).toBlockingObservable().single());
    }
",non-flaky,5
97966,ReactiveX_RxJava,ObservableTests.onSubscribe,"    @Test
    public void testCreate() {

        Observable<String> observable = Observable.create(new OnSubscribeFunc<String>() {

            @Override
            public Subscription onSubscribe(Observer<? super String> Observer) {
                Observer.onNext(""one"");
                Observer.onNext(""two"");
                Observer.onNext(""three"");
                Observer.onCompleted();
                return Subscriptions.empty();
            }
",non-flaky,5
97967,ReactiveX_RxJava,ObservableTests.testCountAFewItems,"    @Test
    public void testCountAFewItems() {
        Observable<String> observable = Observable.from(""a"", ""b"", ""c"", ""d"");
        observable.count().subscribe(w);
        // we should be called only once
        verify(w, times(1)).onNext(anyInt());
        verify(w).onNext(4);
        verify(w, never()).onError(any(Throwable.class));
        verify(w, times(1)).onCompleted();
    }
",non-flaky,5
97968,ReactiveX_RxJava,ObservableTests.testCountZeroItems,"    @Test
    public void testCountZeroItems() {
        Observable<String> observable = Observable.empty();
        observable.count().subscribe(w);
        // we should be called only once
        verify(w, times(1)).onNext(anyInt());
        verify(w).onNext(0);
        verify(w, never()).onError(any(Throwable.class));
        verify(w, times(1)).onCompleted();
    }
",non-flaky,5
97969,ReactiveX_RxJava,ObservableTests.onSubscribe,"    @Test
    public void testCountError() {
        Observable<String> o = Observable.create(new OnSubscribeFunc<String>() {
            @Override
            public Subscription onSubscribe(Observer<? super String> obsv) {
                obsv.onError(new RuntimeException());
                return Subscriptions.empty();
            }
",non-flaky,5
97970,ReactiveX_RxJava,ObservableTests.testFirstWithPredicateOfNoneMatchingThePredicate,"    @Test
    public void testFirstWithPredicateOfNoneMatchingThePredicate() {
        Observable<Integer> observable = Observable.from(1, 3, 5, 7, 9, 7, 5, 3, 1);
        observable.first(IS_EVEN).subscribe(w);
        verify(w, never()).onNext(anyInt());
        verify(w, times(1)).onCompleted();
        verify(w, never()).onError(any(Throwable.class));
    }
",non-flaky,5
97971,ReactiveX_RxJava,ObservableTests.testFirstOfSome,"    @Test
    public void testFirstOfSome() {
        Observable<Integer> observable = Observable.from(1, 2, 3);
        observable.first().subscribe(w);
        verify(w, times(1)).onNext(anyInt());
        verify(w).onNext(1);
        verify(w, times(1)).onCompleted();
        verify(w, never()).onError(any(Throwable.class));
    }
",non-flaky,5
97972,ReactiveX_RxJava,ObservableTests.testFirstOfNone,"    @Test
    public void testFirstOfNone() {
        Observable<Integer> observable = Observable.empty();
        observable.first().subscribe(w);
        verify(w, never()).onNext(anyInt());
        verify(w, times(1)).onCompleted();
        verify(w, never()).onError(any(Throwable.class));
    }
",non-flaky,5
97973,ReactiveX_RxJava,ObservableTests.call,"    @Test
    public void testReduce() {
        Observable<Integer> observable = Observable.from(1, 2, 3, 4);
        observable.reduce(new Func2<Integer, Integer, Integer>() {

            @Override
            public Integer call(Integer t1, Integer t2) {
                return t1 + t2;
            }
",non-flaky,5
97974,ReactiveX_RxJava,ObservableTests.call,"    @Test
    public void testReduceWithInitialValue() {
        Observable<Integer> observable = Observable.from(1, 2, 3, 4);
        observable.reduce(50, new Func2<Integer, Integer, Integer>() {

            @Override
            public Integer call(Integer t1, Integer t2) {
                return t1 + t2;
            }
",non-flaky,5
97975,ReactiveX_RxJava,ObservableTests.testSequenceEqual,"    @Test
    public void testSequenceEqual() {
        Observable<Integer> first = Observable.from(1, 2, 3);
        Observable<Integer> second = Observable.from(1, 2, 4);
        @SuppressWarnings(""unchecked"")
        Observer<Boolean> result = mock(Observer.class);
        Observable.sequenceEqual(first, second).subscribe(result);
        verify(result, times(2)).onNext(true);
        verify(result, times(1)).onNext(false);
    }
",non-flaky,5
97976,ReactiveX_RxJava,ObservableTests.onSubscribe,"    @Test
    public void testOnSubscribeFails() {
        @SuppressWarnings(""unchecked"")
        Observer<String> observer = mock(Observer.class);
        final RuntimeException re = new RuntimeException(""bad impl"");
        Observable<String> o = Observable.create(new OnSubscribeFunc<String>() {

            @Override
            public Subscription onSubscribe(Observer<? super String> t1) {
                throw re;
            }
",non-flaky,5
97977,ReactiveX_RxJava,ObservableTests.testMaterializeDematerializeChaining,"    @Test
    public void testMaterializeDematerializeChaining() {
        Observable<Integer> obs = Observable.just(1);
        Observable<Integer> chained = obs.materialize().dematerialize();

        @SuppressWarnings(""unchecked"")
        Observer<Integer> observer = mock(Observer.class);
        chained.subscribe(observer);

        verify(observer, times(1)).onNext(1);
        verify(observer, times(1)).onCompleted();
        verify(observer, times(0)).onError(any(Throwable.class));
    }
",non-flaky,5
97978,ReactiveX_RxJava,ObservableTests.run,"    @Test
    public void testCustomObservableWithErrorInObserverAsynchronous() throws InterruptedException {
        final CountDownLatch latch = new CountDownLatch(1);
        final AtomicInteger count = new AtomicInteger();
        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
        Observable.create(new OnSubscribeFunc<String>() {

            @Override
            public Subscription onSubscribe(final Observer<? super String> observer) {
                final BooleanSubscription s = new BooleanSubscription();
                new Thread(new Runnable() {

                    @Override
                    public void run() {
                        try {
                            if (!s.isUnsubscribed()) {
                                observer.onNext(""1"");
                                observer.onNext(""2"");
                                observer.onNext(""three"");
                                observer.onNext(""4"");
                                observer.onCompleted();
                            }
                        } finally {
                            latch.countDown();
                        }
                    }
",non-flaky,5
97979,ReactiveX_RxJava,ObservableTests.onSubscribe,"    @Test
    public void testCustomObservableWithErrorInObserverSynchronous() {
        final AtomicInteger count = new AtomicInteger();
        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
        Observable.create(new OnSubscribeFunc<String>() {

            @Override
            public Subscription onSubscribe(Observer<? super String> observer) {
                observer.onNext(""1"");
                observer.onNext(""2"");
                observer.onNext(""three"");
                observer.onNext(""4"");
                observer.onCompleted();
                return Subscriptions.empty();
            }
",non-flaky,5
97980,ReactiveX_RxJava,ObservableTests.onSubscribe,"    @Test
    public void testCustomObservableWithErrorInObservableSynchronous() {
        final AtomicInteger count = new AtomicInteger();
        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
        Observable.create(new OnSubscribeFunc<String>() {

            @Override
            public Subscription onSubscribe(Observer<? super String> observer) {
                observer.onNext(""1"");
                observer.onNext(""2"");
                throw new NumberFormatException();
            }
",non-flaky,5
97981,ReactiveX_RxJava,ObservableTests.run,"    @Test
    public void testPublish() throws InterruptedException {
        final AtomicInteger counter = new AtomicInteger();
        ConnectableObservable<String> o = Observable.create(new OnSubscribeFunc<String>() {

            @Override
            public Subscription onSubscribe(final Observer<? super String> observer) {
                final BooleanSubscription subscription = new BooleanSubscription();
                new Thread(new Runnable() {

                    @Override
                    public void run() {
                        counter.incrementAndGet();
                        observer.onNext(""one"");
                        observer.onCompleted();
                    }
",non-flaky,5
97982,ReactiveX_RxJava,ObservableTests.run,"    @Test
    public void testReplay() throws InterruptedException {
        final AtomicInteger counter = new AtomicInteger();
        ConnectableObservable<String> o = Observable.create(new OnSubscribeFunc<String>() {

            @Override
            public Subscription onSubscribe(final Observer<? super String> observer) {
                final BooleanSubscription subscription = new BooleanSubscription();
                new Thread(new Runnable() {

                    @Override
                    public void run() {
                        counter.incrementAndGet();
                        observer.onNext(""one"");
                        observer.onCompleted();
                    }
",non-flaky,5
97983,ReactiveX_RxJava,ObservableTests.run,"    @Test
    public void testCache() throws InterruptedException {
        final AtomicInteger counter = new AtomicInteger();
        Observable<String> o = Observable.create(new OnSubscribeFunc<String>() {

            @Override
            public Subscription onSubscribe(final Observer<? super String> observer) {
                final BooleanSubscription subscription = new BooleanSubscription();
                new Thread(new Runnable() {

                    @Override
                    public void run() {
                        counter.incrementAndGet();
                        observer.onNext(""one"");
                        observer.onCompleted();
                    }
",non-flaky,5
97984,ReactiveX_RxJava,ObservableTests.call,"    @Test
    public void testErrorThrownWithoutErrorHandlerSynchronous() {
        try {
            Observable.error(new RuntimeException(""failure"")).subscribe(new Action1<Object>() {

                @Override
                public void call(Object t1) {
                    // won't get anything
                }
",non-flaky,5
97985,ReactiveX_RxJava,ObservableTests.run,"    @Test
    public void testErrorThrownWithoutErrorHandlerAsynchronous() throws InterruptedException {
        final CountDownLatch latch = new CountDownLatch(1);
        final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
        Observable.create(new OnSubscribeFunc<String>() {

            @Override
            public Subscription onSubscribe(final Observer<? super String> observer) {
                new Thread(new Runnable() {

                    @Override
                    public void run() {
                        try {
                            observer.onError(new Error(""failure""));
                        } catch (Throwable e) {
                            // without an onError handler it has to just throw on whatever thread invokes it
                            exception.set(e);
                        }
                        latch.countDown();
                    }
",non-flaky,5
97986,ReactiveX_RxJava,ObservableTests.onCompleted,"    @Test
    public void testTakeWithErrorInObserver() {
        final AtomicInteger count = new AtomicInteger();
        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
        Observable.from(""1"", ""2"", ""three"", ""4"").take(3).subscribe(new Observer<String>() {

            @Override
            public void onCompleted() {
                System.out.println(""completed"");
            }
",non-flaky,5
97987,ReactiveX_RxJava,ObservableTests.testOfType,"    @Test
    public void testOfType() {
        Observable<String> observable = Observable.from(1, ""abc"", false, 2L).ofType(String.class);

        @SuppressWarnings(""unchecked"")
        Observer<Object> aObserver = mock(Observer.class);
        observable.subscribe(aObserver);
        verify(aObserver, never()).onNext(1);
        verify(aObserver, times(1)).onNext(""abc"");
        verify(aObserver, never()).onNext(false);
        verify(aObserver, never()).onNext(2L);
        verify(aObserver, never()).onError(
                org.mockito.Matchers.any(Throwable.class));
        verify(aObserver, times(1)).onCompleted();
    }
",non-flaky,5
97988,ReactiveX_RxJava,ObservableTests.testOfTypeWithPolymorphism,"    @Test
    public void testOfTypeWithPolymorphism() {
        ArrayList<Integer> l1 = new ArrayList<Integer>();
        l1.add(1);
        LinkedList<Integer> l2 = new LinkedList<Integer>();
        l2.add(2);

        @SuppressWarnings(""rawtypes"")
        Observable<List> observable = Observable.<Object>from(l1, l2, ""123"").ofType(List.class);

        @SuppressWarnings(""unchecked"")
        Observer<Object> aObserver = mock(Observer.class);
        observable.subscribe(aObserver);
        verify(aObserver, times(1)).onNext(l1);
        verify(aObserver, times(1)).onNext(l2);
        verify(aObserver, never()).onNext(""123"");
        verify(aObserver, never()).onError(
                org.mockito.Matchers.any(Throwable.class));
        verify(aObserver, times(1)).onCompleted();
    }
",non-flaky,5
97989,ReactiveX_RxJava,ThrottleFirstTests.testThrottle,"    @Test
    public void testThrottle() {
        @SuppressWarnings(""unchecked"")
        Observer<Integer> observer = mock(Observer.class);
        TestScheduler s = new TestScheduler();
        PublishSubject<Integer> o = PublishSubject.create();
        o.throttleFirst(500, TimeUnit.MILLISECONDS, s).subscribe(observer);

        // send events with simulated time increments
        s.advanceTimeTo(0, TimeUnit.MILLISECONDS);
        o.onNext(1); // deliver
        o.onNext(2); // skip
        s.advanceTimeTo(501, TimeUnit.MILLISECONDS);
        o.onNext(3); // deliver
        s.advanceTimeTo(600, TimeUnit.MILLISECONDS);
        o.onNext(4); // skip
        s.advanceTimeTo(700, TimeUnit.MILLISECONDS);
        o.onNext(5); // skip
        o.onNext(6); // skip
        s.advanceTimeTo(1001, TimeUnit.MILLISECONDS);
        o.onNext(7); // deliver
        s.advanceTimeTo(1501, TimeUnit.MILLISECONDS);
        o.onCompleted();

        InOrder inOrder = inOrder(observer);
        inOrder.verify(observer).onNext(1);
        inOrder.verify(observer).onNext(3);
        inOrder.verify(observer).onNext(7);
        inOrder.verify(observer).onCompleted();
        inOrder.verifyNoMoreInteractions();
    }
",non-flaky,5
97990,ReactiveX_RxJava,ObserveOnTests.call,"    @Test
    public void testObserveOnWithNewThreadScheduler() {
        final AtomicInteger count = new AtomicInteger();
        final int _multiple = 99;

        Observable.range(1, 100000).map(new Func1<Integer, Integer>() {

            @Override
            public Integer call(Integer t1) {
                return t1 * _multiple;
            }
",non-flaky,5
97991,ReactiveX_RxJava,ObserveOnTests.call,"    @Test
    public void testObserveOnWithThreadPoolScheduler() {
        final AtomicInteger count = new AtomicInteger();
        final int _multiple = 99;

        Observable.range(1, 100000).map(new Func1<Integer, Integer>() {

            @Override
            public Integer call(Integer t1) {
                return t1 * _multiple;
            }
",non-flaky,5
97992,ReactiveX_RxJava,ObserveOnTests.call,"    @Test
    public void testObserveOnOrderingConcurrency() {
        final AtomicInteger count = new AtomicInteger();
        final int _multiple = 99;

        Observable.range(1, 10000).map(new Func1<Integer, Integer>() {

            @Override
            public Integer call(Integer t1) {
                if (randomIntFrom0to100() > 98) {
                    try {
                        Thread.sleep(2);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                return t1 * _multiple;
            }
",non-flaky,5
97993,ReactiveX_RxJava,MergeTests.testCovarianceOfMerge,"    @Test
    public void testCovarianceOfMerge() {
        Observable<HorrorMovie> horrors = Observable.from(new HorrorMovie());
        Observable<Observable<HorrorMovie>> metaHorrors = Observable.just(horrors);
        Observable.<Media> merge(metaHorrors);
    }
",non-flaky,5
97994,ReactiveX_RxJava,MergeTests.testMergeCovariance,"    @Test
    public void testMergeCovariance() {
        Observable<Media> o1 = Observable.<Media> from(new HorrorMovie(), new Movie());
        Observable<Media> o2 = Observable.from(new Media(), new HorrorMovie());

        Observable<Observable<Media>> os = Observable.from(o1, o2);

        List<Media> values = Observable.merge(os).toList().toBlockingObservable().single();
    }
",non-flaky,5
97995,ReactiveX_RxJava,MergeTests.testMergeCovariance2,"    @Test
    public void testMergeCovariance2() {
        Observable<Media> o1 = Observable.from(new HorrorMovie(), new Movie(), new Media());
        Observable<Media> o2 = Observable.from(new Media(), new HorrorMovie());

        Observable<Observable<Media>> os = Observable.from(o1, o2);

        List<Media> values = Observable.merge(os).toList().toBlockingObservable().single();
    }
",non-flaky,5
97996,ReactiveX_RxJava,MergeTests.testMergeCovariance3,"    @Test
    public void testMergeCovariance3() {
        Observable<Movie> o1 = Observable.from(new HorrorMovie(), new Movie());
        Observable<Media> o2 = Observable.from(new Media(), new HorrorMovie());

        List<Media> values = Observable.merge(o1, o2).toList().toBlockingObservable().single();
        
        assertTrue(values.get(0) instanceof HorrorMovie);
        assertTrue(values.get(1) instanceof Movie);
        assertTrue(values.get(2) instanceof Media);
        assertTrue(values.get(3) instanceof HorrorMovie);
    }
",non-flaky,5
97997,ReactiveX_RxJava,MergeTests.onSubscribe,"    @Test
    public void testMergeCovariance4() {

        Observable<Movie> o1 = Observable.create(new OnSubscribeFunc<Movie>() {

            @Override
            public Subscription onSubscribe(Observer<? super Movie> o) {
                o.onNext(new HorrorMovie());
                o.onNext(new Movie());
                //                o.onNext(new Media()); // correctly doesn't compile
                o.onCompleted();
                return Subscriptions.empty();
            }
",non-flaky,5
97998,ReactiveX_RxJava,ReduceTests.call,"    @Test
    public void reduceInts() {
        Observable<Integer> o = Observable.from(1, 2, 3);
        int value = o.reduce(new Func2<Integer, Integer, Integer>() {

            @Override
            public Integer call(Integer t1, Integer t2) {
                return t1 + t2;
            }
",non-flaky,5
97999,ReactiveX_RxJava,ReduceTests.call,"    @Test
    public void reduceWithObjects() {
        Observable<Movie> horrorMovies = Observable.<Movie> from(new HorrorMovie());

        Func2<Movie, Movie, Movie> chooseSecondMovie =
                new Func2<Movie, Movie, Movie>() {
                    public Movie call(Movie t1, Movie t2) {
                        return t2;
                    }
",non-flaky,5
98000,ReactiveX_RxJava,ReduceTests.call,"    @Test
    public void reduceWithCovariantObjects() {
        Observable<Movie> horrorMovies = Observable.<Movie> from(new HorrorMovie());

        Func2<Movie, Movie, Movie> chooseSecondMovie =
                new Func2<Movie, Movie, Movie>() {
                    public Movie call(Movie t1, Movie t2) {
                        return t2;
                    }
",non-flaky,5
98001,ReactiveX_RxJava,ReduceTests.reduceCovariance,"    @Test
    public void reduceCovariance() {
        // must type it to <Movie>
        Observable<Movie> horrorMovies = Observable.<Movie> from(new HorrorMovie());
        libraryFunctionActingOnMovieObservables(horrorMovies);
    }
",non-flaky,5
98002,ReactiveX_RxJava,CombineLatestTests.testCovarianceOfCombineLatest,"    @Test
    public void testCovarianceOfCombineLatest() {
        Observable<HorrorMovie> horrors = Observable.from(new HorrorMovie());
        Observable<CoolRating> ratings = Observable.from(new CoolRating());

        Observable.<Movie, CoolRating, Result> combineLatest(horrors, ratings, combine).toBlockingObservable().forEach(action);
        Observable.<Movie, CoolRating, Result> combineLatest(horrors, ratings, combine).toBlockingObservable().forEach(action);
        Observable.<Media, Rating, ExtendedResult> combineLatest(horrors, ratings, combine).toBlockingObservable().forEach(extendedAction);
        Observable.<Media, Rating, Result> combineLatest(horrors, ratings, combine).toBlockingObservable().forEach(action);
        Observable.<Media, Rating, ExtendedResult> combineLatest(horrors, ratings, combine).toBlockingObservable().forEach(action);

        Observable.<Movie, CoolRating, Result> combineLatest(horrors, ratings, combine);
    }
",non-flaky,5
98003,ReactiveX_RxJava,ThrottleLastTests.testThrottle,"    @Test
    public void testThrottle() {
        @SuppressWarnings(""unchecked"")
        Observer<Integer> observer = mock(Observer.class);
        TestScheduler s = new TestScheduler();
        PublishSubject<Integer> o = PublishSubject.create();
        o.throttleLast(500, TimeUnit.MILLISECONDS, s).subscribe(observer);

        // send events with simulated time increments
        s.advanceTimeTo(0, TimeUnit.MILLISECONDS);
        o.onNext(1); // skip
        o.onNext(2); // deliver
        s.advanceTimeTo(501, TimeUnit.MILLISECONDS);
        o.onNext(3); // skip
        s.advanceTimeTo(600, TimeUnit.MILLISECONDS);
        o.onNext(4); // skip
        s.advanceTimeTo(700, TimeUnit.MILLISECONDS);
        o.onNext(5); // skip
        o.onNext(6); // deliver
        s.advanceTimeTo(1001, TimeUnit.MILLISECONDS);
        o.onNext(7); // deliver
        s.advanceTimeTo(1501, TimeUnit.MILLISECONDS);
        o.onCompleted();

        InOrder inOrder = inOrder(observer);
        inOrder.verify(observer).onNext(2);
        inOrder.verify(observer).onNext(6);
        inOrder.verify(observer).onNext(7);
        inOrder.verify(observer).onCompleted();
        inOrder.verifyNoMoreInteractions();
    }
",non-flaky,5
98004,ReactiveX_RxJava,ScanTests.call,"    @Test
    public void testUnsubscribeScan() {

        EventStream.getEventStream(""HTTP-ClusterB"", 20)
                .scan(new HashMap<String, String>(), new Func2<Map<String, String>, Event, Map<String, String>>() {

                    @Override
                    public Map<String, String> call(Map<String, String> accum, Event perInstanceEvent) {
                        accum.put(""instance"", perInstanceEvent.instanceId);
                        return accum;
                    }

                })
                .take(10)
                .toBlockingObservable().forEach(new Action1<Map<String, String>>() {

                    @Override
                    public void call(Map<String, String> v) {
                        System.out.println(v);
                    }
",non-flaky,5
98005,ReactiveX_RxJava,StartWithTests.startWith1,"    @Test
    public void startWith1() {
        List<String> values = Observable.from(""one"", ""two"").startWith(""zero"").toList().toBlockingObservable().single();

        assertEquals(""zero"", values.get(0));
        assertEquals(""two"", values.get(2));
    }
",non-flaky,5
98006,ReactiveX_RxJava,StartWithTests.startWithIterable,"    @Test
    public void startWithIterable() {
        List<String> li = new ArrayList<String>();
        li.add(""alpha"");
        li.add(""beta"");
        List<String> values = Observable.from(""one"", ""two"").startWith(li).toList().toBlockingObservable().single();

        assertEquals(""alpha"", values.get(0));
        assertEquals(""beta"", values.get(1));
        assertEquals(""one"", values.get(2));
        assertEquals(""two"", values.get(3));
    }
",non-flaky,5
98007,ReactiveX_RxJava,ThrottleWithTimeoutTests.testThrottle,"    @Test
    public void testThrottle() {
        @SuppressWarnings(""unchecked"")
        Observer<Integer> observer = mock(Observer.class);
        TestScheduler s = new TestScheduler();
        PublishSubject<Integer> o = PublishSubject.create();
        o.throttleWithTimeout(500, TimeUnit.MILLISECONDS, s).subscribe(observer);

        // send events with simulated time increments
        s.advanceTimeTo(0, TimeUnit.MILLISECONDS);
        o.onNext(1); // skip
        o.onNext(2); // deliver
        s.advanceTimeTo(501, TimeUnit.MILLISECONDS);
        o.onNext(3); // skip
        s.advanceTimeTo(600, TimeUnit.MILLISECONDS);
        o.onNext(4); // skip
        s.advanceTimeTo(700, TimeUnit.MILLISECONDS);
        o.onNext(5); // skip
        o.onNext(6); // deliver at 1300 after 500ms has passed since onNext(5)
        s.advanceTimeTo(1300, TimeUnit.MILLISECONDS);
        o.onNext(7); // deliver
        s.advanceTimeTo(1800, TimeUnit.MILLISECONDS);
        o.onCompleted();

        InOrder inOrder = inOrder(observer);
        inOrder.verify(observer).onNext(2);
        inOrder.verify(observer).onNext(6);
        inOrder.verify(observer).onNext(7);
        inOrder.verify(observer).onCompleted();
        inOrder.verifyNoMoreInteractions();
    }
",non-flaky,5
98008,ReactiveX_RxJava,GroupByTests.call,"    @Test
    public void testTakeUnsubscribesOnGroupBy() {
        Observable.merge(
                EventStream.getEventStream(""HTTP-ClusterA"", 50),
                EventStream.getEventStream(""HTTP-ClusterB"", 20))
                // group by type (2 clusters)
                .groupBy(new Func1<Event, String>() {

                    @Override
                    public String call(Event event) {
                        return event.type;
                    }
",non-flaky,5
98009,ReactiveX_RxJava,GroupByTests.call,"    @Test
    public void testTakeUnsubscribesOnFlatMapOfGroupBy() {
        Observable.merge(
                EventStream.getEventStream(""HTTP-ClusterA"", 50),
                EventStream.getEventStream(""HTTP-ClusterB"", 20))
                // group by type (2 clusters)
                .groupBy(new Func1<Event, String>() {

                    @Override
                    public String call(Event event) {
                        return event.type;
                    }
",non-flaky,5
98337,Kong_unirest-java,MockClientInterceptorIssueTest.setup,"    @BeforeEach
    public void setup() {
        this.unirestInstance = Unirest.spawnInstance();
        this.unirestInstance.config().interceptor(interceptor);
    }
",non-flaky,5
98338,Kong_unirest-java,ExpectedResponseTest.writeValue,"    @Test
        public String writeValue(Object value) {
            return ""derp"";
        }
",non-flaky,5
98339,Kong_unirest-java,AssertTest.expectAnyPath,"    @Test
    public void expectAnyPath(){
        client.expect(HttpMethod.GET)
                .thenReturn(""woh"");

        Unirest.get(path).asEmpty();

        client.verifyAll();
    }
",non-flaky,5
98340,Kong_unirest-java,ApacheBehaviorTest.setTimeoutsAndCustomClient,"    @Test
    public void setTimeoutsAndCustomClient() {
        try {
            Unirest.config().connectTimeout(1000).socketTimeout(2000);
        } catch (Exception e) {
            fail();
        }

        try {
            Unirest.config().asyncClient(HttpAsyncClientBuilder.create().build());
        } catch (Exception e) {
            fail();
        }

        try {
            Unirest.config().asyncClient(HttpAsyncClientBuilder.create().build());
            Unirest.config().connectTimeout(1000).socketTimeout(2000);
            fail();
        } catch (Exception e) {
            // Ok
        }

        try {
            Unirest.config().httpClient(HttpClientBuilder.create().build());
            Unirest.config().connectTimeout(1000).socketTimeout(2000);
            fail();
        } catch (Exception e) {
            // Ok
        }
    }
",non-flaky,5
98341,Kong_unirest-java,ApacheInterceptorTest.process,"    @Test
        public void process(org.apache.http.HttpRequest httpRequest, org.apache.http.protocol.HttpContext httpContext) throws HttpException, IOException {
            httpRequest.addHeader(""x-custom"", ""foo"");
        }
",non-flaky,5
98342,Kong_unirest-java,ApacheClientTest.setUp,"    @BeforeEach
    public void setUp() {
        super.setUp();
    }
",non-flaky,5
98343,Kong_unirest-java,ApacheClientTest.tearDown,"    @AfterEach
    public void tearDown() {
        super.tearDown();
        requestConfigUsed = false;
    }
",non-flaky,5
98344,Kong_unirest-java,CacheManagerTest.getClient,"    @Test
        public Object getClient() {
            return null;
        }
",non-flaky,5
98345,Kong_unirest-java,UriFormatterTest.testMangler_encoding,"    @Test
    public void testMangler_encoding() {
        assertLinkSurvives(""http://localhost/test%2Fthis"");
    }
",non-flaky,5
98346,Kong_unirest-java,UriFormatterTest.testMangler_fragment,"    @Test
    public void testMangler_fragment() {
        assertLinkSurvives(""http://localhost/test?a=b#fragment"");
    }
",non-flaky,5
98347,Kong_unirest-java,UriFormatterTest.basicBoringUri,"    @Test
    public void basicBoringUri() {
        assertLinkSurvives(""http://localhost/test?a=b"");
    }
",non-flaky,5
98348,Kong_unirest-java,UriFormatterTest.semicolonsAsParam,"    @Test
    public void semicolonsAsParam() {
        assertLinkSurvives(""http://localhost/test?a=b;foo=bar"");
    }
",non-flaky,5
98349,Kong_unirest-java,UriFormatterTest.utf8Chars,"    @Test
    public void utf8Chars(){
        assertLinkSurvives(""http://localhost/test?foo="");
    }
",non-flaky,5
98350,Kong_unirest-java,ClientFactoryTest.before,"    @AfterEach
    public void before(){
        Unirest.shutDown(true);
    }
",non-flaky,5
98351,Kong_unirest-java,JSONArrayTest.toString,"    @Test
        public String toString(){
            return ""Hello World"";
        }
",non-flaky,5
98352,Kong_unirest-java,JsonObjectMapperTest.getDate,"    @Test
        public Date getDate() {
            return date;
        }
",non-flaky,5
98353,Kong_unirest-java,ConsumerTest.tearDown,"    @AfterEach
    public void tearDown() {
        super.tearDown();
        asyncDone = false;
        status = 0;
        File file = test.toFile();
        if(file.exists()){
            file.delete();
        }
    }
",non-flaky,5
98354,Kong_unirest-java,AsObjectTest.writeValue,"    @Test
        public String writeValue(Object value) {
            writeWasCalled = true;
            return new Gson().toJson(value);
        }
",non-flaky,5
98355,Kong_unirest-java,ShutDownHooksTest.setUp,"    @Override @BeforeEach
    public void setUp() {
        super.setUp();
        clearUnirestHooks();
    }
",non-flaky,5
98356,Kong_unirest-java,AsGenericTypeTest.getSomeTees,"    @Test
        public T getSomeTees() {
            return someTees;
        }
",non-flaky,5
98357,Kong_unirest-java,CallbackFutureTest.completed,"    @Test @Disabled
                        public void completed(HttpResponse<JsonNode> response) {
                            throw new UnirestException(""Failure!"");
                        }
",non-flaky,5
98358,Kong_unirest-java,CallbackFutureTest.completed,"    @Test @Disabled
                    public void completed(HttpResponse<JsonNode> response) {
                        throw new UnirestException(""Failure!"");
                    }
",non-flaky,5
98359,Kong_unirest-java,DownloadProgressTest.setUp,"    @BeforeEach
    public void setUp() {
        super.setUp();
        this.monitor = new TestMonitor();
    }
",non-flaky,5
98360,Kong_unirest-java,PostRequestHandlersTest.tearDown,"    @AfterEach
    public void tearDown() {
        super.tearDown();
        captured = null;
    }
",non-flaky,5
98361,Kong_unirest-java,PostRequestHandlersTest.accept,"    @Test
        public void accept(HttpResponse<?> httpResponse) {

            this.httpResponse = httpResponse;
        }
",non-flaky,5
98362,Kong_unirest-java,AsFileTest.tearDown,"    @Override @AfterEach
    public void tearDown() {
        try {
            Files.delete(test);
        } catch (Exception ignored) { }
    }
",non-flaky,5
98363,Kong_unirest-java,CachingAlternativeTest.invalidate,"    @Test
        public void invalidate() {
            regular.invalidateAll();
            async.invalidateAll();
        }
",non-flaky,5
98364,Kong_unirest-java,ProxyTest.tearDown,"    @AfterEach
    public void tearDown() {
        super.tearDown();
        Unirest.shutDown(true);
        JankyProxy.shutdown();
    }
",non-flaky,5
98365,Kong_unirest-java,InterceptorTest.setUp,"    @BeforeEach
    public void setUp() {
        super.setUp();
        interceptor = new UniInterceptor(""x-custom"", ""foo"");
    }
",non-flaky,5
98366,Kong_unirest-java,InterceptorTest.onRequest,"    @Test
            public void onRequest(HttpRequest<?> request, Config config) {
                request.getBody().ifPresent(b ->
                        b.multiParts().forEach(part ->
                                values.add(part.toString())));
            }
",non-flaky,5
98367,Kong_unirest-java,CustomObjectMapperTest.setUp,"    @BeforeEach
    public void setUp() {
        super.setUp();
        customOm = Mockito.spy(JsonObjectMapper.class);
    }
",non-flaky,5
98368,Kong_unirest-java,UploadProgressTest.setUp,"    @Override @BeforeEach
    public void setUp() {
        super.setUp();
        this.monitor = new TestMonitor();
    }
",non-flaky,5
99702,apache_cassandra,DistributionSequenceTest.simpleSequence,"    @Test
    public void simpleSequence() throws Exception
    {
        Distribution dist = OptionDistribution.get(""seq(1..10)"").get();
        assertTrue(dist instanceof DistributionSequence);

        assertEquals(1, dist.minValue());
        assertEquals(10, dist.maxValue());
        assertEquals(5, dist.average());

        assertEquals(1, dist.inverseCumProb(0d));
        assertEquals(10, dist.inverseCumProb(1d));

        long min = dist.next();
        assertEquals(1,min);

        long last = min;
        for (int i=0; i<9; i++)
        {
            long next = dist.next();
            assertEquals(next, last+1); //increase by one each step
            last = next;
        }

        assertEquals(1, dist.next()); // wrapping
    }
",non-flaky,5
99703,apache_cassandra,DistributionSequenceTest.negValueSequence,"    @Test
    public void negValueSequence() throws Exception
    {
        Distribution dist = OptionDistribution.get(""seq(-1000..-10)"").get();
        assertTrue(dist instanceof DistributionSequence);

        assertEquals(-1000, dist.minValue());
        assertEquals( -10, dist.maxValue());
        assertEquals(-504, dist.average());

        assertEquals(-1000, dist.inverseCumProb(0d));
        assertEquals(-10, dist.inverseCumProb(1d));

        long min = dist.next();
        assertEquals(-1000, min);

        long last = min;
        long next = dist.next();
        while (last<next)
        {
            assertEquals(next, last+1); //increase by one each step
            last = next;
            next = dist.next();
        }

        assertEquals(-10, last); // wrapping
        assertEquals(-1000, next); // wrapping
    }
",non-flaky,5
99704,apache_cassandra,DistributionSequenceTest.bigSequence,"    @Test
    public void bigSequence() throws Exception
    {
        Distribution dist = OptionDistribution.get(String.format(""seq(1..%d)"", Long.MAX_VALUE)).get();
        assertTrue(dist instanceof DistributionSequence);

        assertEquals(1, dist.minValue());
        assertEquals(Long.MAX_VALUE, dist.maxValue());

        assertEquals(1, dist.inverseCumProb(0d));
        assertEquals(Long.MAX_VALUE, dist.inverseCumProb(1d));

    }
",non-flaky,5
99705,apache_cassandra,DistributionSequenceTest.setSeed,"    @Test
    public void setSeed() throws Exception
    {
        Distribution dist = OptionDistribution.get(""seq(1..10)"").get();
        assertTrue(dist instanceof DistributionSequence);

        for (int seed=1; seed<500; seed+=seed)
        {
            dist.setSeed(seed);
            assertEquals(1, dist.minValue());
            assertEquals(10, dist.maxValue());
            assertEquals(5, dist.average());

            assertEquals(1, dist.inverseCumProb(0d));
            assertEquals(10, dist.inverseCumProb(1d));

            long last = dist.next();
            for (int i = 0; i < 9; i++)
            {
                long next = dist.next();
                if (next>1)
                {
                    assertEquals(next, last + 1); //increase by one each step
                }else{
                    assertEquals(last, 10); //wrap after the end
                }
                last = next;
            }
        }
    }
",non-flaky,5
99706,apache_cassandra,DistributionGaussianTest.simpleGaussian,"    @Test
    public void simpleGaussian()
    {
        Distribution dist = OptionDistribution.get(""gaussian(1..10)"").get();
        assertTrue(dist instanceof DistributionBoundApache);

        assertEquals(1, dist.minValue());
        assertEquals(10, dist.maxValue());
        assertEquals(5, dist.average());

        assertEquals(1, dist.inverseCumProb(0d));
        assertEquals(10, dist.inverseCumProb(1d));

        int testCount = 100000;
        int[] results = new int[11];
        for (int i = 0; i < testCount; i++)
        {
            int val = toIntExact(dist.next());
            results[val]++;
        }

        // Increasing for the first half
        for (int i = toIntExact(dist.minValue()); i < dist.average(); i++)
        {
            assertTrue(results[i] < results[i + 1]);
        }

        // Decreasing for the second half
        for (int i = toIntExact(dist.average()) + 1; i < dist.maxValue(); i++)
        {
            assertTrue(results[i] > results[i + 1]);
        }
    }
",non-flaky,5
99707,apache_cassandra,DistributionGaussianTest.negValueGaussian,"    @Test
    public void negValueGaussian()
    {
        Distribution dist = OptionDistribution.get(""gaussian(-1000..-10)"").get();
        assertTrue(dist instanceof DistributionBoundApache);

        assertEquals(-1000, dist.minValue());
        assertEquals( -10, dist.maxValue());
        assertEquals(-504, dist.average());

        assertEquals(-1000, dist.inverseCumProb(0d));
        assertEquals(-10, dist.inverseCumProb(1d));
    }
",non-flaky,5
99708,apache_cassandra,MultiResultLoggerTest.delegatesToInitialPrintStream,"    @Test
    public void delegatesToInitialPrintStream() throws Exception
    {
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        PrintStream printStream = new PrintStream(output, true);
        MultiResultLogger underTest = new MultiResultLogger(printStream);

        underTest.println(""Very important result"");

        assertEquals(""Very important result\n"", output.toString());
    }
",non-flaky,5
99709,apache_cassandra,MultiResultLoggerTest.printingExceptions,"    @Test
    public void printingExceptions() throws Exception
    {
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        PrintStream printStream = new PrintStream(output, true);
        MultiResultLogger underTest = new MultiResultLogger(printStream);

        underTest.printException(new RuntimeException(""Bad things""));

        String stackTrace = output.toString();
        assertTrue(""Expected strack trace to be printed but got: "" + stackTrace, stackTrace.startsWith(""java.lang.RuntimeException: Bad things\n"" +
                                                ""\tat org.apache.cassandra.stress.util.MultiResultLoggerTest.printingExceptions""));
    }
",non-flaky,5
99710,apache_cassandra,MultiResultLoggerTest.delegatesToAdditionalPrintStreams,"    @Test
    public void delegatesToAdditionalPrintStreams() throws Exception
    {
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        PrintStream additionalPrintStream = new PrintStream(output, true);
        MultiResultLogger underTest = new MultiResultLogger(new PrintStream(NOOP));

        underTest.addStream(additionalPrintStream);
        underTest.println(""Very important result"");

        assertEquals(""Very important result\n"", output.toString());
    }
",non-flaky,5
99711,apache_cassandra,MultiResultLoggerTest.delegatesPrintfToAdditionalPrintStreams,"    @Test
    public void delegatesPrintfToAdditionalPrintStreams() throws Exception
    {
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        PrintStream additionalPrintStream = new PrintStream(output, true);
        MultiResultLogger underTest = new MultiResultLogger(new PrintStream(NOOP));

        underTest.addStream(additionalPrintStream);
        underTest.printf(""%s %s %s"", ""one"", ""two"", ""three"");

        assertEquals(""one two three"", output.toString());
    }
",non-flaky,5
99712,apache_cassandra,MultiResultLoggerTest.delegatesPrintlnToAdditionalPrintStreams,"    @Test
    public void delegatesPrintlnToAdditionalPrintStreams() throws Exception
    {
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        PrintStream additionalPrintStream = new PrintStream(output, true);
        MultiResultLogger underTest = new MultiResultLogger(new PrintStream(NOOP));

        underTest.addStream(additionalPrintStream);
        underTest.println();

        assertEquals(""\n"", output.toString());
    }
",non-flaky,5
99713,apache_cassandra,SettingsNodeTest.testDefaults,"    @Test
    public void testDefaults() throws Exception
    {
        SettingsNode settingsNode = new SettingsNode(new SettingsNode.Options());
        assertEquals(null, settingsNode.datacenter);
    }
",non-flaky,5
99714,apache_cassandra,SettingsNodeTest.testOveridingDataCenter,"    @Test
    public void testOveridingDataCenter() throws Exception
    {
        SettingsNode.Options options = new SettingsNode.Options();
        options.accept(""datacenter=dc1"");
        SettingsNode settingsNode = new SettingsNode(options);
        assertEquals(""dc1"", settingsNode.datacenter);
    }
",non-flaky,5
99715,apache_cassandra,SettingsMiscTest.versionTriggersSpecialOption,"    @Test
    public void versionTriggersSpecialOption() throws Exception
    {
        assertTrue(SettingsMisc.maybeDoSpecial(ImmutableMap.of(""version"", new String[] {})));
    }
",non-flaky,5
99716,apache_cassandra,SettingsMiscTest.noSpecialOptions,"    @Test
    public void noSpecialOptions() throws Exception
    {
        assertFalse(SettingsMisc.maybeDoSpecial(Collections.emptyMap()));
    }
",non-flaky,5
99717,apache_cassandra,SettingsMiscTest.parsesVersionMatch,"    @Test
    public void parsesVersionMatch() throws Exception
    {
        String versionString = SettingsMisc.parseVersionFile(""CassandraVersion=TheBestVersion\n"");
        assertEquals(""Version: TheBestVersion"", versionString);
    }
",non-flaky,5
99718,apache_cassandra,SettingsMiscTest.parsesVersionNoMatch,"    @Test
    public void parsesVersionNoMatch() throws Exception
    {
        String versionString = SettingsMisc.parseVersionFile(""VersionFileChangedFormat :("");
        assertEquals(""Unable to find version information"", versionString);
    }
",non-flaky,5
99719,apache_cassandra,OptionReplicationTest.defaultsToReplicationFactorOfOne,"    @Test
    public void defaultsToReplicationFactorOfOne() throws Exception
    {
        OptionReplication defaults = new OptionReplication();
        assertEquals(ImmutableMap.of(""replication_factor"", ""1""), defaults.getOptions());
    }
",non-flaky,5
99720,apache_cassandra,StressSettingsTest.isSerializable,"    @Test
    public void isSerializable() throws Exception
    {
        Map<String, String[]> args = new HashMap<>();
        args.put(""write"", new String[] {});
        StressSettings settings = StressSettings.get(args);
        // Will throw if not all settings are Serializable
        new ObjectOutputStream(new ByteArrayOutputStream()).writeObject(settings);
    }
",non-flaky,5
99721,apache_cassandra,FQLReplayTest.testOrderedReplay,"    @Test
    public void testOrderedReplay() throws IOException
    {
        File f = generateQueries(100, true);
        int queryCount = 0;
        try (ChronicleQueue queue = ChronicleQueueBuilder.single(f).build();
             FQLQueryIterator iter = new FQLQueryIterator(queue.createTailer(), 101))
        {
            long last = -1;
            while (iter.hasNext())
            {
                FQLQuery q = iter.next();
                assertTrue(q.queryStartTime >= last);
                last = q.queryStartTime;
                queryCount++;
            }
        }
        assertEquals(100, queryCount);
    }
",non-flaky,5
99722,apache_cassandra,FQLReplayTest.testQueryIterator,"    @Test
    public void testQueryIterator() throws IOException
    {
        File f = generateQueries(100, false);
        int queryCount = 0;
        try (ChronicleQueue queue = ChronicleQueueBuilder.single(f).build();
             FQLQueryIterator iter = new FQLQueryIterator(queue.createTailer(), 1))
        {
            long last = -1;
            while (iter.hasNext())
            {
                FQLQuery q = iter.next();
                assertTrue(q.queryStartTime >= last);
                last = q.queryStartTime;
                queryCount++;
            }
        }
        assertEquals(100, queryCount);
    }
",non-flaky,5
99723,apache_cassandra,FQLReplayTest.testMergingIterator,"    @Test
    public void testMergingIterator() throws IOException
    {
        File f = generateQueries(100, false);
        File f2 = generateQueries(100, false);
        int queryCount = 0;
        try (ChronicleQueue queue = ChronicleQueueBuilder.single(f).build();
             ChronicleQueue queue2 = ChronicleQueueBuilder.single(f2).build();
             FQLQueryIterator iter = new FQLQueryIterator(queue.createTailer(), 101);
             FQLQueryIterator iter2 = new FQLQueryIterator(queue2.createTailer(), 101);
             MergeIterator<FQLQuery, List<FQLQuery>> merger = MergeIterator.get(Lists.newArrayList(iter, iter2), FQLQuery::compareTo, new Replay.Reducer()))
        {
            long last = -1;

            while (merger.hasNext())
            {
                List<FQLQuery> qs = merger.next();
                assertEquals(2, qs.size());
                assertEquals(0, qs.get(0).compareTo(qs.get(1)));
                assertTrue(qs.get(0).queryStartTime >= last);
                last = qs.get(0).queryStartTime;
                queryCount++;
            }
        }
        assertEquals(100, queryCount);
    }
",non-flaky,5
99724,apache_cassandra,FQLReplayTest.testFQLQueryReader,"    @Test
    public void testFQLQueryReader() throws IOException
    {
        FQLQueryReader reader = new FQLQueryReader();

        try (ChronicleQueue queue = ChronicleQueueBuilder.single(generateQueries(1000, true)).build())
        {
            ExcerptTailer tailer = queue.createTailer();
            int queryCount = 0;
            while (tailer.readDocument(reader))
            {
                assertNotNull(reader.getQuery());
                if (reader.getQuery() instanceof FQLQuery.Single)
                {
                    assertTrue(reader.getQuery().keyspace() == null || reader.getQuery().keyspace().equals(""querykeyspace""));
                }
                else
                {
                    assertEquals(""someks"", reader.getQuery().keyspace());
                }
                queryCount++;
            }
            assertEquals(1000, queryCount);
        }
    }
",non-flaky,5
99725,apache_cassandra,FQLReplayTest.testStoringResults,"    @Test
    public void testStoringResults() throws Throwable
    {
        File tmpDir = Files.createTempDirectory(""results"").toFile();
        File queryDir = Files.createTempDirectory(""queries"").toFile();

        ResultHandler.ComparableResultSet res = createResultSet(10, 10, true);
        ResultStore rs = new ResultStore(Collections.singletonList(tmpDir), queryDir);
        FQLQuery query = new FQLQuery.Single(""abc"", QueryOptions.DEFAULT.getProtocolVersion().asInt(), QueryOptions.DEFAULT, 12345, 11111, 22, ""select * from abc"", Collections.emptyList());
        try
        {
            rs.storeColumnDefinitions(query, Collections.singletonList(res.getColumnDefinitions()));
            Iterator<ResultHandler.ComparableRow> it = res.iterator();
            while (it.hasNext())
            {
                List<ResultHandler.ComparableRow> row = Collections.singletonList(it.next());
                rs.storeRows(row);
            }
            // this marks the end of the result set:
            rs.storeRows(Collections.singletonList(null));
        }
        finally
        {
            rs.close();
        }

        compareResults(Collections.singletonList(Pair.create(query, res)),
                       readResultFile(tmpDir, queryDir));

    }
",non-flaky,5
99726,apache_cassandra,FQLReplayTest.testCompareColumnDefinitions,"    @Test
    public void testCompareColumnDefinitions()
    {
        ResultHandler.ComparableResultSet res = createResultSet(10, 10, false);
        ResultComparator rc = new ResultComparator();

        List<ResultHandler.ComparableColumnDefinitions> colDefs = new ArrayList<>(100);
        List<String> targetHosts = new ArrayList<>(100);
        for (int i = 0; i < 100; i++)
        {
            targetHosts.add(""host""+i);
            colDefs.add(res.getColumnDefinitions());
        }
        assertTrue(rc.compareColumnDefinitions(targetHosts, null, colDefs));
        colDefs.set(50, createResultSet(9, 9, false).getColumnDefinitions());
        assertFalse(rc.compareColumnDefinitions(targetHosts, null, colDefs));
    }
",non-flaky,5
99727,apache_cassandra,FQLReplayTest.testCompareEqualRows,"    @Test
    public void testCompareEqualRows()
    {
        ResultComparator rc = new ResultComparator();

        ResultHandler.ComparableResultSet res = createResultSet(10, 10, false);
        ResultHandler.ComparableResultSet res2 = createResultSet(10, 10, false);
        List<ResultHandler.ComparableResultSet> toCompare = Lists.newArrayList(res, res2);
        List<Iterator<ResultHandler.ComparableRow>> iters = toCompare.stream().map(Iterable::iterator).collect(Collectors.toList());

        while (true)
        {
            List<ResultHandler.ComparableRow> rows = ResultHandler.rows(iters);
            assertTrue(rc.compareRows(Lists.newArrayList(""eq1"", ""eq2""), null, rows));
            if (rows.stream().allMatch(Objects::isNull))
                break;
        }
    }
",non-flaky,5
99728,apache_cassandra,FQLReplayTest.testCompareRowsDifferentCount,"    @Test
    public void testCompareRowsDifferentCount()
    {
        ResultComparator rc = new ResultComparator();
        ResultHandler.ComparableResultSet res = createResultSet(10, 10, false);
        ResultHandler.ComparableResultSet res2 = createResultSet(10, 10, false);
        List<ResultHandler.ComparableResultSet> toCompare = Lists.newArrayList(res, res2, createResultSet(10, 11, false));
        List<Iterator<ResultHandler.ComparableRow>> iters = toCompare.stream().map(Iterable::iterator).collect(Collectors.toList());
        boolean foundMismatch = false;
        while (true)
        {
            List<ResultHandler.ComparableRow> rows = ResultHandler.rows(iters);
            if (rows.stream().allMatch(Objects::isNull))
                break;
            if (!rc.compareRows(Lists.newArrayList(""eq1"", ""eq2"", ""diff""), null, rows))
            {
                foundMismatch = true;
            }
        }
        assertTrue(foundMismatch);
    }
",non-flaky,5
99729,apache_cassandra,FQLReplayTest.testCompareRowsDifferentContent,"    @Test
    public void testCompareRowsDifferentContent()
    {
        ResultComparator rc = new ResultComparator();
        ResultHandler.ComparableResultSet res = createResultSet(10, 10, false);
        ResultHandler.ComparableResultSet res2 = createResultSet(10, 10, false);
        List<ResultHandler.ComparableResultSet> toCompare = Lists.newArrayList(res, res2, createResultSet(10, 10, true));
        List<Iterator<ResultHandler.ComparableRow>> iters = toCompare.stream().map(Iterable::iterator).collect(Collectors.toList());
        while (true)
        {
            List<ResultHandler.ComparableRow> rows = ResultHandler.rows(iters);
            if (rows.stream().allMatch(Objects::isNull))
                break;
            assertFalse(rows.toString(), rc.compareRows(Lists.newArrayList(""eq1"", ""eq2"", ""diff""), null, rows));
        }
    }
",non-flaky,5
99730,apache_cassandra,FQLReplayTest.testCompareRowsDifferentColumnCount,"    @Test
    public void testCompareRowsDifferentColumnCount()
    {
        ResultComparator rc = new ResultComparator();
        ResultHandler.ComparableResultSet res = createResultSet(10, 10, false);
        ResultHandler.ComparableResultSet res2 = createResultSet(10, 10, false);
        List<ResultHandler.ComparableResultSet> toCompare = Lists.newArrayList(res, res2, createResultSet(11, 10, false));
        List<Iterator<ResultHandler.ComparableRow>> iters = toCompare.stream().map(Iterable::iterator).collect(Collectors.toList());
        while (true)
        {
            List<ResultHandler.ComparableRow> rows = ResultHandler.rows(iters);
            if (rows.stream().allMatch(Objects::isNull))
                break;
            assertFalse(rows.toString(), rc.compareRows(Lists.newArrayList(""eq1"", ""eq2"", ""diff""), null, rows));
        }
    }
",non-flaky,5
99731,apache_cassandra,FQLReplayTest.testResultHandler,"    @Test
    public void testResultHandler() throws IOException
    {
        List<String> targetHosts = Lists.newArrayList(""hosta"", ""hostb"", ""hostc"");
        File tmpDir = Files.createTempDirectory(""testresulthandler"").toFile();
        File queryDir = Files.createTempDirectory(""queries"").toFile();
        List<File> resultPaths = new ArrayList<>();
        targetHosts.forEach(host -> { File f = new File(tmpDir, host); f.mkdir(); resultPaths.add(f);});

        ResultHandler.ComparableResultSet res = createResultSet(10, 10, false);
        ResultHandler.ComparableResultSet res2 = createResultSet(10, 10, false);
        ResultHandler.ComparableResultSet res3 = createResultSet(10, 10, false);
        List<ResultHandler.ComparableResultSet> toCompare = Lists.newArrayList(res, res2, res3);
        FQLQuery query = new FQLQuery.Single(""abcabc"", QueryOptions.DEFAULT.getProtocolVersion().asInt(), QueryOptions.DEFAULT, 1111, 2222, 3333, ""select * from xyz"", Collections.emptyList());
        try (ResultHandler rh = new ResultHandler(targetHosts, resultPaths, queryDir))
        {
            rh.handleResults(query, toCompare);
        }
        List<Pair<FQLQuery, ResultHandler.ComparableResultSet>> results1 = readResultFile(resultPaths.get(0), queryDir);
        List<Pair<FQLQuery, ResultHandler.ComparableResultSet>> results2 = readResultFile(resultPaths.get(1), queryDir);
        List<Pair<FQLQuery, ResultHandler.ComparableResultSet>> results3 = readResultFile(resultPaths.get(2), queryDir);
        compareResults(results1, results2);
        compareResults(results1, results3);
        compareResults(results3, Collections.singletonList(Pair.create(query, res)));
    }
",non-flaky,5
99732,apache_cassandra,FQLReplayTest.testResultHandlerWithDifference,"    @Test
    public void testResultHandlerWithDifference() throws IOException
    {
        List<String> targetHosts = Lists.newArrayList(""hosta"", ""hostb"", ""hostc"");
        File tmpDir = Files.createTempDirectory(""testresulthandler"").toFile();
        File queryDir = Files.createTempDirectory(""queries"").toFile();
        List<File> resultPaths = new ArrayList<>();
        targetHosts.forEach(host -> { File f = new File(tmpDir, host); f.mkdir(); resultPaths.add(f);});

        ResultHandler.ComparableResultSet res = createResultSet(10, 10, false);
        ResultHandler.ComparableResultSet res2 = createResultSet(10, 5, false);
        ResultHandler.ComparableResultSet res3 = createResultSet(10, 10, false);
        List<ResultHandler.ComparableResultSet> toCompare = Lists.newArrayList(res, res2, res3);
        FQLQuery query = new FQLQuery.Single(""aaa"", QueryOptions.DEFAULT.getProtocolVersion().asInt(), QueryOptions.DEFAULT, 123123, 11111, 22222, ""select * from abcabc"", Collections.emptyList());
        try (ResultHandler rh = new ResultHandler(targetHosts, resultPaths, queryDir))
        {
            rh.handleResults(query, toCompare);
        }
        List<Pair<FQLQuery, ResultHandler.ComparableResultSet>> results1 = readResultFile(resultPaths.get(0), queryDir);
        List<Pair<FQLQuery, ResultHandler.ComparableResultSet>> results2 = readResultFile(resultPaths.get(1), queryDir);
        List<Pair<FQLQuery, ResultHandler.ComparableResultSet>> results3 = readResultFile(resultPaths.get(2), queryDir);
        compareResults(results1, results3);
        compareResults(results2, Collections.singletonList(Pair.create(query, res2)));
    }
",non-flaky,5
99733,apache_cassandra,FQLReplayTest.testResultHandlerMultipleResultSets,"    @Test
    public void testResultHandlerMultipleResultSets() throws IOException
    {
        List<String> targetHosts = Lists.newArrayList(""hosta"", ""hostb"", ""hostc"");
        File tmpDir = Files.createTempDirectory(""testresulthandler"").toFile();
        File queryDir = Files.createTempDirectory(""queries"").toFile();
        List<File> resultPaths = new ArrayList<>();
        targetHosts.forEach(host -> { File f = new File(tmpDir, host); f.mkdir(); resultPaths.add(f);});
        List<Pair<FQLQuery, List<ResultHandler.ComparableResultSet>>> resultSets = new ArrayList<>();
        Random random = new Random();
        for (int i = 0; i < 10; i++)
        {
            List<ResultHandler.ComparableResultSet> results = new ArrayList<>();
            List<ByteBuffer> values = Collections.singletonList(ByteBufferUtil.bytes(i * 50));
            for (int jj = 0; jj < targetHosts.size(); jj++)
            {
                results.add(createResultSet(5, 1 + random.nextInt(10), true));
            }
            FQLQuery q = i % 2 == 0
                         ? new FQLQuery.Single(""abc""+i,
                                             3,
                                             QueryOptions.forInternalCalls(values),
                                             i * 1000,
                                             12345,
                                             54321,
                                             ""select * from xyz where id = ""+i,
                                             values)
                         : new FQLQuery.Batch(""abc""+i,
                                              3,
                                              QueryOptions.forInternalCalls(values),
                                              i * 1000,
                                              i * 54321,
                                              i * 12345,
                                              com.datastax.driver.core.BatchStatement.Type.UNLOGGED,
                                              Lists.newArrayList(""select * from aaaa""),
                                              Collections.singletonList(values));

            resultSets.add(Pair.create(q, results));
        }
        try (ResultHandler rh = new ResultHandler(targetHosts, resultPaths, queryDir))
        {
            for (int i = 0; i < resultSets.size(); i++)
                rh.handleResults(resultSets.get(i).left, resultSets.get(i).right);
        }

        for (int i = 0; i < targetHosts.size(); i++)
            compareWithFile(resultPaths, queryDir, resultSets, i);
    }
",non-flaky,5
99734,apache_cassandra,FQLReplayTest.testResultHandlerFailedQuery,"    @Test
    public void testResultHandlerFailedQuery() throws IOException
    {
        List<String> targetHosts = Lists.newArrayList(""hosta"", ""hostb"", ""hostc"", ""hostd"");
        File tmpDir = Files.createTempDirectory(""testresulthandler"").toFile();
        File queryDir = Files.createTempDirectory(""queries"").toFile();
        List<File> resultPaths = new ArrayList<>();
        targetHosts.forEach(host -> { File f = new File(tmpDir, host); f.mkdir(); resultPaths.add(f);});

        List<Pair<FQLQuery, List<ResultHandler.ComparableResultSet>>> resultSets = new ArrayList<>();
        Random random = new Random();
        for (int i = 0; i < 10; i++)
        {
            List<ResultHandler.ComparableResultSet> results = new ArrayList<>();
            List<ByteBuffer> values = Collections.singletonList(ByteBufferUtil.bytes(i * 50));
            for (int jj = 0; jj < targetHosts.size(); jj++)
            {
                results.add(createResultSet(5, 1 + random.nextInt(10), true));
            }
            results.set(0, StoredResultSet.failed(""testing abc""));
            results.set(3, StoredResultSet.failed(""testing abc""));
            FQLQuery q = new FQLQuery.Single(""abc""+i,
                                             3,
                                             QueryOptions.forInternalCalls(values),
                                             i * 1000,
                                             i * 12345,
                                             i * 54321,
                                             ""select * from xyz where id = ""+i,
                                             values);
            resultSets.add(Pair.create(q, results));
        }
        try (ResultHandler rh = new ResultHandler(targetHosts, resultPaths, queryDir))
        {
            for (int i = 0; i < resultSets.size(); i++)
                rh.handleResults(resultSets.get(i).left, resultSets.get(i).right);
        }
        for (int i = 0; i < targetHosts.size(); i++)
            compareWithFile(resultPaths, queryDir, resultSets, i);
    }
",non-flaky,5
99735,apache_cassandra,FQLReplayTest.testCompare,"    @Test
    public void testCompare()
    {
        FQLQuery q1 = new FQLQuery.Single(""abc"", 0, QueryOptions.DEFAULT, 123, 111, 222, ""aaaa"", Collections.emptyList());
        FQLQuery q2 = new FQLQuery.Single(""abc"", 0, QueryOptions.DEFAULT, 123, 111, 222,""aaaa"", Collections.emptyList());

        assertEquals(0, q1.compareTo(q2));
        assertEquals(0, q2.compareTo(q1));

        FQLQuery q3 = new FQLQuery.Batch(""abc"", 0, QueryOptions.DEFAULT, 123, 111, 222, com.datastax.driver.core.BatchStatement.Type.UNLOGGED, Collections.emptyList(), Collections.emptyList());
        // single queries before batch queries
        assertTrue(q1.compareTo(q3) < 0);
        assertTrue(q3.compareTo(q1) > 0);

        // check that smaller query time
        FQLQuery q4 = new FQLQuery.Single(""abc"", 0, QueryOptions.DEFAULT, 124, 111, 222, ""aaaa"", Collections.emptyList());
        assertTrue(q1.compareTo(q4) < 0);
        assertTrue(q4.compareTo(q1) > 0);

        FQLQuery q5 = new FQLQuery.Batch(""abc"", 0, QueryOptions.DEFAULT, 124, 111, 222, com.datastax.driver.core.BatchStatement.Type.UNLOGGED, Collections.emptyList(), Collections.emptyList());
        assertTrue(q1.compareTo(q5) < 0);
        assertTrue(q5.compareTo(q1) > 0);

        FQLQuery q6 = new FQLQuery.Single(""abc"", 0, QueryOptions.DEFAULT, 123, 111, 222, ""aaaa"", Collections.singletonList(ByteBufferUtil.bytes(10)));
        FQLQuery q7 = new FQLQuery.Single(""abc"", 0, QueryOptions.DEFAULT, 123, 111, 222, ""aaaa"", Collections.emptyList());
        assertTrue(q6.compareTo(q7) > 0);
        assertTrue(q7.compareTo(q6) < 0);

        FQLQuery q8 = new FQLQuery.Single(""abc"", 0, QueryOptions.DEFAULT, 123, 111, 222, ""aaaa"", Collections.singletonList(ByteBufferUtil.bytes(""a"")));
        FQLQuery q9 = new FQLQuery.Single(""abc"", 0, QueryOptions.DEFAULT, 123, 111, 222, ""aaaa"", Collections.singletonList(ByteBufferUtil.bytes(""b"")));
        assertTrue(q8.compareTo(q9) < 0);
        assertTrue(q9.compareTo(q8) > 0);
    }
",non-flaky,5
99736,apache_cassandra,FQLReplayTest.testFQLQuerySingleToStatement,"    @Test
    public void testFQLQuerySingleToStatement()
    {
        List<ByteBuffer> values = new ArrayList<>();
        for (int i = 0; i < 10; i++)
            values.add(ByteBufferUtil.bytes(i));
        FQLQuery.Single single = new FQLQuery.Single(""xyz"",
                                                     QueryOptions.DEFAULT.getProtocolVersion().asInt(),
                                                     QueryOptions.forInternalCalls(values),
                                                     1234,
                                                     12345,
                                                     54321,
                                                     ""select * from aaa"",
                                                     values);
        Statement stmt = single.toStatement();
        assertEquals(stmt.getDefaultTimestamp(), 12345);
        assertTrue(stmt instanceof SimpleStatement);
        SimpleStatement simpleStmt = (SimpleStatement)stmt;
        assertEquals(""select * from aaa"",simpleStmt.getQueryString(CodecRegistry.DEFAULT_INSTANCE));
        assertArrayEquals(values.toArray(), simpleStmt.getValues(com.datastax.driver.core.ProtocolVersion.fromInt(QueryOptions.DEFAULT.getProtocolVersion().asInt()), CodecRegistry.DEFAULT_INSTANCE));
    }
",non-flaky,5
99737,apache_cassandra,FQLReplayTest.testFQLQueryBatchToStatement,"    @Test
    public void testFQLQueryBatchToStatement()
    {
        List<List<ByteBuffer>> values = new ArrayList<>();
        List<String> queries = new ArrayList<>();
        for (int bqCount = 0; bqCount < 10; bqCount++)
        {
            queries.add(""select * from asdf where x = ? and y = "" + bqCount);
            List<ByteBuffer> queryValues = new ArrayList<>();
            for (int i = 0; i < 10; i++)
                queryValues.add(ByteBufferUtil.bytes(i + "":"" + bqCount));
            values.add(queryValues);
        }

        FQLQuery.Batch batch = new FQLQuery.Batch(""xyz"",
                                                   QueryOptions.DEFAULT.getProtocolVersion().asInt(),
                                                   QueryOptions.DEFAULT,
                                                   1234,
                                                   12345,
                                                   54321,
                                                   com.datastax.driver.core.BatchStatement.Type.UNLOGGED,
                                                   queries,
                                                   values);
        Statement stmt = batch.toStatement();
        assertEquals(stmt.getDefaultTimestamp(), 12345);
        assertTrue(stmt instanceof com.datastax.driver.core.BatchStatement);
        com.datastax.driver.core.BatchStatement batchStmt = (com.datastax.driver.core.BatchStatement)stmt;
        List<Statement> statements = Lists.newArrayList(batchStmt.getStatements());
        List<Statement> fromFQLQueries = batch.queries.stream().map(FQLQuery.Single::toStatement).collect(Collectors.toList());
        assertEquals(statements.size(), fromFQLQueries.size());
        assertEquals(12345, batchStmt.getDefaultTimestamp());
        for (int i = 0; i < statements.size(); i++)
            compareStatements(statements.get(i), fromFQLQueries.get(i));
    }
",non-flaky,5
99738,apache_cassandra,FQLReplayTest.testParser,"    @Test
    public void testParser() {
        QueryReplayer.ParsedTargetHost pth;
        pth = fromString(""127.0.0.1"");
        assertEquals(""127.0.0.1"", pth.host);
        assertEquals(9042, pth.port );
        assertNull(pth.user);
        assertNull(pth.password);

        pth = fromString(""127.0.0.1:3333"");
        assertEquals(""127.0.0.1"", pth.host);
        assertEquals(3333, pth.port );
        assertNull(pth.user);
        assertNull(pth.password);

        pth = fromString(""aaa:bbb@127.0.0.1:3333"");
        assertEquals(""127.0.0.1"", pth.host);
        assertEquals(3333, pth.port );
        assertEquals(""aaa"", pth.user);
        assertEquals(""bbb"", pth.password);

        pth = fromString(""aaa:bbb@127.0.0.1"");
        assertEquals(""127.0.0.1"", pth.host);
        assertEquals(9042, pth.port );
        assertEquals(""aaa"", pth.user);
        assertEquals(""bbb"", pth.password);
    }
",non-flaky,5
99739,apache_cassandra,FQLReplayTest.testNoPass,"    @Test(expected = RuntimeException.class)
    public void testNoPass()
    {
        fromString(""blabla@abc.com:1234"");
    }
",non-flaky,5
99740,apache_cassandra,FQLReplayTest.testBadPort,"    @Test(expected = RuntimeException.class)
    public void testBadPort()
    {
        fromString(""aaa:bbb@abc.com:xyz"");
    }
",non-flaky,5
99741,apache_cassandra,FQLReplayTest.writeMarshallablePayload,"    @Test (expected = IORuntimeException.class)
    public void testFutureVersion() throws Exception
    {
        FQLQueryReader reader = new FQLQueryReader();
        File dir = Files.createTempDirectory(""chronicle"").toFile();
        try (ChronicleQueue queue = ChronicleQueueBuilder.single(dir).build())
        {
            ExcerptAppender appender = queue.acquireAppender();
            appender.writeDocument(new BinLog.ReleaseableWriteMarshallable() {
                protected long version()
                {
                    return 999;
                }

                protected String type()
                {
                    return FullQueryLogger.SINGLE_QUERY;
                }

                public void writeMarshallablePayload(WireOut wire)
                {
                    wire.write(""future-field"").text(""future_value"");
                }
",non-flaky,5
99742,apache_cassandra,FQLReplayTest.writeMarshallablePayload,"    @Test (expected = IORuntimeException.class)
    public void testUnknownRecord() throws Exception
    {
        FQLQueryReader reader = new FQLQueryReader();
        File dir = Files.createTempDirectory(""chronicle"").toFile();
        try (ChronicleQueue queue = ChronicleQueueBuilder.single(dir).build())
        {
            ExcerptAppender appender = queue.acquireAppender();
            appender.writeDocument(new BinLog.ReleaseableWriteMarshallable() {
                protected long version()
                {
                    return FullQueryLogger.CURRENT_VERSION;
                }

                protected String type()
                {
                    return ""unknown-type"";
                }

                public void writeMarshallablePayload(WireOut wire)
                {
                    wire.write(""unknown-field"").text(""unknown_value"");
                }
",non-flaky,5
99743,apache_cassandra,FQLCompareTest.endToEnd,"    @Test
    public void endToEnd() throws IOException
    {
        List<String> targetHosts = Lists.newArrayList(""hosta"", ""hostb"");
        File tmpDir = Files.createTempDirectory(""testresulthandler"").toFile();
        File queryDir = Files.createTempDirectory(""queries"").toFile();
        List<File> resultPaths = generateResultSets(targetHosts, tmpDir, queryDir, true, false);
        Compare.compare(queryDir.toString(), resultPaths.stream().map(File::toString).collect(Collectors.toList()));
    }
",non-flaky,5
99744,apache_cassandra,FQLCompareTest.endToEndQueryFailures,"    @Test
    public void endToEndQueryFailures() throws IOException
    {
        List<String> targetHosts = Lists.newArrayList(""hosta"", ""hostb"");
        File tmpDir = Files.createTempDirectory(""testresulthandler"").toFile();
        File queryDir = Files.createTempDirectory(""queries"").toFile();
        List<File> resultPaths = generateResultSets(targetHosts, tmpDir, queryDir, true,true);
        Compare.compare(queryDir.toString(), resultPaths.stream().map(File::toString).collect(Collectors.toList()));
    }
",non-flaky,5
99745,apache_cassandra,FQLCompareTest.compareEqual,"    @Test
    public void compareEqual() throws IOException
    {
        List<String> targetHosts = Lists.newArrayList(""hosta"", ""hostb"");
        File tmpDir = Files.createTempDirectory(""testresulthandler"").toFile();
        File queryDir = Files.createTempDirectory(""queries"").toFile();
        List<File> resultPaths = generateResultSets(targetHosts, tmpDir, queryDir, false,false);

        ResultComparator comparator = new ResultComparator();
        List<ChronicleQueue> readQueues = null;
        try
        {
            readQueues = resultPaths.stream().map(s -> ChronicleQueueBuilder.single(s).readOnly(true).build()).collect(Collectors.toList());
            List<Iterator<ResultHandler.ComparableResultSet>> its = readQueues.stream().map(q -> new Compare.StoredResultSetIterator(q.createTailer())).collect(Collectors.toList());
            List<ResultHandler.ComparableResultSet> resultSets = Compare.resultSets(its);
            while(resultSets.stream().allMatch(Objects::nonNull))
            {
                assertTrue(comparator.compareColumnDefinitions(targetHosts, query(), resultSets.stream().map(ResultHandler.ComparableResultSet::getColumnDefinitions).collect(Collectors.toList())));
                List<Iterator<ResultHandler.ComparableRow>> rows = resultSets.stream().map(Iterable::iterator).collect(Collectors.toList());

                List<ResultHandler.ComparableRow> toCompare = ResultHandler.rows(rows);

                while (toCompare.stream().allMatch(Objects::nonNull))
                {
                    assertTrue(comparator.compareRows(targetHosts, query(), ResultHandler.rows(rows)));
                    toCompare = ResultHandler.rows(rows);
                }
                resultSets = Compare.resultSets(its);
            }
        }
        finally
        {
            if (readQueues != null)
                readQueues.forEach(Closeable::close);
        }
    }
",non-flaky,5
99746,apache_cassandra,AsyncStreamingInputPlusTest.isOpen,"//    @Test
//    public void isOpen()
//    {
//        Assert.assertTrue(inputPlus.isOpen());
//        inputPlus.requestClosure();
//        Assert.assertFalse(inputPlus.isOpen());
//    }
",non-flaky,5
99747,apache_cassandra,AsyncStreamingInputPlusTest.append_closed,"    @Test
    public void append_closed()
    {
        inputPlus = new AsyncStreamingInputPlus(channel);
        inputPlus.requestClosure();
        inputPlus.close();
        buf = channel.alloc().buffer(4);
        assertFalse(inputPlus.append(buf));
    }
",non-flaky,5
99748,apache_cassandra,AsyncStreamingInputPlusTest.append_normal,"    @Test
    public void append_normal()
    {
        inputPlus = new AsyncStreamingInputPlus(channel);
        int size = 4;
        buf = channel.alloc().buffer(size);
        buf.writerIndex(size);
        inputPlus.append(buf);
        Assert.assertEquals(buf.readableBytes(), inputPlus.unsafeAvailable());
    }
",non-flaky,5
99749,apache_cassandra,AsyncStreamingInputPlusTest.read,"    @Test
    public void read() throws IOException
    {
        inputPlus = new AsyncStreamingInputPlus(channel);
        // put two buffers of 8 bytes each into the queue.
        // then read an int, then a long. the latter tests offset into the inputPlus, as well as spanning across queued buffers.
        // the values of those int/long will both be '42', but spread across both queue buffers.
        ByteBuf buf = channel.alloc().buffer(8);
        buf.writeInt(42);
        buf.writerIndex(8);
        inputPlus.append(buf);
        buf = channel.alloc().buffer(8);
        buf.writeInt(42);
        buf.writerIndex(8);
        inputPlus.append(buf);
        Assert.assertEquals(16, inputPlus.unsafeAvailable());

//        ByteBuffer out = ByteBuffer.allocate(4);
//        int readCount = inputPlus.read(out);
//        Assert.assertEquals(4, readCount);
//        out.flip();
//        Assert.assertEquals(42, out.getInt());
//        Assert.assertEquals(12, inputPlus.unsafeAvailable());

//        out = ByteBuffer.allocate(8);
//        readCount = inputPlus.read(out);
//        Assert.assertEquals(8, readCount);
//        out.flip();
//        Assert.assertEquals(42, out.getLong());
//        Assert.assertEquals(4, inputPlus.unsafeAvailable());
    }
",non-flaky,5
99750,apache_cassandra,AsyncStreamingInputPlusTest.read_closed,"//    @Test (expected = EOFException.class)
//    public void read_closed() throws IOException
//    {
//        inputPlus.requestClosure();
//        ByteBuffer buf = ByteBuffer.allocate(1);
//        inputPlus.read(buf);
//    }
",non-flaky,5
99751,apache_cassandra,AsyncStreamingInputPlusTest.available_closed,"    @Test
    public void available_closed()
    {
        inputPlus = new AsyncStreamingInputPlus(channel);
        inputPlus.requestClosure();
        inputPlus.unsafeAvailable();
    }
",non-flaky,5
99752,apache_cassandra,AsyncStreamingInputPlusTest.available_HappyPath,"    @Test
    public void available_HappyPath()
    {
        inputPlus = new AsyncStreamingInputPlus(channel);
        int size = 4;
        buf = channel.alloc().heapBuffer(size);
        buf.writerIndex(size);
        inputPlus.append(buf);
        Assert.assertEquals(size, inputPlus.unsafeAvailable());
    }
",non-flaky,5
99753,apache_cassandra,AsyncStreamingInputPlusTest.available_ClosedButWithBytes,"    @Test
    public void available_ClosedButWithBytes()
    {
        inputPlus = new AsyncStreamingInputPlus(channel);
        int size = 4;
        buf = channel.alloc().heapBuffer(size);
        buf.writerIndex(size);
        inputPlus.append(buf);
        inputPlus.requestClosure();
        Assert.assertEquals(size, inputPlus.unsafeAvailable());
    }
",non-flaky,5
99754,apache_cassandra,AsyncStreamingInputPlusTest.consumeUntil_SingleBuffer_Partial_HappyPath,"    @Test
    public void consumeUntil_SingleBuffer_Partial_HappyPath() throws IOException
    {
        consumeUntilTestCycle(1, 8, 0, 4);
    }
",non-flaky,5
99755,apache_cassandra,AsyncStreamingInputPlusTest.consumeUntil_SingleBuffer_AllBytes_HappyPath,"    @Test
    public void consumeUntil_SingleBuffer_AllBytes_HappyPath() throws IOException
    {
        consumeUntilTestCycle(1, 8, 0, 8);
    }
",non-flaky,5
99756,apache_cassandra,AsyncStreamingInputPlusTest.consumeUntil_MultipleBufferr_Partial_HappyPath,"    @Test
    public void consumeUntil_MultipleBufferr_Partial_HappyPath() throws IOException
    {
        consumeUntilTestCycle(2, 8, 0, 13);
    }
",non-flaky,5
99757,apache_cassandra,AsyncStreamingInputPlusTest.consumeUntil_MultipleBuffer_AllBytes_HappyPath,"    @Test
    public void consumeUntil_MultipleBuffer_AllBytes_HappyPath() throws IOException
    {
        consumeUntilTestCycle(2, 8, 0, 16);
    }
",non-flaky,5
99758,apache_cassandra,AsyncStreamingInputPlusTest.consumeUntil_SingleBuffer_Fails,"    @Test(expected = EOFException.class)
    public void consumeUntil_SingleBuffer_Fails() throws IOException
    {
        consumeUntilTestCycle(1, 8, 0, 9);
    }
",non-flaky,5
99759,apache_cassandra,AsyncStreamingInputPlusTest.consumeUntil_MultipleBuffer_Fails,"    @Test(expected = EOFException.class)
    public void consumeUntil_MultipleBuffer_Fails() throws IOException
    {
        consumeUntilTestCycle(2, 8, 0, 17);
    }
",non-flaky,5
99760,apache_cassandra,AsyncStreamingInputPlusTest.rebufferTimeout,"    @Test
    public void rebufferTimeout() throws IOException
    {
        long timeoutMillis = 1000;
        inputPlus = new AsyncStreamingInputPlus(channel, timeoutMillis, TimeUnit.MILLISECONDS);

        long startNanos = System.nanoTime();
        try
        {
            inputPlus.readInt();
            Assert.fail(""should not have been able to read from the queue"");
        }
        catch (InputTimeoutException e)
        {
            // this is the success case, and is expected. any other exception is a failure.
        }

        long durationNanos = System.nanoTime() - startNanos;
        Assert.assertTrue(TimeUnit.MILLISECONDS.toNanos(timeoutMillis) <= durationNanos);
    }
",non-flaky,5
99761,apache_cassandra,RateBasedBackPressureTest.testAcceptsNoLessThanThreeArguments,"    @Test(expected = IllegalArgumentException.class)
    public void testAcceptsNoLessThanThreeArguments() throws Exception
    {
        new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, ""1""), new TestTimeSource(), 10);
    }
",non-flaky,5
99762,apache_cassandra,RateBasedBackPressureTest.testHighRatioMustBeBiggerThanZero,"    @Test(expected = IllegalArgumentException.class)
    public void testHighRatioMustBeBiggerThanZero() throws Exception
    {
        new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, ""0"", FACTOR, ""2"", FLOW, ""FAST""), new TestTimeSource(), 10);
    }
",non-flaky,5
99763,apache_cassandra,RateBasedBackPressureTest.testHighRatioMustBeSmallerEqualThanOne,"    @Test(expected = IllegalArgumentException.class)
    public void testHighRatioMustBeSmallerEqualThanOne() throws Exception
    {
        new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, ""2"", FACTOR, ""2"", FLOW, ""FAST""), new TestTimeSource(), 10);
    }
",non-flaky,5
99764,apache_cassandra,RateBasedBackPressureTest.testFactorMustBeBiggerEqualThanOne,"    @Test(expected = IllegalArgumentException.class)
    public void testFactorMustBeBiggerEqualThanOne() throws Exception
    {
        new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, ""0.9"", FACTOR, ""0"", FLOW, ""FAST""), new TestTimeSource(), 10);
    }
",non-flaky,5
99765,apache_cassandra,RateBasedBackPressureTest.testWindowSizeMustBeBiggerEqualThanTen,"    @Test(expected = IllegalArgumentException.class)
    public void testWindowSizeMustBeBiggerEqualThanTen() throws Exception
    {
        new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, ""0.9"", FACTOR, ""5"", FLOW, ""FAST""), new TestTimeSource(), 1);
    }
",non-flaky,5
99766,apache_cassandra,RateBasedBackPressureTest.testFlowMustBeEitherFASTorSLOW,"    @Test
    public void testFlowMustBeEitherFASTorSLOW() throws Exception
    {
        new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, ""0.9"", FACTOR, ""1"", FLOW, ""FAST""), new TestTimeSource(), 10);
        new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, ""0.9"", FACTOR, ""1"", FLOW, ""SLOW""), new TestTimeSource(), 10);
        try
        {
            new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, ""0.9"", FACTOR, ""1"", FLOW, ""WRONG""), new TestTimeSource(), 10);
            fail(""Expected to fail with wrong flow type."");
        }
        catch (Exception ex)
        {
        }
    }
",non-flaky,5
99767,apache_cassandra,RateBasedBackPressureTest.testBackPressureStateUpdates,"    @Test
    public void testBackPressureStateUpdates()
    {
        long windowSize = 6000;
        TestTimeSource timeSource = new TestTimeSource();
        RateBasedBackPressure strategy = new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, ""0.9"", FACTOR, ""10"", FLOW, ""FAST""), timeSource, windowSize);

        RateBasedBackPressureState state = strategy.newState(InetAddressAndPort.getLoopbackAddress());
        state.onMessageSent(null);
        assertEquals(0, state.incomingRate.size());
        assertEquals(0, state.outgoingRate.size());

        state = strategy.newState(InetAddressAndPort.getLoopbackAddress());
        state.onResponseReceived();
        assertEquals(1, state.incomingRate.size());
        assertEquals(1, state.outgoingRate.size());

        state = strategy.newState(InetAddressAndPort.getLoopbackAddress());
        state.onResponseTimeout();
        assertEquals(0, state.incomingRate.size());
        assertEquals(1, state.outgoingRate.size());
    }
",non-flaky,5
99768,apache_cassandra,RateBasedBackPressureTest.testBackPressureIsNotUpdatedBeyondInfinity,"    @Test
    public void testBackPressureIsNotUpdatedBeyondInfinity() throws Exception
    {
        long windowSize = 6000;
        TestTimeSource timeSource = new TestTimeSource();
        RateBasedBackPressure strategy = new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, ""0.9"", FACTOR, ""10"", FLOW, ""FAST""), timeSource, windowSize);
        RateBasedBackPressureState state = strategy.newState(InetAddressAndPort.getLoopbackAddress());

        // Get initial rate:
        double initialRate = state.rateLimiter.getRate();
        assertEquals(Double.POSITIVE_INFINITY, initialRate, 0.0);

        // Update incoming and outgoing rate equally:
        state.incomingRate.update(1);
        state.outgoingRate.update(1);

        // Move time ahead:
        timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);

        // Verify the rate doesn't change because already at infinity:
        strategy.apply(Sets.newHashSet(state), 1, TimeUnit.SECONDS);
        assertEquals(initialRate, state.rateLimiter.getRate(), 0.0);
    }
",non-flaky,5
99769,apache_cassandra,RateBasedBackPressureTest.testBackPressureIsUpdatedOncePerWindowSize,"    @Test
    public void testBackPressureIsUpdatedOncePerWindowSize() throws Exception
    {
        long windowSize = 6000;
        TestTimeSource timeSource = new TestTimeSource();
        RateBasedBackPressure strategy = new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, ""0.9"", FACTOR, ""10"", FLOW, ""FAST""), timeSource, windowSize);
        RateBasedBackPressureState state = strategy.newState(InetAddressAndPort.getLoopbackAddress());

        // Get initial time:
        long current = state.getLastIntervalAcquire();
        assertEquals(0, current);

        // Update incoming and outgoing rate:
        state.incomingRate.update(1);
        state.outgoingRate.update(1);

        // Move time ahead by window size:
        timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);

        // Verify the timestamp changed:
        strategy.apply(Sets.newHashSet(state), 1, TimeUnit.SECONDS);
        current = state.getLastIntervalAcquire();
        assertEquals(timeSource.currentTimeMillis(), current);

        // Move time ahead by less than interval:
        long previous = current;
        timeSource.sleep(windowSize / 2, TimeUnit.MILLISECONDS);

        // Verify the last timestamp didn't change because below the window size:
        strategy.apply(Sets.newHashSet(state), 1, TimeUnit.SECONDS);
        current = state.getLastIntervalAcquire();
        assertEquals(previous, current);
    }
",non-flaky,5
99770,apache_cassandra,RateBasedBackPressureTest.testBackPressureWhenBelowHighRatio,"    @Test
    public void testBackPressureWhenBelowHighRatio() throws Exception
    {
        long windowSize = 6000;
        TestTimeSource timeSource = new TestTimeSource();
        RateBasedBackPressure strategy = new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, ""0.9"", FACTOR, ""10"", FLOW, ""FAST""), timeSource, windowSize);
        RateBasedBackPressureState state = strategy.newState(InetAddressAndPort.getLoopbackAddress());

        // Update incoming and outgoing rate so that the ratio is 0.5:
        state.incomingRate.update(50);
        state.outgoingRate.update(100);

        // Move time ahead:
        timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);

        // Verify the rate is decreased by factor:
        strategy.apply(Sets.newHashSet(state), 1, TimeUnit.SECONDS);
        assertEquals(7.4, state.rateLimiter.getRate(), 0.1);
    }
",non-flaky,5
99771,apache_cassandra,RateBasedBackPressureTest.testBackPressureRateLimiterIsIncreasedAfterGoingAgainAboveHighRatio,"    @Test
    public void testBackPressureRateLimiterIsIncreasedAfterGoingAgainAboveHighRatio() throws Exception
    {
        long windowSize = 6000;
        TestTimeSource timeSource = new TestTimeSource();
        RateBasedBackPressure strategy = new RateBasedBackPressure(ImmutableMap.of(HIGH_RATIO, ""0.9"", FACTOR, ""10"", FLOW, ""FAST""), timeSource, windowSize);
        RateBasedBackPressureState state = strategy.newState(InetAddressAndPort.getLoopbackAddress());

        // Update incoming and outgoing rate so that the ratio is 0.5:
        state.incomingRate.update(50);
        state.outgoingRate.update(100);

        // Move time ahead:
        timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);

        // Verify the rate decreased:
        strategy.apply(Sets.newHashSet(state), 1, TimeUnit.SECONDS);
        assertEquals(7.4, state.rateLimiter.getRate(), 0.1);

        // Update incoming and outgoing rate back above high rate:
        state.incomingRate.update(50);
        state.outgoingRate.update(50);

        // Move time ahead:
        timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);

        // Verify rate limiter is increased by factor:
        strategy.apply(Sets.newHashSet(state), 1, TimeUnit.SECONDS);
        assertEquals(8.25, state.rateLimiter.getRate(), 0.1);

        // Update incoming and outgoing rate to keep it below the limiter rate:
        state.incomingRate.update(1);
        state.outgoingRate.update(1);

        // Move time ahead:
        timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);

        // Verify rate limiter is not increased as already higher than the actual rate:
        strategy.apply(Sets.newHashSet(state), 1, TimeUnit.SECONDS);
        assertEquals(8.25, state.rateLimiter.getRate(), 0.1);
    }
",non-flaky,5
99772,apache_cassandra,RateBasedBackPressureTest.testBackPressureFastFlow,"    @Test
    public void testBackPressureFastFlow() throws Exception
    {
        long windowSize = 6000;
        TestTimeSource timeSource = new TestTimeSource();
        TestableBackPressure strategy = new TestableBackPressure(ImmutableMap.of(HIGH_RATIO, ""0.9"", FACTOR, ""10"", FLOW, ""FAST""), timeSource, windowSize);
        RateBasedBackPressureState state1 = strategy.newState(InetAddressAndPort.getByName(""127.0.0.1""));
        RateBasedBackPressureState state2 = strategy.newState(InetAddressAndPort.getByName(""127.0.0.2""));
        RateBasedBackPressureState state3 = strategy.newState(InetAddressAndPort.getByName(""127.0.0.3""));

        // Update incoming and outgoing rates:
        state1.incomingRate.update(50);
        state1.outgoingRate.update(100);
        state2.incomingRate.update(80); // fast
        state2.outgoingRate.update(100);
        state3.incomingRate.update(20);
        state3.outgoingRate.update(100);

        // Move time ahead:
        timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);

        // Verify the fast replica rate limiting has been applied:
        Set<RateBasedBackPressureState> replicaGroup = Sets.newHashSet(state1, state2, state3);
        strategy.apply(replicaGroup, 1, TimeUnit.SECONDS);
        assertTrue(strategy.checkAcquired());
        assertTrue(strategy.checkApplied());
        assertEquals(12.0, strategy.getRateLimiterForReplicaGroup(replicaGroup).getRate(), 0.1);
    }
",non-flaky,5
99773,apache_cassandra,RateBasedBackPressureTest.testBackPressureSlowFlow,"    @Test
    public void testBackPressureSlowFlow() throws Exception
    {
        long windowSize = 6000;
        TestTimeSource timeSource = new TestTimeSource();
        TestableBackPressure strategy = new TestableBackPressure(ImmutableMap.of(HIGH_RATIO, ""0.9"", FACTOR, ""10"", FLOW, ""SLOW""), timeSource, windowSize);
        RateBasedBackPressureState state1 = strategy.newState(InetAddressAndPort.getByName(""127.0.0.1""));
        RateBasedBackPressureState state2 = strategy.newState(InetAddressAndPort.getByName(""127.0.0.2""));
        RateBasedBackPressureState state3 = strategy.newState(InetAddressAndPort.getByName(""127.0.0.3""));

        // Update incoming and outgoing rates:
        state1.incomingRate.update(50);
        state1.outgoingRate.update(100);
        state2.incomingRate.update(100);
        state2.outgoingRate.update(100);
        state3.incomingRate.update(20); // slow
        state3.outgoingRate.update(100);

        // Move time ahead:
        timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);

        // Verify the slow replica rate limiting has been applied:
        Set<RateBasedBackPressureState> replicaGroup = Sets.newHashSet(state1, state2, state3);
        strategy.apply(replicaGroup, 1, TimeUnit.SECONDS);
        assertTrue(strategy.checkAcquired());
        assertTrue(strategy.checkApplied());
        assertEquals(3.0, strategy.getRateLimiterForReplicaGroup(replicaGroup).getRate(), 0.1);
    }
",non-flaky,5
99774,apache_cassandra,RateBasedBackPressureTest.testBackPressureWithDifferentGroups,"    @Test
    public void testBackPressureWithDifferentGroups() throws Exception
    {
        long windowSize = 6000;
        TestTimeSource timeSource = new TestTimeSource();
        TestableBackPressure strategy = new TestableBackPressure(ImmutableMap.of(HIGH_RATIO, ""0.9"", FACTOR, ""10"", FLOW, ""SLOW""), timeSource, windowSize);
        RateBasedBackPressureState state1 = strategy.newState(InetAddressAndPort.getByName(""127.0.0.1""));
        RateBasedBackPressureState state2 = strategy.newState(InetAddressAndPort.getByName(""127.0.0.2""));
        RateBasedBackPressureState state3 = strategy.newState(InetAddressAndPort.getByName(""127.0.0.3""));
        RateBasedBackPressureState state4 = strategy.newState(InetAddressAndPort.getByName(""127.0.0.4""));

        // Update incoming and outgoing rates:
        state1.incomingRate.update(50); // this
        state1.outgoingRate.update(100);
        state2.incomingRate.update(100);
        state2.outgoingRate.update(100);
        state3.incomingRate.update(20); // this
        state3.outgoingRate.update(100);
        state4.incomingRate.update(80);
        state4.outgoingRate.update(100);

        // Move time ahead:
        timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);

        // Verify the first group:
        Set<RateBasedBackPressureState> replicaGroup = Sets.newHashSet(state1, state2);
        strategy.apply(replicaGroup, 1, TimeUnit.SECONDS);
        assertTrue(strategy.checkAcquired());
        assertTrue(strategy.checkApplied());
        assertEquals(7.4, strategy.getRateLimiterForReplicaGroup(replicaGroup).getRate(), 0.1);

        // Verify the second group:
        replicaGroup = Sets.newHashSet(state3, state4);
        strategy.apply(replicaGroup, 1, TimeUnit.SECONDS);
        assertTrue(strategy.checkAcquired());
        assertTrue(strategy.checkApplied());
        assertEquals(3.0, strategy.getRateLimiterForReplicaGroup(replicaGroup).getRate(), 0.1);
    }
",non-flaky,5
99775,apache_cassandra,RateBasedBackPressureTest.testBackPressurePastTimeout,"    @Test
    public void testBackPressurePastTimeout() throws Exception
    {
        long windowSize = 10000;
        TestTimeSource timeSource = new TestTimeSource();
        TestableBackPressure strategy = new TestableBackPressure(ImmutableMap.of(HIGH_RATIO, ""0.9"", FACTOR, ""10"", FLOW, ""SLOW""), timeSource, windowSize);
        RateBasedBackPressureState state1 = strategy.newState(InetAddressAndPort.getByName(""127.0.0.1""));
        RateBasedBackPressureState state2 = strategy.newState(InetAddressAndPort.getByName(""127.0.0.2""));
        RateBasedBackPressureState state3 = strategy.newState(InetAddressAndPort.getByName(""127.0.0.3""));

        // Update incoming and outgoing rates:
        state1.incomingRate.update(5); // slow
        state1.outgoingRate.update(100);
        state2.incomingRate.update(100);
        state2.outgoingRate.update(100);
        state3.incomingRate.update(100);
        state3.outgoingRate.update(100);

        // Move time ahead:
        timeSource.sleep(windowSize, TimeUnit.MILLISECONDS);

        // Verify the slow replica rate limiting has been applied:
        Set<RateBasedBackPressureState> replicaGroup = Sets.newHashSet(state1, state2, state3);
        strategy.apply(replicaGroup, 4, TimeUnit.SECONDS);
        assertTrue(strategy.checkAcquired());
        assertTrue(strategy.checkApplied());
        assertEquals(0.5, strategy.getRateLimiterForReplicaGroup(replicaGroup).getRate(), 0.1);

        // Make one more apply call to saturate the rate limit timeout (0.5 requests per second means 2 requests span
        // 4 seconds, but we can only make one as we have to subtract the incoming response time):
        strategy.apply(replicaGroup, 4, TimeUnit.SECONDS);

        // Now verify another call to apply doesn't acquire the rate limit because of the max timeout of 4 seconds minus
        // 2 seconds of response time, so the time source itself sleeps two second:
        long start = timeSource.currentTimeMillis();
        strategy.apply(replicaGroup, 4, TimeUnit.SECONDS);
        assertFalse(strategy.checkAcquired());
        assertTrue(strategy.checkApplied());
        assertEquals(TimeUnit.NANOSECONDS.convert(2, TimeUnit.SECONDS),
                     strategy.timeout);
        assertEquals(strategy.timeout,
                     TimeUnit.NANOSECONDS.convert(timeSource.currentTimeMillis() - start, TimeUnit.MILLISECONDS));
    }
",non-flaky,5
99776,apache_cassandra,MessagingServiceTest.testDroppedMessages,"    @Test
    public void testDroppedMessages()
    {
        Verb verb = Verb.READ_REQ;

        for (int i = 1; i <= 5000; i++)
            messagingService.metrics.recordDroppedMessage(verb, i, MILLISECONDS, i % 2 == 0);

        List<String> logs = new ArrayList<>();
        messagingService.metrics.resetAndConsumeDroppedErrors(logs::add);
        assertEquals(1, logs.size());
        Pattern regexp = Pattern.compile(""READ_REQ messages were dropped in last 5000 ms: (\\d+) internal and (\\d+) cross node. Mean internal dropped latency: (\\d+) ms and Mean cross-node dropped latency: (\\d+) ms"");
        Matcher matcher = regexp.matcher(logs.get(0));
        assertTrue(matcher.find());
        assertEquals(2500, Integer.parseInt(matcher.group(1)));
        assertEquals(2500, Integer.parseInt(matcher.group(2)));
        assertTrue(Integer.parseInt(matcher.group(3)) > 0);
        assertTrue(Integer.parseInt(matcher.group(4)) > 0);
        assertEquals(5000, (int) messagingService.metrics.getDroppedMessages().get(verb.toString()));

        logs.clear();
        messagingService.metrics.resetAndConsumeDroppedErrors(logs::add);
        assertEquals(0, logs.size());

        for (int i = 0; i < 2500; i++)
            messagingService.metrics.recordDroppedMessage(verb, i, MILLISECONDS, i % 2 == 0);

        logs.clear();
        messagingService.metrics.resetAndConsumeDroppedErrors(logs::add);
        assertEquals(1, logs.size());
        matcher = regexp.matcher(logs.get(0));
        assertTrue(matcher.find());
        assertEquals(1250, Integer.parseInt(matcher.group(1)));
        assertEquals(1250, Integer.parseInt(matcher.group(2)));
        assertTrue(Integer.parseInt(matcher.group(3)) > 0);
        assertTrue(Integer.parseInt(matcher.group(4)) > 0);
        assertEquals(7500, (int) messagingService.metrics.getDroppedMessages().get(verb.toString()));
    }
",non-flaky,5
99777,apache_cassandra,MessagingServiceTest.testDCLatency,"    @Test
    public void testDCLatency() throws Exception
    {
        int latency = 100;
        ConcurrentHashMap<String, MessagingMetrics.DCLatencyRecorder> dcLatency = MessagingService.instance().metrics.dcLatency;
        dcLatency.clear();

        long now = System.currentTimeMillis();
        long sentAt = now - latency;
        assertNull(dcLatency.get(""datacenter1""));
        addDCLatency(sentAt, now);
        assertNotNull(dcLatency.get(""datacenter1""));
        assertEquals(1, dcLatency.get(""datacenter1"").dcLatency.getCount());
        long expectedBucket = bucketOffsets[Math.abs(Arrays.binarySearch(bucketOffsets, MILLISECONDS.toNanos(latency))) - 1];
        assertEquals(expectedBucket, dcLatency.get(""datacenter1"").dcLatency.getSnapshot().getMax());
    }
",non-flaky,5
99778,apache_cassandra,MessagingServiceTest.testNegativeDCLatency,"    @Test
    public void testNegativeDCLatency()
    {
        MessagingMetrics.DCLatencyRecorder updater = MessagingService.instance().metrics.internodeLatencyRecorder(InetAddressAndPort.getLocalHost());

        // if clocks are off should just not track anything
        int latency = -100;

        long now = System.currentTimeMillis();
        long sentAt = now - latency;

        long count = updater.dcLatency.getCount();
        updater.accept(now - sentAt, MILLISECONDS);
        // negative value shoudln't be recorded
        assertEquals(count, updater.dcLatency.getCount());
    }
",non-flaky,5
99779,apache_cassandra,MessagingServiceTest.testQueueWaitLatency,"    @Test
    public void testQueueWaitLatency()
    {
        int latency = 100;
        Verb verb = Verb.MUTATION_REQ;

        Map<Verb, Timer> queueWaitLatency = MessagingService.instance().metrics.internalLatency;
        MessagingService.instance().metrics.recordInternalLatency(verb, latency, MILLISECONDS);
        assertEquals(1, queueWaitLatency.get(verb).getCount());
        long expectedBucket = bucketOffsets[Math.abs(Arrays.binarySearch(bucketOffsets, MILLISECONDS.toNanos(latency))) - 1];
        assertEquals(expectedBucket, queueWaitLatency.get(verb).getSnapshot().getMax());
    }
",non-flaky,5
99780,apache_cassandra,MessagingServiceTest.testNegativeQueueWaitLatency,"    @Test
    public void testNegativeQueueWaitLatency() throws Exception
    {
        int latency = -100;
        Verb verb = Verb.MUTATION_REQ;

        Map<Verb, Timer> queueWaitLatency = MessagingService.instance().metrics.internalLatency;
        queueWaitLatency.clear();

        assertNull(queueWaitLatency.get(verb));
        MessagingService.instance().metrics.recordInternalLatency(verb, latency, MILLISECONDS);
        assertNull(queueWaitLatency.get(verb));
    }
",non-flaky,5
99781,apache_cassandra,MessagingServiceTest.testUpdatesBackPressureOnSendWhenEnabledAndWithSupportedCallback,"    @Test
    public void testUpdatesBackPressureOnSendWhenEnabledAndWithSupportedCallback() throws UnknownHostException
    {
        MockBackPressureStrategy.MockBackPressureState backPressureState = (MockBackPressureStrategy.MockBackPressureState) messagingService.getBackPressureState(InetAddressAndPort.getByName(""127.0.0.2""));
        RequestCallback bpCallback = new BackPressureCallback();
        RequestCallback noCallback = new NoBackPressureCallback();
        Message<?> ignored = null;

        DatabaseDescriptor.setBackPressureEnabled(true);
        messagingService.updateBackPressureOnSend(InetAddressAndPort.getByName(""127.0.0.2""), noCallback, ignored);
        assertFalse(backPressureState.onSend);

        DatabaseDescriptor.setBackPressureEnabled(false);
        messagingService.updateBackPressureOnSend(InetAddressAndPort.getByName(""127.0.0.2""), bpCallback, ignored);
        assertFalse(backPressureState.onSend);

        DatabaseDescriptor.setBackPressureEnabled(true);
        messagingService.updateBackPressureOnSend(InetAddressAndPort.getByName(""127.0.0.2""), bpCallback, ignored);
        assertTrue(backPressureState.onSend);
    }
",non-flaky,5
99782,apache_cassandra,MessagingServiceTest.testUpdatesBackPressureOnReceiveWhenEnabledAndWithSupportedCallback,"    @Test
    public void testUpdatesBackPressureOnReceiveWhenEnabledAndWithSupportedCallback() throws UnknownHostException
    {
        MockBackPressureStrategy.MockBackPressureState backPressureState = (MockBackPressureStrategy.MockBackPressureState) messagingService.getBackPressureState(InetAddressAndPort.getByName(""127.0.0.2""));
        RequestCallback bpCallback = new BackPressureCallback();
        RequestCallback noCallback = new NoBackPressureCallback();
        boolean timeout = false;

        DatabaseDescriptor.setBackPressureEnabled(true);
        messagingService.updateBackPressureOnReceive(InetAddressAndPort.getByName(""127.0.0.2""), noCallback, timeout);
        assertFalse(backPressureState.onReceive);
        assertFalse(backPressureState.onTimeout);

        DatabaseDescriptor.setBackPressureEnabled(false);
        messagingService.updateBackPressureOnReceive(InetAddressAndPort.getByName(""127.0.0.2""), bpCallback, timeout);
        assertFalse(backPressureState.onReceive);
        assertFalse(backPressureState.onTimeout);

        DatabaseDescriptor.setBackPressureEnabled(true);
        messagingService.updateBackPressureOnReceive(InetAddressAndPort.getByName(""127.0.0.2""), bpCallback, timeout);
        assertTrue(backPressureState.onReceive);
        assertFalse(backPressureState.onTimeout);
    }
",non-flaky,5
99783,apache_cassandra,MessagingServiceTest.testUpdatesBackPressureOnTimeoutWhenEnabledAndWithSupportedCallback,"    @Test
    public void testUpdatesBackPressureOnTimeoutWhenEnabledAndWithSupportedCallback() throws UnknownHostException
    {
        MockBackPressureStrategy.MockBackPressureState backPressureState = (MockBackPressureStrategy.MockBackPressureState) messagingService.getBackPressureState(InetAddressAndPort.getByName(""127.0.0.2""));
        RequestCallback bpCallback = new BackPressureCallback();
        RequestCallback noCallback = new NoBackPressureCallback();
        boolean timeout = true;

        DatabaseDescriptor.setBackPressureEnabled(true);
        messagingService.updateBackPressureOnReceive(InetAddressAndPort.getByName(""127.0.0.2""), noCallback, timeout);
        assertFalse(backPressureState.onReceive);
        assertFalse(backPressureState.onTimeout);

        DatabaseDescriptor.setBackPressureEnabled(false);
        messagingService.updateBackPressureOnReceive(InetAddressAndPort.getByName(""127.0.0.2""), bpCallback, timeout);
        assertFalse(backPressureState.onReceive);
        assertFalse(backPressureState.onTimeout);

        DatabaseDescriptor.setBackPressureEnabled(true);
        messagingService.updateBackPressureOnReceive(InetAddressAndPort.getByName(""127.0.0.2""), bpCallback, timeout);
        assertFalse(backPressureState.onReceive);
        assertTrue(backPressureState.onTimeout);
    }
",non-flaky,5
99784,apache_cassandra,MessagingServiceTest.testAppliesBackPressureWhenEnabled,"    @Test
    public void testAppliesBackPressureWhenEnabled() throws UnknownHostException
    {
        DatabaseDescriptor.setBackPressureEnabled(false);
        messagingService.applyBackPressure(Arrays.asList(InetAddressAndPort.getByName(""127.0.0.2"")), ONE_SECOND);
        assertFalse(MockBackPressureStrategy.applied);

        DatabaseDescriptor.setBackPressureEnabled(true);
        messagingService.applyBackPressure(Arrays.asList(InetAddressAndPort.getByName(""127.0.0.2"")), ONE_SECOND);
        assertTrue(MockBackPressureStrategy.applied);
    }
",non-flaky,5
99785,apache_cassandra,MessagingServiceTest.testDoesntApplyBackPressureToBroadcastAddress,"    @Test
    public void testDoesntApplyBackPressureToBroadcastAddress() throws UnknownHostException
    {
        DatabaseDescriptor.setBackPressureEnabled(true);
        messagingService.applyBackPressure(Arrays.asList(InetAddressAndPort.getByName(""127.0.0.1"")), ONE_SECOND);
        assertFalse(MockBackPressureStrategy.applied);
    }
",non-flaky,5
99786,apache_cassandra,MessagingServiceTest.testFailedInternodeAuth,"    @Test
    public void testFailedInternodeAuth() throws Exception
    {
        MessagingService ms = MessagingService.instance();
        DatabaseDescriptor.setInternodeAuthenticator(ALLOW_NOTHING_AUTHENTICATOR);
        InetAddressAndPort address = InetAddressAndPort.getByName(""127.0.0.250"");

        //Should return null
        Message messageOut = Message.out(Verb.ECHO_REQ, NoPayload.noPayload);
        assertFalse(ms.isConnected(address, messageOut));

        //Should tolerate null
        ms.closeOutbound(address);
        ms.send(messageOut, address);
    }
",non-flaky,5
99787,apache_cassandra,MessagingServiceTest.reconnectWithNewIp,"//    @Test
//    public void reconnectWithNewIp() throws Exception
//    {
//        InetAddressAndPort publicIp = InetAddressAndPort.getByName(""127.0.0.2"");
//        InetAddressAndPort privateIp = InetAddressAndPort.getByName(""127.0.0.3"");
//
//        // reset the preferred IP value, for good test hygene
//        SystemKeyspace.updatePreferredIP(publicIp, publicIp);
//
//        // create pool/conn with public addr
//        Assert.assertEquals(publicIp, messagingService.getCurrentEndpoint(publicIp));
//        messagingService.maybeReconnectWithNewIp(publicIp, privateIp).await(1L, TimeUnit.SECONDS);
//        Assert.assertEquals(privateIp, messagingService.getCurrentEndpoint(publicIp));
//
//        messagingService.closeOutbound(publicIp);
//
//        // recreate the pool/conn, and make sure the preferred ip addr is used
//        Assert.assertEquals(privateIp, messagingService.getCurrentEndpoint(publicIp));
//    }
",non-flaky,5
99788,apache_cassandra,MessagingServiceTest.listenPlainConnection,"    @Test
    public void listenPlainConnection() throws InterruptedException
    {
        ServerEncryptionOptions serverEncryptionOptions = new ServerEncryptionOptions()
                                                          .withInternodeEncryption(ServerEncryptionOptions.InternodeEncryption.none);
        listen(serverEncryptionOptions, false);
    }
",non-flaky,5
99789,apache_cassandra,MessagingServiceTest.listenPlainConnectionWithBroadcastAddr,"    @Test
    public void listenPlainConnectionWithBroadcastAddr() throws InterruptedException
    {
        ServerEncryptionOptions serverEncryptionOptions = new ServerEncryptionOptions()
                                                          .withInternodeEncryption(ServerEncryptionOptions.InternodeEncryption.none);
        listen(serverEncryptionOptions, true);
    }
",non-flaky,5
99790,apache_cassandra,MessagingServiceTest.listenRequiredSecureConnection,"    @Test
    public void listenRequiredSecureConnection() throws InterruptedException
    {
        ServerEncryptionOptions serverEncryptionOptions = new ServerEncryptionOptions()
                                                          .withOptional(false)
                                                          .withInternodeEncryption(ServerEncryptionOptions.InternodeEncryption.all)
                                                          .withLegacySslStoragePort(false);
        listen(serverEncryptionOptions, false);
    }
",non-flaky,5
99791,apache_cassandra,MessagingServiceTest.listenRequiredSecureConnectionWithBroadcastAddr,"    @Test
    public void listenRequiredSecureConnectionWithBroadcastAddr() throws InterruptedException
    {
        ServerEncryptionOptions serverEncryptionOptions = new ServerEncryptionOptions()
                                                          .withOptional(false)
                                                          .withInternodeEncryption(ServerEncryptionOptions.InternodeEncryption.all)
                                                          .withLegacySslStoragePort(false);
        listen(serverEncryptionOptions, true);
    }
",non-flaky,5
99792,apache_cassandra,MessagingServiceTest.listenRequiredSecureConnectionWithLegacyPort,"    @Test
    public void listenRequiredSecureConnectionWithLegacyPort() throws InterruptedException
    {
        ServerEncryptionOptions serverEncryptionOptions = new ServerEncryptionOptions()
                                                          .withInternodeEncryption(ServerEncryptionOptions.InternodeEncryption.all)
                                                          .withOptional(false)
                                                          .withLegacySslStoragePort(true);
        listen(serverEncryptionOptions, false);
    }
",non-flaky,5
99793,apache_cassandra,MessagingServiceTest.listenRequiredSecureConnectionWithBroadcastAddrAndLegacyPort,"    @Test
    public void listenRequiredSecureConnectionWithBroadcastAddrAndLegacyPort() throws InterruptedException
    {
        ServerEncryptionOptions serverEncryptionOptions = new ServerEncryptionOptions()
                                                          .withInternodeEncryption(ServerEncryptionOptions.InternodeEncryption.all)
                                                          .withOptional(false)
                                                          .withLegacySslStoragePort(true);
        listen(serverEncryptionOptions, true);
    }
",non-flaky,5
99794,apache_cassandra,MessagingServiceTest.listenOptionalSecureConnection,"    @Test
    public void listenOptionalSecureConnection() throws InterruptedException
    {
        ServerEncryptionOptions serverEncryptionOptions = new ServerEncryptionOptions()
                                                          .withOptional(true);
        listen(serverEncryptionOptions, false);
    }
",non-flaky,5
99795,apache_cassandra,MessagingServiceTest.listenOptionalSecureConnectionWithBroadcastAddr,"    @Test
    public void listenOptionalSecureConnectionWithBroadcastAddr() throws InterruptedException
    {
        ServerEncryptionOptions serverEncryptionOptions = new ServerEncryptionOptions()
                                                          .withOptional(true);
        listen(serverEncryptionOptions, true);
    }
",non-flaky,5
99796,apache_cassandra,MessagingServiceTest.getPreferredRemoteAddrUsesPrivateIp,"//    @Test
//    public void getPreferredRemoteAddrUsesPrivateIp() throws UnknownHostException
//    {
//        MessagingService ms = MessagingService.instance();
//        InetAddressAndPort remote = InetAddressAndPort.getByNameOverrideDefaults(""127.0.0.151"", 7000);
//        InetAddressAndPort privateIp = InetAddressAndPort.getByName(""127.0.0.6"");
//
//        OutboundConnectionSettings template = new OutboundConnectionSettings(remote)
//                                              .withConnectTo(privateIp)
//                                              .withAuthenticator(ALLOW_NOTHING_AUTHENTICATOR);
//        OutboundConnections pool = new OutboundConnections(template, new MockBackPressureStrategy(null).newState(remote));
//        ms.channelManagers.put(remote, pool);
//
//        Assert.assertEquals(privateIp, ms.getPreferredRemoteAddr(remote));
//    }
",non-flaky,5
99797,apache_cassandra,MessagingServiceTest.getPreferredRemoteAddrUsesPreferredIp,"//    @Test
//    public void getPreferredRemoteAddrUsesPreferredIp() throws UnknownHostException
//    {
//        MessagingService ms = MessagingService.instance();
//        InetAddressAndPort remote = InetAddressAndPort.getByNameOverrideDefaults(""127.0.0.115"", 7000);
//
//        InetAddressAndPort preferredIp = InetAddressAndPort.getByName(""127.0.0.16"");
//        SystemKeyspace.updatePreferredIP(remote, preferredIp);
//
//        Assert.assertEquals(preferredIp, ms.getPreferredRemoteAddr(remote));
//    }
",non-flaky,5
99798,apache_cassandra,MessagingServiceTest.getPreferredRemoteAddrUsesPrivateIpOverridesPreferredIp,"//    @Test
//    public void getPreferredRemoteAddrUsesPrivateIpOverridesPreferredIp() throws UnknownHostException
//    {
//        MessagingService ms = MessagingService.instance();
//        InetAddressAndPort local = InetAddressAndPort.getByNameOverrideDefaults(""127.0.0.4"", 7000);
//        InetAddressAndPort remote = InetAddressAndPort.getByNameOverrideDefaults(""127.0.0.105"", 7000);
//        InetAddressAndPort privateIp = InetAddressAndPort.getByName(""127.0.0.6"");
//
//        OutboundConnectionSettings template = new OutboundConnectionSettings(remote)
//                                              .withConnectTo(privateIp)
//                                              .withAuthenticator(ALLOW_NOTHING_AUTHENTICATOR);
//
//        OutboundConnections pool = new OutboundConnections(template, new MockBackPressureStrategy(null).newState(remote));
//        ms.channelManagers.put(remote, pool);
//
//        InetAddressAndPort preferredIp = InetAddressAndPort.getByName(""127.0.0.16"");
//        SystemKeyspace.updatePreferredIP(remote, preferredIp);
//
//        Assert.assertEquals(privateIp, ms.getPreferredRemoteAddr(remote));
//    }
",non-flaky,5
99799,apache_cassandra,OutboundConnectionSettingsTest.build_SmallSendSize,"    @Test (expected = IllegalArgumentException.class)
    public void build_SmallSendSize()
    {
        test(settings -> settings.withSocketSendBufferSizeInBytes(999));
    }
",non-flaky,5
99800,apache_cassandra,OutboundConnectionSettingsTest.build_SendSizeLessThanZero,"    @Test (expected = IllegalArgumentException.class)
    public void build_SendSizeLessThanZero()
    {
        test(settings -> settings.withSocketSendBufferSizeInBytes(-1));
    }
",non-flaky,5
99801,apache_cassandra,OutboundConnectionSettingsTest.build_TcpConnectTimeoutLessThanZero,"    @Test (expected = IllegalArgumentException.class)
    public void build_TcpConnectTimeoutLessThanZero()
    {
        test(settings -> settings.withTcpConnectTimeoutInMS(-1));
    }
",non-flaky,5
110836,pushtorefresh_storio,GetObjectObserveChangesTest.repeatsOperationWithQueryByChangeOfTable,"    @Test
    public void repeatsOperationWithQueryByChangeOfTable() {
        User user = putUserBlocking();

        PreparedGetObject<User> operation = storIOSQLite
                .get()
                .object(User.class)
                .withQuery(query)
                .prepare();

        verifyChangesReceived(operation, tableChanges, user);
    }
",non-flaky,5
110837,pushtorefresh_storio,GetObjectObserveChangesTest.repeatsOperationWithRawQueryByChangeOfTable,"    @Test
    public void repeatsOperationWithRawQueryByChangeOfTable() {
        User user = putUserBlocking();

        PreparedGetObject<User> operation = storIOSQLite
                .get()
                .object(User.class)
                .withQuery(query)
                .prepare();

        verifyChangesReceived(operation, tableChanges, user);
    }
",non-flaky,5
110838,pushtorefresh_storio,GetObjectObserveChangesTest.repeatsOperationWithQueryByChangeOfTag,"    @Test
    public void repeatsOperationWithQueryByChangeOfTag() {
        User user = putUserBlocking();

        PreparedGetObject<User> operation = storIOSQLite
                .get()
                .object(User.class)
                .withQuery(query)
                .prepare();

        verifyChangesReceived(operation, tagChanges, user);
    }
",non-flaky,5
110839,pushtorefresh_storio,GetObjectObserveChangesTest.repeatsOperationWithRawQueryByChangeOfTag,"    @Test
    public void repeatsOperationWithRawQueryByChangeOfTag() {
        User user = putUserBlocking();

        PreparedGetObject<User> operation = storIOSQLite
                .get()
                .object(User.class)
                .withQuery(query)
                .prepare();

        verifyChangesReceived(operation, tagChanges, user);
    }
",non-flaky,5
110840,pushtorefresh_storio,GetListOfObjectsObserveChangesTest.repeatsOperationWithQueryByChangeOfTable,"    @Test
    public void repeatsOperationWithQueryByChangeOfTable() {
        User user = putUserBlocking();

        PreparedGetListOfObjects<User> operation = storIOSQLite
                .get()
                .listOfObjects(User.class)
                .withQuery(query)
                .prepare();

        verifyChangesReceived(operation, tableChanges, singletonList(user));
    }
",non-flaky,5
110841,pushtorefresh_storio,GetListOfObjectsObserveChangesTest.repeatsOperationWithRawQueryByChangeOfTable,"    @Test
    public void repeatsOperationWithRawQueryByChangeOfTable() {
        User user = putUserBlocking();

        PreparedGetListOfObjects<User> operation = storIOSQLite
                .get()
                .listOfObjects(User.class)
                .withQuery(rawQuery)
                .prepare();

        verifyChangesReceived(operation, tableChanges, singletonList(user));
    }
",non-flaky,5
110842,pushtorefresh_storio,GetListOfObjectsObserveChangesTest.repeatsOperationWithQueryByChangeOfTag,"    @Test
    public void repeatsOperationWithQueryByChangeOfTag() {
        User user = putUserBlocking();

        PreparedGetListOfObjects<User> operation = storIOSQLite
                .get()
                .listOfObjects(User.class)
                .withQuery(query)
                .prepare();

        verifyChangesReceived(operation, tagChanges, singletonList(user));
    }
",non-flaky,5
110843,pushtorefresh_storio,GetListOfObjectsObserveChangesTest.repeatsOperationWithRawQueryByChangeOfTag,"    @Test
    public void repeatsOperationWithRawQueryByChangeOfTag() {
        User user = putUserBlocking();

        PreparedGetListOfObjects<User> operation = storIOSQLite
                .get()
                .listOfObjects(User.class)
                .withQuery(rawQuery)
                .prepare();

        verifyChangesReceived(operation, tagChanges, singletonList(user));
    }
",non-flaky,5
110844,pushtorefresh_storio,ObserveChangesOfTagTest.insertEmission,"    @Test
    public void insertEmission() {
        final List<User> users = TestFactory.newUsers(10);

        final Queue<Changes> expectedChanges = new LinkedList<Changes>();
        expectedChanges.add(Changes.newInstance(UserTableMeta.TABLE, UserTableMeta.NOTIFICATION_TAG));

        final EmissionChecker emissionChecker = new EmissionChecker(expectedChanges);
        final Subscription subscription = emissionChecker.subscribe();

        putUsersBlocking(users);

        // Should receive changes of Users table
        emissionChecker.awaitNextExpectedValue();

        emissionChecker.assertThatNoExpectedValuesLeft();

        subscription.unsubscribe();
    }
",non-flaky,5
110845,pushtorefresh_storio,ObserveChangesOfTagTest.updateEmission,"    @Test
    public void updateEmission() {
        final List<User> users = putUsersBlocking(10);
        final List<User> updated = new ArrayList<User>(users.size());

        for (User user : users) {
            updated.add(User.newInstance(user.id(), user.email()));
        }

        final Queue<Changes> expectedChanges = new LinkedList<Changes>();
        expectedChanges.add(Changes.newInstance(UserTableMeta.TABLE, UserTableMeta.NOTIFICATION_TAG));

        final EmissionChecker emissionChecker = new EmissionChecker(expectedChanges);
        final Subscription subscription = emissionChecker.subscribe();

        storIOSQLite
                .put()
                .objects(updated)
                .prepare()
                .executeAsBlocking();

        // Should receive changes of Users table
        emissionChecker.awaitNextExpectedValue();

        emissionChecker.assertThatNoExpectedValuesLeft();

        subscription.unsubscribe();
    }
",non-flaky,5
110846,pushtorefresh_storio,ObserveChangesOfTagTest.deleteEmission,"    @Test
    public void deleteEmission() {
        final List<User> users = putUsersBlocking(10);

        final Queue<Changes> expectedChanges = new LinkedList<Changes>();
        expectedChanges.add(Changes.newInstance(UserTableMeta.TABLE, UserTableMeta.NOTIFICATION_TAG));

        final EmissionChecker emissionChecker = new EmissionChecker(expectedChanges);
        final Subscription subscription = emissionChecker.subscribe();

        deleteUsersBlocking(users);

        // Should receive changes of Users table
        emissionChecker.awaitNextExpectedValue();

        emissionChecker.assertThatNoExpectedValuesLeft();

        subscription.unsubscribe();
    }
",non-flaky,5
110847,pushtorefresh_storio,QueryTest.queryAll,"    @Test
    public void queryAll() {
        final List<User> users = putUsersBlocking(3);
        final List<User> usersFromQuery = getAllUsersBlocking();
        assertThat(users.equals(usersFromQuery)).isTrue();
    }
",non-flaky,5
110848,pushtorefresh_storio,QueryTest.queryOneByField,"    @Test
    public void queryOneByField() {
        final List<User> users = putUsersBlocking(3);

        for (User user : users) {
            final List<User> usersFromQuery = storIOSQLite
                    .get()
                    .listOfObjects(User.class)
                    .withQuery(Query.builder()
                            .table(UserTableMeta.TABLE)
                            .where(UserTableMeta.COLUMN_EMAIL + ""=?"")
                            .whereArgs(user.email())
                            .build())
                    .prepare()
                    .executeAsBlocking();

            assertThat(usersFromQuery).isNotNull();
            assertThat(usersFromQuery).hasSize(1);
            assertThat(usersFromQuery.get(0)).isEqualTo(user);
        }
    }
",non-flaky,5
110849,pushtorefresh_storio,QueryTest.queryOrdered,"    @Test
    public void queryOrdered() {
        final List<User> users = TestFactory.newUsers(3);

        // Reverse sorting by email before inserting, for the purity of the experiment.
        Collections.reverse(users);

        putUsersBlocking(users);

        final List<User> usersFromQueryOrdered = storIOSQLite
                .get()
                .listOfObjects(User.class)
                .withQuery(Query.builder()
                        .table(UserTableMeta.TABLE)
                        .orderBy(UserTableMeta.COLUMN_EMAIL)
                        .build())
                .prepare()
                .executeAsBlocking();

        assertThat(usersFromQueryOrdered).isNotNull();
        assertThat(usersFromQueryOrdered).hasSize(users.size());

        // Sorting by email for check ordering.
        Collections.sort(users);

        for (int i = 0; i < users.size(); i++) {
            assertThat(usersFromQueryOrdered.get(i)).isEqualTo(users.get(i));
        }
    }
",non-flaky,5
110850,pushtorefresh_storio,QueryTest.queryOrderedDesc,"    @Test
    public void queryOrderedDesc() {
        final List<User> users = TestFactory.newUsers(3);

        // Sorting by email before inserting, for the purity of the experiment.
        Collections.sort(users);

        putUsersBlocking(users);

        final List<User> usersFromQueryOrdered = storIOSQLite
                .get()
                .listOfObjects(User.class)
                .withQuery(Query.builder()
                        .table(UserTableMeta.TABLE)
                        .orderBy(UserTableMeta.COLUMN_EMAIL + "" DESC"")
                        .build())
                .prepare()
                .executeAsBlocking();

        assertThat(usersFromQueryOrdered).isNotNull();
        assertThat(usersFromQueryOrdered).hasSize(users.size());

        // Reverse sorting by email for check ordering.
        Collections.reverse(users);

        for (int i = 0; i < users.size(); i++) {
            assertThat(usersFromQueryOrdered.get(i)).isEqualTo(users.get(i));
        }
    }
",non-flaky,5
110851,pushtorefresh_storio,QueryTest.querySingleLimit,"    @Test
    public void querySingleLimit() {
        putUsersBlocking(10);

        final int limit = 8;
        final List<User> usersFromQuery = storIOSQLite
                .get()
                .listOfObjects(User.class)
                .withQuery(Query.builder()
                        .table(UserTableMeta.TABLE)
                        .limit(String.valueOf(limit))
                        .build())
                .prepare()
                .executeAsBlocking();

        assertThat(usersFromQuery).isNotNull();
        assertThat(usersFromQuery).hasSize(limit);
    }
",non-flaky,5
110852,pushtorefresh_storio,QueryTest.queryLimitOffset,"    @Test
    public void queryLimitOffset() {
        final List<User> users = putUsersBlocking(10);

        final int offset = 5;
        final int limit = 3;
        final List<User> usersFromQuery = storIOSQLite
                .get()
                .listOfObjects(User.class)
                .withQuery(Query.builder()
                        .table(UserTableMeta.TABLE)
                        .orderBy(UserTableMeta.COLUMN_EMAIL)
                        .limit(offset + "", "" + limit)
                        .build())
                .prepare()
                .executeAsBlocking();

        assertThat(usersFromQuery).isNotNull();
        assertThat(usersFromQuery).hasSize(Math.min(limit, users.size() - offset));

        Collections.sort(users);

        int position = 0;
        for (int i = offset; i < offset + limit; i++) {
            assertThat(usersFromQuery.get(position++)).isEqualTo(users.get(i));
        }
    }
",non-flaky,5
110853,pushtorefresh_storio,QueryTest.queryIntegerLimit,"    @Test
    public void queryIntegerLimit() {
        putUsersBlocking(10);

        final int limit = 8;
        final List<User> usersFromQuery = storIOSQLite
                .get()
                .listOfObjects(User.class)
                .withQuery(Query.builder()
                        .table(UserTableMeta.TABLE)
                        .limit(limit)
                        .build())
                .prepare()
                .executeAsBlocking();

        assertThat(usersFromQuery).isNotNull();
        assertThat(usersFromQuery).hasSize(limit);
    }
",non-flaky,5
110854,pushtorefresh_storio,QueryTest.queryLimitOffsetQuantity,"    @Test
    public void queryLimitOffsetQuantity() {
        final List<User> users = putUsersBlocking(10);

        final int offset = 5;
        final int quantity = 3;
        final List<User> usersFromQuery = storIOSQLite
                .get()
                .listOfObjects(User.class)
                .withQuery(Query.builder()
                        .table(UserTableMeta.TABLE)
                        .orderBy(UserTableMeta.COLUMN_EMAIL)
                        .limit(offset, quantity)
                        .build())
                .prepare()
                .executeAsBlocking();

        assertThat(usersFromQuery).isNotNull();
        assertThat(usersFromQuery).hasSize(Math.min(quantity, users.size() - offset));

        Collections.sort(users);

        int position = 0;
        for (int i = offset; i < offset + quantity; i++) {
            assertThat(usersFromQuery.get(position++)).isEqualTo(users.get(i));
        }
    }
",non-flaky,5
110855,pushtorefresh_storio,QueryTest.mapFromCursor,"    @Test
    public void queryGroupBy() {
        final List<User> users = TestFactory.newUsers(10);

        for (int i = 0; i < users.size(); i++) {
            final String commonEmail;
            if (i < 3) {
                commonEmail = ""first_group@gmail.com"";
            } else {
                commonEmail = ""second_group@gmail.com"";
            }

            users.set(i, User.newInstance(null, commonEmail));
        }

        putUsersBlocking(users);

        final List<User> groupsOfUsers = storIOSQLite
                .get()
                .listOfObjects(User.class)
                .withQuery(Query.builder()
                        .table(UserTableMeta.TABLE)
                        .columns(UserTableMeta.COLUMN_EMAIL)
                        .groupBy(UserTableMeta.COLUMN_EMAIL)
                        .build())
                .withGetResolver(new DefaultGetResolver<User>() {
                    @NonNull
                    @Override
                    public User mapFromCursor(@NonNull StorIOSQLite storIOSQLite, @NonNull Cursor cursor) {
                        return User.newInstance(null, cursor.getString(cursor.getColumnIndex(UserTableMeta.COLUMN_EMAIL)));
                    }
",non-flaky,5
110856,pushtorefresh_storio,QueryTest.mapFromCursor,"    @Test
    public void queryHaving() {
        final List<User> users = TestFactory.newUsers(10);

        for (int i = 0; i < users.size(); i++) {
            final String commonEmail;
            if (i < 3) {
                commonEmail = ""first_group@gmail.com"";
            } else {
                commonEmail = ""second_group@gmail.com"";
            }

            users.set(i, User.newInstance(null, commonEmail));
        }

        putUsersBlocking(users);

        final int bigGroupThreshold = 5;

        final List<User> groupsOfUsers = storIOSQLite
                .get()
                .listOfObjects(User.class)
                .withQuery(Query.builder()
                        .table(UserTableMeta.TABLE)
                        .columns(UserTableMeta.COLUMN_EMAIL)
                        .groupBy(UserTableMeta.COLUMN_EMAIL)
                        .having(""COUNT(*) >= "" + bigGroupThreshold)
                        .build())
                .withGetResolver(new DefaultGetResolver<User>() {
                    @NonNull
                    @Override
                    public User mapFromCursor(@NonNull StorIOSQLite storIOSQLite, @NonNull Cursor cursor) {
                        return User.newInstance(null, cursor.getString(cursor.getColumnIndex(UserTableMeta.COLUMN_EMAIL)));
                    }
",non-flaky,5
110857,pushtorefresh_storio,QueryTest.mapFromCursor,"    @Test
    public void queryDistinct() {
        final List<User> users = new ArrayList<User>();

        for (int i = 0; i < 10; i++) {
            users.add(User.newInstance((long) i, ""same@email.com""));
        }

        putUsersBlocking(users);

        final GetResolver<User> customGetResolver = new DefaultGetResolver<User>() {
            @NonNull
            @Override
            public User mapFromCursor(@NonNull StorIOSQLite storIOSQLite, @NonNull Cursor cursor) {
                return User.newInstance(null, cursor.getString(cursor.getColumnIndex(UserTableMeta.COLUMN_EMAIL)));
            }
",non-flaky,5
110858,pushtorefresh_storio,QueryTest.queryWithRawQuery,"    @Test
    public void queryWithRawQuery() {
        final List<User> users = TestFactory.newUsers(20);

        int counter = 1;

        for (int i = 0; i < users.size(); i++) {
            char[] chars = new char[counter++];
            Arrays.fill(chars, '*'); // wtf is going on?
            users.set(i, User.newInstance(null, new String(chars)));
        }

        putUsersBlocking(users);

        final List<User> usersWithLongName = new ArrayList<User>(users.size());

        int lengthSum = 0;
        for (User user : users) {
            lengthSum += user.email().length();
        }

        final int avrLength = lengthSum / users.size();

        for (User user : users) {
            if (user.email().length() > avrLength) {
                usersWithLongName.add(user);
            }
        }

        final String query = ""Select * from "" + UserTableMeta.TABLE
                + "" where length("" + UserTableMeta.COLUMN_EMAIL + "") > ""
                + ""(select avg(length("" + UserTableMeta.COLUMN_EMAIL + "")) from users)"";

        final List<User> usersFromQuery = storIOSQLite
                .get()
                .listOfObjects(User.class)
                .withQuery(RawQuery.builder()
                        .query(query)
                        .build())
                .prepare()
                .executeAsBlocking();

        assertThat(usersFromQuery).isEqualTo(usersWithLongName);
    }
",non-flaky,5
110859,pushtorefresh_storio,QueryTest.queryWithRawQueryAndArguments,"    @Test
    public void queryWithRawQueryAndArguments() {
        final User testUser = User.newInstance(null, ""testUserName"");

        final List<User> users = TestFactory.newUsers(10);
        users.add(testUser);
        putUsersBlocking(users);

        final String query = ""SELECT * FROM "" + UserTableMeta.TABLE
                + "" WHERE "" + UserTableMeta.COLUMN_EMAIL + "" LIKE ?"";

        final List<User> usersFromQuery = storIOSQLite
                .get()
                .listOfObjects(User.class)
                .withQuery(RawQuery.builder()
                        .query(query)
                        .args(testUser.email())
                        .build())
                .prepare()
                .executeAsBlocking();

        assertThat(usersFromQuery).isNotNull();
        assertThat(usersFromQuery).hasSize(1);
        assertThat(usersFromQuery.get(0)).isEqualTo(testUser);
    }
",non-flaky,5
110860,pushtorefresh_storio,QueryTest.queryWithRawQuerySqlInjectionFail,"    @Test
    public void queryWithRawQuerySqlInjectionFail() {
        final List<User> users = putUsersBlocking(10);

        final String query = ""SELECT * FROM "" + UserTableMeta.TABLE
                + "" WHERE "" + UserTableMeta.COLUMN_EMAIL + "" LIKE ?"";

        final String arg = ""(DELETE FROM "" + UserTableMeta.TABLE + "")"";

        storIOSQLite.get()
                .listOfObjects(User.class)
                .withQuery(RawQuery.builder()
                        .query(query)
                        .args(arg)
                        .build())
                .prepare()
                .executeAsBlocking();

        assertThat(getAllUsersBlocking()).isEqualTo(users);
    }
",non-flaky,5
110861,pushtorefresh_storio,QueryTest.getNumberOfResults,"    @Test
    public void getNumberOfResults() {
        putUsersBlocking(8);

        Integer numberOfResults = storIOSQLite
                .get()
                .numberOfResults()
                .withQuery(UserTableMeta.QUERY_ALL)
                .prepare()
                .executeAsBlocking();

        assertThat(numberOfResults).isEqualTo(8);
    }
",non-flaky,5
110862,pushtorefresh_storio,QueryTest.queryOneExistedObject,"    @Test
    public void queryOneExistedObject() {
        final List<User> users = putUsersBlocking(3);
        final User user = users.get(0);

        final User userFromQuery = storIOSQLite
                .get()
                .object(User.class)
                .withQuery(Query.builder()
                        .table(UserTableMeta.TABLE)
                        .where(UserTableMeta.COLUMN_EMAIL + ""=?"")
                        .whereArgs(user.email())
                        .build())
                .prepare()
                .executeAsBlocking();

        assertThat(userFromQuery).isNotNull();
        assertThat(userFromQuery).isEqualTo(user);
    }
",non-flaky,5
110863,pushtorefresh_storio,QueryTest.queryOneNonExistedObject,"    @Test
    public void queryOneNonExistedObject() {
        putUsersBlocking(3);

        final User userFromQuery = storIOSQLite
                .get()
                .object(User.class)
                .withQuery(Query.builder()
                        .table(UserTableMeta.TABLE)
                        .where(UserTableMeta.COLUMN_EMAIL + ""=?"")
                        .whereArgs(""some arg"")
                        .build())
                .prepare()
                .executeAsBlocking();

        assertThat(userFromQuery).isNull();
    }
",non-flaky,5
110864,pushtorefresh_storio,DeleteTest.deleteOne,"    @Test
    public void deleteOne() {
        final User user = putUserBlocking();

        final Cursor cursorAfterInsert = db.query(UserTableMeta.TABLE, null, null, null, null, null, null);
        assertThat(cursorAfterInsert.getCount()).isEqualTo(1);
        cursorAfterInsert.close();

        deleteUserBlocking(user);

        final Cursor cursorAfterDelete = db.query(UserTableMeta.TABLE, null, null, null, null, null, null);
        assertThat(cursorAfterDelete.getCount()).isEqualTo(0);
        cursorAfterDelete.close();
    }
",non-flaky,5
110865,pushtorefresh_storio,DeleteTest.deleteCollection,"    @Test
    public void deleteCollection() {
        final List<User> allUsers = putUsersBlocking(10);

        final List<User> usersToDelete = new ArrayList<User>();

        for (int i = 0; i < allUsers.size(); i += 2) {  // Delete every second user
            usersToDelete.add(allUsers.get(i));
        }

        final DeleteResults<User> deleteResults = storIOSQLite
                .delete()
                .objects(usersToDelete)
                .prepare()
                .executeAsBlocking();

        final List<User> usersAfterDelete = getAllUsersBlocking();

        assertThat(usersAfterDelete).hasSize(allUsers.size() / 2);

        for (User user : allUsers) {
            final boolean shouldBeDeleted = usersToDelete.contains(user);

            // Check that we deleted what we going to.
            assertThat(deleteResults.wasDeleted(user)).isEqualTo(shouldBeDeleted);

            // Check that we didn't delete users that we didn't want to
            assertThat(usersAfterDelete.contains(user)).isEqualTo(!shouldBeDeleted);
        }
    }
",non-flaky,5
110866,pushtorefresh_storio,RxQueryTest.insertEmission,"    @Test
    public void insertEmission() {
        final List<User> initialUsers = putUsersBlocking(10);
        final List<User> usersForInsert = TestFactory.newUsers(10);
        final List<User> allUsers = new ArrayList<User>(initialUsers.size() + usersForInsert.size());

        allUsers.addAll(initialUsers);
        allUsers.addAll(usersForInsert);

        final Queue<List<User>> expectedUsers = new LinkedList<List<User>>();
        expectedUsers.add(initialUsers);
        expectedUsers.add(allUsers);

        final EmissionChecker emissionChecker = new EmissionChecker(expectedUsers);
        final Subscription subscription = emissionChecker.subscribe();

        // Should receive initial users
        emissionChecker.awaitNextExpectedValue();

        putUsersBlocking(usersForInsert);

        // Should receive initial users + inserted users
        emissionChecker.awaitNextExpectedValue();

        emissionChecker.assertThatNoExpectedValuesLeft();

        subscription.unsubscribe();
    }
",non-flaky,5
110867,pushtorefresh_storio,RxQueryTest.updateEmission,"    @Test
    public void updateEmission() {
        final List<User> users = putUsersBlocking(10);

        final Queue<List<User>> expectedUsers = new LinkedList<List<User>>();

        final List<User> updatedList = new ArrayList<User>(users.size());

        int count = 1;
        for (User user : users) {
            updatedList.add(User.newInstance(user.id(), ""new_email"" + count++));
        }
        expectedUsers.add(users);
        expectedUsers.add(updatedList);
        final EmissionChecker emissionChecker = new EmissionChecker(expectedUsers);
        final Subscription subscription = emissionChecker.subscribe();

        // Should receive all users
        emissionChecker.awaitNextExpectedValue();

        storIOSQLite
                .put()
                .objects(updatedList)
                .prepare()
                .executeAsBlocking();

        // Should receive updated users
        emissionChecker.awaitNextExpectedValue();

        emissionChecker.assertThatNoExpectedValuesLeft();

        subscription.unsubscribe();
    }
",non-flaky,5
110868,pushtorefresh_storio,RxQueryTest.deleteEmission,"    @Test
    public void deleteEmission() {
        final List<User> usersThatShouldBeSaved = TestFactory.newUsers(10);
        final List<User> usersThatShouldBeDeleted = TestFactory.newUsers(10);
        final List<User> allUsers = new ArrayList<User>();

        allUsers.addAll(usersThatShouldBeSaved);
        allUsers.addAll(usersThatShouldBeDeleted);

        putUsersBlocking(allUsers);

        final Queue<List<User>> expectedUsers = new LinkedList<List<User>>();

        expectedUsers.add(allUsers);
        expectedUsers.add(usersThatShouldBeSaved);

        final EmissionChecker emissionChecker = new EmissionChecker(expectedUsers);
        final Subscription subscription = emissionChecker.subscribe();

        // Should receive all users
        emissionChecker.awaitNextExpectedValue();

        deleteUsersBlocking(usersThatShouldBeDeleted);

        // Should receive users that should be saved
        emissionChecker.awaitNextExpectedValue();

        emissionChecker.assertThatNoExpectedValuesLeft();

        subscription.unsubscribe();
    }
",non-flaky,5
110869,pushtorefresh_storio,RxQueryTest.run,"    @Test
    public void concurrentPutWithoutGlobalTransaction() throws InterruptedException {
        final int numberOfConcurrentPuts = ConcurrencyTesting.optimalTestThreadsCount();

        TestSubscriber<Changes> testSubscriber = new TestSubscriber<Changes>();

        storIOSQLite
                .observeChangesInTable(TweetTableMeta.TABLE)
                .subscribe(testSubscriber);

        final CountDownLatch concurrentPutLatch = new CountDownLatch(1);
        final CountDownLatch allPutsDoneLatch = new CountDownLatch(numberOfConcurrentPuts);

        for (int i = 0; i < numberOfConcurrentPuts; i++) {
            final int iCopy = i;

            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        concurrentPutLatch.await();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }

                    storIOSQLite
                            .put()
                            .object(Tweet.newInstance(null, 1L, ""Some text: "" + iCopy))
                            .prepare()
                            .executeAsBlocking();

                    allPutsDoneLatch.countDown();
                }
",non-flaky,5
110870,pushtorefresh_storio,RxQueryTest.nestedTransaction,"    @Test
    public void nestedTransaction() {
        storIOSQLite.lowLevel().beginTransaction();

        storIOSQLite.lowLevel().beginTransaction();

        storIOSQLite.lowLevel().setTransactionSuccessful();
        storIOSQLite.lowLevel().endTransaction();

        storIOSQLite.lowLevel().setTransactionSuccessful();
        storIOSQLite.lowLevel().endTransaction();
    }
",non-flaky,5
110871,pushtorefresh_storio,RxQueryTest.queryOneExistedObjectObservable,"    @Test
    public void queryOneExistedObjectObservable() {
        final List<User> users = putUsersBlocking(3);
        final User expectedUser = users.get(0);

        final Observable<User> userObservable = storIOSQLite
                .get()
                .object(User.class)
                .withQuery(Query.builder()
                        .table(UserTableMeta.TABLE)
                        .where(UserTableMeta.COLUMN_EMAIL + ""=?"")
                        .whereArgs(expectedUser.email())
                        .build())
                .prepare()
                .asRxObservable()
                .take(1);

        TestSubscriber<User> testSubscriber = new TestSubscriber<User>();
        userObservable.subscribe(testSubscriber);

        testSubscriber.awaitTerminalEvent(5, SECONDS);
        testSubscriber.assertNoErrors();
        testSubscriber.assertValue(expectedUser);
    }
",non-flaky,5
110872,pushtorefresh_storio,RxQueryTest.queryOneNonExistedObjectObservable,"    @Test
    public void queryOneNonExistedObjectObservable() {
        putUsersBlocking(3);

        final Observable<User> userObservable = storIOSQLite
                .get()
                .object(User.class)
                .withQuery(Query.builder()
                        .table(UserTableMeta.TABLE)
                        .where(UserTableMeta.COLUMN_EMAIL + ""=?"")
                        .whereArgs(""some arg"")
                        .build())
                .prepare()
                .asRxObservable()
                .take(1);

        TestSubscriber<User> testSubscriber = new TestSubscriber<User>();
        userObservable.subscribe(testSubscriber);

        testSubscriber.awaitTerminalEvent(5, SECONDS);
        testSubscriber.assertNoErrors();
        testSubscriber.assertValue(null);
    }
",non-flaky,5
110873,pushtorefresh_storio,RxQueryTest.queryOneExistedObjectTableUpdate,"    @Test
    public void queryOneExistedObjectTableUpdate() {
        User expectedUser = User.newInstance(null, ""such@email.com"");
        putUsersBlocking(3);

        final Observable<User> userObservable = storIOSQLite
                .get()
                .object(User.class)
                .withQuery(Query.builder()
                        .table(UserTableMeta.TABLE)
                        .where(UserTableMeta.COLUMN_EMAIL + ""=?"")
                        .whereArgs(expectedUser.email())
                        .build())
                .prepare()
                .asRxObservable()
                .take(2);

        TestSubscriber<User> testSubscriber = new TestSubscriber<User>();
        userObservable.subscribe(testSubscriber);

        testSubscriber.awaitTerminalEvent(5, SECONDS);
        testSubscriber.assertNoErrors();
        testSubscriber.assertValue(null);

        putUserBlocking(expectedUser);

        testSubscriber.awaitTerminalEvent(5, SECONDS);
        testSubscriber.assertNoErrors();
        testSubscriber.assertValues(null, expectedUser);
    }
",non-flaky,5
110874,pushtorefresh_storio,RxQueryTest.queryOneNonexistedObjectTableUpdate,"    @Test
    public void queryOneNonexistedObjectTableUpdate() {
        final Observable<User> userObservable = storIOSQLite
                .get()
                .object(User.class)
                .withQuery(Query.builder()
                        .table(UserTableMeta.TABLE)
                        .where(UserTableMeta.COLUMN_EMAIL + ""=?"")
                        .whereArgs(""some arg"")
                        .build())
                .prepare()
                .asRxObservable()
                .take(2);

        TestSubscriber<User> testSubscriber = new TestSubscriber<User>();
        userObservable.subscribe(testSubscriber);

        testSubscriber.awaitTerminalEvent(5, SECONDS);
        testSubscriber.assertNoErrors();
        testSubscriber.assertValue(null);

        putUserBlocking();

        testSubscriber.awaitTerminalEvent(5, SECONDS);
        testSubscriber.assertNoErrors();
        testSubscriber.assertValues(null, null);
    }
",non-flaky,5
110875,pushtorefresh_storio,RxQueryTest.queryListOfObjectsAsSingle,"    @Test
    public void queryListOfObjectsAsSingle() {
        final List<User> users = putUsersBlocking(10);

        final Single<List<User>> usersSingle = storIOSQLite
                .get()
                .listOfObjects(User.class)
                .withQuery(UserTableMeta.QUERY_ALL)
                .prepare()
                .asRxSingle();

        TestSubscriber<List<User>> testSubscriber = new TestSubscriber<List<User>>();
        usersSingle.subscribe(testSubscriber);

        testSubscriber.awaitTerminalEvent(5, SECONDS);
        testSubscriber.assertNoErrors();
        testSubscriber.assertValue(users);
        testSubscriber.assertCompleted();
    }
",non-flaky,5
110876,pushtorefresh_storio,RxQueryTest.queryObjectAsSingle,"    @Test
    public void queryObjectAsSingle() {
        final List<User> users = putUsersBlocking(3);

        final Single<User> usersSingle = storIOSQLite
                .get()
                .object(User.class)
                .withQuery(UserTableMeta.QUERY_ALL)
                .prepare()
                .asRxSingle();

        TestSubscriber<User> testSubscriber = new TestSubscriber<User>();
        usersSingle.subscribe(testSubscriber);

        testSubscriber.awaitTerminalEvent(5, SECONDS);
        testSubscriber.assertNoErrors();
        testSubscriber.assertValues(users.get(0));
        testSubscriber.assertCompleted();
    }
",non-flaky,5
110877,pushtorefresh_storio,RxQueryTest.queryNumberOfResultsAsSingle,"    @Test
    public void queryNumberOfResultsAsSingle() {
        final List<User> users = putUsersBlocking(3);

        final Single<Integer> usersSingle = storIOSQLite
                .get()
                .numberOfResults()
                .withQuery(UserTableMeta.QUERY_ALL)
                .prepare()
                .asRxSingle();

        TestSubscriber<Integer> testSubscriber = new TestSubscriber<Integer>();
        usersSingle.subscribe(testSubscriber);

        testSubscriber.awaitTerminalEvent(5, SECONDS);
        testSubscriber.assertNoErrors();
        testSubscriber.assertValue(users.size());
        testSubscriber.assertCompleted();
    }
",non-flaky,5
110878,pushtorefresh_storio,InterceptorTest.deleteByQuery,"    @Test
    public void deleteByQuery() {
        storIOSQLite.delete()
                .byQuery(DeleteQuery.builder()
                        .table(TweetTableMeta.TABLE)
                        .build()
                )
                .prepare()
                .executeAsBlocking();
        checkInterceptorsCalls();
    }
",non-flaky,5
110879,pushtorefresh_storio,InterceptorTest.deleteCollectionOfObjects,"    @Test
    public void deleteCollectionOfObjects() {
        storIOSQLite.delete()
                .objects(Collections.singleton(createTweet()))
                .prepare()
                .executeAsBlocking();
        checkInterceptorsCalls();
    }
",non-flaky,5
110880,pushtorefresh_storio,InterceptorTest.deleteObject,"    @Test
    public void deleteObject() {
        storIOSQLite.delete()
                .object(createTweet())
                .prepare()
                .executeAsBlocking();
        checkInterceptorsCalls();
    }
",non-flaky,5
110881,pushtorefresh_storio,InterceptorTest.execSql,"    @Test
    public void execSql() {
        storIOSQLite.executeSQL()
                .withQuery(RawQuery.builder()
                        .query(""select * from "" + TweetTableMeta.TABLE)
                        .build()
                )
                .prepare()
                .executeAsBlocking();
        checkInterceptorsCalls();
    }
",non-flaky,5
110882,pushtorefresh_storio,InterceptorTest.getCursorWithRawQuery,"    @Test
    public void getCursorWithRawQuery() {
        storIOSQLite.get()
                .cursor()
                .withQuery(RawQuery.builder()
                        .query(""select * from "" + TweetTableMeta.TABLE)
                        .build()
                )
                .prepare()
                .executeAsBlocking();
        checkInterceptorsCalls();
    }
",non-flaky,5
110883,pushtorefresh_storio,InterceptorTest.getCursorWithQuery,"    @Test
    public void getCursorWithQuery() {
        storIOSQLite.get()
                .cursor()
                .withQuery(Query.builder()
                        .table(TweetTableMeta.TABLE)
                        .build()
                )
                .prepare()
                .executeAsBlocking();
        checkInterceptorsCalls();
    }
",non-flaky,5
110884,pushtorefresh_storio,InterceptorTest.getListOfObjectsWithRawQuery,"    @Test
    public void getListOfObjectsWithRawQuery() {
        storIOSQLite.get()
                .listOfObjects(Tweet.class)
                .withQuery(RawQuery.builder()
                        .query(""select * from "" + TweetTableMeta.TABLE)
                        .build()
                )
                .prepare()
                .executeAsBlocking();
        checkInterceptorsCalls();
    }
",non-flaky,5
110885,pushtorefresh_storio,InterceptorTest.getListOfObjectsWithQuery,"    @Test
    public void getListOfObjectsWithQuery() {
        storIOSQLite.get()
                .listOfObjects(Tweet.class)
                .withQuery(Query.builder()
                        .table(TweetTableMeta.TABLE)
                        .build()
                )
                .prepare()
                .executeAsBlocking();
        checkInterceptorsCalls();
    }
",non-flaky,5
110886,pushtorefresh_storio,InterceptorTest.getNumberOfResultsWithRawQuery,"    @Test
    public void getNumberOfResultsWithRawQuery() {
        storIOSQLite.get()
                .numberOfResults()
                .withQuery(RawQuery.builder()
                        .query(""select * from "" + TweetTableMeta.TABLE)
                        .build()
                )
                .prepare()
                .executeAsBlocking();
        checkInterceptorsCalls();
    }
",non-flaky,5
110887,pushtorefresh_storio,InterceptorTest.getNumberOfResultsWithQuery,"    @Test
    public void getNumberOfResultsWithQuery() {
        storIOSQLite.get()
                .numberOfResults()
                .withQuery(Query.builder()
                        .table(TweetTableMeta.TABLE)
                        .build()
                )
                .prepare()
                .executeAsBlocking();
        checkInterceptorsCalls();
    }
",non-flaky,5
110888,pushtorefresh_storio,InterceptorTest.getObjectWithRawQuery,"    @Test
    public void getObjectWithRawQuery() {
        storIOSQLite.get()
                .object(Tweet.class)
                .withQuery(RawQuery.builder()
                        .query(""select * from "" + TweetTableMeta.TABLE)
                        .build()
                )
                .prepare()
                .executeAsBlocking();
        checkInterceptorsCalls();
    }
",non-flaky,5
110889,pushtorefresh_storio,InterceptorTest.getObjectWithQuery,"    @Test
    public void getObjectWithQuery() {
        storIOSQLite.get()
                .object(Tweet.class)
                .withQuery(Query.builder()
                        .table(TweetTableMeta.TABLE)
                        .build()
                )
                .prepare()
                .executeAsBlocking();
        checkInterceptorsCalls();
    }
",non-flaky,5
110890,pushtorefresh_storio,InterceptorTest.putCollection,"    @Test
    public void putCollection() {
        storIOSQLite.put()
                .objects(Collections.singleton(createTweet()))
                .prepare()
                .executeAsBlocking();
        checkInterceptorsCalls();
    }
",non-flaky,5
110891,pushtorefresh_storio,InterceptorTest.putContentValues,"    @Test
    public void putContentValues() {
        storIOSQLite.put()
                .contentValues(createContentValues())
                .withPutResolver(createCVPutResolver())
                .prepare()
                .executeAsBlocking();
        checkInterceptorsCalls();
    }
",non-flaky,5
110892,pushtorefresh_storio,InterceptorTest.putContentValuesIterable,"    @Test
    public void putContentValuesIterable() {
        storIOSQLite.put()
                .contentValues(createContentValues(), createContentValues())
                .withPutResolver(createCVPutResolver())
                .prepare()
                .executeAsBlocking();
        checkInterceptorsCalls();
    }
",non-flaky,5
110893,pushtorefresh_storio,InterceptorTest.putObject,"    @Test
    public void putObject() {
        storIOSQLite.put()
                .object(createTweet())
                .prepare()
                .executeAsBlocking();
        checkInterceptorsCalls();
    }
",non-flaky,5
110894,pushtorefresh_storio,InsertTest.insertOne,"    @Test
    public void insertOne() {
        final User user = putUserBlocking();

        // why we created StorIOSQLite: nobody loves nulls
        final Cursor cursor = db.query(UserTableMeta.TABLE, null, null, null, null, null, null);

        // asserting that values was really inserted to db
        assertThat(cursor.getCount()).isEqualTo(1);
        assertThat(cursor.moveToFirst()).isTrue();

        final User insertedUser = UserTableMeta.GET_RESOLVER.mapFromCursor(storIOSQLite, cursor);

        assertThat(insertedUser.id()).isNotNull();
        assertThat(user.equalsExceptId(insertedUser)).isTrue();

        cursor.close();
    }
",non-flaky,5
110895,pushtorefresh_storio,InsertTest.insertCollection,"    @Test
    public void insertCollection() {
        final List<User> users = putUsersBlocking(3);

        // asserting that values was really inserted to db
        final Cursor cursor = db.query(UserTableMeta.TABLE, null, null, null, null, null, null);

        assertThat(cursor.getCount()).isEqualTo(users.size());

        for (int i = 0; i < users.size(); i++) {
            assertThat(cursor.moveToNext()).isTrue();
            assertThat(UserTableMeta.GET_RESOLVER.mapFromCursor(storIOSQLite, cursor)).isEqualTo(users.get(i));
        }

        cursor.close();
    }
",non-flaky,5
110896,pushtorefresh_storio,InsertTest.insertAndDeleteTwice,"    @Test
    public void insertAndDeleteTwice() {
        final User user = TestFactory.newUser();

        for (int i = 0; i < 2; i++) {
            putUserBlocking(user);

            final List<User> existUsers = getAllUsersBlocking();

            assertThat(existUsers).isNotNull();
            assertThat(existUsers).hasSize(1);

            final Cursor cursorAfterPut = db.query(UserTableMeta.TABLE, null, null, null, null, null, null);
            assertThat(cursorAfterPut.getCount()).isEqualTo(1);
            cursorAfterPut.close();

            deleteUserBlocking(user);

            final Cursor cursorAfterDelete = db.query(UserTableMeta.TABLE, null, null, null, null, null, null);
            assertThat(cursorAfterDelete.getCount()).isEqualTo(0);
            cursorAfterDelete.close();
        }
    }
",non-flaky,5
110897,pushtorefresh_storio,InsertTest.insertOneWithNullField,"    @Test
    public void insertOneWithNullField() {
        User user = User.newInstance(null, ""user@example.com"", null); // phone is null
        putUserBlocking(user);

        final Cursor cursor = db.query(UserTableMeta.TABLE, null, null, null, null, null, null);

        // asserting that values was really inserted to db
        assertThat(cursor.getCount()).isEqualTo(1);
        assertThat(cursor.moveToFirst()).isTrue();

        final User insertedUser = UserTableMeta.GET_RESOLVER.mapFromCursor(storIOSQLite, cursor);

        assertThat(insertedUser.id()).isNotNull();
        assertThat(user.equalsExceptId(insertedUser)).isTrue();

        cursor.close();
    }
",non-flaky,5
110898,pushtorefresh_storio,UpdateTest.updateOne,"    @Test
    public void updateOne() {
        final User userForInsert = putUserBlocking();

        final User userForUpdate = User.newInstance(
                userForInsert.id(), // using id of inserted user
                ""new@email.com"" // new value
        );

        updateUserBlocking(userForUpdate);
        checkOnlyOneItemInStorage(userForUpdate);  // update should not add new rows!
    }
",non-flaky,5
110899,pushtorefresh_storio,UpdateTest.updateNullFieldToNotNull,"    @Test
    public void updateNullFieldToNotNull() {
        final User userForInsert = User.newInstance(null, ""user@email.com"", null); // phone is null

        putUserBlocking(userForInsert);

        final User userForUpdate = User.newInstance(
                userForInsert.id(),
                userForInsert.email(),
                ""1-999-547867""  // phone not null
        );

        updateUserBlocking(userForUpdate);
        checkOnlyOneItemInStorage(userForUpdate);
    }
",non-flaky,5
110900,pushtorefresh_storio,UpdateTest.updateNotNullFieldToNull,"    @Test
    public void updateNotNullFieldToNull() {
        final User userForInsert = User.newInstance(null, ""user@email.com"", ""1-999-547867""); // phone not null

        putUserBlocking(userForInsert);

        final User userForUpdate = User.newInstance(
                userForInsert.id(),
                userForInsert.email(),
                null    // phone is null
        );

        updateUserBlocking(userForUpdate);
        checkOnlyOneItemInStorage(userForUpdate);
    }
",non-flaky,5
110901,pushtorefresh_storio,UpdateTest.updateCollection,"    @Test
    public void updateCollection() {
        final List<User> usersForInsert = TestFactory.newUsers(3);

        final PutResults<User> insertResults = storIOSQLite
                .put()
                .objects(usersForInsert)
                .prepare()
                .executeAsBlocking();

        assertThat(insertResults.numberOfInserts()).isEqualTo(usersForInsert.size());

        final List<User> usersForUpdate = new ArrayList<User>(usersForInsert.size());

        for (int i = 0; i < usersForInsert.size(); i++) {
            usersForUpdate.add(User.newInstance(usersForInsert.get(i).id(), ""new"" + i + ""@email.com"" + i));
        }

        final PutResults<User> updateResults = storIOSQLite
                .put()
                .objects(usersForUpdate)
                .prepare()
                .executeAsBlocking();

        assertThat(updateResults.numberOfUpdates()).isEqualTo(usersForUpdate.size());

        final Cursor cursor = db.query(UserTableMeta.TABLE, null, null, null, null, null, null);

        assertThat(cursor.getCount()).isEqualTo(usersForUpdate.size()); // update should not add new rows!

        for (int i = 0; i < usersForUpdate.size(); i++) {
            assertThat(cursor.moveToNext()).isTrue();
            assertThat(UserTableMeta.GET_RESOLVER.mapFromCursor(storIOSQLite, cursor)).isEqualTo(usersForUpdate.get(i));
        }

        cursor.close();
    }
",non-flaky,5
110902,pushtorefresh_storio,ObserveChangesInTableTest.insertEmission,"    @Test
    public void insertEmission() {
        final List<User> users = TestFactory.newUsers(10);

        final Queue<Changes> expectedChanges = new LinkedList<Changes>();
        expectedChanges.add(Changes.newInstance(UserTableMeta.TABLE, UserTableMeta.NOTIFICATION_TAG));

        final EmissionChecker emissionChecker = new EmissionChecker(expectedChanges);
        final Subscription subscription = emissionChecker.subscribe();

        putUsersBlocking(users);

        // Should receive changes of Users table
        emissionChecker.awaitNextExpectedValue();

        emissionChecker.assertThatNoExpectedValuesLeft();

        subscription.unsubscribe();
    }
",non-flaky,5
110903,pushtorefresh_storio,ObserveChangesInTableTest.updateEmission,"    @Test
    public void updateEmission() {
        final List<User> users = putUsersBlocking(10);
        final List<User> updated = new ArrayList<User>(users.size());

        for (User user : users) {
            updated.add(User.newInstance(user.id(), user.email()));
        }

        final Queue<Changes> expectedChanges = new LinkedList<Changes>();
        expectedChanges.add(Changes.newInstance(UserTableMeta.TABLE, UserTableMeta.NOTIFICATION_TAG));

        final EmissionChecker emissionChecker = new EmissionChecker(expectedChanges);
        final Subscription subscription = emissionChecker.subscribe();

        storIOSQLite
                .put()
                .objects(updated)
                .prepare()
                .executeAsBlocking();

        // Should receive changes of Users table
        emissionChecker.awaitNextExpectedValue();

        emissionChecker.assertThatNoExpectedValuesLeft();

        subscription.unsubscribe();
    }
",non-flaky,5
110904,pushtorefresh_storio,ObserveChangesInTableTest.deleteEmission,"    @Test
    public void deleteEmission() {
        final List<User> users = putUsersBlocking(10);

        final Queue<Changes> expectedChanges = new LinkedList<Changes>();
        expectedChanges.add(Changes.newInstance(UserTableMeta.TABLE, UserTableMeta.NOTIFICATION_TAG));

        final EmissionChecker emissionChecker = new EmissionChecker(expectedChanges);
        final Subscription subscription = emissionChecker.subscribe();

        deleteUsersBlocking(users);

        // Should receive changes of Users table
        emissionChecker.awaitNextExpectedValue();

        emissionChecker.assertThatNoExpectedValuesLeft();

        subscription.unsubscribe();
    }
",non-flaky,5
110905,pushtorefresh_storio,ExecSQLTest.shouldReturnQueryInGetData,"    @Test
    public void shouldReturnQueryInGetData() {
        final RawQuery query = RawQuery.builder()
                .query(""DROP TABLE IF EXISTS no_such_table"") // we don't want to really delete table
                .build();
        final PreparedExecuteSQL operation = storIOSQLite
                .executeSQL()
                .withQuery(query)
                .prepare();

        assertThat(operation.getData()).isEqualTo(query);
    }
",non-flaky,5
110906,pushtorefresh_storio,ExecSQLTest.execSQLWithEmptyArgs,"    @Test
    public void execSQLWithEmptyArgs() {
        // Should not throw exceptions!
        storIOSQLite
                .executeSQL()
                .withQuery(RawQuery.builder()
                        .query(""DROP TABLE IF EXISTS no_such_table"") // we don't want to really delete table
                        .build())
                .prepare()
                .executeAsBlocking();
    }
",non-flaky,5
110907,pushtorefresh_storio,ExecSQLTest.shouldPassArgsAsObjects,"    @Test
    public void shouldPassArgsAsObjects() {
        final User user = putUserBlocking();

        assertThat(user.id()).isNotNull();
        //noinspection ConstantConditions
        final long uid = user.id();

        final String query = ""UPDATE "" + UserTableMeta.TABLE
                + "" SET "" + UserTableMeta.COLUMN_ID + "" = MIN("" + UserTableMeta.COLUMN_ID + "", ?)"";

        storIOSQLite
                .executeSQL()
                .withQuery(
                        RawQuery.builder()
                                .query(query)
                                .args(uid - 1)  // as integer is less, as string is greater
                                .build())
                .prepare()
                .executeAsBlocking();

        List<User> users = getAllUsersBlocking();

        assertThat(users.size()).isEqualTo(1);

        // Was updated, because (uid - 1) passed as object, not string, and (uid - 1) < uid.
        assertThat(users.get(0).id()).isEqualTo(uid - 1);
    }
",non-flaky,5
110908,pushtorefresh_storio,GetCursorObserveChangesTest.repeatsOperationWithQueryByChangeOfTable,"    @Test
    public void repeatsOperationWithQueryByChangeOfTable() {
        putUserBlocking();

        TestSubscriber<Cursor> testSubscriber = new TestSubscriber<Cursor>();
        storIOSQLite
                .get()
                .cursor()
                .withQuery(query)
                .prepare()
                .asRxObservable()
                .subscribe(testSubscriber);

        testSubscriber.assertValueCount(1);

        storIOSQLite.lowLevel().notifyAboutChanges(tableChanges);

        testSubscriber.assertValueCount(2);
    }
",non-flaky,5
110909,pushtorefresh_storio,GetCursorObserveChangesTest.repeatsOperationWithRawQueryByChangeOfTable,"    @Test
    public void repeatsOperationWithRawQueryByChangeOfTable() {
        putUserBlocking();

        TestSubscriber<Cursor> testSubscriber = new TestSubscriber<Cursor>();
        storIOSQLite
                .get()
                .cursor()
                .withQuery(rawQuery)
                .prepare()
                .asRxObservable()
                .subscribe(testSubscriber);

        testSubscriber.assertValueCount(1);

        storIOSQLite.lowLevel().notifyAboutChanges(tableChanges);

        testSubscriber.assertValueCount(2);
    }
",non-flaky,5
110910,pushtorefresh_storio,GetCursorObserveChangesTest.repeatsOperationWithQueryByChangeOfTag,"    @Test
    public void repeatsOperationWithQueryByChangeOfTag() {
        putUserBlocking();

        TestSubscriber<Cursor> testSubscriber = new TestSubscriber<Cursor>();
        storIOSQLite
                .get()
                .cursor()
                .withQuery(query)
                .prepare()
                .asRxObservable()
                .subscribe(testSubscriber);

        testSubscriber.assertValueCount(1);

        storIOSQLite.lowLevel().notifyAboutChanges(tagChanges);

        testSubscriber.assertValueCount(2);
    }
",non-flaky,5
110911,pushtorefresh_storio,GetCursorObserveChangesTest.repeatsOperationWithRawQueryByChangeOfTag,"    @Test
    public void repeatsOperationWithRawQueryByChangeOfTag() {
        putUserBlocking();

        TestSubscriber<Cursor> testSubscriber = new TestSubscriber<Cursor>();
        storIOSQLite
                .get()
                .cursor()
                .withQuery(rawQuery)
                .prepare()
                .asRxObservable()
                .subscribe(testSubscriber);

        testSubscriber.assertValueCount(1);

        storIOSQLite.lowLevel().notifyAboutChanges(tagChanges);

        testSubscriber.assertValueCount(2);
    }
",non-flaky,5
110912,pushtorefresh_storio,GetNumberOfResultsObserveChangesTest.repeatsOperationWithQueryByChangeOfTable,"    @Test
    public void repeatsOperationWithQueryByChangeOfTable() {
        putUserBlocking();

        PreparedGetNumberOfResults operation = storIOSQLite
                .get()
                .numberOfResults()
                .withQuery(query)
                .prepare();

        verifyChangesReceived(operation, tableChanges, 1);
    }
",non-flaky,5
110913,pushtorefresh_storio,GetNumberOfResultsObserveChangesTest.repeatsOperationWithRawQueryByChangeOfTable,"    @Test
    public void repeatsOperationWithRawQueryByChangeOfTable() {
        putUserBlocking();

        PreparedGetNumberOfResults operation = storIOSQLite
                .get()
                .numberOfResults()
                .withQuery(rawQuery)
                .prepare();

        verifyChangesReceived(operation, tableChanges, 1);
    }
",non-flaky,5
110914,pushtorefresh_storio,GetNumberOfResultsObserveChangesTest.repeatsOperationWithQueryByChangeOfTag,"    @Test
    public void repeatsOperationWithQueryByChangeOfTag() {
        putUserBlocking();

        PreparedGetNumberOfResults operation = storIOSQLite
                .get()
                .numberOfResults()
                .withQuery(query)
                .prepare();

        verifyChangesReceived(operation, tagChanges, 1);
    }
",non-flaky,5
110915,pushtorefresh_storio,GetNumberOfResultsObserveChangesTest.repeatsOperationWithRawQueryByChangeOfTag,"    @Test
    public void repeatsOperationWithRawQueryByChangeOfTag() {
        putUserBlocking();

        PreparedGetNumberOfResults operation = storIOSQLite
                .get()
                .numberOfResults()
                .withQuery(rawQuery)
                .prepare();

        verifyChangesReceived(operation, tagChanges, 1);
    }
",non-flaky,5
110916,pushtorefresh_storio,AutoParcelTest.insertObject,"    @Test
    public void insertObject() {
        final Book book = Book.builder()
                .id(1)
                .title(""What a great book"")
                .author(""Somebody"")
                .build();

        final PutResult putResult = storIOSQLite
                .put()
                .object(book)
                .prepare()
                .executeAsBlocking();

        assertThat(putResult.wasInserted()).isTrue();

        final List<Book> storedBooks = storIOSQLite
                .get()
                .listOfObjects(Book.class)
                .withQuery(Query.builder()
                        .table(BookTableMeta.TABLE)
                        .build())
                .prepare()
                .executeAsBlocking();

        assertThat(storedBooks).hasSize(1);

        assertThat(storedBooks.get(0)).isEqualTo(book);
    }
",non-flaky,5
110917,pushtorefresh_storio,AutoParcelTest.updateObject,"    @Test
    public void updateObject() {
        final Book book = Book.builder()
                .id(1)
                .title(""What a great book"")
                .author(""Somebody"")
                .build();

        final PutResult putResult1 = storIOSQLite
                .put()
                .object(book)
                .prepare()
                .executeAsBlocking();

        assertThat(putResult1.wasInserted()).isTrue();

        final Book bookWithUpdatedInfo = Book.builder()
                .id(1) // Same id, should be updated
                .title(""Corrected title"")
                .author(""Corrected author"")
                .build();

        final PutResult putResult2 = storIOSQLite
                .put()
                .object(bookWithUpdatedInfo)
                .prepare()
                .executeAsBlocking();

        assertThat(putResult2.wasUpdated()).isTrue();

        final List<Book> storedBooks = storIOSQLite
                .get()
                .listOfObjects(Book.class)
                .withQuery(Query.builder()
                        .table(BookTableMeta.TABLE)
                        .build())
                .prepare()
                .executeAsBlocking();

        assertThat(storedBooks).hasSize(1);

        assertThat(storedBooks.get(0)).isEqualTo(bookWithUpdatedInfo);
    }
",non-flaky,5
110918,pushtorefresh_storio,AutoParcelTest.deleteObject,"    @Test
    public void deleteObject() {
        final Book book = Book.builder()
                .id(1)
                .title(""What a great book"")
                .author(""Somebody"")
                .build();

        final PutResult putResult = storIOSQLite
                .put()
                .object(book)
                .prepare()
                .executeAsBlocking();

        assertThat(putResult.wasInserted()).isTrue();

        final DeleteResult deleteResult = storIOSQLite
                .delete()
                .object(book)
                .prepare()
                .executeAsBlocking();

        assertThat(deleteResult.numberOfRowsDeleted()).isEqualTo(1);

        final List<Book> storedBooks = storIOSQLite
                .get()
                .listOfObjects(Book.class)
                .withQuery(Query.builder()
                        .table(BookTableMeta.TABLE)
                        .build())
                .prepare()
                .executeAsBlocking();

        assertThat(storedBooks).hasSize(0);
    }
",non-flaky,5
110919,pushtorefresh_storio,SQLiteTypeMappingTest.nullPutResolver,"    @Test(expected = NullPointerException.class)
    public void nullPutResolver() {
        SQLiteTypeMapping.builder()
                .putResolver(null)
                .getResolver(mock(GetResolver.class))
                .deleteResolver(mock(DeleteResolver.class))
                .build();
    }
",non-flaky,5
110920,pushtorefresh_storio,SQLiteTypeMappingTest.nullMapFromCursor,"    @Test(expected = NullPointerException.class)
    public void nullMapFromCursor() {
        SQLiteTypeMapping.builder()
                .putResolver(mock(PutResolver.class))
                .getResolver(null)
                .deleteResolver(mock(DeleteResolver.class))
                .build();
    }
",non-flaky,5
110921,pushtorefresh_storio,SQLiteTypeMappingTest.nullMapToDeleteQuery,"    @Test(expected = NullPointerException.class)
    public void nullMapToDeleteQuery() {
        SQLiteTypeMapping.builder()
                .putResolver(mock(PutResolver.class))
                .getResolver(mock(GetResolver.class))
                .deleteResolver(null)
                .build();
    }
",non-flaky,5
110922,pushtorefresh_storio,SQLiteTypeMappingTest.build,"    @Test
    public void build() {
        class TestItem {

        }

        final PutResolver<TestItem> putResolver = mock(PutResolver.class);
        final GetResolver<TestItem> getResolver = mock(GetResolver.class);
        final DeleteResolver<TestItem> deleteResolver = mock(DeleteResolver.class);

        final SQLiteTypeMapping<TestItem> typeMapping = SQLiteTypeMapping.<TestItem>builder()
                .putResolver(putResolver)
                .getResolver(getResolver)
                .deleteResolver(deleteResolver)
                .build();

        assertThat(typeMapping.putResolver()).isSameAs(putResolver);
        assertThat(typeMapping.getResolver()).isSameAs(getResolver);
        assertThat(typeMapping.deleteResolver()).isSameAs(deleteResolver);
    }
",non-flaky,5
110923,pushtorefresh_storio,InsertQueryTest.shouldNotAllowNullTable,"    @Test
    public void shouldNotAllowNullTable() {
        expectedException.expect(NullPointerException.class);
        expectedException.expectMessage(equalTo(""Table name is null or empty""));
        expectedException.expectCause(nullValue(Throwable.class));

        //noinspection ConstantConditions
        InsertQuery.builder().table(null);
    }
",non-flaky,5
110924,pushtorefresh_storio,InsertQueryTest.shouldNotAllowEmptyTable,"    @Test
    public void shouldNotAllowEmptyTable() {
        expectedException.expect(IllegalStateException.class);
        expectedException.expectMessage(equalTo(""Table name is null or empty""));
        expectedException.expectCause(nullValue(Throwable.class));

        InsertQuery.builder().table("""");
    }
",non-flaky,5
110925,pushtorefresh_storio,InsertQueryTest.nullColumnHackShouldBeNullByDefault,"    @Test
    public void nullColumnHackShouldBeNullByDefault() {
        InsertQuery insertQuery = InsertQuery.builder()
                .table(""test_table"")
                .build();

        assertThat(insertQuery.nullColumnHack()).isNull();
    }
",non-flaky,5
110926,pushtorefresh_storio,InsertQueryTest.completeBuilderShouldNotAllowNullTable,"    @Test
    public void completeBuilderShouldNotAllowNullTable() {
        try {
            //noinspection ConstantConditions
            InsertQuery.builder()
                    .table(""test_table"")
                    .table(null);
            failBecauseExceptionWasNotThrown(NullPointerException.class);
        } catch (NullPointerException expected) {
            assertThat(expected)
                    .hasMessage(""Table name is null or empty"")
                    .hasNoCause();
        }
    }
",non-flaky,5
110927,pushtorefresh_storio,InsertQueryTest.completeBuilderShouldNotAllowEmptyTable,"    @Test
    public void completeBuilderShouldNotAllowEmptyTable() {
        try {
            InsertQuery.builder()
                    .table(""test_table"")
                    .table("""");
            failBecauseExceptionWasNotThrown(IllegalStateException.class);
        } catch (IllegalStateException expected) {
            assertThat(expected)
                    .hasMessage(""Table name is null or empty"")
                    .hasNoCause();
        }
    }
",non-flaky,5
110928,pushtorefresh_storio,InsertQueryTest.completeBuilderShouldUpdateTable,"    @Test
    public void completeBuilderShouldUpdateTable() {
        InsertQuery query = InsertQuery.builder()
                .table(""old_table"")
                .table(""new_table"")
                .build();

        assertThat(query.table()).isEqualTo(""new_table"");
    }
",non-flaky,5
110929,pushtorefresh_storio,InsertQueryTest.createdThroughToBuilderQueryShouldBeEqual,"    @Test
    public void createdThroughToBuilderQueryShouldBeEqual() {
        final String table = ""test_table"";
        final String nullColumnHack = ""test_null_column_hack"";
        final String tag = ""test_tag"";

        final InsertQuery firstQuery = InsertQuery.builder()
                .table(table)
                .nullColumnHack(nullColumnHack)
                .affectsTags(tag)
                .build();

        final InsertQuery secondQuery = firstQuery.toBuilder().build();

        assertThat(secondQuery).isEqualTo(firstQuery);
    }
",non-flaky,5
110930,pushtorefresh_storio,InsertQueryTest.affectsTagsCollectionShouldRewrite,"    @Test
    public void affectsTagsCollectionShouldRewrite() {
        InsertQuery insertQuery = InsertQuery.builder()
                .table(""table"")
                .affectsTags(new HashSet<String>((singletonList(""first_call_collection""))))
                .affectsTags(new HashSet<String>((singletonList(""second_call_collection""))))
                .build();

        assertThat(insertQuery.affectsTags()).isEqualTo(singleton(""second_call_collection""));
    }
",non-flaky,5
110931,pushtorefresh_storio,InsertQueryTest.affectsTagsVarargShouldRewrite,"    @Test
    public void affectsTagsVarargShouldRewrite() {
        InsertQuery insertQuery = InsertQuery.builder()
                .table(""table"")
                .affectsTags(""first_call_vararg"")
                .affectsTags(""second_call_vararg"")
                .build();

        assertThat(insertQuery.affectsTags()).isEqualTo(singleton(""second_call_vararg""));
    }
",non-flaky,5
110932,pushtorefresh_storio,InsertQueryTest.affectsTagsCollectionAllowsNull,"    @Test
    public void affectsTagsCollectionAllowsNull() {
        InsertQuery insertQuery = InsertQuery.builder()
                .table(""table"")
                .affectsTags(new HashSet<String>((singletonList(""first_call_collection""))))
                .affectsTags(null)
                .build();

        assertThat(insertQuery.affectsTags()).isEmpty();
    }
",non-flaky,5
110933,pushtorefresh_storio,InsertQueryTest.buildWithNormalValues,"    @Test
    public void buildWithNormalValues() {
        final String table = ""test_table"";
        final String nullColumnHack = ""test_null_column_hack"";
        final Set<String> tags = singleton(""tag"");

        final InsertQuery insertQuery = InsertQuery.builder()
                .table(table)
                .nullColumnHack(nullColumnHack)
                .affectsTags(tags)
                .build();

        assertThat(insertQuery.table()).isEqualTo(table);
        assertThat(insertQuery.nullColumnHack()).isEqualTo(nullColumnHack);
        assertThat(insertQuery.affectsTags()).isEqualTo(tags);
    }
",non-flaky,5
110934,pushtorefresh_storio,InsertQueryTest.shouldNotAllowNullTag,"    @Test
    public void shouldNotAllowNullTag() {
        expectedException.expect(NullPointerException.class);
        expectedException.expectMessage(startsWith(""affectsTag must not be null or empty, affectsTags = ""));
        expectedException.expectCause(nullValue(Throwable.class));

        //noinspection ConstantConditions
        InsertQuery.builder()
                .table(""table"")
                .affectsTags((String) null)
                .build();
    }
",non-flaky,5
110935,pushtorefresh_storio,InsertQueryTest.shouldNotAllowEmptyTag,"    @Test
    public void shouldNotAllowEmptyTag() {
        expectedException.expect(IllegalStateException.class);
        expectedException.expectMessage(startsWith(""affectsTag must not be null or empty, affectsTags = ""));
        expectedException.expectCause(nullValue(Throwable.class));

        //noinspection ConstantConditions
        InsertQuery.builder()
                .table(""table"")
                .affectsTags("""")
                .build();
    }
",non-flaky,5
118685,netty_netty,XmlDecoderTest.shouldDecodeRequestWithSimpleXml,"    @Test
    public void shouldDecodeRequestWithSimpleXml() {
        Object temp;

        write(XML1);

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlDocumentStart.class));
        assertThat(((XmlDocumentStart) temp).version(), is(""1.0""));
        assertThat(((XmlDocumentStart) temp).encoding(), is(""UTF-8""));
        assertThat(((XmlDocumentStart) temp).standalone(), is(false));
        assertThat(((XmlDocumentStart) temp).encodingScheme(), is(nullValue()));

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlDTD.class));
        assertThat(((XmlDTD) temp).text(), is(""employee.dtd""));

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlProcessingInstruction.class));
        assertThat(((XmlProcessingInstruction) temp).target(), is(""xml-stylesheet""));
        assertThat(((XmlProcessingInstruction) temp).data(), is(""type=\""text/css\"" href=\""netty.css\""""));

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlProcessingInstruction.class));
        assertThat(((XmlProcessingInstruction) temp).target(), is(""xml-test""));
        assertThat(((XmlProcessingInstruction) temp).data(), is(""""));

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlElementStart.class));
        assertThat(((XmlElementStart) temp).name(), is(""employee""));
        assertThat(((XmlElementStart) temp).prefix(), is(""""));
        assertThat(((XmlElementStart) temp).namespace(), is(""""));
        assertThat(((XmlElementStart) temp).attributes().size(), is(0));
        assertThat(((XmlElementStart) temp).namespaces().size(), is(1));
        assertThat(((XmlElementStart) temp).namespaces().get(0).prefix(), is(""nettya""));
        assertThat(((XmlElementStart) temp).namespaces().get(0).uri(), is(""http://netty.io/netty/a""));

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlElementStart.class));
        assertThat(((XmlElementStart) temp).name(), is(""id""));
        assertThat(((XmlElementStart) temp).prefix(), is(""nettya""));
        assertThat(((XmlElementStart) temp).namespace(), is(""http://netty.io/netty/a""));
        assertThat(((XmlElementStart) temp).attributes().size(), is(0));
        assertThat(((XmlElementStart) temp).namespaces().size(), is(0));

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlEntityReference.class));
        assertThat(((XmlEntityReference) temp).name(), is(""plusmn""));
        assertThat(((XmlEntityReference) temp).text(), is(""""));

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlCharacters.class));
        assertThat(((XmlCharacters) temp).data(), is(""1""));

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlElementEnd.class));
        assertThat(((XmlElementEnd) temp).name(), is(""id""));
        assertThat(((XmlElementEnd) temp).prefix(), is(""nettya""));
        assertThat(((XmlElementEnd) temp).namespace(), is(""http://netty.io/netty/a""));

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlCharacters.class));
        assertThat(((XmlCharacters) temp).data(), is(""\n""));

        temp = channel.readInbound();
        assertThat(temp, nullValue());

        write(XML2);

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlElementStart.class));
        assertThat(((XmlElementStart) temp).name(), is(""name""));
        assertThat(((XmlElementStart) temp).prefix(), is(""""));
        assertThat(((XmlElementStart) temp).namespace(), is(""""));
        assertThat(((XmlElementStart) temp).attributes().size(), is(1));
        assertThat(((XmlElementStart) temp).attributes().get(0).name(), is(""type""));
        assertThat(((XmlElementStart) temp).attributes().get(0).value(), is(""given""));
        assertThat(((XmlElementStart) temp).attributes().get(0).prefix(), is(""""));
        assertThat(((XmlElementStart) temp).attributes().get(0).namespace(), is(""""));
        assertThat(((XmlElementStart) temp).namespaces().size(), is(0));

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlCharacters.class));
        assertThat(((XmlCharacters) temp).data(), is(""Alba""));

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlElementEnd.class));
        assertThat(((XmlElementEnd) temp).name(), is(""name""));
        assertThat(((XmlElementEnd) temp).prefix(), is(""""));
        assertThat(((XmlElementEnd) temp).namespace(), is(""""));

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlCdata.class));
        assertThat(((XmlCdata) temp).data(), is("" <some data &gt;/> ""));

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlCharacters.class));
        assertThat(((XmlCharacters) temp).data(), is(""   ""));

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlComment.class));
        assertThat(((XmlComment) temp).data(), is("" namespaced ""));

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlElementStart.class));
        assertThat(((XmlElementStart) temp).name(), is(""salary""));
        assertThat(((XmlElementStart) temp).prefix(), is(""nettyb""));
        assertThat(((XmlElementStart) temp).namespace(), is(""http://netty.io/netty/b""));
        assertThat(((XmlElementStart) temp).attributes().size(), is(1));
        assertThat(((XmlElementStart) temp).attributes().get(0).name(), is(""period""));
        assertThat(((XmlElementStart) temp).attributes().get(0).value(), is(""weekly""));
        assertThat(((XmlElementStart) temp).attributes().get(0).prefix(), is(""nettyb""));
        assertThat(((XmlElementStart) temp).attributes().get(0).namespace(), is(""http://netty.io/netty/b""));
        assertThat(((XmlElementStart) temp).namespaces().size(), is(1));
        assertThat(((XmlElementStart) temp).namespaces().get(0).prefix(), is(""nettyb""));
        assertThat(((XmlElementStart) temp).namespaces().get(0).uri(), is(""http://netty.io/netty/b""));

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlCharacters.class));
        assertThat(((XmlCharacters) temp).data(), is(""100""));

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlElementEnd.class));
        assertThat(((XmlElementEnd) temp).name(), is(""salary""));
        assertThat(((XmlElementEnd) temp).prefix(), is(""nettyb""));
        assertThat(((XmlElementEnd) temp).namespace(), is(""http://netty.io/netty/b""));
        assertThat(((XmlElementEnd) temp).namespaces().size(), is(1));
        assertThat(((XmlElementEnd) temp).namespaces().get(0).prefix(), is(""nettyb""));
        assertThat(((XmlElementEnd) temp).namespaces().get(0).uri(), is(""http://netty.io/netty/b""));

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlElementStart.class));
        assertThat(((XmlElementStart) temp).name(), is(""last""));
        assertThat(((XmlElementStart) temp).prefix(), is(""""));
        assertThat(((XmlElementStart) temp).namespace(), is(""""));
        assertThat(((XmlElementStart) temp).attributes().size(), is(0));
        assertThat(((XmlElementStart) temp).namespaces().size(), is(0));

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlElementEnd.class));
        assertThat(((XmlElementEnd) temp).name(), is(""last""));
        assertThat(((XmlElementEnd) temp).prefix(), is(""""));
        assertThat(((XmlElementEnd) temp).namespace(), is(""""));
        assertThat(((XmlElementEnd) temp).namespaces().size(), is(0));

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlElementEnd.class));
        assertThat(((XmlElementEnd) temp).name(), is(""employee""));
        assertThat(((XmlElementEnd) temp).prefix(), is(""""));
        assertThat(((XmlElementEnd) temp).namespace(), is(""""));
        assertThat(((XmlElementEnd) temp).namespaces().size(), is(1));
        assertThat(((XmlElementEnd) temp).namespaces().get(0).prefix(), is(""nettya""));
        assertThat(((XmlElementEnd) temp).namespaces().get(0).uri(), is(""http://netty.io/netty/a""));

        temp = channel.readInbound();
        assertThat(temp, nullValue());
    }
",non-flaky,5
118686,netty_netty,XmlDecoderTest.shouldDecodeXmlHeader,"    @Test
    public void shouldDecodeXmlHeader() {
        Object temp;

        write(XML3);

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlDocumentStart.class));
        assertThat(((XmlDocumentStart) temp).version(), is(""1.1""));
        assertThat(((XmlDocumentStart) temp).encoding(), is(""UTF-8""));
        assertThat(((XmlDocumentStart) temp).standalone(), is(true));
        assertThat(((XmlDocumentStart) temp).encodingScheme(), is(""UTF-8""));

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlElementStart.class));
        assertThat(((XmlElementStart) temp).name(), is(""netty""));
        assertThat(((XmlElementStart) temp).prefix(), is(""""));
        assertThat(((XmlElementStart) temp).namespace(), is(""""));
        assertThat(((XmlElementStart) temp).attributes().size(), is(0));
        assertThat(((XmlElementStart) temp).namespaces().size(), is(0));

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlElementEnd.class));
        assertThat(((XmlElementEnd) temp).name(), is(""netty""));
        assertThat(((XmlElementEnd) temp).prefix(), is(""""));
        assertThat(((XmlElementEnd) temp).namespace(), is(""""));
        assertThat(((XmlElementEnd) temp).namespaces().size(), is(0));

        temp = channel.readInbound();
        assertThat(temp, nullValue());
    }
",non-flaky,5
118687,netty_netty,XmlDecoderTest.shouldDecodeWithoutHeader,"    @Test
    public void shouldDecodeWithoutHeader() {
        Object temp;

        write(XML4);

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlDocumentStart.class));
        assertThat(((XmlDocumentStart) temp).version(), is(nullValue()));
        assertThat(((XmlDocumentStart) temp).encoding(), is(""UTF-8""));
        assertThat(((XmlDocumentStart) temp).standalone(), is(false));
        assertThat(((XmlDocumentStart) temp).encodingScheme(), is(nullValue()));

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlElementStart.class));
        assertThat(((XmlElementStart) temp).name(), is(""netty""));
        assertThat(((XmlElementStart) temp).prefix(), is(""""));
        assertThat(((XmlElementStart) temp).namespace(), is(""""));
        assertThat(((XmlElementStart) temp).attributes().size(), is(0));
        assertThat(((XmlElementStart) temp).namespaces().size(), is(0));

        temp = channel.readInbound();
        assertThat(temp, instanceOf(XmlElementEnd.class));
        assertThat(((XmlElementEnd) temp).name(), is(""netty""));
        assertThat(((XmlElementEnd) temp).prefix(), is(""""));
        assertThat(((XmlElementEnd) temp).namespace(), is(""""));
        assertThat(((XmlElementEnd) temp).namespaces().size(), is(0));

        temp = channel.readInbound();
        assertThat(temp, nullValue());
    }
",non-flaky,5
118688,netty_netty,SmtpCommandTest.getCommandFromCache,"    @Test
    public void getCommandFromCache() {
        assertSame(SmtpCommand.DATA, SmtpCommand.valueOf(""DATA""));
        assertSame(SmtpCommand.EHLO, SmtpCommand.valueOf(""EHLO""));
        assertNotSame(SmtpCommand.EHLO, SmtpCommand.valueOf(""ehlo""));
    }
",non-flaky,5
118689,netty_netty,SmtpCommandTest.equalsIgnoreCase,"    @Test
    public void equalsIgnoreCase() {
        assertEquals(SmtpCommand.MAIL, SmtpCommand.valueOf(""mail""));
        assertEquals(SmtpCommand.valueOf(""test""), SmtpCommand.valueOf(""TEST""));
    }
",non-flaky,5
118690,netty_netty,SmtpCommandTest.isContentExpected,"    @Test
    public void isContentExpected() {
        assertTrue(SmtpCommand.valueOf(""DATA"").isContentExpected());
        assertTrue(SmtpCommand.valueOf(""data"").isContentExpected());

        assertFalse(SmtpCommand.HELO.isContentExpected());
        assertFalse(SmtpCommand.HELP.isContentExpected());
        assertFalse(SmtpCommand.valueOf(""DATA2"").isContentExpected());
    }
",non-flaky,5
118691,netty_netty,SmtpRequestEncoderTest.testEncodeEhlo,"    @Test
    public void testEncodeEhlo() {
        testEncode(SmtpRequests.ehlo(""localhost""), ""EHLO localhost\r\n"");
    }
",non-flaky,5
118692,netty_netty,SmtpRequestEncoderTest.testEncodeHelo,"    @Test
    public void testEncodeHelo() {
        testEncode(SmtpRequests.helo(""localhost""), ""HELO localhost\r\n"");
    }
",non-flaky,5
118693,netty_netty,SmtpRequestEncoderTest.testEncodeMail,"    @Test
    public void testEncodeMail() {
        testEncode(SmtpRequests.mail(""me@netty.io""), ""MAIL FROM:<me@netty.io>\r\n"");
    }
",non-flaky,5
118694,netty_netty,SmtpRequestEncoderTest.testEncodeMailNullSender,"    @Test
    public void testEncodeMailNullSender() {
        testEncode(SmtpRequests.mail(null), ""MAIL FROM:<>\r\n"");
    }
",non-flaky,5
118695,netty_netty,SmtpRequestEncoderTest.testEncodeRcpt,"    @Test
    public void testEncodeRcpt() {
        testEncode(SmtpRequests.rcpt(""me@netty.io""), ""RCPT TO:<me@netty.io>\r\n"");
    }
",non-flaky,5
118696,netty_netty,SmtpRequestEncoderTest.testEncodeNoop,"    @Test
    public void testEncodeNoop() {
        testEncode(SmtpRequests.noop(), ""NOOP\r\n"");
    }
",non-flaky,5
118697,netty_netty,SmtpRequestEncoderTest.testEncodeRset,"    @Test
    public void testEncodeRset() {
        testEncode(SmtpRequests.rset(), ""RSET\r\n"");
    }
",non-flaky,5
118698,netty_netty,SmtpRequestEncoderTest.testEncodeHelp,"    @Test
    public void testEncodeHelp() {
        testEncode(SmtpRequests.help(null), ""HELP\r\n"");
    }
",non-flaky,5
118699,netty_netty,SmtpRequestEncoderTest.testEncodeHelpWithArg,"    @Test
    public void testEncodeHelpWithArg() {
        testEncode(SmtpRequests.help(""MAIL""), ""HELP MAIL\r\n"");
    }
",non-flaky,5
118700,netty_netty,SmtpRequestEncoderTest.testEncodeData,"    @Test
    public void testEncodeData() {
        testEncode(SmtpRequests.data(), ""DATA\r\n"");
    }
",non-flaky,5
118701,netty_netty,SmtpRequestEncoderTest.testEncodeDataAndContent,"    @Test
    public void testEncodeDataAndContent() {
        EmbeddedChannel channel = new EmbeddedChannel(new SmtpRequestEncoder());
        assertTrue(channel.writeOutbound(SmtpRequests.data()));
        assertTrue(channel.writeOutbound(
                new DefaultSmtpContent(Unpooled.copiedBuffer(""Subject: Test\r\n\r\n"", CharsetUtil.US_ASCII))));
        assertTrue(channel.writeOutbound(
                new DefaultLastSmtpContent(Unpooled.copiedBuffer(""Test\r\n"", CharsetUtil.US_ASCII))));
        assertTrue(channel.finish());

        assertEquals(""DATA\r\nSubject: Test\r\n\r\nTest\r\n.\r\n"", getWrittenString(channel));
    }
",non-flaky,5
118702,netty_netty,SmtpRequestEncoderTest.testThrowsIfContentExpected,"    @Test(expected = EncoderException.class)
    public void testThrowsIfContentExpected() {
        EmbeddedChannel channel = new EmbeddedChannel(new SmtpRequestEncoder());
        try {
            assertTrue(channel.writeOutbound(SmtpRequests.data()));
            channel.writeOutbound(SmtpRequests.noop());
        } finally {
            channel.finishAndReleaseAll();
        }
    }
",non-flaky,5
118703,netty_netty,SmtpRequestEncoderTest.testRsetClearsContentExpectedFlag,"    @Test
    public void testRsetClearsContentExpectedFlag() {
        EmbeddedChannel channel = new EmbeddedChannel(new SmtpRequestEncoder());

        assertTrue(channel.writeOutbound(SmtpRequests.data()));
        assertTrue(channel.writeOutbound(SmtpRequests.rset()));
        assertTrue(channel.writeOutbound(SmtpRequests.noop()));
        assertTrue(channel.finish());

        assertEquals(""DATA\r\nRSET\r\nNOOP\r\n"", getWrittenString(channel));
    }
",non-flaky,5
118704,netty_netty,SmtpResponseDecoderTest.testDecodeOneLineResponse,"    @Test
    public void testDecodeOneLineResponse() {
        EmbeddedChannel channel = newChannel();
        assertTrue(channel.writeInbound(newBuffer(""200 Ok\r\n"")));
        assertTrue(channel.finish());

        SmtpResponse response = channel.readInbound();
        assertEquals(200, response.code());
        List<CharSequence> sequences = response.details();
        assertEquals(1, sequences.size());

        assertEquals(""Ok"", sequences.get(0).toString());
        assertNull(channel.readInbound());
    }
",non-flaky,5
118705,netty_netty,SmtpResponseDecoderTest.testDecodeOneLineResponseNoDetails,"    @Test
    public void testDecodeOneLineResponseNoDetails() {
        EmbeddedChannel channel = newChannel();
        assertTrue(channel.writeInbound(newBuffer(""250 \r\n"")));
        assertTrue(channel.finish());

        SmtpResponse response = channel.readInbound();
        assertEquals(250, response.code());
        List<CharSequence> sequences = response.details();
        assertEquals(0, sequences.size());
    }
",non-flaky,5
118706,netty_netty,SmtpResponseDecoderTest.testDecodeOneLineResponseChunked,"    @Test
    public void testDecodeOneLineResponseChunked() {
        EmbeddedChannel channel = newChannel();
        assertFalse(channel.writeInbound(newBuffer(""200 Ok"")));
        assertTrue(channel.writeInbound(newBuffer(""\r\n"")));
        assertTrue(channel.finish());

        SmtpResponse response = channel.readInbound();
        assertEquals(200, response.code());
        List<CharSequence> sequences = response.details();
        assertEquals(1, sequences.size());

        assertEquals(""Ok"", sequences.get(0).toString());
        assertNull(channel.readInbound());
    }
",non-flaky,5
118707,netty_netty,SmtpResponseDecoderTest.testDecodeTwoLineResponse,"    @Test
    public void testDecodeTwoLineResponse() {
        EmbeddedChannel channel = newChannel();
        assertTrue(channel.writeInbound(newBuffer(""200-Hello\r\n200 Ok\r\n"")));
        assertTrue(channel.finish());

        SmtpResponse response = channel.readInbound();
        assertEquals(200, response.code());
        List<CharSequence> sequences = response.details();
        assertEquals(2, sequences.size());

        assertEquals(""Hello"", sequences.get(0).toString());
        assertEquals(""Ok"", sequences.get(1).toString());
        assertNull(channel.readInbound());
    }
",non-flaky,5
118708,netty_netty,SmtpResponseDecoderTest.testDecodeTwoLineResponseChunked,"    @Test
    public void testDecodeTwoLineResponseChunked() {
        EmbeddedChannel channel = newChannel();
        assertFalse(channel.writeInbound(newBuffer(""200-"")));
        assertFalse(channel.writeInbound(newBuffer(""Hello\r\n2"")));
        assertFalse(channel.writeInbound(newBuffer(""00 Ok"")));
        assertTrue(channel.writeInbound(newBuffer(""\r\n"")));
        assertTrue(channel.finish());

        SmtpResponse response = channel.readInbound();
        assertEquals(200, response.code());
        List<CharSequence> sequences = response.details();
        assertEquals(2, sequences.size());

        assertEquals(""Hello"", sequences.get(0).toString());
        assertEquals(""Ok"", sequences.get(1).toString());
        assertNull(channel.readInbound());
    }
",non-flaky,5
118709,netty_netty,SmtpResponseDecoderTest.testDecodeInvalidSeparator,"    @Test(expected = DecoderException.class)
    public void testDecodeInvalidSeparator() {
        EmbeddedChannel channel = newChannel();
        assertTrue(channel.writeInbound(newBuffer(""200:Ok\r\n"")));
    }
",non-flaky,5
118710,netty_netty,SmtpResponseDecoderTest.testDecodeInvalidCode,"    @Test(expected = DecoderException.class)
    public void testDecodeInvalidCode() {
        EmbeddedChannel channel = newChannel();
        assertTrue(channel.writeInbound(newBuffer(""xyz Ok\r\n"")));
    }
",non-flaky,5
118711,netty_netty,SmtpResponseDecoderTest.testDecodeInvalidLine,"    @Test(expected = DecoderException.class)
    public void testDecodeInvalidLine() {
        EmbeddedChannel channel = newChannel();
        assertTrue(channel.writeInbound(newBuffer(""Ok\r\n"")));
    }
",non-flaky,5
118712,netty_netty,UnixChannelUtilTest.testPooledAllocatorIsBufferCopyNeededForWrite,"    @Test
    public void testPooledAllocatorIsBufferCopyNeededForWrite() {
        testIsBufferCopyNeededForWrite(PooledByteBufAllocator.DEFAULT);
    }
",non-flaky,5
118713,netty_netty,UnixChannelUtilTest.testUnPooledAllocatorIsBufferCopyNeededForWrite,"    @Test
    public void testUnPooledAllocatorIsBufferCopyNeededForWrite() {
        testIsBufferCopyNeededForWrite(UnpooledByteBufAllocator.DEFAULT);
    }
",non-flaky,5
118714,netty_netty,SocketTest.testKeepAlive,"    @Test
    public void testKeepAlive() throws Exception {
        assertFalse(socket.isKeepAlive());
        socket.setKeepAlive(true);
        assertTrue(socket.isKeepAlive());
    }
",non-flaky,5
118715,netty_netty,SocketTest.testTcpNoDelay,"    @Test
    public void testTcpNoDelay() throws Exception {
        assertFalse(socket.isTcpNoDelay());
        socket.setTcpNoDelay(true);
        assertTrue(socket.isTcpNoDelay());
    }
",non-flaky,5
118716,netty_netty,SocketTest.testReceivedBufferSize,"    @Test
    public void testReceivedBufferSize() throws Exception {
        int size = socket.getReceiveBufferSize();
        int newSize = 65535;
        assertTrue(size > 0);
        socket.setReceiveBufferSize(newSize);
        // Linux usually set it to double what is specified
        assertTrue(newSize <= socket.getReceiveBufferSize());
    }
",non-flaky,5
118717,netty_netty,SocketTest.testSendBufferSize,"    @Test
    public void testSendBufferSize() throws Exception {
        int size = socket.getSendBufferSize();
        int newSize = 65535;
        assertTrue(size > 0);
        socket.setSendBufferSize(newSize);
        // Linux usually set it to double what is specified
        assertTrue(newSize <= socket.getSendBufferSize());
    }
",non-flaky,5
118718,netty_netty,SocketTest.testSoLinger,"    @Test
    public void testSoLinger() throws Exception {
        assertEquals(-1, socket.getSoLinger());
        socket.setSoLinger(10);
        assertEquals(10, socket.getSoLinger());
    }
",non-flaky,5
118719,netty_netty,SocketTest.testDoubleCloseDoesNotThrow,"    @Test
    public void testDoubleCloseDoesNotThrow() throws IOException {
        Socket socket = Socket.newSocketStream();
        socket.close();
        socket.close();
    }
",non-flaky,5
118720,netty_netty,SocketTest.testTrafficClass,"    @Test
    public void testTrafficClass() throws IOException {
        // IPTOS_THROUGHPUT
        final int value = 0x08;
        socket.setTrafficClass(value);
        assertEquals(value, socket.getTrafficClass());
    }
",non-flaky,5
118721,netty_netty,DetectPeerCloseWithoutReadTest.clientCloseWithoutServerReadIsDetectedNoExtraReadRequested,"    @Test(timeout = 10000)
    public void clientCloseWithoutServerReadIsDetectedNoExtraReadRequested() throws InterruptedException {
        clientCloseWithoutServerReadIsDetected0(false);
    }
",non-flaky,5
118722,netty_netty,DetectPeerCloseWithoutReadTest.clientCloseWithoutServerReadIsDetectedExtraReadRequested,"    @Test(timeout = 10000)
    public void clientCloseWithoutServerReadIsDetectedExtraReadRequested() throws InterruptedException {
        clientCloseWithoutServerReadIsDetected0(true);
    }
",non-flaky,5
118723,netty_netty,DetectPeerCloseWithoutReadTest.serverCloseWithoutClientReadIsDetectedNoExtraReadRequested,"    @Test(timeout = 10000)
    public void serverCloseWithoutClientReadIsDetectedNoExtraReadRequested() throws InterruptedException {
        serverCloseWithoutClientReadIsDetected0(false);
    }
",non-flaky,5
118724,netty_netty,DetectPeerCloseWithoutReadTest.serverCloseWithoutClientReadIsDetectedExtraReadRequested,"    @Test(timeout = 10000)
    public void serverCloseWithoutClientReadIsDetectedExtraReadRequested() throws InterruptedException {
        serverCloseWithoutClientReadIsDetected0(true);
    }
",non-flaky,5
118725,netty_netty,BigEndianCompositeByteBufTest.testInternalNioBufferAfterRelease,"    @Test(expected = UnsupportedOperationException.class)
    public void testInternalNioBufferAfterRelease() {
        super.testInternalNioBufferAfterRelease();
    }
",non-flaky,5
118726,netty_netty,ByteProcessorTest.testForward,"    @Test
    public void testForward() {
        final ByteBuf buf =
                Unpooled.copiedBuffer(""abc\r\n\ndef\r\rghi\n\njkl\0\0mno  \t\tx"", CharsetUtil.ISO_8859_1);
        final int length = buf.readableBytes();

        assertEquals(3,  buf.forEachByte(0,  length, ByteProcessor.FIND_CRLF));
        assertEquals(6,  buf.forEachByte(3,  length - 3, ByteProcessor.FIND_NON_CRLF));
        assertEquals(9,  buf.forEachByte(6,  length - 6, ByteProcessor.FIND_CR));
        assertEquals(11, buf.forEachByte(9,  length - 9, ByteProcessor.FIND_NON_CR));
        assertEquals(14, buf.forEachByte(11, length - 11, ByteProcessor.FIND_LF));
        assertEquals(16, buf.forEachByte(14, length - 14, ByteProcessor.FIND_NON_LF));
        assertEquals(19, buf.forEachByte(16, length - 16, ByteProcessor.FIND_NUL));
        assertEquals(21, buf.forEachByte(19, length - 19, ByteProcessor.FIND_NON_NUL));
        assertEquals(24, buf.forEachByte(19, length - 19, ByteProcessor.FIND_ASCII_SPACE));
        assertEquals(24, buf.forEachByte(21, length - 21, ByteProcessor.FIND_LINEAR_WHITESPACE));
        assertEquals(28, buf.forEachByte(24, length - 24, ByteProcessor.FIND_NON_LINEAR_WHITESPACE));
        assertEquals(-1, buf.forEachByte(28, length - 28, ByteProcessor.FIND_LINEAR_WHITESPACE));

        buf.release();
    }
",non-flaky,5
118727,netty_netty,ByteProcessorTest.testBackward,"    @Test
    public void testBackward() {
        final ByteBuf buf =
                Unpooled.copiedBuffer(""abc\r\n\ndef\r\rghi\n\njkl\0\0mno  \t\tx"", CharsetUtil.ISO_8859_1);
        final int length = buf.readableBytes();

        assertEquals(27, buf.forEachByteDesc(0, length, ByteProcessor.FIND_LINEAR_WHITESPACE));
        assertEquals(25, buf.forEachByteDesc(0, length, ByteProcessor.FIND_ASCII_SPACE));
        assertEquals(23, buf.forEachByteDesc(0, 28, ByteProcessor.FIND_NON_LINEAR_WHITESPACE));
        assertEquals(20, buf.forEachByteDesc(0, 24, ByteProcessor.FIND_NUL));
        assertEquals(18, buf.forEachByteDesc(0, 21, ByteProcessor.FIND_NON_NUL));
        assertEquals(15, buf.forEachByteDesc(0, 19, ByteProcessor.FIND_LF));
        assertEquals(13, buf.forEachByteDesc(0, 16, ByteProcessor.FIND_NON_LF));
        assertEquals(10, buf.forEachByteDesc(0, 14, ByteProcessor.FIND_CR));
        assertEquals(8,  buf.forEachByteDesc(0, 11, ByteProcessor.FIND_NON_CR));
        assertEquals(5,  buf.forEachByteDesc(0, 9, ByteProcessor.FIND_CRLF));
        assertEquals(2,  buf.forEachByteDesc(0, 6, ByteProcessor.FIND_NON_CRLF));
        assertEquals(-1, buf.forEachByteDesc(0, 3, ByteProcessor.FIND_CRLF));

        buf.release();
    }
",non-flaky,5
118728,netty_netty,BigEndianHeapByteBufTest.shouldNotAllowNullInConstructor1,"    @Test(expected = NullPointerException.class)
    public void shouldNotAllowNullInConstructor1() {
        new UnpooledHeapByteBuf(null, new byte[1], 0);
    }
",non-flaky,5
118729,netty_netty,BigEndianHeapByteBufTest.shouldNotAllowNullInConstructor2,"    @Test(expected = NullPointerException.class)
    public void shouldNotAllowNullInConstructor2() {
        new UnpooledHeapByteBuf(UnpooledByteBufAllocator.DEFAULT, null, 0);
    }
",non-flaky,5
118730,netty_netty,EmptyByteBufTest.testIsWritable,"    @Test
    public void testIsWritable() {
        EmptyByteBuf empty = new EmptyByteBuf(UnpooledByteBufAllocator.DEFAULT);
        assertFalse(empty.isWritable());
        assertFalse(empty.isWritable(1));
    }
",non-flaky,5
118731,netty_netty,EmptyByteBufTest.testWriteEmptyByteBuf,"    @Test
    public void testWriteEmptyByteBuf() {
        EmptyByteBuf empty = new EmptyByteBuf(UnpooledByteBufAllocator.DEFAULT);
        empty.writeBytes(Unpooled.EMPTY_BUFFER); // Ok
        ByteBuf nonEmpty = UnpooledByteBufAllocator.DEFAULT.buffer().writeBoolean(false);
        try {
            empty.writeBytes(nonEmpty);
            fail();
        } catch (IndexOutOfBoundsException ignored) {
            // Ignore.
        } finally {
            nonEmpty.release();
        }
    }
",non-flaky,5
118732,netty_netty,EmptyByteBufTest.testIsReadable,"    @Test
    public void testIsReadable() {
        EmptyByteBuf empty = new EmptyByteBuf(UnpooledByteBufAllocator.DEFAULT);
        assertFalse(empty.isReadable());
        assertFalse(empty.isReadable(1));
    }
",non-flaky,5
118733,netty_netty,EmptyByteBufTest.testArray,"    @Test
    public void testArray() {
        EmptyByteBuf empty = new EmptyByteBuf(UnpooledByteBufAllocator.DEFAULT);
        assertThat(empty.hasArray(), is(true));
        assertThat(empty.array().length, is(0));
        assertThat(empty.arrayOffset(), is(0));
    }
",non-flaky,5
118734,netty_netty,EmptyByteBufTest.testNioBuffer,"    @Test
    public void testNioBuffer() {
        EmptyByteBuf empty = new EmptyByteBuf(UnpooledByteBufAllocator.DEFAULT);
        assertThat(empty.nioBufferCount(), is(1));
        assertThat(empty.nioBuffer().position(), is(0));
        assertThat(empty.nioBuffer().limit(), is(0));
        assertThat(empty.nioBuffer(), is(sameInstance(empty.nioBuffer())));
        assertThat(empty.nioBuffer(), is(sameInstance(empty.internalNioBuffer(empty.readerIndex(), 0))));
    }
",non-flaky,5
118735,netty_netty,EmptyByteBufTest.testMemoryAddress,"    @Test
    public void testMemoryAddress() {
        EmptyByteBuf empty = new EmptyByteBuf(UnpooledByteBufAllocator.DEFAULT);
        if (empty.hasMemoryAddress()) {
            assertThat(empty.memoryAddress(), is(not(0L)));
        } else {
            try {
                empty.memoryAddress();
                fail();
            } catch (UnsupportedOperationException ignored) {
                // Ignore.
            }
        }
    }
",non-flaky,5
118736,netty_netty,EmptyByteBufTest.consistentEqualsAndHashCodeWithAbstractBytebuf,"    @Test
    public void consistentEqualsAndHashCodeWithAbstractBytebuf() {
        ByteBuf empty = new EmptyByteBuf(UnpooledByteBufAllocator.DEFAULT);
        ByteBuf emptyAbstract = new UnpooledHeapByteBuf(UnpooledByteBufAllocator.DEFAULT, 0, 0);
        assertEquals(emptyAbstract, empty);
        assertEquals(emptyAbstract.hashCode(), empty.hashCode());
        assertEquals(EmptyByteBuf.EMPTY_BYTE_BUF_HASH_CODE, empty.hashCode());
        assertTrue(emptyAbstract.release());
        assertFalse(empty.release());
    }
",non-flaky,5
118737,netty_netty,ByteBufUtilTest.decodeRandomHexBytesWithEvenLength,"    @Test
    public void decodeRandomHexBytesWithEvenLength() {
        decodeRandomHexBytes(256);
    }
",non-flaky,5
118738,netty_netty,ByteBufUtilTest.decodeRandomHexBytesWithOddLength,"    @Test
    public void decodeRandomHexBytesWithOddLength() {
        decodeRandomHexBytes(257);
    }
",non-flaky,5
118739,netty_netty,ByteBufUtilTest.decodeHexDumpWithOddLength,"    @Test(expected = IllegalArgumentException.class)
    public void decodeHexDumpWithOddLength() {
        ByteBufUtil.decodeHexDump(""abc"");
    }
",non-flaky,5
118740,netty_netty,ByteBufUtilTest.decodeHexDumpWithInvalidChar,"    @Test(expected = IllegalArgumentException.class)
    public void decodeHexDumpWithInvalidChar() {
        ByteBufUtil.decodeHexDump(""fg"");
    }
",non-flaky,5
118741,netty_netty,ByteBufUtilTest.equalsBufferSubsections,"    @Test
    public void equalsBufferSubsections() {
        byte[] b1 = new byte[128];
        byte[] b2 = new byte[256];
        Random rand = new Random();
        rand.nextBytes(b1);
        rand.nextBytes(b2);
        final int iB1 = b1.length / 2;
        final int iB2 = iB1 + b1.length;
        final int length = b1.length - iB1;
        System.arraycopy(b1, iB1, b2, iB2, length);
        assertTrue(ByteBufUtil.equals(Unpooled.wrappedBuffer(b1), iB1, Unpooled.wrappedBuffer(b2), iB2, length));
    }
",non-flaky,5
118742,netty_netty,ByteBufUtilTest.notEqualsBufferSubsections,"    @Test
    public void notEqualsBufferSubsections() {
        byte[] b1 = new byte[50];
        byte[] b2 = new byte[256];
        Random rand = new Random();
        rand.nextBytes(b1);
        rand.nextBytes(b2);
        final int iB1 = b1.length / 2;
        final int iB2 = iB1 + b1.length;
        final int length = b1.length - iB1;
        System.arraycopy(b1, iB1, b2, iB2, length);
        // Randomly pick an index in the range that will be compared and make the value at that index differ between
        // the 2 arrays.
        int diffIndex = random(rand, iB1, iB1 + length - 1);
        ++b1[diffIndex];
        assertFalse(ByteBufUtil.equals(Unpooled.wrappedBuffer(b1), iB1, Unpooled.wrappedBuffer(b2), iB2, length));
    }
",non-flaky,5
118743,netty_netty,ByteBufUtilTest.notEqualsBufferOverflow,"    @Test
    public void notEqualsBufferOverflow() {
        byte[] b1 = new byte[8];
        byte[] b2 = new byte[16];
        Random rand = new Random();
        rand.nextBytes(b1);
        rand.nextBytes(b2);
        final int iB1 = b1.length / 2;
        final int iB2 = iB1 + b1.length;
        final int length = b1.length - iB1;
        System.arraycopy(b1, iB1, b2, iB2, length - 1);
        assertFalse(ByteBufUtil.equals(Unpooled.wrappedBuffer(b1), iB1, Unpooled.wrappedBuffer(b2), iB2,
                Math.max(b1.length, b2.length) * 2));
    }
",non-flaky,5
118744,netty_netty,ByteBufUtilTest.notEqualsBufferUnderflow,"    @Test (expected = IllegalArgumentException.class)
    public void notEqualsBufferUnderflow() {
        byte[] b1 = new byte[8];
        byte[] b2 = new byte[16];
        Random rand = new Random();
        rand.nextBytes(b1);
        rand.nextBytes(b2);
        final int iB1 = b1.length / 2;
        final int iB2 = iB1 + b1.length;
        final int length = b1.length - iB1;
        System.arraycopy(b1, iB1, b2, iB2, length - 1);
        assertFalse(ByteBufUtil.equals(Unpooled.wrappedBuffer(b1), iB1, Unpooled.wrappedBuffer(b2), iB2,
                -1));
    }
",non-flaky,5
118745,netty_netty,ByteBufUtilTest.writeShortBE,"    @Test
    public void writeShortBE() {
        int expected = 0x1234;

        ByteBuf buf = Unpooled.buffer(2).order(ByteOrder.BIG_ENDIAN);
        ByteBufUtil.writeShortBE(buf, expected);
        assertEquals(expected, buf.readShort());
        buf.resetReaderIndex();
        assertEquals(ByteBufUtil.swapShort((short) expected), buf.readShortLE());
        buf.release();

        buf = Unpooled.buffer(2).order(ByteOrder.LITTLE_ENDIAN);
        ByteBufUtil.writeShortBE(buf, expected);
        assertEquals((short) expected, buf.readShortLE());
        buf.resetReaderIndex();
        assertEquals(ByteBufUtil.swapShort((short) expected), buf.readShort());
        buf.release();
    }
",non-flaky,5
118746,netty_netty,ByteBufUtilTest.setShortBE,"    @Test
    public void setShortBE() {
        int shortValue = 0x1234;

        ByteBuf buf = Unpooled.wrappedBuffer(new byte[2]).order(ByteOrder.BIG_ENDIAN);
        ByteBufUtil.setShortBE(buf, 0, shortValue);
        assertEquals(shortValue, buf.readShort());
        buf.resetReaderIndex();
        assertEquals(ByteBufUtil.swapShort((short) shortValue), buf.readShortLE());
        buf.release();

        buf = Unpooled.wrappedBuffer(new byte[2]).order(ByteOrder.LITTLE_ENDIAN);
        ByteBufUtil.setShortBE(buf, 0, shortValue);
        assertEquals((short) shortValue, buf.readShortLE());
        buf.resetReaderIndex();
        assertEquals(ByteBufUtil.swapShort((short) shortValue), buf.readShort());
        buf.release();
    }
",non-flaky,5
118747,netty_netty,ByteBufUtilTest.writeMediumBE,"    @Test
    public void writeMediumBE() {
        int mediumValue = 0x123456;

        ByteBuf buf = Unpooled.buffer(4).order(ByteOrder.BIG_ENDIAN);
        ByteBufUtil.writeMediumBE(buf, mediumValue);
        assertEquals(mediumValue, buf.readMedium());
        buf.resetReaderIndex();
        assertEquals(ByteBufUtil.swapMedium(mediumValue), buf.readMediumLE());
        buf.release();

        buf = Unpooled.buffer(4).order(ByteOrder.LITTLE_ENDIAN);
        ByteBufUtil.writeMediumBE(buf, mediumValue);
        assertEquals(mediumValue, buf.readMediumLE());
        buf.resetReaderIndex();
        assertEquals(ByteBufUtil.swapMedium(mediumValue), buf.readMedium());
        buf.release();
    }
",non-flaky,5
118748,netty_netty,ByteBufUtilTest.testWriteUsAscii,"    @Test
    public void testWriteUsAscii() {
        String usAscii = ""NettyRocks"";
        ByteBuf buf = Unpooled.buffer(16);
        buf.writeBytes(usAscii.getBytes(CharsetUtil.US_ASCII));
        ByteBuf buf2 = Unpooled.buffer(16);
        ByteBufUtil.writeAscii(buf2, usAscii);

        assertEquals(buf, buf2);

        buf.release();
        buf2.release();
    }
",non-flaky,5
118749,netty_netty,ByteBufUtilTest.testWriteUsAsciiSwapped,"    @Test
    public void testWriteUsAsciiSwapped() {
        String usAscii = ""NettyRocks"";
        ByteBuf buf = Unpooled.buffer(16);
        buf.writeBytes(usAscii.getBytes(CharsetUtil.US_ASCII));
        SwappedByteBuf buf2 = new SwappedByteBuf(Unpooled.buffer(16));
        ByteBufUtil.writeAscii(buf2, usAscii);

        assertEquals(buf, buf2);

        buf.release();
        buf2.release();
    }
",non-flaky,5
118750,netty_netty,ByteBufUtilTest.testWriteUsAsciiWrapped,"    @Test
    public void testWriteUsAsciiWrapped() {
        String usAscii = ""NettyRocks"";
        ByteBuf buf = unreleasableBuffer(Unpooled.buffer(16));
        assertWrapped(buf);
        buf.writeBytes(usAscii.getBytes(CharsetUtil.US_ASCII));
        ByteBuf buf2 = unreleasableBuffer(Unpooled.buffer(16));
        assertWrapped(buf2);
        ByteBufUtil.writeAscii(buf2, usAscii);

        assertEquals(buf, buf2);

        buf.unwrap().release();
        buf2.unwrap().release();
    }
",non-flaky,5
118751,netty_netty,ByteBufUtilTest.testWriteUsAsciiComposite,"    @Test
    public void testWriteUsAsciiComposite() {
        String usAscii = ""NettyRocks"";
        ByteBuf buf = Unpooled.buffer(16);
        buf.writeBytes(usAscii.getBytes(CharsetUtil.US_ASCII));
        ByteBuf buf2 = Unpooled.compositeBuffer().addComponent(
                Unpooled.buffer(8)).addComponent(Unpooled.buffer(24));
        // write some byte so we start writing with an offset.
        buf2.writeByte(1);
        ByteBufUtil.writeAscii(buf2, usAscii);

        // Skip the previously written byte.
        assertEquals(buf, buf2.skipBytes(1));

        buf.release();
        buf2.release();
    }
",non-flaky,5
118752,netty_netty,ByteBufUtilTest.testWriteUsAsciiCompositeWrapped,"    @Test
    public void testWriteUsAsciiCompositeWrapped() {
        String usAscii = ""NettyRocks"";
        ByteBuf buf = Unpooled.buffer(16);
        buf.writeBytes(usAscii.getBytes(CharsetUtil.US_ASCII));
        ByteBuf buf2 = new WrappedCompositeByteBuf(Unpooled.compositeBuffer().addComponent(
                Unpooled.buffer(8)).addComponent(Unpooled.buffer(24)));
        // write some byte so we start writing with an offset.
        buf2.writeByte(1);
        ByteBufUtil.writeAscii(buf2, usAscii);

        // Skip the previously written byte.
        assertEquals(buf, buf2.skipBytes(1));

        buf.release();
        buf2.release();
    }
",non-flaky,5
118753,netty_netty,ByteBufUtilTest.testWriteUtf8,"    @Test
    public void testWriteUtf8() {
        String usAscii = ""Some UTF-8 like "";
        ByteBuf buf = Unpooled.buffer(16);
        buf.writeBytes(usAscii.getBytes(CharsetUtil.UTF_8));
        ByteBuf buf2 = Unpooled.buffer(16);
        ByteBufUtil.writeUtf8(buf2, usAscii);

        assertEquals(buf, buf2);

        buf.release();
        buf2.release();
    }
",non-flaky,5
118754,netty_netty,ByteBufUtilTest.testWriteUtf8Composite,"    @Test
    public void testWriteUtf8Composite() {
        String utf8 = ""Some UTF-8 like "";
        ByteBuf buf = Unpooled.buffer(16);
        buf.writeBytes(utf8.getBytes(CharsetUtil.UTF_8));
        ByteBuf buf2 = Unpooled.compositeBuffer().addComponent(
                Unpooled.buffer(8)).addComponent(Unpooled.buffer(24));
        // write some byte so we start writing with an offset.
        buf2.writeByte(1);
        ByteBufUtil.writeUtf8(buf2, utf8);

        // Skip the previously written byte.
        assertEquals(buf, buf2.skipBytes(1));

        buf.release();
        buf2.release();
    }
",non-flaky,5
118755,netty_netty,ByteBufUtilTest.testWriteUtf8CompositeWrapped,"    @Test
    public void testWriteUtf8CompositeWrapped() {
        String utf8 = ""Some UTF-8 like "";
        ByteBuf buf = Unpooled.buffer(16);
        buf.writeBytes(utf8.getBytes(CharsetUtil.UTF_8));
        ByteBuf buf2 = new WrappedCompositeByteBuf(Unpooled.compositeBuffer().addComponent(
                Unpooled.buffer(8)).addComponent(Unpooled.buffer(24)));
        // write some byte so we start writing with an offset.
        buf2.writeByte(1);
        ByteBufUtil.writeUtf8(buf2, utf8);

        // Skip the previously written byte.
        assertEquals(buf, buf2.skipBytes(1));

        buf.release();
        buf2.release();
    }
",non-flaky,5
118756,netty_netty,ByteBufUtilTest.testWriteUtf8Surrogates,"    @Test
    public void testWriteUtf8Surrogates() {
        // leading surrogate + trailing surrogate
        String surrogateString = new StringBuilder(2)
                                .append('a')
                                .append('\uD800')
                                .append('\uDC00')
                                .append('b')
                                .toString();
        ByteBuf buf = Unpooled.buffer(16);
        buf.writeBytes(surrogateString.getBytes(CharsetUtil.UTF_8));
        ByteBuf buf2 = Unpooled.buffer(16);
        ByteBufUtil.writeUtf8(buf2, surrogateString);

        assertEquals(buf, buf2);
        assertEquals(buf.readableBytes(), ByteBufUtil.utf8Bytes(surrogateString));

        buf.release();
        buf2.release();
    }
",non-flaky,5
118757,netty_netty,ByteBufUtilTest.testWriteUtf8InvalidOnlyTrailingSurrogate,"    @Test
    public void testWriteUtf8InvalidOnlyTrailingSurrogate() {
        String surrogateString = new StringBuilder(2)
                                .append('a')
                                .append('\uDC00')
                                .append('b')
                                .toString();
        ByteBuf buf = Unpooled.buffer(16);
        buf.writeBytes(surrogateString.getBytes(CharsetUtil.UTF_8));
        ByteBuf buf2 = Unpooled.buffer(16);
        ByteBufUtil.writeUtf8(buf2, surrogateString);

        assertEquals(buf, buf2);
        assertEquals(buf.readableBytes(), ByteBufUtil.utf8Bytes(surrogateString));

        buf.release();
        buf2.release();
    }
",non-flaky,5
118758,netty_netty,ByteBufUtilTest.testWriteUtf8InvalidOnlyLeadingSurrogate,"    @Test
    public void testWriteUtf8InvalidOnlyLeadingSurrogate() {
        String surrogateString = new StringBuilder(2)
                                .append('a')
                                .append('\uD800')
                                .append('b')
                                .toString();
        ByteBuf buf = Unpooled.buffer(16);
        buf.writeBytes(surrogateString.getBytes(CharsetUtil.UTF_8));
        ByteBuf buf2 = Unpooled.buffer(16);
        ByteBufUtil.writeUtf8(buf2, surrogateString);

        assertEquals(buf, buf2);
        assertEquals(buf.readableBytes(), ByteBufUtil.utf8Bytes(surrogateString));

        buf.release();
        buf2.release();
    }
",non-flaky,5
118759,netty_netty,ByteBufUtilTest.testWriteUtf8InvalidSurrogatesSwitched,"    @Test
    public void testWriteUtf8InvalidSurrogatesSwitched() {
        String surrogateString = new StringBuilder(2)
                                .append('a')
                                .append('\uDC00')
                                .append('\uD800')
                                .append('b')
                                .toString();
        ByteBuf buf = Unpooled.buffer(16);
        buf.writeBytes(surrogateString.getBytes(CharsetUtil.UTF_8));
        ByteBuf buf2 = Unpooled.buffer(16);
        ByteBufUtil.writeUtf8(buf2, surrogateString);

        assertEquals(buf, buf2);
        assertEquals(buf.readableBytes(), ByteBufUtil.utf8Bytes(surrogateString));

        buf.release();
        buf2.release();
    }
",non-flaky,5
118760,netty_netty,ByteBufUtilTest.testWriteUtf8InvalidTwoLeadingSurrogates,"    @Test
    public void testWriteUtf8InvalidTwoLeadingSurrogates() {
        String surrogateString = new StringBuilder(2)
                                .append('a')
                                .append('\uD800')
                                .append('\uD800')
                                .append('b')
                                .toString();
        ByteBuf buf = Unpooled.buffer(16);
        buf.writeBytes(surrogateString.getBytes(CharsetUtil.UTF_8));
        ByteBuf buf2 = Unpooled.buffer(16);
        ByteBufUtil.writeUtf8(buf2, surrogateString);

        assertEquals(buf, buf2);
        assertEquals(buf.readableBytes(), ByteBufUtil.utf8Bytes(surrogateString));
        buf.release();
        buf2.release();
    }
",non-flaky,5
118761,netty_netty,ByteBufUtilTest.testWriteUtf8InvalidTwoTrailingSurrogates,"    @Test
    public void testWriteUtf8InvalidTwoTrailingSurrogates() {
        String surrogateString = new StringBuilder(2)
                                .append('a')
                                .append('\uDC00')
                                .append('\uDC00')
                                .append('b')
                                .toString();
        ByteBuf buf = Unpooled.buffer(16);
        buf.writeBytes(surrogateString.getBytes(CharsetUtil.UTF_8));
        ByteBuf buf2 = Unpooled.buffer(16);
        ByteBufUtil.writeUtf8(buf2, surrogateString);

        assertEquals(buf, buf2);
        assertEquals(buf.readableBytes(), ByteBufUtil.utf8Bytes(surrogateString));

        buf.release();
        buf2.release();
    }
",non-flaky,5
118762,netty_netty,ByteBufUtilTest.testWriteUtf8InvalidEndOnLeadingSurrogate,"    @Test
    public void testWriteUtf8InvalidEndOnLeadingSurrogate() {
        String surrogateString = new StringBuilder(2)
                                .append('\uD800')
                                .toString();
        ByteBuf buf = Unpooled.buffer(16);
        buf.writeBytes(surrogateString.getBytes(CharsetUtil.UTF_8));
        ByteBuf buf2 = Unpooled.buffer(16);
        ByteBufUtil.writeUtf8(buf2, surrogateString);

        assertEquals(buf, buf2);
        assertEquals(buf.readableBytes(), ByteBufUtil.utf8Bytes(surrogateString));

        buf.release();
        buf2.release();
    }
",non-flaky,5
118763,netty_netty,ByteBufUtilTest.testWriteUtf8InvalidEndOnTrailingSurrogate,"    @Test
    public void testWriteUtf8InvalidEndOnTrailingSurrogate() {
        String surrogateString = new StringBuilder(2)
                                .append('\uDC00')
                                .toString();
        ByteBuf buf = Unpooled.buffer(16);
        buf.writeBytes(surrogateString.getBytes(CharsetUtil.UTF_8));
        ByteBuf buf2 = Unpooled.buffer(16);
        ByteBufUtil.writeUtf8(buf2, surrogateString);

        assertEquals(buf, buf2);
        assertEquals(buf.readableBytes(), ByteBufUtil.utf8Bytes(surrogateString));

        buf.release();
        buf2.release();
    }
",non-flaky,5
118764,netty_netty,ByteBufUtilTest.testWriteUsAsciiString,"    @Test
    public void testWriteUsAsciiString() {
        AsciiString usAscii = new AsciiString(""NettyRocks"");
        ByteBuf buf = Unpooled.buffer(16);
        buf.writeBytes(usAscii.toString().getBytes(CharsetUtil.US_ASCII));
        ByteBuf buf2 = Unpooled.buffer(16);
        ByteBufUtil.writeAscii(buf2, usAscii);

        assertEquals(buf, buf2);

        buf.release();
        buf2.release();
    }
",non-flaky,5
118765,netty_netty,ByteBufUtilTest.testWriteUtf8Wrapped,"    @Test
    public void testWriteUtf8Wrapped() {
        String usAscii = ""Some UTF-8 like "";
        ByteBuf buf = unreleasableBuffer(Unpooled.buffer(16));
        assertWrapped(buf);
        buf.writeBytes(usAscii.getBytes(CharsetUtil.UTF_8));
        ByteBuf buf2 = unreleasableBuffer(Unpooled.buffer(16));
        assertWrapped(buf2);
        ByteBufUtil.writeUtf8(buf2, usAscii);

        assertEquals(buf, buf2);

        buf.release();
        buf2.release();
    }
",non-flaky,5
118766,netty_netty,ByteBufUtilTest.testDecodeUsAscii,"    @Test
    public void testDecodeUsAscii() {
        testDecodeString(""This is a test"", CharsetUtil.US_ASCII);
    }
",non-flaky,5
118767,netty_netty,ByteBufUtilTest.testDecodeUtf8,"    @Test
    public void testDecodeUtf8() {
        testDecodeString(""Some UTF-8 like "", CharsetUtil.UTF_8);
    }
",non-flaky,5
118768,netty_netty,ByteBufUtilTest.testToStringDoesNotThrowIndexOutOfBounds,"    @Test
    public void testToStringDoesNotThrowIndexOutOfBounds() {
        CompositeByteBuf buffer = Unpooled.compositeBuffer();
        try {
            byte[] bytes = ""1234"".getBytes(CharsetUtil.UTF_8);
            buffer.addComponent(Unpooled.buffer(bytes.length).writeBytes(bytes));
            buffer.addComponent(Unpooled.buffer(bytes.length).writeBytes(bytes));
            assertEquals(""1234"", buffer.toString(bytes.length, bytes.length, CharsetUtil.UTF_8));
        } finally {
            buffer.release();
        }
    }
",non-flaky,5
118769,netty_netty,ByteBufUtilTest.testIsTextWithUtf8,"    @Test
    public void testIsTextWithUtf8() {
        byte[][] validUtf8Bytes = {
                ""netty"".getBytes(CharsetUtil.UTF_8),
                {(byte) 0x24},
                {(byte) 0xC2, (byte) 0xA2},
                {(byte) 0xE2, (byte) 0x82, (byte) 0xAC},
                {(byte) 0xF0, (byte) 0x90, (byte) 0x8D, (byte) 0x88},
                {(byte) 0x24,
                        (byte) 0xC2, (byte) 0xA2,
                        (byte) 0xE2, (byte) 0x82, (byte) 0xAC,
                        (byte) 0xF0, (byte) 0x90, (byte) 0x8D, (byte) 0x88} // multiple characters
        };
        for (byte[] bytes : validUtf8Bytes) {
            assertIsText(bytes, true, CharsetUtil.UTF_8);
        }
        byte[][] invalidUtf8Bytes = {
                {(byte) 0x80},
                {(byte) 0xF0, (byte) 0x82, (byte) 0x82, (byte) 0xAC}, // Overlong encodings
                {(byte) 0xC2},                                        // not enough bytes
                {(byte) 0xE2, (byte) 0x82},                           // not enough bytes
                {(byte) 0xF0, (byte) 0x90, (byte) 0x8D},              // not enough bytes
                {(byte) 0xC2, (byte) 0xC0},                           // not correct bytes
                {(byte) 0xE2, (byte) 0x82, (byte) 0xC0},              // not correct bytes
                {(byte) 0xF0, (byte) 0x90, (byte) 0x8D, (byte) 0xC0}, // not correct bytes
                {(byte) 0xC1, (byte) 0x80},                           // out of lower bound
                {(byte) 0xE0, (byte) 0x80, (byte) 0x80},              // out of lower bound
                {(byte) 0xED, (byte) 0xAF, (byte) 0x80}               // out of upper bound
        };
        for (byte[] bytes : invalidUtf8Bytes) {
            assertIsText(bytes, false, CharsetUtil.UTF_8);
        }
    }
",non-flaky,5
118770,netty_netty,ByteBufUtilTest.testIsTextWithoutOptimization,"    @Test
    public void testIsTextWithoutOptimization() {
        byte[] validBytes = {(byte) 0x01, (byte) 0xD8, (byte) 0x37, (byte) 0xDC};
        byte[] invalidBytes = {(byte) 0x01, (byte) 0xD8};

        assertIsText(validBytes, true, CharsetUtil.UTF_16LE);
        assertIsText(invalidBytes, false, CharsetUtil.UTF_16LE);
    }
",non-flaky,5
118771,netty_netty,ByteBufUtilTest.testIsTextWithAscii,"    @Test
    public void testIsTextWithAscii() {
        byte[] validBytes = {(byte) 0x00, (byte) 0x01, (byte) 0x37, (byte) 0x7F};
        byte[] invalidBytes = {(byte) 0x80, (byte) 0xFF};

        assertIsText(validBytes, true, CharsetUtil.US_ASCII);
        assertIsText(invalidBytes, false, CharsetUtil.US_ASCII);
    }
",non-flaky,5
118772,netty_netty,ByteBufUtilTest.testIsTextWithInvalidIndexAndLength,"    @Test
    public void testIsTextWithInvalidIndexAndLength() {
        ByteBuf buffer = Unpooled.buffer();
        try {
            buffer.writeBytes(new byte[4]);
            int[][] validIndexLengthPairs = {
                    {4, 0},
                    {0, 4},
                    {1, 3},
            };
            for (int[] pair : validIndexLengthPairs) {
                assertTrue(ByteBufUtil.isText(buffer, pair[0], pair[1], CharsetUtil.US_ASCII));
            }
            int[][] invalidIndexLengthPairs = {
                    {4, 1},
                    {-1, 2},
                    {3, -1},
                    {3, -2},
                    {5, 0},
                    {1, 5},
            };
            for (int[] pair : invalidIndexLengthPairs) {
                try {
                    ByteBufUtil.isText(buffer, pair[0], pair[1], CharsetUtil.US_ASCII);
                    fail(""Expected IndexOutOfBoundsException"");
                } catch (IndexOutOfBoundsException e) {
                    // expected
                }
            }
        } finally {
            buffer.release();
        }
    }
",non-flaky,5
118773,netty_netty,ByteBufUtilTest.testUtf8Bytes,"    @Test
    public void testUtf8Bytes() {
        final String s = ""Some UTF-8 like "";
        checkUtf8Bytes(s);
    }
",non-flaky,5
118774,netty_netty,ByteBufUtilTest.testUtf8BytesWithSurrogates,"    @Test
    public void testUtf8BytesWithSurrogates() {
        final String s = ""a\uD800\uDC00b"";
        checkUtf8Bytes(s);
    }
",non-flaky,5
118775,netty_netty,ByteBufUtilTest.testUtf8BytesWithNonSurrogates3Bytes,"    @Test
    public void testUtf8BytesWithNonSurrogates3Bytes() {
        final String s = ""a\uE000b"";
        checkUtf8Bytes(s);
    }
",non-flaky,5
118776,netty_netty,ByteBufUtilTest.testUtf8BytesWithNonSurrogatesNonAscii,"    @Test
    public void testUtf8BytesWithNonSurrogatesNonAscii() {
        final char nonAscii = (char) 0x81;
        final String s = ""a"" + nonAscii + ""b"";
        checkUtf8Bytes(s);
    }
",non-flaky,5
118777,netty_netty,ByteBufUtilTest.run,"    @Test
    public void testIsTextMultiThreaded() throws Throwable {
        final ByteBuf buffer = Unpooled.copiedBuffer(""Hello, World!"", CharsetUtil.ISO_8859_1);

        try {
            final AtomicInteger counter = new AtomicInteger(60000);
            final AtomicReference<Throwable> errorRef = new AtomicReference<Throwable>();
            List<Thread> threads = new ArrayList<Thread>();
            for (int i = 0; i < 10; i++) {
                Thread thread = new Thread(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            while (errorRef.get() == null && counter.decrementAndGet() > 0) {
                                assertTrue(ByteBufUtil.isText(buffer, CharsetUtil.ISO_8859_1));
                            }
                        } catch (Throwable cause) {
                            errorRef.compareAndSet(null, cause);
                        }
                    }
",non-flaky,5
118778,netty_netty,AbstractReferenceCountedByteBufTest.testRetainOverflow,"    @Test(expected = IllegalReferenceCountException.class)
    public void testRetainOverflow() {
        AbstractReferenceCountedByteBuf referenceCounted = newReferenceCounted();
        referenceCounted.setRefCnt(Integer.MAX_VALUE);
        assertEquals(Integer.MAX_VALUE, referenceCounted.refCnt());
        referenceCounted.retain();
    }
",non-flaky,5
118779,netty_netty,AbstractReferenceCountedByteBufTest.testRetainOverflow2,"    @Test(expected = IllegalReferenceCountException.class)
    public void testRetainOverflow2() {
        AbstractReferenceCountedByteBuf referenceCounted = newReferenceCounted();
        assertEquals(1, referenceCounted.refCnt());
        referenceCounted.retain(Integer.MAX_VALUE);
    }
",non-flaky,5
118780,netty_netty,AbstractReferenceCountedByteBufTest.testReleaseOverflow,"    @Test(expected = IllegalReferenceCountException.class)
    public void testReleaseOverflow() {
        AbstractReferenceCountedByteBuf referenceCounted = newReferenceCounted();
        referenceCounted.setRefCnt(0);
        assertEquals(0, referenceCounted.refCnt());
        referenceCounted.release(Integer.MAX_VALUE);
    }
",non-flaky,5
118781,netty_netty,AbstractReferenceCountedByteBufTest.testReleaseErrorMessage,"    @Test
    public void testReleaseErrorMessage() {
        AbstractReferenceCountedByteBuf referenceCounted = newReferenceCounted();
        assertTrue(referenceCounted.release());
        try {
            referenceCounted.release(1);
            fail(""IllegalReferenceCountException didn't occur"");
        } catch (IllegalReferenceCountException e) {
            assertEquals(""refCnt: 0, decrement: 1"", e.getMessage());
        }
    }
",non-flaky,5
118782,netty_netty,AbstractReferenceCountedByteBufTest.testRetainResurrect,"    @Test(expected = IllegalReferenceCountException.class)
    public void testRetainResurrect() {
        AbstractReferenceCountedByteBuf referenceCounted = newReferenceCounted();
        assertTrue(referenceCounted.release());
        assertEquals(0, referenceCounted.refCnt());
        referenceCounted.retain();
    }
",non-flaky,5
118783,netty_netty,AbstractReferenceCountedByteBufTest.testRetainResurrect2,"    @Test(expected = IllegalReferenceCountException.class)
    public void testRetainResurrect2() {
        AbstractReferenceCountedByteBuf referenceCounted = newReferenceCounted();
        assertTrue(referenceCounted.release());
        assertEquals(0, referenceCounted.refCnt());
        referenceCounted.retain(2);
    }
",non-flaky,5
118784,netty_netty,ReadOnlyByteBufferBufTest.testCopyDirect,"    @Test
    public void testCopyDirect() {
        testCopy(true);
    }
",non-flaky,5
136452,kiwiproject_dropwizard-service-utilities,StandardExceptionMappersTest.setRegisterDefaultExceptionMappers,"        @Test
                public void setRegisterDefaultExceptionMappers(Boolean registerDefaultExceptionMappers) {
                    assertThat(registerDefaultExceptionMappers).isFalse();
                }
",non-flaky,5
136453,kiwiproject_dropwizard-service-utilities,StandardExceptionMappersTest.build,"        @Test
                public Server build(Environment environment) {
                    return null;
                }
",non-flaky,5
136454,kiwiproject_dropwizard-service-utilities,StandardExceptionMappersTest.setRegisterDefaultExceptionMappers,"        @Test
                public void setRegisterDefaultExceptionMappers(Boolean registerDefaultExceptionMappers) {
                    assertThat(registerDefaultExceptionMappers).isFalse();
                }
",non-flaky,5
136455,kiwiproject_dropwizard-service-utilities,StandardExceptionMappersTest.setRegisterDefaultExceptionMappers,"        @Test
                public void setRegisterDefaultExceptionMappers(Boolean registerDefaultExceptionMappers) {
                    throw new RuntimeException(""oops"");
                }
",non-flaky,5
136456,kiwiproject_dropwizard-service-utilities,StandardExceptionMappersTest.setRegisterDefaultExceptionMappers,"        @Test
                public void setRegisterDefaultExceptionMappers(Boolean registerDefaultExceptionMappers) {
                    assertThat(registerDefaultExceptionMappers).isFalse();
                }
",non-flaky,5
136457,kiwiproject_dropwizard-service-utilities,DropwizardConnectorsTest.build,"        @Test
                public Connector build(Server server, MetricRegistry metricRegistry, String s, ThreadPool threadPool) {
                    return null;
                }
",non-flaky,5
136458,kiwiproject_dropwizard-service-utilities,DropwizardConnectorsTest.build,"        @Test
                public Connector build(Server server, MetricRegistry metricRegistry, String s, ThreadPool threadPool) {
                    return null;
                }
",non-flaky,5
136459,kiwiproject_dropwizard-service-utilities,MonitoredJobTest.handle,"        @Test
                public void handle(MonitoredJob job, Exception exception) {
                    taskHandledCount.incrementAndGet();
                }
",non-flaky,5
136460,kiwiproject_dropwizard-service-utilities,MonitoredJobTest.handle,"        @Test
                public void handle(MonitoredJob job, Exception exception) {
                    throw new RuntimeException(""error handling error"");
                }
",non-flaky,5
137071,spring-projects_spring-framework,PropertiesMarshallerTests.readWrite,"	@Test
	public void readWrite() throws IOException {
		CandidateComponentsMetadata metadata = new CandidateComponentsMetadata();
		metadata.add(createItem(""com.foo"", ""first"", ""second""));
		metadata.add(createItem(""com.bar"", ""first""));

		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		PropertiesMarshaller.write(metadata, outputStream);
		CandidateComponentsMetadata readMetadata = PropertiesMarshaller.read(
				new ByteArrayInputStream(outputStream.toByteArray()));
		assertThat(readMetadata).has(Metadata.of(""com.foo"", ""first"", ""second""));
		assertThat(readMetadata).has(Metadata.of(""com.bar"", ""first""));
		assertThat(readMetadata.getItems()).hasSize(2);
	}
",non-flaky,5
137072,spring-projects_spring-framework,PropertiesMarshallerTests.metadataIsWrittenDeterministically,"	@Test
	public void metadataIsWrittenDeterministically() throws IOException {
		CandidateComponentsMetadata metadata = new CandidateComponentsMetadata();
		metadata.add(createItem(""com.b"", ""type""));
		metadata.add(createItem(""com.c"", ""type""));
		metadata.add(createItem(""com.a"", ""type""));

		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		PropertiesMarshaller.write(metadata, outputStream);
		String contents = new String(outputStream.toByteArray(), StandardCharsets.ISO_8859_1);
		assertThat(contents.split(System.lineSeparator())).containsExactly(""com.a=type"", ""com.b=type"", ""com.c=type"");
	}
",non-flaky,5
137073,spring-projects_spring-framework,BridgeMethodResolverTests.someMethod,"	@Test  // SPR-16103
		public void someMethod(Integer theArg, Object otherArg) {
		}
",non-flaky,5
137074,spring-projects_spring-framework,ResolvableTypeTests.getResolvableType,"	@Test
		public ResolvableType getResolvableType() {
			if (this.type == null) {
				return null;
			}
			return ResolvableType.forClassWithGenerics(getClass(), this.type);
		}
",non-flaky,5
137075,spring-projects_spring-framework,AbstractAnnotationMetadataTests.verifyEquals,"	@Test
	public void verifyEquals() throws Exception {
		AnnotationMetadata testClass1 = get(TestClass.class);
		AnnotationMetadata testClass2 = get(TestClass.class);
		AnnotationMetadata testMemberClass1 = get(TestMemberClass.class);
		AnnotationMetadata testMemberClass2 = get(TestMemberClass.class);

		assertThat(testClass1.equals(null)).isFalse();

		assertThat(testClass1.equals(testClass1)).isTrue();
		assertThat(testClass2.equals(testClass2)).isTrue();
		assertThat(testClass1.equals(testClass2)).isTrue();
		assertThat(testClass2.equals(testClass1)).isTrue();

		assertThat(testMemberClass1.equals(testMemberClass1)).isTrue();
		assertThat(testMemberClass2.equals(testMemberClass2)).isTrue();
		assertThat(testMemberClass1.equals(testMemberClass2)).isTrue();
		assertThat(testMemberClass2.equals(testMemberClass1)).isTrue();

		assertThat(testClass1.equals(testMemberClass1)).isFalse();
		assertThat(testMemberClass1.equals(testClass1)).isFalse();
	}
",non-flaky,5
137076,spring-projects_spring-framework,AbstractAnnotationMetadataTests.verifyHashCode,"	@Test
	public void verifyHashCode() throws Exception {
		AnnotationMetadata testClass1 = get(TestClass.class);
		AnnotationMetadata testClass2 = get(TestClass.class);
		AnnotationMetadata testMemberClass1 = get(TestMemberClass.class);
		AnnotationMetadata testMemberClass2 = get(TestMemberClass.class);

		assertThat(testClass1).hasSameHashCodeAs(testClass2);
		assertThat(testMemberClass1).hasSameHashCodeAs(testMemberClass2);

		assertThat(testClass1).doesNotHaveSameHashCodeAs(testMemberClass1);
	}
",non-flaky,5
137077,spring-projects_spring-framework,AbstractAnnotationMetadataTests.verifyToString,"	@Test
	public void verifyToString() throws Exception {
		assertThat(get(TestClass.class).toString()).isEqualTo(TestClass.class.getName());
	}
",non-flaky,5
137078,spring-projects_spring-framework,AbstractAnnotationMetadataTests.getClassNameReturnsClassName,"	@Test
	public void getClassNameReturnsClassName() {
		assertThat(get(TestClass.class).getClassName()).isEqualTo(TestClass.class.getName());
	}
",non-flaky,5
137079,spring-projects_spring-framework,AbstractAnnotationMetadataTests.isInterfaceWhenInterfaceReturnsTrue,"	@Test
	public void isInterfaceWhenInterfaceReturnsTrue() {
		assertThat(get(TestInterface.class).isInterface()).isTrue();
		assertThat(get(TestAnnotation.class).isInterface()).isTrue();
	}
",non-flaky,5
137080,spring-projects_spring-framework,AbstractAnnotationMetadataTests.isInterfaceWhenNotInterfaceReturnsFalse,"	@Test
	public void isInterfaceWhenNotInterfaceReturnsFalse() {
		assertThat(get(TestClass.class).isInterface()).isFalse();
	}
",non-flaky,5
137081,spring-projects_spring-framework,AbstractAnnotationMetadataTests.isAnnotationWhenAnnotationReturnsTrue,"	@Test
	public void isAnnotationWhenAnnotationReturnsTrue() {
		assertThat(get(TestAnnotation.class).isAnnotation()).isTrue();
	}
",non-flaky,5
137082,spring-projects_spring-framework,AbstractAnnotationMetadataTests.isAnnotationWhenNotAnnotationReturnsFalse,"	@Test
	public void isAnnotationWhenNotAnnotationReturnsFalse() {
		assertThat(get(TestClass.class).isAnnotation()).isFalse();
		assertThat(get(TestInterface.class).isAnnotation()).isFalse();
	}
",non-flaky,5
137083,spring-projects_spring-framework,AbstractAnnotationMetadataTests.isFinalWhenFinalReturnsTrue,"	@Test
	public void isFinalWhenFinalReturnsTrue() {
		assertThat(get(TestFinalClass.class).isFinal()).isTrue();
	}
",non-flaky,5
137084,spring-projects_spring-framework,AbstractAnnotationMetadataTests.isFinalWhenNonFinalReturnsFalse,"	@Test
	public void isFinalWhenNonFinalReturnsFalse() {
		assertThat(get(TestClass.class).isFinal()).isFalse();
	}
",non-flaky,5
137085,spring-projects_spring-framework,AbstractAnnotationMetadataTests.isIndependentWhenIndependentReturnsTrue,"	@Test
	public void isIndependentWhenIndependentReturnsTrue() {
		assertThat(get(AbstractAnnotationMetadataTests.class).isIndependent()).isTrue();
		assertThat(get(TestClass.class).isIndependent()).isTrue();
	}
",non-flaky,5
137086,spring-projects_spring-framework,AbstractAnnotationMetadataTests.isIndependentWhenNotIndependentReturnsFalse,"	@Test
	public void isIndependentWhenNotIndependentReturnsFalse() {
		assertThat(get(TestNonStaticInnerClass.class).isIndependent()).isFalse();
	}
",non-flaky,5
137087,spring-projects_spring-framework,AbstractAnnotationMetadataTests.getEnclosingClassNameWhenHasEnclosingClassReturnsEnclosingClass,"	@Test
	public void getEnclosingClassNameWhenHasEnclosingClassReturnsEnclosingClass() {
		assertThat(get(TestClass.class).getEnclosingClassName()).isEqualTo(
				AbstractAnnotationMetadataTests.class.getName());
	}
",non-flaky,5
137088,spring-projects_spring-framework,AbstractAnnotationMetadataTests.getEnclosingClassNameWhenHasNoEnclosingClassReturnsNull,"	@Test
	public void getEnclosingClassNameWhenHasNoEnclosingClassReturnsNull() {
		assertThat(get(AbstractAnnotationMetadataTests.class).getEnclosingClassName()).isNull();
	}
",non-flaky,5
137089,spring-projects_spring-framework,AbstractAnnotationMetadataTests.getSuperClassNameWhenHasSuperClassReturnsName,"	@Test
	public void getSuperClassNameWhenHasSuperClassReturnsName() {
		assertThat(get(TestSubclass.class).getSuperClassName()).isEqualTo(TestClass.class.getName());
		assertThat(get(TestClass.class).getSuperClassName()).isEqualTo(Object.class.getName());
	}
",non-flaky,5
137090,spring-projects_spring-framework,AbstractAnnotationMetadataTests.getSuperClassNameWhenHasNoSuperClassReturnsNull,"	@Test
	public void getSuperClassNameWhenHasNoSuperClassReturnsNull() {
		assertThat(get(Object.class).getSuperClassName()).isNull();
		assertThat(get(TestInterface.class).getSuperClassName()).isNull();
		assertThat(get(TestSubInterface.class).getSuperClassName()).isNull();
	}
",non-flaky,5
137091,spring-projects_spring-framework,AbstractAnnotationMetadataTests.getInterfaceNamesWhenHasInterfacesReturnsNames,"	@Test
	public void getInterfaceNamesWhenHasInterfacesReturnsNames() {
		assertThat(get(TestSubclass.class).getInterfaceNames()).containsExactlyInAnyOrder(TestInterface.class.getName());
		assertThat(get(TestSubInterface.class).getInterfaceNames()).containsExactlyInAnyOrder(TestInterface.class.getName());
	}
",non-flaky,5
137092,spring-projects_spring-framework,AbstractAnnotationMetadataTests.getInterfaceNamesWhenHasNoInterfacesReturnsEmptyArray,"	@Test
	public void getInterfaceNamesWhenHasNoInterfacesReturnsEmptyArray() {
		assertThat(get(TestClass.class).getInterfaceNames()).isEmpty();
	}
",non-flaky,5
137093,spring-projects_spring-framework,AbstractAnnotationMetadataTests.getMemberClassNamesWhenHasMemberClassesReturnsNames,"	@Test
	public void getMemberClassNamesWhenHasMemberClassesReturnsNames() {
		assertThat(get(TestMemberClass.class).getMemberClassNames()).containsExactlyInAnyOrder(
			TestMemberClassInnerClass.class.getName(), TestMemberClassInnerInterface.class.getName());
	}
",non-flaky,5
137094,spring-projects_spring-framework,AbstractAnnotationMetadataTests.getMemberClassNamesWhenHasNoMemberClassesReturnsEmptyArray,"	@Test
	public void getMemberClassNamesWhenHasNoMemberClassesReturnsEmptyArray() {
		assertThat(get(TestClass.class).getMemberClassNames()).isEmpty();
	}
",non-flaky,5
137095,spring-projects_spring-framework,AbstractAnnotationMetadataTests.getAnnotationsReturnsDirectAnnotations,"	@Test
	public void getAnnotationsReturnsDirectAnnotations() {
		assertThat(get(WithDirectAnnotations.class).getAnnotations().stream())
			.filteredOn(MergedAnnotation::isDirectlyPresent)
			.extracting(a -> a.getType().getName())
			.containsExactlyInAnyOrder(DirectAnnotation1.class.getName(), DirectAnnotation2.class.getName());
	}
",non-flaky,5
137096,spring-projects_spring-framework,AbstractAnnotationMetadataTests.isAnnotatedWhenMatchesDirectAnnotationReturnsTrue,"	@Test
	public void isAnnotatedWhenMatchesDirectAnnotationReturnsTrue() {
		assertThat(get(WithDirectAnnotations.class).isAnnotated(DirectAnnotation1.class.getName())).isTrue();
	}
",non-flaky,5
137097,spring-projects_spring-framework,AbstractAnnotationMetadataTests.isAnnotatedWhenMatchesMetaAnnotationReturnsTrue,"	@Test
	public void isAnnotatedWhenMatchesMetaAnnotationReturnsTrue() {
		assertThat(get(WithMetaAnnotations.class).isAnnotated(MetaAnnotation2.class.getName())).isTrue();
	}
",non-flaky,5
137098,spring-projects_spring-framework,AbstractAnnotationMetadataTests.isAnnotatedWhenDoesNotMatchDirectOrMetaAnnotationReturnsFalse,"	@Test
	public void isAnnotatedWhenDoesNotMatchDirectOrMetaAnnotationReturnsFalse() {
		assertThat(get(TestClass.class).isAnnotated(DirectAnnotation1.class.getName())).isFalse();
	}
",non-flaky,5
137099,spring-projects_spring-framework,AbstractAnnotationMetadataTests.getAnnotationAttributesReturnsAttributes,"	@Test
	public void getAnnotationAttributesReturnsAttributes() {
		assertThat(get(WithAnnotationAttributes.class).getAnnotationAttributes(AnnotationAttributes.class.getName()))
			.containsOnly(entry(""name"", ""test""), entry(""size"", 1));
	}
",non-flaky,5
137100,spring-projects_spring-framework,AbstractAnnotationMetadataTests.getAllAnnotationAttributesReturnsAllAttributes,"	@Test
	public void getAllAnnotationAttributesReturnsAllAttributes() {
		MultiValueMap<String, Object> attributes =
				get(WithMetaAnnotationAttributes.class).getAllAnnotationAttributes(AnnotationAttributes.class.getName());
		assertThat(attributes).containsOnlyKeys(""name"", ""size"");
		assertThat(attributes.get(""name"")).containsExactlyInAnyOrder(""m1"", ""m2"");
		assertThat(attributes.get(""size"")).containsExactlyInAnyOrder(1, 2);
	}
",non-flaky,5
137101,spring-projects_spring-framework,AbstractAnnotationMetadataTests.getAnnotationTypesReturnsDirectAnnotations,"	@Test
	public void getAnnotationTypesReturnsDirectAnnotations() {
		AnnotationMetadata metadata = get(WithDirectAnnotations.class);
		assertThat(metadata.getAnnotationTypes()).containsExactlyInAnyOrder(
				DirectAnnotation1.class.getName(), DirectAnnotation2.class.getName());
	}
",non-flaky,5
137102,spring-projects_spring-framework,AbstractAnnotationMetadataTests.getMetaAnnotationTypesReturnsMetaAnnotations,"	@Test
	public void getMetaAnnotationTypesReturnsMetaAnnotations() {
		AnnotationMetadata metadata = get(WithMetaAnnotations.class);
		assertThat(metadata.getMetaAnnotationTypes(MetaAnnotationRoot.class.getName()))
			.containsExactlyInAnyOrder(MetaAnnotation1.class.getName(), MetaAnnotation2.class.getName());
	}
",non-flaky,5
137103,spring-projects_spring-framework,AbstractAnnotationMetadataTests.hasAnnotationWhenMatchesDirectAnnotationReturnsTrue,"	@Test
	public void hasAnnotationWhenMatchesDirectAnnotationReturnsTrue() {
		assertThat(get(WithDirectAnnotations.class).hasAnnotation(DirectAnnotation1.class.getName())).isTrue();
	}
",non-flaky,5
137104,spring-projects_spring-framework,AbstractAnnotationMetadataTests.hasAnnotationWhenMatchesMetaAnnotationReturnsFalse,"	@Test
	public void hasAnnotationWhenMatchesMetaAnnotationReturnsFalse() {
		assertThat(get(WithMetaAnnotations.class).hasAnnotation(MetaAnnotation1.class.getName())).isFalse();
		assertThat(get(WithMetaAnnotations.class).hasAnnotation(MetaAnnotation2.class.getName())).isFalse();
	}
",non-flaky,5
137105,spring-projects_spring-framework,AbstractAnnotationMetadataTests.hasAnnotationWhenDoesNotMatchDirectOrMetaAnnotationReturnsFalse,"	@Test
	public void hasAnnotationWhenDoesNotMatchDirectOrMetaAnnotationReturnsFalse() {
		assertThat(get(TestClass.class).hasAnnotation(DirectAnnotation1.class.getName())).isFalse();
	}
",non-flaky,5
137106,spring-projects_spring-framework,AbstractAnnotationMetadataTests.hasMetaAnnotationWhenMatchesDirectReturnsFalse,"	@Test
	public void hasMetaAnnotationWhenMatchesDirectReturnsFalse() {
		assertThat(get(WithDirectAnnotations.class).hasMetaAnnotation(DirectAnnotation1.class.getName())).isFalse();
	}
",non-flaky,5
137107,spring-projects_spring-framework,AbstractAnnotationMetadataTests.hasMetaAnnotationWhenMatchesMetaAnnotationReturnsTrue,"	@Test
	public void hasMetaAnnotationWhenMatchesMetaAnnotationReturnsTrue() {
		assertThat(get(WithMetaAnnotations.class).hasMetaAnnotation(MetaAnnotation1.class.getName())).isTrue();
		assertThat(get(WithMetaAnnotations.class).hasMetaAnnotation(MetaAnnotation2.class.getName())).isTrue();
	}
",non-flaky,5
137108,spring-projects_spring-framework,AbstractAnnotationMetadataTests.hasMetaAnnotationWhenDoesNotMatchDirectOrMetaAnnotationReturnsFalse,"	@Test
	public void hasMetaAnnotationWhenDoesNotMatchDirectOrMetaAnnotationReturnsFalse() {
		assertThat(get(TestClass.class).hasMetaAnnotation(MetaAnnotation1.class.getName())).isFalse();
	}
",non-flaky,5
137109,spring-projects_spring-framework,AbstractAnnotationMetadataTests.hasAnnotatedMethodsWhenMatchesDirectAnnotationReturnsTrue,"	@Test
	public void hasAnnotatedMethodsWhenMatchesDirectAnnotationReturnsTrue() {
		assertThat(get(WithAnnotatedMethod.class).hasAnnotatedMethods(DirectAnnotation1.class.getName())).isTrue();
	}
",non-flaky,5
137110,spring-projects_spring-framework,AbstractAnnotationMetadataTests.hasAnnotatedMethodsWhenMatchesMetaAnnotationReturnsTrue,"	@Test
	public void hasAnnotatedMethodsWhenMatchesMetaAnnotationReturnsTrue() {
		assertThat(get(WithMetaAnnotatedMethod.class).hasAnnotatedMethods(MetaAnnotation2.class.getName())).isTrue();
	}
",non-flaky,5
137111,spring-projects_spring-framework,AbstractAnnotationMetadataTests.hasAnnotatedMethodsWhenDoesNotMatchAnyAnnotationReturnsFalse,"	@Test
	public void hasAnnotatedMethodsWhenDoesNotMatchAnyAnnotationReturnsFalse() {
		assertThat(get(WithAnnotatedMethod.class).hasAnnotatedMethods(MetaAnnotation2.class.getName())).isFalse();
		assertThat(get(WithNonAnnotatedMethod.class).hasAnnotatedMethods(DirectAnnotation1.class.getName())).isFalse();
	}
",non-flaky,5
137112,spring-projects_spring-framework,AbstractAnnotationMetadataTests.getAnnotatedMethodsReturnsMatchingAnnotatedAndMetaAnnotatedMethods,"	@Test
	public void getAnnotatedMethodsReturnsMatchingAnnotatedAndMetaAnnotatedMethods() {
		assertThat(get(WithDirectAndMetaAnnotatedMethods.class).getAnnotatedMethods(MetaAnnotation2.class.getName()))
			.extracting(MethodMetadata::getMethodName)
			.containsExactlyInAnyOrder(""direct"", ""meta"");
	}
",non-flaky,5
137113,spring-projects_spring-framework,AnnotationMetadataTests.doSleep,"		public void doWork(@TestQualifier(""myColor"") java.awt.Color color) {
		public void doSleep() {
		}
",non-flaky,5
137114,spring-projects_spring-framework,AbstractMethodMetadataTests.verifyEquals,"	@Test
	public void verifyEquals() throws Exception {
		MethodMetadata withMethod1 = getTagged(WithMethod.class);
		MethodMetadata withMethod2 = getTagged(WithMethod.class);
		MethodMetadata withMethodWithTwoArguments1 = getTagged(WithMethodWithTwoArguments.class);
		MethodMetadata withMethodWithTwoArguments2 = getTagged(WithMethodWithTwoArguments.class);

		assertThat(withMethod1.equals(null)).isFalse();

		assertThat(withMethod1.equals(withMethod1)).isTrue();
		assertThat(withMethod2.equals(withMethod2)).isTrue();
		assertThat(withMethod1.equals(withMethod2)).isTrue();
		assertThat(withMethod2.equals(withMethod1)).isTrue();

		assertThat(withMethodWithTwoArguments1.equals(withMethodWithTwoArguments1)).isTrue();
		assertThat(withMethodWithTwoArguments2.equals(withMethodWithTwoArguments2)).isTrue();
		assertThat(withMethodWithTwoArguments1.equals(withMethodWithTwoArguments2)).isTrue();
		assertThat(withMethodWithTwoArguments2.equals(withMethodWithTwoArguments1)).isTrue();

		assertThat(withMethod1.equals(withMethodWithTwoArguments1)).isFalse();
		assertThat(withMethodWithTwoArguments1.equals(withMethod1)).isFalse();
	}
",non-flaky,5
137115,spring-projects_spring-framework,AbstractMethodMetadataTests.verifyHashCode,"	@Test
	public void verifyHashCode() throws Exception {
		MethodMetadata withMethod1 = getTagged(WithMethod.class);
		MethodMetadata withMethod2 = getTagged(WithMethod.class);
		MethodMetadata withMethodWithTwoArguments1 = getTagged(WithMethodWithTwoArguments.class);
		MethodMetadata withMethodWithTwoArguments2 = getTagged(WithMethodWithTwoArguments.class);

		assertThat(withMethod1).hasSameHashCodeAs(withMethod2);
		assertThat(withMethodWithTwoArguments1).hasSameHashCodeAs(withMethodWithTwoArguments2);

		assertThat(withMethod1).doesNotHaveSameHashCodeAs(withMethodWithTwoArguments1);
	}
",non-flaky,5
137116,spring-projects_spring-framework,AbstractMethodMetadataTests.verifyToString,"	@Test
	public void verifyToString() throws Exception {
		assertThat(getTagged(WithMethod.class).toString())
			.endsWith(WithMethod.class.getName() + "".test()"");

		assertThat(getTagged(WithMethodWithOneArgument.class).toString())
			.endsWith(WithMethodWithOneArgument.class.getName() + "".test(java.lang.String)"");

		assertThat(getTagged(WithMethodWithTwoArguments.class).toString())
			.endsWith(WithMethodWithTwoArguments.class.getName() + "".test(java.lang.String,java.lang.Integer)"");
	}
",non-flaky,5
137117,spring-projects_spring-framework,AbstractMethodMetadataTests.getMethodNameReturnsMethodName,"	@Test
	public void getMethodNameReturnsMethodName() {
		assertThat(getTagged(WithMethod.class).getMethodName()).isEqualTo(""test"");
	}
",non-flaky,5
137118,spring-projects_spring-framework,AbstractMethodMetadataTests.getDeclaringClassReturnsDeclaringClass,"	@Test
	public void getDeclaringClassReturnsDeclaringClass() {
		assertThat(getTagged(WithMethod.class).getDeclaringClassName()).isEqualTo(
				WithMethod.class.getName());
	}
",non-flaky,5
137119,spring-projects_spring-framework,AbstractMethodMetadataTests.getReturnTypeReturnsReturnType,"	@Test
	public void getReturnTypeReturnsReturnType() {
		assertThat(getTagged(WithMethod.class).getReturnTypeName()).isEqualTo(
				String.class.getName());
	}
",non-flaky,5
137120,spring-projects_spring-framework,AbstractMethodMetadataTests.isAbstractWhenAbstractReturnsTrue,"	@Test
	public void isAbstractWhenAbstractReturnsTrue() {
		assertThat(getTagged(WithAbstractMethod.class).isAbstract()).isTrue();
	}
",non-flaky,5
137121,spring-projects_spring-framework,AbstractMethodMetadataTests.isAbstractWhenNotAbstractReturnsFalse,"	@Test
	public void isAbstractWhenNotAbstractReturnsFalse() {
		assertThat(getTagged(WithMethod.class).isAbstract()).isFalse();
	}
",non-flaky,5
137122,spring-projects_spring-framework,AbstractMethodMetadataTests.isStatusWhenStaticReturnsTrue,"	@Test
	public void isStatusWhenStaticReturnsTrue() {
		assertThat(getTagged(WithStaticMethod.class).isStatic()).isTrue();
	}
",non-flaky,5
137123,spring-projects_spring-framework,AbstractMethodMetadataTests.isStaticWhenNotStaticReturnsFalse,"	@Test
	public void isStaticWhenNotStaticReturnsFalse() {
		assertThat(getTagged(WithMethod.class).isStatic()).isFalse();
	}
",non-flaky,5
137124,spring-projects_spring-framework,AbstractMethodMetadataTests.isFinalWhenFinalReturnsTrue,"	@Test
	public void isFinalWhenFinalReturnsTrue() {
		assertThat(getTagged(WithFinalMethod.class).isFinal()).isTrue();
	}
",non-flaky,5
137125,spring-projects_spring-framework,AbstractMethodMetadataTests.isFinalWhenNonFinalReturnsFalse,"	@Test
	public void isFinalWhenNonFinalReturnsFalse() {
		assertThat(getTagged(WithMethod.class).isFinal()).isFalse();
	}
",non-flaky,5
137126,spring-projects_spring-framework,AbstractMethodMetadataTests.isOverridableWhenOverridableReturnsTrue,"	@Test
	public void isOverridableWhenOverridableReturnsTrue() {
		assertThat(getTagged(WithMethod.class).isOverridable()).isTrue();
	}
",non-flaky,5
137127,spring-projects_spring-framework,AbstractMethodMetadataTests.isOverridableWhenNonOverridableReturnsFalse,"	@Test
	public void isOverridableWhenNonOverridableReturnsFalse() {
		assertThat(getTagged(WithStaticMethod.class).isOverridable()).isFalse();
		assertThat(getTagged(WithFinalMethod.class).isOverridable()).isFalse();
		assertThat(getTagged(WithPrivateMethod.class).isOverridable()).isFalse();
	}
",non-flaky,5
137128,spring-projects_spring-framework,AbstractMethodMetadataTests.getAnnotationsReturnsDirectAnnotations,"	@Test
	public void getAnnotationsReturnsDirectAnnotations() {
		MethodMetadata metadata = getTagged(WithDirectAnnotation.class);
		assertThat(metadata.getAnnotations().stream().filter(
				MergedAnnotation::isDirectlyPresent).map(
						a -> a.getType().getName())).containsExactlyInAnyOrder(
								Tag.class.getName(),
								DirectAnnotation.class.getName());
	}
",non-flaky,5
137129,spring-projects_spring-framework,AbstractMethodMetadataTests.isAnnotatedWhenMatchesDirectAnnotationReturnsTrue,"	@Test
	public void isAnnotatedWhenMatchesDirectAnnotationReturnsTrue() {
		assertThat(getTagged(WithDirectAnnotation.class).isAnnotated(
				DirectAnnotation.class.getName())).isTrue();
	}
",non-flaky,5
137130,spring-projects_spring-framework,AbstractMethodMetadataTests.isAnnotatedWhenMatchesMetaAnnotationReturnsTrue,"	@Test
	public void isAnnotatedWhenMatchesMetaAnnotationReturnsTrue() {
		assertThat(getTagged(WithMetaAnnotation.class).isAnnotated(
				DirectAnnotation.class.getName())).isTrue();
	}
",non-flaky,5
137131,spring-projects_spring-framework,AbstractMethodMetadataTests.isAnnotatedWhenDoesNotMatchDirectOrMetaAnnotationReturnsFalse,"	@Test
	public void isAnnotatedWhenDoesNotMatchDirectOrMetaAnnotationReturnsFalse() {
		assertThat(getTagged(WithMethod.class).isAnnotated(
				DirectAnnotation.class.getName())).isFalse();
	}
",non-flaky,5
137132,spring-projects_spring-framework,AbstractMethodMetadataTests.getAnnotationAttributesReturnsAttributes,"	@Test
	public void getAnnotationAttributesReturnsAttributes() {
		assertThat(getTagged(WithAnnotationAttributes.class).getAnnotationAttributes(
				AnnotationAttributes.class.getName())).containsOnly(entry(""name"", ""test""),
						entry(""size"", 1));
	}
",non-flaky,5
137133,spring-projects_spring-framework,AbstractMethodMetadataTests.getAllAnnotationAttributesReturnsAllAttributes,"	@Test
	public void getAllAnnotationAttributesReturnsAllAttributes() {
		MultiValueMap<String, Object> attributes = getTagged(
				WithMetaAnnotationAttributes.class).getAllAnnotationAttributes(
						AnnotationAttributes.class.getName());
		assertThat(attributes).containsOnlyKeys(""name"", ""size"");
		assertThat(attributes.get(""name"")).containsExactlyInAnyOrder(""m1"", ""m2"");
		assertThat(attributes.get(""size"")).containsExactlyInAnyOrder(1, 2);
	}
",non-flaky,5
137134,spring-projects_spring-framework,AbstractMethodMetadataTests.metadataLoadsForNestedAnnotations,"	@Test // gh-24375
	public void metadataLoadsForNestedAnnotations() {
		AnnotationMetadata annotationMetadata = get(AnnotatedComponent.class);
		assertThat(annotationMetadata.getAnnotationTypes()).containsExactly(EnclosingAnnotation.class.getName());
	}
",non-flaky,5
137135,spring-projects_spring-framework,MergedAnnotationMetadataVisitorTests.visitAnnotation,"	@Test
			public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
				return MergedAnnotationReadingVisitor.get(getClass().getClassLoader(),
						null, descriptor, visible,
						annotation -> MergedAnnotationMetadataVisitorTests.this.annotation = annotation);
			}
",non-flaky,5
137136,spring-projects_spring-framework,AnnotationMetadataReadingVisitorTests.verifyEquals,"	@Test
	public void verifyEquals() throws Exception {
	}
",non-flaky,5
137137,spring-projects_spring-framework,AnnotationMetadataReadingVisitorTests.verifyHashCode,"	@Test
	public void verifyHashCode() throws Exception {
	}
",non-flaky,5
137138,spring-projects_spring-framework,AnnotationMetadataReadingVisitorTests.verifyToString,"	@Test
	public void verifyToString() {
	}
",non-flaky,5
137139,spring-projects_spring-framework,AnnotationMetadataReadingVisitorTests.getAnnotationsReturnsDirectAnnotations,"	@Test
	public void getAnnotationsReturnsDirectAnnotations() {
		assertThatExceptionOfType(UnsupportedOperationException.class)
			.isThrownBy(super::getAnnotationsReturnsDirectAnnotations);
	}
",non-flaky,5
137140,spring-projects_spring-framework,MethodMetadataReadingVisitorTests.verifyEquals,"	@Test
	public void verifyEquals() throws Exception {
	}
",non-flaky,5
137141,spring-projects_spring-framework,MethodMetadataReadingVisitorTests.verifyHashCode,"	@Test
	public void verifyHashCode() throws Exception {
	}
",non-flaky,5
137142,spring-projects_spring-framework,MethodMetadataReadingVisitorTests.verifyToString,"	@Test
	public void verifyToString() {
	}
",non-flaky,5
137143,spring-projects_spring-framework,MethodMetadataReadingVisitorTests.getAnnotationsReturnsDirectAnnotations,"	@Test
	public void getAnnotationsReturnsDirectAnnotations() {
		assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(
				super::getAnnotationsReturnsDirectAnnotations);
	}
",non-flaky,5
137144,spring-projects_spring-framework,CachingMetadataReaderLeakTests.equals,"	@Test
				public boolean equals(Object obj) {
					return (obj == this);
				}
",non-flaky,5
137145,spring-projects_spring-framework,ReactiveAdapterRegistryTests.subscribe,"	@Test
		public void subscribe(CoreSubscriber<? super T> actual) {
			throw new UnsupportedOperationException();
		}
",non-flaky,5
137146,spring-projects_spring-framework,OrderComparatorTests.getOrder,"	@Test
		public int getOrder() {
			return this.order;
		}
",non-flaky,5
137147,spring-projects_spring-framework,ToStringCreatorTests.toString,"	@BeforeEach
			public String toString() {
				return ""A"";
			}
",non-flaky,5
137148,spring-projects_spring-framework,ToStringCreatorTests.toString,"	@Test
			public String toString() {
				return new ToStringCreator(this).append(""familyFavoriteSport"", map).toString();
			}
",non-flaky,5
137149,spring-projects_spring-framework,MultipleComposedAnnotationsOnSingleAnnotatedElementTests.getFor,"	@Test
		public String getFor(Class<String> cls) {
			return ""foo"";
		}
",non-flaky,5
137150,spring-projects_spring-framework,AnnotatedElementUtilsTests.handleParameterized,"	@TestPropSource(locations = ""test.properties"")
		public void handleParameterized(T t) {
		}
",non-flaky,5
137151,spring-projects_spring-framework,AnnotatedElementUtilsTests.doIt,"	@TestComponentScan(packages = ""com.example.app.test"")
		public Object doIt() {
			return null;
		}
",non-flaky,5
137152,spring-projects_spring-framework,OrderSourceProviderTests.getOrder,"	@Test
		public int getOrder() {
			return order;
		}
",non-flaky,5
137153,spring-projects_spring-framework,MergedAnnotationsTests.handleParameterized,"	@TestPropertySource(locations = ""test.properties"")
		public void handleParameterized(T t) {
		}
",non-flaky,5
137154,spring-projects_spring-framework,MergedAnnotationsTests.doIt,"	@TestComponentScan(packages = ""com.example.app.test"")
		public void doIt() {
		}
",non-flaky,5
137155,spring-projects_spring-framework,AnnotationUtilsTests.annotatedOnRoot,"	@Test  // gh-23929
		public void annotatedOnRoot() {
		}
",non-flaky,5
137156,spring-projects_spring-framework,AnnotationsScannerTests.doWithAggregate,"	@Test
					public String doWithAggregate(Object context, int aggregateIndex) {
						return """";
					}
",non-flaky,5
137157,spring-projects_spring-framework,AnnotationsScannerTests.doWithAnnotations,"	@Test
					public String doWithAnnotations(Object context, int aggregateIndex,
							Object source, Annotation[] annotations) {
						return ""K"";
					}
",non-flaky,5
137158,spring-projects_spring-framework,AnnotationsScannerTests.method,"		@TestAnnotation1
		public void method() {
		}
",non-flaky,5
137159,spring-projects_spring-framework,AnnotationsScannerTests.method,"		@TestAnnotation2
		public void method() {
		}
",non-flaky,5
137160,spring-projects_spring-framework,AnnotationsScannerTests.method,"		@TestInheritedAnnotation2
		public void method() {
		}
",non-flaky,5
137161,spring-projects_spring-framework,AnnotationsScannerTests.method,"		@TestAnnotation1
		public void method() {
		}
",non-flaky,5
137162,spring-projects_spring-framework,AnnotationsScannerTests.method,"		@TestAnnotation1
		public void method() {
		}
",non-flaky,5
137163,spring-projects_spring-framework,AnnotationsScannerTests.method,"		@TestAnnotation1
		public void method() {
		}
",non-flaky,5
137164,spring-projects_spring-framework,AnnotationsScannerTests.method,"		@TestAnnotation1
		public void method() {
		}
",non-flaky,5
137165,spring-projects_spring-framework,AnnotationsScannerTests.method,"		@TestInheritedAnnotation2
		public void method() {
		}
",non-flaky,5
137166,spring-projects_spring-framework,AnnotationsScannerTests.method,"		@TestAnnotation3
		public void method() {
		}
",non-flaky,5
137167,spring-projects_spring-framework,AnnotationsScannerTests.method,"		@TestAnnotation1
		public void method(String arg) {
		}
",non-flaky,5
137168,spring-projects_spring-framework,AnnotationsScannerTests.method,"		@TestAnnotation1
		public void method() {
		}
",non-flaky,5
137169,spring-projects_spring-framework,AnnotationsScannerTests.method,"		@TestAnnotation1
		public void method() {
		}
",non-flaky,5
137170,spring-projects_spring-framework,AnnotationsScannerTests.method,"		@TestAnnotation1
		public void method(String argument) {
		}
",non-flaky,5
156375,apache_commons-lang,ClassPathUtilsTest.testConstructor,"    @Test
    public void testConstructor() {
        assertNotNull(new ClassPathUtils());
        final Constructor<?>[] cons = ClassPathUtils.class.getDeclaredConstructors();
        assertEquals(1, cons.length);
        assertTrue(Modifier.isPublic(cons[0].getModifiers()));
        assertTrue(Modifier.isPublic(ClassPathUtils.class.getModifiers()));
        assertFalse(Modifier.isFinal(ClassPathUtils.class.getModifiers()));
    }
",non-flaky,5
156376,apache_commons-lang,ClassPathUtilsTest.testToFullyQualifiedNameNullClassString,"    @Test
    public void testToFullyQualifiedNameNullClassString() {
        assertThrows(NullPointerException.class,
                () -> ClassPathUtils.toFullyQualifiedName((Class<?>) null, ""Test.properties""));
    }
",non-flaky,5
156377,apache_commons-lang,ClassPathUtilsTest.testToFullyQualifiedNameClassNull,"    @Test
    public void testToFullyQualifiedNameClassNull() {
        assertThrows(NullPointerException.class, () -> ClassPathUtils.toFullyQualifiedName(ClassPathUtils.class, null));
    }
",non-flaky,5
156378,apache_commons-lang,ClassPathUtilsTest.testToFullyQualifiedNameClassString,"    @Test
    public void testToFullyQualifiedNameClassString() {
        final String expected = ""org.apache.commons.lang3.Test.properties"";
        final String actual = ClassPathUtils.toFullyQualifiedName(ClassPathUtils.class, ""Test.properties"");

        assertEquals(expected, actual);
    }
",non-flaky,5
156379,apache_commons-lang,ClassPathUtilsTest.testToFullyQualifiedNameNullPackageString,"    @Test
    public void testToFullyQualifiedNameNullPackageString() {
        assertThrows(NullPointerException.class,
                () -> ClassPathUtils.toFullyQualifiedName((Package) null, ""Test.properties""));
    }
",non-flaky,5
156380,apache_commons-lang,ClassPathUtilsTest.testToFullyQualifiedNamePackageNull,"    @Test
    public void testToFullyQualifiedNamePackageNull() {
        assertThrows(NullPointerException.class,
                () -> ClassPathUtils.toFullyQualifiedName(ClassPathUtils.class.getPackage(), null));
    }
",non-flaky,5
156381,apache_commons-lang,ClassPathUtilsTest.testToFullyQualifiedNamePackageString,"    @Test
    public void testToFullyQualifiedNamePackageString() {
        final String expected = ""org.apache.commons.lang3.Test.properties"";
        final String actual = ClassPathUtils.toFullyQualifiedName(ClassPathUtils.class.getPackage(), ""Test.properties"");

        assertEquals(expected, actual);
    }
",non-flaky,5
156382,apache_commons-lang,ClassPathUtilsTest.testToFullyQualifiedPathClassNullString,"    @Test
    public void testToFullyQualifiedPathClassNullString() {
        assertThrows(NullPointerException.class,
                () -> ClassPathUtils.toFullyQualifiedPath((Class<?>) null, ""Test.properties""));
    }
",non-flaky,5
156383,apache_commons-lang,ClassPathUtilsTest.testToFullyQualifiedPathClassNull,"    @Test
    public void testToFullyQualifiedPathClassNull() {
        assertThrows(NullPointerException.class, () -> ClassPathUtils.toFullyQualifiedPath(ClassPathUtils.class, null));
    }
",non-flaky,5
156384,apache_commons-lang,ClassPathUtilsTest.testToFullyQualifiedPathClass,"    @Test
    public void testToFullyQualifiedPathClass() {
        final String expected = ""org/apache/commons/lang3/Test.properties"";
        final String actual = ClassPathUtils.toFullyQualifiedPath(ClassPathUtils.class, ""Test.properties"");

        assertEquals(expected, actual);
    }
",non-flaky,5
156385,apache_commons-lang,ClassPathUtilsTest.testToFullyQualifiedPathPackageNullString,"    @Test
    public void testToFullyQualifiedPathPackageNullString() {
        assertThrows(NullPointerException.class,
                () -> ClassPathUtils.toFullyQualifiedPath((Package) null, ""Test.properties""));
    }
",non-flaky,5
156386,apache_commons-lang,ClassPathUtilsTest.testToFullyQualifiedPathPackageNull,"    @Test
    public void testToFullyQualifiedPathPackageNull() {
        assertThrows(NullPointerException.class,
                () -> ClassPathUtils.toFullyQualifiedPath(ClassPathUtils.class.getPackage(), null));
    }
",non-flaky,5
156387,apache_commons-lang,ClassPathUtilsTest.testToFullyQualifiedPathPackage,"    @Test
    public void testToFullyQualifiedPathPackage() {
        final String expected = ""org/apache/commons/lang3/Test.properties"";
        final String actual = ClassPathUtils.toFullyQualifiedPath(ClassPathUtils.class.getPackage(), ""Test.properties"");

        assertEquals(expected, actual);
    }
",non-flaky,5
156388,apache_commons-lang,StringUtilsEmptyBlankTest.testIsEmpty,"    @Test
    public void testIsEmpty() {
        assertTrue(StringUtils.isEmpty(null));
        assertTrue(StringUtils.isEmpty(""""));
        assertFalse(StringUtils.isEmpty("" ""));
        assertFalse(StringUtils.isEmpty(""foo""));
        assertFalse(StringUtils.isEmpty(""  foo  ""));
    }
",non-flaky,5
156389,apache_commons-lang,StringUtilsEmptyBlankTest.testIsNotEmpty,"    @Test
    public void testIsNotEmpty() {
        assertFalse(StringUtils.isNotEmpty(null));
        assertFalse(StringUtils.isNotEmpty(""""));
        assertTrue(StringUtils.isNotEmpty("" ""));
        assertTrue(StringUtils.isNotEmpty(""foo""));
        assertTrue(StringUtils.isNotEmpty(""  foo  ""));
    }
",non-flaky,5
156390,apache_commons-lang,StringUtilsEmptyBlankTest.testIsAnyEmpty,"    @Test
    public void testIsAnyEmpty() {
        assertTrue(StringUtils.isAnyEmpty((String) null));
        assertFalse(StringUtils.isAnyEmpty((String[]) null));
        assertTrue(StringUtils.isAnyEmpty(null, ""foo""));
        assertTrue(StringUtils.isAnyEmpty("""", ""bar""));
        assertTrue(StringUtils.isAnyEmpty(""bob"", """"));
        assertTrue(StringUtils.isAnyEmpty(""  bob  "", null));
        assertFalse(StringUtils.isAnyEmpty("" "", ""bar""));
        assertFalse(StringUtils.isAnyEmpty(""foo"", ""bar""));
    }
",non-flaky,5
156391,apache_commons-lang,StringUtilsEmptyBlankTest.testIsNoneEmpty,"    @Test
    public void testIsNoneEmpty() {
        assertFalse(StringUtils.isNoneEmpty((String) null));
        assertTrue(StringUtils.isNoneEmpty((String[]) null));
        assertFalse(StringUtils.isNoneEmpty(null, ""foo""));
        assertFalse(StringUtils.isNoneEmpty("""", ""bar""));
        assertFalse(StringUtils.isNoneEmpty(""bob"", """"));
        assertFalse(StringUtils.isNoneEmpty(""  bob  "", null));
        assertTrue(StringUtils.isNoneEmpty("" "", ""bar""));
        assertTrue(StringUtils.isNoneEmpty(""foo"", ""bar""));
    }
",non-flaky,5
156392,apache_commons-lang,StringUtilsEmptyBlankTest.testIsAllEmpty,"    @Test
    public void testIsAllEmpty() {
        assertTrue(StringUtils.isAllEmpty());
        assertTrue(StringUtils.isAllEmpty(new String[]{}));
        assertTrue(StringUtils.isAllEmpty((String) null));
        assertTrue(StringUtils.isAllEmpty((String[]) null));
        assertFalse(StringUtils.isAllEmpty(null, ""foo""));
        assertFalse(StringUtils.isAllEmpty("""", ""bar""));
        assertFalse(StringUtils.isAllEmpty(""bob"", """"));
        assertFalse(StringUtils.isAllEmpty(""  bob  "", null));
        assertFalse(StringUtils.isAllEmpty("" "", ""bar""));
        assertFalse(StringUtils.isAllEmpty(""foo"", ""bar""));
        assertTrue(StringUtils.isAllEmpty("""", null));
    }
",non-flaky,5
156393,apache_commons-lang,StringUtilsEmptyBlankTest.testIsBlank,"    @Test
    public void testIsBlank() {
        assertTrue(StringUtils.isBlank(null));
        assertTrue(StringUtils.isBlank(""""));
        assertTrue(StringUtils.isBlank(StringUtilsTest.WHITESPACE));
        assertFalse(StringUtils.isBlank(""foo""));
        assertFalse(StringUtils.isBlank(""  foo  ""));
    }
",non-flaky,5
156394,apache_commons-lang,StringUtilsEmptyBlankTest.testIsNotBlank,"    @Test
    public void testIsNotBlank() {
        assertFalse(StringUtils.isNotBlank(null));
        assertFalse(StringUtils.isNotBlank(""""));
        assertFalse(StringUtils.isNotBlank(StringUtilsTest.WHITESPACE));
        assertTrue(StringUtils.isNotBlank(""foo""));
        assertTrue(StringUtils.isNotBlank(""  foo  ""));
    }
",non-flaky,5
156395,apache_commons-lang,StringUtilsEmptyBlankTest.testIsAnyBlank,"    @Test
    public void testIsAnyBlank() {
        assertTrue(StringUtils.isAnyBlank((String) null));
        assertFalse(StringUtils.isAnyBlank((String[]) null));
        assertTrue(StringUtils.isAnyBlank(null, ""foo""));
        assertTrue(StringUtils.isAnyBlank(null, null));
        assertTrue(StringUtils.isAnyBlank("""", ""bar""));
        assertTrue(StringUtils.isAnyBlank(""bob"", """"));
        assertTrue(StringUtils.isAnyBlank(""  bob  "", null));
        assertTrue(StringUtils.isAnyBlank("" "", ""bar""));
        assertFalse(StringUtils.isAnyBlank(""foo"", ""bar""));
    }
",non-flaky,5
156396,apache_commons-lang,StringUtilsEmptyBlankTest.testIsNoneBlank,"    @Test
    public void testIsNoneBlank() {
        assertFalse(StringUtils.isNoneBlank((String) null));
        assertTrue(StringUtils.isNoneBlank((String[]) null));
        assertFalse(StringUtils.isNoneBlank(null, ""foo""));
        assertFalse(StringUtils.isNoneBlank(null, null));
        assertFalse(StringUtils.isNoneBlank("""", ""bar""));
        assertFalse(StringUtils.isNoneBlank(""bob"", """"));
        assertFalse(StringUtils.isNoneBlank(""  bob  "", null));
        assertFalse(StringUtils.isNoneBlank("" "", ""bar""));
        assertTrue(StringUtils.isNoneBlank(""foo"", ""bar""));
    }
",non-flaky,5
156397,apache_commons-lang,StringUtilsEmptyBlankTest.testIsAllBlank,"    @Test
    public void testIsAllBlank() {
        assertTrue(StringUtils.isAllBlank((String) null));
        assertTrue(StringUtils.isAllBlank((String[]) null));
        assertTrue(StringUtils.isAllBlank(null, null));
        assertTrue(StringUtils.isAllBlank(null, "" ""));
        assertFalse(StringUtils.isAllBlank(null, ""foo""));
        assertFalse(StringUtils.isAllBlank("""", ""bar""));
        assertFalse(StringUtils.isAllBlank(""bob"", """"));
        assertFalse(StringUtils.isAllBlank(""  bob  "", null));
        assertFalse(StringUtils.isAllBlank("" "", ""bar""));
        assertFalse(StringUtils.isAllBlank(""foo"", ""bar""));
    }
",non-flaky,5
156398,apache_commons-lang,StringUtilsEmptyBlankTest.testFirstNonBlank,"    @Test
    public void testFirstNonBlank() {
        assertNull(StringUtils.firstNonBlank());
        assertNull(StringUtils.firstNonBlank((String[]) null));
        assertNull(StringUtils.firstNonBlank(null, null, null));
        assertNull(StringUtils.firstNonBlank(null, """", "" ""));
        assertNull(StringUtils.firstNonBlank(null, null, "" ""));
        assertEquals(""zz"", StringUtils.firstNonBlank(null, ""zz""));
        assertEquals(""abc"", StringUtils.firstNonBlank(""abc""));
        assertEquals(""xyz"", StringUtils.firstNonBlank(null, ""xyz""));
        assertEquals(""xyz"", StringUtils.firstNonBlank(null, ""xyz"", ""abc""));
    }
",non-flaky,5
156399,apache_commons-lang,StringUtilsEmptyBlankTest.testFirstNonEmpty,"    @Test
    public void testFirstNonEmpty() {
        assertNull(StringUtils.firstNonEmpty());
        assertNull(StringUtils.firstNonEmpty((String[]) null));
        assertNull(StringUtils.firstNonEmpty(null, null, null));
        assertEquals("" "", StringUtils.firstNonEmpty(null, """", "" ""));
        assertNull(StringUtils.firstNonEmpty(null, null, """"));
        assertEquals(""zz"", StringUtils.firstNonEmpty(null, ""zz""));
        assertEquals(""abc"", StringUtils.firstNonEmpty(""abc""));
        assertEquals(""xyz"", StringUtils.firstNonEmpty(null, ""xyz""));
        assertEquals(""xyz"", StringUtils.firstNonEmpty(null, ""xyz"", ""abc""));
    }
",non-flaky,5
156400,apache_commons-lang,FastDateFormatTest.test_getInstance,"    @Test
    public void test_getInstance() {
        final FastDateFormat format1 = FastDateFormat.getInstance();
        final FastDateFormat format2 = FastDateFormat.getInstance();
        assertSame(format1, format2);
    }
",non-flaky,5
156401,apache_commons-lang,FastDateFormatTest.test_getInstance_String,"    @Test
    public void test_getInstance_String() {
        final FastDateFormat format1 = FastDateFormat.getInstance(""MM/DD/yyyy"");
        final FastDateFormat format2 = FastDateFormat.getInstance(""MM-DD-yyyy"");
        final FastDateFormat format3 = FastDateFormat.getInstance(""MM-DD-yyyy"");

        assertNotSame(format1, format2);
        assertSame(format2, format3);
        assertEquals(""MM/DD/yyyy"", format1.getPattern());
        assertEquals(TimeZone.getDefault(), format1.getTimeZone());
        assertEquals(TimeZone.getDefault(), format2.getTimeZone());
    }
",non-flaky,5
156402,apache_commons-lang,FastDateFormatTest.test_getInstance_String_TimeZone,"    @Test
    public void test_getInstance_String_TimeZone() {

        final FastDateFormat format1 = FastDateFormat.getInstance(""MM/DD/yyyy"",
                TimeZone.getTimeZone(""Atlantic/Reykjavik""));
        final FastDateFormat format2 = FastDateFormat.getInstance(""MM/DD/yyyy"");
        final FastDateFormat format3 = FastDateFormat.getInstance(""MM/DD/yyyy"", TimeZone.getDefault());
        final FastDateFormat format4 = FastDateFormat.getInstance(""MM/DD/yyyy"", TimeZone.getDefault());
        final FastDateFormat format5 = FastDateFormat.getInstance(""MM-DD-yyyy"", TimeZone.getDefault());
        final FastDateFormat format6 = FastDateFormat.getInstance(""MM-DD-yyyy"");

        assertNotSame(format1, format2);
        assertEquals(TimeZone.getTimeZone(""Atlantic/Reykjavik""), format1.getTimeZone());
        assertEquals(TimeZone.getDefault(), format2.getTimeZone());
        assertSame(format3, format4);
        assertNotSame(format3, format5);
        assertNotSame(format4, format6);
    }
",non-flaky,5
156403,apache_commons-lang,FastDateFormatTest.test_getInstance_String_Locale,"    @Test
    public void test_getInstance_String_Locale() {
        final FastDateFormat format1 = FastDateFormat.getInstance(""MM/DD/yyyy"", Locale.GERMANY);
        final FastDateFormat format2 = FastDateFormat.getInstance(""MM/DD/yyyy"");
        final FastDateFormat format3 = FastDateFormat.getInstance(""MM/DD/yyyy"", Locale.GERMANY);

        assertNotSame(format1, format2);
        assertSame(format1, format3);
        assertEquals(Locale.GERMANY, format1.getLocale());
    }
",non-flaky,5
156404,apache_commons-lang,FastDateFormatTest.test_changeDefault_Locale_DateInstance,"    @Test
    public void test_changeDefault_Locale_DateInstance() {
        final FastDateFormat format1 = FastDateFormat.getDateInstance(FastDateFormat.FULL, Locale.GERMANY);
        final FastDateFormat format2 = FastDateFormat.getDateInstance(FastDateFormat.FULL);
        Locale.setDefault(Locale.GERMANY);
        final FastDateFormat format3 = FastDateFormat.getDateInstance(FastDateFormat.FULL);

        assertSame(Locale.GERMANY, format1.getLocale());
        assertEquals(Locale.US, format2.getLocale());
        assertSame(Locale.GERMANY, format3.getLocale());
        assertNotSame(format1, format2);
        assertNotSame(format2, format3);
    }
",non-flaky,5
156405,apache_commons-lang,FastDateFormatTest.test_changeDefault_Locale_DateTimeInstance,"    @Test
    public void test_changeDefault_Locale_DateTimeInstance() {
        final FastDateFormat format1 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL, Locale.GERMANY);
        final FastDateFormat format2 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL);
        Locale.setDefault(Locale.GERMANY);
        final FastDateFormat format3 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL);

        assertSame(Locale.GERMANY, format1.getLocale());
        assertEquals(Locale.US, format2.getLocale());
        assertSame(Locale.GERMANY, format3.getLocale());
        assertNotSame(format1, format2);
        assertNotSame(format2, format3);
    }
",non-flaky,5
156406,apache_commons-lang,FastDateFormatTest.test_getInstance_String_TimeZone_Locale,"    @Test
    public void test_getInstance_String_TimeZone_Locale() {
        final FastDateFormat format1 = FastDateFormat.getInstance(""MM/DD/yyyy"",
                TimeZone.getTimeZone(""Atlantic/Reykjavik""), Locale.GERMANY);
        final FastDateFormat format2 = FastDateFormat.getInstance(""MM/DD/yyyy"", Locale.GERMANY);
        final FastDateFormat format3 = FastDateFormat.getInstance(""MM/DD/yyyy"",
                TimeZone.getDefault(), Locale.GERMANY);

        assertNotSame(format1, format2);
        assertEquals(TimeZone.getTimeZone(""Atlantic/Reykjavik""), format1.getTimeZone());
        assertEquals(TimeZone.getDefault(), format2.getTimeZone());
        assertEquals(TimeZone.getDefault(), format3.getTimeZone());
        assertEquals(Locale.GERMANY, format1.getLocale());
        assertEquals(Locale.GERMANY, format2.getLocale());
        assertEquals(Locale.GERMANY, format3.getLocale());
    }
",non-flaky,5
156407,apache_commons-lang,FastDateFormatTest.testCheckDefaults,"    @Test
    public void testCheckDefaults() {
        final FastDateFormat format = FastDateFormat.getInstance();
        final FastDateFormat medium = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.SHORT);
        assertEquals(medium, format);

        final SimpleDateFormat sdf = new SimpleDateFormat();
        assertEquals(sdf.toPattern(), format.getPattern());

        assertEquals(Locale.getDefault(), format.getLocale());
        assertEquals(TimeZone.getDefault(), format.getTimeZone());
    }
",non-flaky,5
156408,apache_commons-lang,FastDateFormatTest.testCheckDifferingStyles,"    @Test
    public void testCheckDifferingStyles() {
        final FastDateFormat shortShort = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.SHORT, Locale.US);
        final FastDateFormat shortLong = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.LONG, Locale.US);
        final FastDateFormat longShort = FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.SHORT, Locale.US);
        final FastDateFormat longLong = FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.LONG, Locale.US);

        assertNotEquals(shortShort, shortLong);
        assertNotEquals(shortShort, longShort);
        assertNotEquals(shortShort, longLong);
        assertNotEquals(shortLong, longShort);
        assertNotEquals(shortLong, longLong);
        assertNotEquals(longShort, longLong);
    }
",non-flaky,5
156409,apache_commons-lang,FastDateFormatTest.testDateDefaults,"    @Test
    public void testDateDefaults() {
        assertEquals(FastDateFormat.getDateInstance(FastDateFormat.LONG, Locale.CANADA),
                FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA));

        assertEquals(FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getTimeZone(""America/New_York"")),
                FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getTimeZone(""America/New_York""), Locale.getDefault()));

        assertEquals(FastDateFormat.getDateInstance(FastDateFormat.LONG),
                FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault()));
    }
",non-flaky,5
156410,apache_commons-lang,FastDateFormatTest.testTimeDefaults,"    @Test
    public void testTimeDefaults() {
        assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA),
                FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA));

        assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone(""America/New_York"")),
                FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone(""America/New_York""), Locale.getDefault()));

        assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG),
                FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault()));
    }
",non-flaky,5
156411,apache_commons-lang,FastDateFormatTest.testTimeDateDefaults,"    @Test
    public void testTimeDateDefaults() {
        assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA),
                FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA));

        assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone(""America/New_York"")),
                FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone(""America/New_York""), Locale.getDefault()));

        assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM),
                FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault()));
    }
",non-flaky,5
156412,apache_commons-lang,FastDateFormatTest.format,"    @Test
    public void testParseSync() throws InterruptedException {
        final String pattern = ""yyyy-MM-dd'T'HH:mm:ss.SSS"";
        final SimpleDateFormat inner = new SimpleDateFormat(pattern);
        final Format sdf= new Format() {
            private static final long serialVersionUID = 1L;

            @Override
            public StringBuffer format(final Object obj,
                    final StringBuffer toAppendTo,
",non-flaky,5
156413,apache_commons-lang,FastDateFormatTest.testLANG_954,"    @Test
    public void testLANG_954() {
        final String pattern = ""yyyy-MM-dd'T'"";
        FastDateFormat.getInstance(pattern);
    }
",non-flaky,5
156414,apache_commons-lang,FastDateFormatTest.testLANG_1152,"    @Test
    public void testLANG_1152() {
        final TimeZone utc = FastTimeZone.getGmtTimeZone();
        final Date date = new Date(Long.MAX_VALUE);

        String dateAsString = FastDateFormat.getInstance(""yyyy-MM-dd"", utc, Locale.US).format(date);
        assertEquals(""292278994-08-17"", dateAsString);

        dateAsString = FastDateFormat.getInstance(""dd/MM/yyyy"", utc, Locale.US).format(date);
        assertEquals(""17/08/292278994"", dateAsString);
    }
",non-flaky,5
156415,apache_commons-lang,FastDateFormatTest.testLANG_1267,"    @Test
    public void testLANG_1267() {
        FastDateFormat.getInstance(""yyyy-MM-dd'T'HH:mm:ss.SSSXXX"");
    }
",non-flaky,5
156416,apache_commons-lang,GmtTimeZoneTest.hoursOutOfRange,"    @Test
    public void hoursOutOfRange() {
        assertThrows(IllegalArgumentException.class, () -> new GmtTimeZone(false, 24, 0));
    }
",non-flaky,5
156417,apache_commons-lang,GmtTimeZoneTest.hoursInRange,"    @Test
    public void hoursInRange() {
        assertEquals(23 * 60 * 60 * 1000, new GmtTimeZone(false, 23, 0).getRawOffset());
    }
",non-flaky,5
156418,apache_commons-lang,GmtTimeZoneTest.minutesOutOfRange,"    @Test
    public void minutesOutOfRange() {
        assertThrows(IllegalArgumentException.class, () -> new GmtTimeZone(false, 0, 60));
    }
",non-flaky,5
156419,apache_commons-lang,GmtTimeZoneTest.minutesInRange,"    @Test
    public void minutesInRange() {
        assertEquals(59 * 60 * 1000, new GmtTimeZone(false, 0, 59).getRawOffset());
    }
",non-flaky,5
156420,apache_commons-lang,GmtTimeZoneTest.getOffset,"    @Test
    public void getOffset() {
        assertEquals(0, new GmtTimeZone(false, 0, 0).getOffset(234304));
    }
",non-flaky,5
156421,apache_commons-lang,GmtTimeZoneTest.setRawOffset,"    @Test
    public void setRawOffset() {
        assertThrows(UnsupportedOperationException.class, () -> new GmtTimeZone(false, 0, 0).setRawOffset(0));
    }
",non-flaky,5
156422,apache_commons-lang,GmtTimeZoneTest.getRawOffset,"    @Test
    public void getRawOffset() {
        assertEquals(0, new GmtTimeZone(false, 0, 0).getRawOffset());
    }
",non-flaky,5
156423,apache_commons-lang,GmtTimeZoneTest.getID,"    @Test
    public void getID() {
        assertEquals(""GMT+00:00"", new GmtTimeZone(false, 0, 0).getID());
        assertEquals(""GMT+01:02"", new GmtTimeZone(false, 1, 2).getID());
        assertEquals(""GMT+11:22"", new GmtTimeZone(false, 11, 22).getID());
        assertEquals(""GMT-01:02"", new GmtTimeZone(true, 1, 2).getID());
        assertEquals(""GMT-11:22"", new GmtTimeZone(true, 11, 22).getID());
    }
",non-flaky,5
156424,apache_commons-lang,GmtTimeZoneTest.useDaylightTime,"    @Test
    public void useDaylightTime() {
        assertFalse(new GmtTimeZone(false, 0, 0).useDaylightTime());
    }
",non-flaky,5
156425,apache_commons-lang,GmtTimeZoneTest.inDaylightTime,"    @Test
    public void inDaylightTime() {
        assertFalse(new GmtTimeZone(false, 0, 0).useDaylightTime());
    }
",non-flaky,5
156426,apache_commons-lang,GmtTimeZoneTest.testToString,"    @Test
    public void testToString() {
        assertEquals(""[GmtTimeZone id=\""GMT-12:00\"",offset=-43200000]"",
            new GmtTimeZone(true, 12, 0).toString());
    }
",non-flaky,5
156427,apache_commons-lang,GmtTimeZoneTest.testGetOffset,"    @Test
    public void testGetOffset() {
        assertEquals(-(6 * 60 + 30) * 60 * 1000,
            new GmtTimeZone(true, 6, 30).getOffset(1, 1, 1, 1, 1, 1));
    }
",non-flaky,5
156428,apache_commons-lang,DateUtilsFragmentTest.setUp,"    @BeforeEach
    public void setUp() {
        aCalendar = Calendar.getInstance();
        aCalendar.set(2005, months, days, hours, minutes, seconds);
        aCalendar.set(Calendar.MILLISECOND, millis);
        aDate = aCalendar.getTime();
    }
",non-flaky,5
156429,apache_commons-lang,DateUtilsFragmentTest.testNullDate,"    @Test
    public void testNullDate() {
        assertThrows(
                IllegalArgumentException.class,
                () -> DateUtils.getFragmentInMilliseconds((Date) null, Calendar.MILLISECOND));

        assertThrows(
                IllegalArgumentException.class,
                () -> DateUtils.getFragmentInSeconds((Date) null, Calendar.MILLISECOND));

        assertThrows(
                IllegalArgumentException.class,
                () -> DateUtils.getFragmentInMinutes((Date) null, Calendar.MILLISECOND));

        assertThrows(
                IllegalArgumentException.class,
                () -> DateUtils.getFragmentInHours((Date) null, Calendar.MILLISECOND));

        assertThrows(
                IllegalArgumentException.class,
                () -> DateUtils.getFragmentInDays((Date) null, Calendar.MILLISECOND));
    }
",non-flaky,5
156430,apache_commons-lang,DateUtilsFragmentTest.testNullCalendar,"    @Test
    public void testNullCalendar() {
        assertThrows(
                IllegalArgumentException.class,
                () -> DateUtils.getFragmentInMilliseconds((Calendar) null, Calendar.MILLISECOND));

        assertThrows(
                IllegalArgumentException.class,
                () -> DateUtils.getFragmentInSeconds((Calendar) null, Calendar.MILLISECOND));

        assertThrows(
                IllegalArgumentException.class,
                () -> DateUtils.getFragmentInMinutes((Calendar) null, Calendar.MILLISECOND));

        assertThrows(
                IllegalArgumentException.class,
                () -> DateUtils.getFragmentInHours((Calendar) null, Calendar.MILLISECOND));

        assertThrows(
                IllegalArgumentException.class,
                () -> DateUtils.getFragmentInDays((Calendar) null, Calendar.MILLISECOND));
    }
",non-flaky,5
156431,apache_commons-lang,DateUtilsFragmentTest.testInvalidFragmentWithDate,"    @Test
    public void testInvalidFragmentWithDate() {
        assertThrows(IllegalArgumentException.class, () -> DateUtils.getFragmentInMilliseconds(aDate, 0));
        assertThrows(IllegalArgumentException.class, () -> DateUtils.getFragmentInSeconds(aDate, 0));
        assertThrows(IllegalArgumentException.class, () -> DateUtils.getFragmentInMinutes(aDate, 0));
        assertThrows(IllegalArgumentException.class, () -> DateUtils.getFragmentInHours(aDate, 0));
        assertThrows(IllegalArgumentException.class, () -> DateUtils.getFragmentInDays(aDate, 0));
    }
",non-flaky,5
156432,apache_commons-lang,DateUtilsFragmentTest.testInvalidFragmentWithCalendar,"    @Test
    public void testInvalidFragmentWithCalendar() {
        assertThrows(IllegalArgumentException.class, () -> DateUtils.getFragmentInMilliseconds(aCalendar, 0));
        assertThrows(IllegalArgumentException.class, () -> DateUtils.getFragmentInSeconds(aCalendar, 0));
        assertThrows(IllegalArgumentException.class, () -> DateUtils.getFragmentInMinutes(aCalendar, 0));
        assertThrows(IllegalArgumentException.class, () -> DateUtils.getFragmentInHours(aCalendar, 0));
        assertThrows(IllegalArgumentException.class, () -> DateUtils.getFragmentInDays(aCalendar, 0));
    }
",non-flaky,5
156433,apache_commons-lang,DateUtilsFragmentTest.testMillisecondFragmentInLargerUnitWithDate,"    @Test
    public void testMillisecondFragmentInLargerUnitWithDate() {
        assertEquals(0, DateUtils.getFragmentInMilliseconds(aDate, Calendar.MILLISECOND));
        assertEquals(0, DateUtils.getFragmentInSeconds(aDate, Calendar.MILLISECOND));
        assertEquals(0, DateUtils.getFragmentInMinutes(aDate, Calendar.MILLISECOND));
        assertEquals(0, DateUtils.getFragmentInHours(aDate, Calendar.MILLISECOND));
        assertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.MILLISECOND));
    }
",non-flaky,5
156434,apache_commons-lang,DateUtilsFragmentTest.testMillisecondFragmentInLargerUnitWithCalendar,"    @Test
    public void testMillisecondFragmentInLargerUnitWithCalendar() {
        assertEquals(0, DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.MILLISECOND));
        assertEquals(0, DateUtils.getFragmentInSeconds(aCalendar, Calendar.MILLISECOND));
        assertEquals(0, DateUtils.getFragmentInMinutes(aCalendar, Calendar.MILLISECOND));
        assertEquals(0, DateUtils.getFragmentInHours(aCalendar, Calendar.MILLISECOND));
        assertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.MILLISECOND));
    }
",non-flaky,5
156435,apache_commons-lang,DateUtilsFragmentTest.testSecondFragmentInLargerUnitWithDate,"    @Test
    public void testSecondFragmentInLargerUnitWithDate() {
        assertEquals(0, DateUtils.getFragmentInSeconds(aDate, Calendar.SECOND));
        assertEquals(0, DateUtils.getFragmentInMinutes(aDate, Calendar.SECOND));
        assertEquals(0, DateUtils.getFragmentInHours(aDate, Calendar.SECOND));
        assertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.SECOND));
    }
",non-flaky,5
156436,apache_commons-lang,DateUtilsFragmentTest.testSecondFragmentInLargerUnitWithCalendar,"    @Test
    public void testSecondFragmentInLargerUnitWithCalendar() {
        assertEquals(0, DateUtils.getFragmentInSeconds(aCalendar, Calendar.SECOND));
        assertEquals(0, DateUtils.getFragmentInMinutes(aCalendar, Calendar.SECOND));
        assertEquals(0, DateUtils.getFragmentInHours(aCalendar, Calendar.SECOND));
        assertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.SECOND));
    }
",non-flaky,5
156437,apache_commons-lang,DateUtilsFragmentTest.testMinuteFragmentInLargerUnitWithDate,"    @Test
    public void testMinuteFragmentInLargerUnitWithDate() {
        assertEquals(0, DateUtils.getFragmentInMinutes(aDate, Calendar.MINUTE));
        assertEquals(0, DateUtils.getFragmentInHours(aDate, Calendar.MINUTE));
        assertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.MINUTE));
    }
",non-flaky,5
156438,apache_commons-lang,DateUtilsFragmentTest.testMinuteFragmentInLargerUnitWithCalendar,"    @Test
    public void testMinuteFragmentInLargerUnitWithCalendar() {
        assertEquals(0, DateUtils.getFragmentInMinutes(aCalendar, Calendar.MINUTE));
        assertEquals(0, DateUtils.getFragmentInHours(aCalendar, Calendar.MINUTE));
        assertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.MINUTE));
    }
",non-flaky,5
156439,apache_commons-lang,DateUtilsFragmentTest.testHourOfDayFragmentInLargerUnitWithDate,"    @Test
    public void testHourOfDayFragmentInLargerUnitWithDate() {
        assertEquals(0, DateUtils.getFragmentInHours(aDate, Calendar.HOUR_OF_DAY));
        assertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.HOUR_OF_DAY));
    }
",non-flaky,5
156440,apache_commons-lang,DateUtilsFragmentTest.testHourOfDayFragmentInLargerUnitWithCalendar,"    @Test
    public void testHourOfDayFragmentInLargerUnitWithCalendar() {
        assertEquals(0, DateUtils.getFragmentInHours(aCalendar, Calendar.HOUR_OF_DAY));
        assertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.HOUR_OF_DAY));
    }
",non-flaky,5
156441,apache_commons-lang,DateUtilsFragmentTest.testDayOfYearFragmentInLargerUnitWithDate,"    @Test
    public void testDayOfYearFragmentInLargerUnitWithDate() {
        assertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.DAY_OF_YEAR));
    }
",non-flaky,5
156442,apache_commons-lang,DateUtilsFragmentTest.testDayOfYearFragmentInLargerUnitWithCalendar,"    @Test
    public void testDayOfYearFragmentInLargerUnitWithCalendar() {
        assertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.DAY_OF_YEAR));
    }
",non-flaky,5
156443,apache_commons-lang,DateUtilsFragmentTest.testDateFragmentInLargerUnitWithDate,"    @Test
    public void testDateFragmentInLargerUnitWithDate() {
        assertEquals(0, DateUtils.getFragmentInDays(aDate, Calendar.DATE));
    }
",non-flaky,5
156444,apache_commons-lang,DateUtilsFragmentTest.testDateFragmentInLargerUnitWithCalendar,"    @Test
    public void testDateFragmentInLargerUnitWithCalendar() {
        assertEquals(0, DateUtils.getFragmentInDays(aCalendar, Calendar.DATE));
    }
",non-flaky,5
156445,apache_commons-lang,DateUtilsFragmentTest.testMillisecondsOfSecondWithDate,"    @Test
    public void testMillisecondsOfSecondWithDate() {
        final long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.SECOND);
        assertEquals(millis, testResult);
    }
",non-flaky,5
156446,apache_commons-lang,DateUtilsFragmentTest.testMillisecondsOfSecondWithCalendar,"    @Test
    public void testMillisecondsOfSecondWithCalendar() {
        final long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.SECOND);
        assertEquals(millis, testResult);
        assertEquals(aCalendar.get(Calendar.MILLISECOND), testResult);
    }
",non-flaky,5
156447,apache_commons-lang,DateUtilsFragmentTest.testMillisecondsOfMinuteWithDate,"    @Test
    public void testMillisecondsOfMinuteWithDate() {
        final long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.MINUTE);
        assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND), testResult);
    }
",non-flaky,5
156448,apache_commons-lang,DateUtilsFragmentTest.testMillisecondsOfMinuteWithCalender,"    @Test
    public void testMillisecondsOfMinuteWithCalender() {
        final long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.MINUTE);
        assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND), testResult);
    }
",non-flaky,5
156449,apache_commons-lang,DateUtilsFragmentTest.testSecondsofMinuteWithDate,"    @Test
    public void testSecondsofMinuteWithDate() {
        final long testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.MINUTE);
        assertEquals(seconds, testResult);
    }
",non-flaky,5
156450,apache_commons-lang,DateUtilsFragmentTest.testSecondsofMinuteWithCalendar,"    @Test
    public void testSecondsofMinuteWithCalendar() {
        final long testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.MINUTE);
        assertEquals(seconds, testResult);
        assertEquals(aCalendar.get(Calendar.SECOND), testResult);
    }
",non-flaky,5
156451,apache_commons-lang,DateUtilsFragmentTest.testMillisecondsOfHourWithDate,"    @Test
    public void testMillisecondsOfHourWithDate() {
        final long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.HOUR_OF_DAY);
        assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE), testResult);
    }
",non-flaky,5
156452,apache_commons-lang,DateUtilsFragmentTest.testMillisecondsOfHourWithCalendar,"    @Test
    public void testMillisecondsOfHourWithCalendar() {
        final long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.HOUR_OF_DAY);
        assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE), testResult);
    }
",non-flaky,5
156453,apache_commons-lang,DateUtilsFragmentTest.testSecondsofHourWithDate,"    @Test
    public void testSecondsofHourWithDate() {
        final long testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.HOUR_OF_DAY);
        assertEquals(
                seconds
                        + (minutes
                                * DateUtils.MILLIS_PER_MINUTE / DateUtils.MILLIS_PER_SECOND),
                testResult);
    }
",non-flaky,5
156454,apache_commons-lang,DateUtilsFragmentTest.testSecondsofHourWithCalendar,"    @Test
    public void testSecondsofHourWithCalendar() {
        final long testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.HOUR_OF_DAY);
        assertEquals(
                seconds
                        + (minutes
                                * DateUtils.MILLIS_PER_MINUTE / DateUtils.MILLIS_PER_SECOND),
                testResult);
    }
",non-flaky,5
156455,apache_commons-lang,DateUtilsFragmentTest.testMinutesOfHourWithDate,"    @Test
    public void testMinutesOfHourWithDate() {
        final long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.HOUR_OF_DAY);
        assertEquals(minutes, testResult);
    }
",non-flaky,5
156456,apache_commons-lang,DateUtilsFragmentTest.testMinutesOfHourWithCalendar,"    @Test
    public void testMinutesOfHourWithCalendar() {
        final long testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.HOUR_OF_DAY);
        assertEquals(minutes, testResult);
    }
",non-flaky,5
156457,apache_commons-lang,DateUtilsFragmentTest.testMillisecondsOfDayWithDate,"    @Test
    public void testMillisecondsOfDayWithDate() {
        long testresult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.DATE);
        final long expectedValue = millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR);
        assertEquals(expectedValue, testresult);
        testresult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.DAY_OF_YEAR);
        assertEquals(expectedValue, testresult);
    }
",non-flaky,5
156458,apache_commons-lang,DateUtilsFragmentTest.testMillisecondsOfDayWithCalendar,"    @Test
    public void testMillisecondsOfDayWithCalendar() {
        long testresult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.DATE);
        final long expectedValue = millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR);
        assertEquals(expectedValue, testresult);
        testresult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.DAY_OF_YEAR);
        assertEquals(expectedValue, testresult);
    }
",non-flaky,5
156459,apache_commons-lang,DateUtilsFragmentTest.testSecondsOfDayWithDate,"    @Test
    public void testSecondsOfDayWithDate() {
        long testresult = DateUtils.getFragmentInSeconds(aDate, Calendar.DATE);
        final long expectedValue = seconds + ((minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_SECOND;
        assertEquals(expectedValue, testresult);
        testresult = DateUtils.getFragmentInSeconds(aDate, Calendar.DAY_OF_YEAR);
        assertEquals(expectedValue, testresult);
    }
",non-flaky,5
156460,apache_commons-lang,DateUtilsFragmentTest.testSecondsOfDayWithCalendar,"    @Test
    public void testSecondsOfDayWithCalendar() {
        long testresult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.DATE);
        final long expectedValue = seconds + ((minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_SECOND;
        assertEquals(expectedValue, testresult);
        testresult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.DAY_OF_YEAR);
        assertEquals(expectedValue, testresult);
    }
",non-flaky,5
156461,apache_commons-lang,DateUtilsFragmentTest.testMinutesOfDayWithDate,"    @Test
    public void testMinutesOfDayWithDate() {
        long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE);
        final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE;
        assertEquals(expectedValue, testResult);
        testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR);
        assertEquals(expectedValue, testResult);
    }
",non-flaky,5
156462,apache_commons-lang,DateUtilsFragmentTest.testMinutesOfDayWithCalendar,"    @Test
    public void testMinutesOfDayWithCalendar() {
        long testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.DATE);
        final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE;
        assertEquals(expectedValue, testResult);
        testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.DAY_OF_YEAR);
        assertEquals(expectedValue, testResult);
    }
",non-flaky,5
156463,apache_commons-lang,DateUtilsFragmentTest.testHoursOfDayWithDate,"    @Test
    public void testHoursOfDayWithDate() {
        long testResult = DateUtils.getFragmentInHours(aDate, Calendar.DATE);
        final long expectedValue = hours;
        assertEquals(expectedValue, testResult);
        testResult = DateUtils.getFragmentInHours(aDate, Calendar.DAY_OF_YEAR);
        assertEquals(expectedValue, testResult);
    }
",non-flaky,5
156464,apache_commons-lang,DateUtilsFragmentTest.testHoursOfDayWithCalendar,"    @Test
    public void testHoursOfDayWithCalendar() {
        long testResult = DateUtils.getFragmentInHours(aCalendar, Calendar.DATE);
        final long expectedValue = hours;
        assertEquals(expectedValue, testResult);
        testResult = DateUtils.getFragmentInHours(aCalendar, Calendar.DAY_OF_YEAR);
        assertEquals(expectedValue, testResult);
    }
",non-flaky,5
156465,apache_commons-lang,DateUtilsFragmentTest.testMillisecondsOfMonthWithDate,"    @Test
    public void testMillisecondsOfMonthWithDate() {
        final long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.MONTH);
        assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE)
                                + (hours * DateUtils.MILLIS_PER_HOUR) + ((days - 1) * DateUtils.MILLIS_PER_DAY),
                testResult);
    }
",non-flaky,5
156466,apache_commons-lang,DateUtilsFragmentTest.testMillisecondsOfMonthWithCalendar,"    @Test
    public void testMillisecondsOfMonthWithCalendar() {
        final long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.MONTH);
        assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE)
                + (hours * DateUtils.MILLIS_PER_HOUR) + ((days - 1) * DateUtils.MILLIS_PER_DAY),
testResult);
    }
",non-flaky,5
156467,apache_commons-lang,DateUtilsFragmentTest.testSecondsOfMonthWithDate,"    @Test
    public void testSecondsOfMonthWithDate() {
        final long testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.MONTH);
        assertEquals(
                seconds
                        + ((minutes * DateUtils.MILLIS_PER_MINUTE)
                                + (hours * DateUtils.MILLIS_PER_HOUR) + ((days - 1) * DateUtils.MILLIS_PER_DAY))
                        / DateUtils.MILLIS_PER_SECOND,
                testResult);
    }
",non-flaky,5
156468,apache_commons-lang,DateUtilsFragmentTest.testSecondsOfMonthWithCalendar,"    @Test
    public void testSecondsOfMonthWithCalendar() {
        final long testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.MONTH);
        assertEquals(
                seconds
                        + ((minutes * DateUtils.MILLIS_PER_MINUTE)
                                + (hours * DateUtils.MILLIS_PER_HOUR) + ((days - 1) * DateUtils.MILLIS_PER_DAY))
                        / DateUtils.MILLIS_PER_SECOND,
                testResult);
    }
",non-flaky,5
156469,apache_commons-lang,DateUtilsFragmentTest.testMinutesOfMonthWithDate,"    @Test
    public void testMinutesOfMonthWithDate() {
        final long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.MONTH);
        assertEquals(minutes
                                + ((hours * DateUtils.MILLIS_PER_HOUR) + ((days - 1) * DateUtils.MILLIS_PER_DAY))
                        / DateUtils.MILLIS_PER_MINUTE,
                testResult);
    }
",non-flaky,5
156470,apache_commons-lang,DateUtilsFragmentTest.testMinutesOfMonthWithCalendar,"    @Test
    public void testMinutesOfMonthWithCalendar() {
        final long testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.MONTH);
        assertEquals( minutes  +((hours * DateUtils.MILLIS_PER_HOUR) + ((days - 1) * DateUtils.MILLIS_PER_DAY))
                        / DateUtils.MILLIS_PER_MINUTE,
                testResult);
    }
",non-flaky,5
156471,apache_commons-lang,DateUtilsFragmentTest.testHoursOfMonthWithDate,"    @Test
    public void testHoursOfMonthWithDate() {
        final long testResult = DateUtils.getFragmentInHours(aDate, Calendar.MONTH);
        assertEquals(hours + (((days - 1) * DateUtils.MILLIS_PER_DAY))
                        / DateUtils.MILLIS_PER_HOUR,
                testResult);
    }
",non-flaky,5
156472,apache_commons-lang,DateUtilsFragmentTest.testHoursOfMonthWithCalendar,"    @Test
    public void testHoursOfMonthWithCalendar() {
        final long testResult = DateUtils.getFragmentInHours(aCalendar, Calendar.MONTH);
        assertEquals( hours +(((days - 1) * DateUtils.MILLIS_PER_DAY))
                        / DateUtils.MILLIS_PER_HOUR,
                testResult);
    }
",non-flaky,5
156473,apache_commons-lang,DateUtilsFragmentTest.testMillisecondsOfYearWithDate,"    @Test
    public void testMillisecondsOfYearWithDate() {
        final long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.YEAR);
        final Calendar cal = Calendar.getInstance();
        cal.setTime(aDate);
        assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE)
                                + (hours * DateUtils.MILLIS_PER_HOUR) + ((cal.get(Calendar.DAY_OF_YEAR) - 1)* DateUtils.MILLIS_PER_DAY),
                testResult);
    }
",non-flaky,5
156474,apache_commons-lang,DateUtilsFragmentTest.testMillisecondsOfYearWithCalendar,"    @Test
    public void testMillisecondsOfYearWithCalendar() {
        final long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.YEAR);
        assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE)
                + (hours * DateUtils.MILLIS_PER_HOUR) + ((aCalendar.get(Calendar.DAY_OF_YEAR) - 1) * DateUtils.MILLIS_PER_DAY),
testResult);
    }
",non-flaky,5
159612,liquibase_liquibase,MavenIntegrationTest.nothing,"    @Test
    public void nothing() {
        //tests fail when not running a maven based build. need to figure out how to determine that
    }
",non-flaky,5
159613,liquibase_liquibase,MavenIntegrationTest.testUpdate,"//    @Test
//    public void testUpdate() throws Exception{
//        Verifier verifier=createVerifier();
//
//        verifier.executeGoal( ""clean"" );
//        verifier.executeGoal( ""install"" );
//
//        //Verify everithing has gone well.
//        verifier.verifyErrorFreeLog();
//
//        //Reset the streams before executing the verifier
//        verifier.resetStreams();
//    }
",non-flaky,5
159614,liquibase_liquibase,MavenIntegrationTest.testRollbackTag,"//    @Test
//    public void testRollbackTag() throws Exception {
//        Verifier verifier= createVerifier();
//
//
//        verifier.executeGoal(""clean"");
//        verifier.executeGoal(""liquibase:tag"");
//        verifier.executeGoal(""package""); //runs update that is bound to test phase
//        verifier.executeGoal(""liquibase:rollback"");
//        //If we can reupdate rollback has succeded
//        verifier.executeGoal(""liquibase:update"");
//
//        //Verify everithing has gone well.
//        verifier.verifyErrorFreeLog();
//
//        //Reset the streams before executing the verifier
//        verifier.resetStreams();
//    }
",non-flaky,5
159615,liquibase_liquibase,IntXMLChangeLogSAXParserTest.sampleChangeLogs,"    @Test
    public void sampleChangeLogs() throws Exception {
        new XMLChangeLogSAXParser().parse(""changelogs/cache/complete/root.changelog.xml"", new ChangeLogParameters(), new JUnitResourceAccessor());
        new XMLChangeLogSAXParser().parse(""changelogs/db2/complete/root.changelog.xml"", new ChangeLogParameters(), new JUnitResourceAccessor());
        new XMLChangeLogSAXParser().parse(""changelogs/derby/complete/root.changelog.xml"", new ChangeLogParameters(), new JUnitResourceAccessor());
        new XMLChangeLogSAXParser().parse(""changelogs/firebird/complete/root.changelog.xml"", new ChangeLogParameters(), new JUnitResourceAccessor());
        new XMLChangeLogSAXParser().parse(""changelogs/h2/complete/root.changelog.xml"", new ChangeLogParameters(), new JUnitResourceAccessor());
        new XMLChangeLogSAXParser().parse(""changelogs/hsqldb/complete/root.changelog.xml"", new ChangeLogParameters(), new JUnitResourceAccessor());
        new XMLChangeLogSAXParser().parse(""changelogs/maxdb/complete/root.changelog.xml"", new ChangeLogParameters(), new JUnitResourceAccessor());
        new XMLChangeLogSAXParser().parse(""changelogs/mysql/complete/root.changelog.xml"", new ChangeLogParameters(), new JUnitResourceAccessor());
        new XMLChangeLogSAXParser().parse(""changelogs/oracle/complete/root.changelog.xml"", new ChangeLogParameters(), new JUnitResourceAccessor());
        new XMLChangeLogSAXParser().parse(""changelogs/pgsql/complete/root.changelog.xml"", new ChangeLogParameters(), new JUnitResourceAccessor());
        new XMLChangeLogSAXParser().parse(""changelogs/sybase/complete/root.changelog.xml"", new ChangeLogParameters(), new JUnitResourceAccessor());
        new XMLChangeLogSAXParser().parse(""changelogs/asany/complete/root.changelog.xml"", new ChangeLogParameters(), new JUnitResourceAccessor());
        new XMLChangeLogSAXParser().parse(""changelogs/unsupported/complete/root.changelog.xml"", new ChangeLogParameters(), new JUnitResourceAccessor());
    }
",non-flaky,5
159616,liquibase_liquibase,MySQLIntegrationTest.testRunChangeLog,"    @Test
    public void testRunChangeLog() throws Exception {
        super.testRunChangeLog();    //To change body of overridden methods use File | Settings | File Templates.
    }
",non-flaky,5
159617,liquibase_liquibase,MySQLIntegrationTest.snapshot,"    @Test
    public void snapshot() throws Exception {
        if (getDatabase() == null) {
            return;
        }


        runCompleteChangeLog();
        DatabaseSnapshot snapshot = SnapshotGeneratorFactory.getInstance().createSnapshot(getDatabase().getDefaultSchema(), getDatabase(), new SnapshotControl(getDatabase()));
        System.out.println(snapshot);
    }
",non-flaky,5
159618,liquibase_liquibase,MySQLIntegrationTest.dateDefaultValue,"    @Test
    public void dateDefaultValue() throws Exception {
        if (getDatabase() == null) {
            return;
        }
        ExecutorService.getInstance().getExecutor(getDatabase()).execute(new RawSqlStatement(""DROP TABLE IF "" +
                                                                                                     ""EXISTS ad""));
        
        try {
            ExecutorService.getInstance().getExecutor(getDatabase()).execute(new RawSqlStatement(""CREATE TABLE ad (\n"" +
                                                                                                         ""ad_id int(10) unsigned NOT NULL AUTO_INCREMENT,\n"" +
                                                                                                         ""advertiser_id int(10) unsigned NOT NULL,\n"" +
                                                                                                         ""ad_type_id int(10) unsigned NOT NULL,\n"" +
                                                                                                         ""name varchar(155) NOT NULL DEFAULT '',\n"" +
                                                                                                         ""label varchar(155)NOT NULL DEFAULT '',\n"" +
                                                                                                         ""description text NOT NULL,\n"" +
                                                                                                         ""active tinyint(1) NOT NULL DEFAULT '0',\n"" +
                                                                                                         ""created datetime NOT NULL DEFAULT '0000-00-00 00:00:00',\n"" +
                                                                                                         ""updated datetime DEFAULT '0000-00-00 00:00:00',\n"" +
                                                                                                         ""PRIMARY KEY (ad_id),\n"" +
                                                                                                         ""KEY active (active)\n"" +
                                                                                                         "")""));
        } catch (DatabaseException e) {
            if (e.getCause() instanceof SQLSyntaxErrorException) {
                Scope.getCurrentScope().getLog(getClass()).warning(LogType.LOG, ""MySQL returned DatabaseException"", e);
                assumeTrue(""MySQL seems to run in strict mode (no datetime literals with 0000-00-00 allowed). "" + ""Cannot run this test"", false);
                
            } else {
                throw e;
            }
        }
        
        DatabaseSnapshot snapshot = SnapshotGeneratorFactory.getInstance().createSnapshot(CatalogAndSchema.DEFAULT, getDatabase(), new SnapshotControl(getDatabase()));
        Column createdColumn = snapshot.get(new Column().setRelation(new Table().setName(""ad"").setSchema(new Schema())).setName(""created""));
        
        Object defaultValue = createdColumn.getDefaultValue();
        assertNotNull(defaultValue);
        assertEquals(""0000-00-00 00:00:00"", defaultValue);
    }
",non-flaky,5
159619,liquibase_liquibase,MariaDBIntegrationTest.testRunChangeLog,"    @Test
    public void testRunChangeLog() throws Exception {
        super.testRunChangeLog();    //To change body of overridden methods use File | Settings | File Templates.
    }
",non-flaky,5
159620,liquibase_liquibase,MariaDBIntegrationTest.snapshot,"    @Test
    public void snapshot() throws Exception {
        if (getDatabase() == null) {
            return;
        }


        runCompleteChangeLog();
        DatabaseSnapshot snapshot = SnapshotGeneratorFactory.getInstance().createSnapshot(getDatabase().getDefaultSchema(), getDatabase(), new SnapshotControl(getDatabase()));
        System.out.println(snapshot);
    }
",non-flaky,5
159621,liquibase_liquibase,MariaDBIntegrationTest.dateDefaultValue,"    @Test
    public void dateDefaultValue() throws Exception {
        if (getDatabase() == null) {
            return;
        }
        ExecutorService.getInstance().getExecutor(getDatabase()).execute(new RawSqlStatement(""DROP TABLE IF "" +
             ""EXISTS ad""));
    
        try {
            ExecutorService.getInstance().getExecutor(getDatabase()).execute(new RawSqlStatement(""CREATE TABLE ad (\n"" +
                    ""ad_id int(10) unsigned NOT NULL AUTO_INCREMENT,\n"" +
                    ""advertiser_id int(10) unsigned NOT NULL,\n"" +
                    ""ad_type_id int(10) unsigned NOT NULL,\n"" +
                    ""name varchar(155) NOT NULL DEFAULT '',\n"" +
                    ""label varchar(155)NOT NULL DEFAULT '',\n"" +
                    ""description text NOT NULL,\n"" +
                    ""active tinyint(1) NOT NULL DEFAULT '0',\n"" +
                    ""created datetime NOT NULL DEFAULT '0000-00-00 00:00:00',\n"" +
                    ""updated datetime DEFAULT '0000-00-00 00:00:00',\n"" +
                    ""PRIMARY KEY (ad_id),\n"" +
                    ""KEY active (active)\n"" +
                    "")""));
        } catch (DatabaseException e) {
            if (e.getCause() instanceof SQLSyntaxErrorException) {
                Scope.getCurrentScope().getLog(getClass()).warning(LogType.LOG, ""MariaDB returned DatabaseException"", e);
                assumeTrue(""MariaDB seems to run in strict mode (no datetime literals with 0000-00-00 allowed). "" + ""Cannot run this test"", false);
                
            } else {
                throw e;
            }
        }
    
        DatabaseSnapshot snapshot = SnapshotGeneratorFactory.getInstance().createSnapshot(CatalogAndSchema.DEFAULT, getDatabase(), new SnapshotControl(getDatabase()));
        Column createdColumn = snapshot.get(new Column().setRelation(new Table().setName(""ad"").setSchema(new Schema())).setName(""created""));

        Object defaultValue = createdColumn.getDefaultValue();
        assertNotNull(defaultValue);
        assertEquals(""0000-00-00 00:00:00"", defaultValue);
    }
",non-flaky,5
159622,liquibase_liquibase,H2IntegrationTest.diffToPrintStream,"    @Test
    public void diffToPrintStream() throws Exception{
        if (getDatabase() == null) {
            return;
        }

        runCompleteChangeLog();

        DiffResult diffResult = DiffGeneratorFactory.getInstance().compare(getDatabase(), null, new CompareControl());
        new DiffToReport(diffResult, System.out).print();
    }
",non-flaky,5
159623,liquibase_liquibase,H2IntegrationTest.diffToChangeLog,"    @Test
    public void diffToChangeLog() throws Exception{
        if (getDatabase() == null) {
            return;
        }

        runCompleteChangeLog();

        DiffResult diffResult = DiffGeneratorFactory.getInstance().compare(getDatabase(), null, new CompareControl());
        File outputFile = new File(""diffToChangeLog_"" + getDatabase().getShortName() + "".log"");
        if (outputFile.exists())
            outputFile.delete();
        PrintStream writer = new PrintStream(outputFile);

        new DiffToChangeLog(diffResult, new DiffOutputControl(true, true, true, null)).print(writer);
        writer.close();


    }
",non-flaky,5
159624,liquibase_liquibase,H2IntegrationTest.snapshot,"    @Test
    public void snapshot() throws Exception {
        if (getDatabase() == null) {
            return;
        }


        runCompleteChangeLog();
        DatabaseSnapshot snapshot = SnapshotGeneratorFactory.getInstance().createSnapshot(getDatabase().getDefaultSchema(), getDatabase(), new SnapshotControl(getDatabase()));
        System.out.println(snapshot);
    }
",non-flaky,5
159625,liquibase_liquibase,H2IntegrationTest.canSpecifyDbmsForIndividualChanges,"    @Test
    public void canSpecifyDbmsForIndividualChanges() throws Exception {
        runChangeLogFile(changeSpecifyDbmsChangeLog);
    }
",non-flaky,5
159626,liquibase_liquibase,H2IntegrationTest.h2IsExcludedFromRunningChangeset,"    @Test
    public void h2IsExcludedFromRunningChangeset() throws Exception {
        runChangeLogFile(dbmsExcludeChangelog);
    }
",non-flaky,5
159627,liquibase_liquibase,H2IntegrationTest.runYamlChangelog,"    @Test
    public void runYamlChangelog() throws Exception {
        if (getDatabase() == null) {
            return;
        }

        Liquibase liquibase = createLiquibase(completeChangeLog);
        clearDatabase();

        //run again to test changelog testing logic
        liquibase = createLiquibase(""changelogs/yaml/common.tests.changelog.yaml"");
        liquibase.setChangeLogParameter(""loginuser"", getUsername());

        try {
            liquibase.update(this.contexts);
        } catch (ValidationFailedException e) {
            e.printDescriptiveError(System.out);
            throw e;
        }


    }
",non-flaky,5
159628,liquibase_liquibase,H2IntegrationTest.runJsonChangelog,"    @Test
    public void runJsonChangelog() throws Exception {
        if (getDatabase() == null) {
            return;
        }

        Liquibase liquibase = createLiquibase(completeChangeLog);
        clearDatabase();

        //run again to test changelog testing logic
        liquibase = createLiquibase(""changelogs/json/common.tests.changelog.json"");
        liquibase.setChangeLogParameter(""loginuser"", getUsername());

        try {
            liquibase.update(this.contexts);
        } catch (ValidationFailedException e) {
            e.printDescriptiveError(System.out);
            throw e;
        }
    }
",non-flaky,5
159629,liquibase_liquibase,H2IntegrationTest.testGenerateChangeLogWithNoChanges,"    @Test
    public void testGenerateChangeLogWithNoChanges() throws Exception {
        super.testGenerateChangeLogWithNoChanges();    //To change body of overridden methods use File | Settings |
        // File Templates.
    }
",non-flaky,5
159630,liquibase_liquibase,SQLiteIntegrationTest.testRunChangeLog,"    @Test
    public void testRunChangeLog() throws Exception {
        super.testRunChangeLog();    //To change body of overridden methods use File | Settings | File Templates.
    }
",non-flaky,5
159631,liquibase_liquibase,SQLiteIntegrationTest.smartDataLoad,"    @Test
    public void smartDataLoad() throws Exception {
        if (this.getDatabase() == null) {
            return;
        }

        Liquibase liquibase = createLiquibase(""changelogs/common/smartDataLoad.changelog.xml"");
        clearDatabase();

        try {
            liquibase.update(this.contexts);
        } catch (ValidationFailedException e) {
            e.printDescriptiveError(System.out);
            throw e;
        }

        // check that the automatically rollback now works too
        try {
            liquibase.rollback(new Date(0), this.contexts);
        } catch (ValidationFailedException e) {
            e.printDescriptiveError(System.out);
            throw e;
        }
    }
",non-flaky,5
159632,liquibase_liquibase,SQLiteIntegrationTest.testDiffExternalForeignKeys,"    @Test
    public void testDiffExternalForeignKeys() throws Exception {
        //cross-schema security for oracle is a bother, ignoring test for now
    }
",non-flaky,5
159633,liquibase_liquibase,OracleIntegrationTest.testRunChangeLog,"    @Test
    public void testRunChangeLog() throws Exception {
        super.testRunChangeLog();    //To change body of overridden methods use File | Settings | File Templates.
    }
",non-flaky,5
159634,liquibase_liquibase,OracleIntegrationTest.indexCreatedOnCorrectSchema,"    @Test
    public void indexCreatedOnCorrectSchema() throws Exception {
        assumeNotNull(this.getDatabase());

        Liquibase liquibase = createLiquibase(this.indexOnSchemaChangeLog);
        clearDatabase();

        try {
            liquibase.update(this.contexts);
        } catch (ValidationFailedException e) {
            e.printDescriptiveError(System.out);
            throw e;
        }

        Statement queryIndex = ((JdbcConnection) this.getDatabase().getConnection()).getUnderlyingConnection().createStatement();

        ResultSet indexOwner = queryIndex.executeQuery(""SELECT owner FROM ALL_INDEXES WHERE index_name = 'IDX_BOOK_ID'"");

        assertTrue(indexOwner.next());

        String owner = indexOwner.getString(""owner"");

        assertEquals(""LBCAT2"", owner);

        // check that the automatically rollback now works too
        try {
            liquibase.rollback( new Date(0),this.contexts);
        } catch (ValidationFailedException e) {
            e.printDescriptiveError(System.out);
            throw e;
        }




    }
",non-flaky,5
159635,liquibase_liquibase,OracleIntegrationTest.viewCreatedOnCorrectSchema,"    @Test
    public void viewCreatedOnCorrectSchema() throws Exception {
        assumeNotNull(this.getDatabase());

        Liquibase liquibase = createLiquibase(this.viewOnSchemaChangeLog);
        clearDatabase();

        try {
            liquibase.update(this.contexts);
        } catch (ValidationFailedException e) {
            e.printDescriptiveError(System.out);
            throw e;
        }

        Statement queryIndex = ((JdbcConnection) this.getDatabase().getConnection()).getUnderlyingConnection().createStatement();

        ResultSet indexOwner = queryIndex.executeQuery(""SELECT owner FROM ALL_VIEWS WHERE view_name = 'V_BOOK2'"");

        assertTrue(indexOwner.next());

        String owner = indexOwner.getString(""owner"");

        assertEquals(""LBCAT2"", owner);

        // check that the automatically rollback now works too
        try {
            liquibase.rollback( new Date(0),this.contexts);
        } catch (ValidationFailedException e) {
            e.printDescriptiveError(System.out);
            throw e;
        }
    }
",non-flaky,5
159636,liquibase_liquibase,OracleIntegrationTest.smartDataLoad,"    @Test
    public void smartDataLoad() throws Exception {
        assumeNotNull(this.getDatabase());

        Liquibase liquibase = createLiquibase(""changelogs/common/smartDataLoad.changelog.xml"");
        clearDatabase();

        try {
            liquibase.update(this.contexts);
        } catch (ValidationFailedException e) {
            e.printDescriptiveError(System.out);
            throw e;
        }

        // check that the automatically rollback now works too
        try {
            liquibase.rollback( new Date(0),this.contexts);
        } catch (ValidationFailedException e) {
            e.printDescriptiveError(System.out);
            throw e;
        }
    }
",non-flaky,5
159637,liquibase_liquibase,OracleIntegrationTest.testDiffExternalForeignKeys,"    @Test
    public void testDiffExternalForeignKeys() throws Exception {
        //cross-schema security for oracle is a bother, ignoring test for now
    }
",non-flaky,5
159638,liquibase_liquibase,AbstractIntegrationTest.testBatchInsert,"    @Test
    public void testBatchInsert() throws Exception {
        if (this.getDatabase() == null) {
            return;
        }
        clearDatabase();

        createLiquibase(""changelogs/common/batchInsert.changelog.xml"").update(this.contexts);
        // ChangeLog already contains the verification code
    }
",non-flaky,5
159639,liquibase_liquibase,AbstractIntegrationTest.testDatabaseIsReachableIfRequired,"    @Test
    public void testDatabaseIsReachableIfRequired() {
        if (isDatabaseProvidedByTravisCI()) {
            assertNotNull(
                    ""This integration test is expected to pass on Travis CI.\n"" +
                            ""If you are running on a dev machine and do not have the required\n"" +
                            ""database installed, you may choose to ignore this failed test.\n"" +
                            ""To run this test on a dev machine, you will need to install the corresponding\n"" +
                            ""database and configure liquibase.integrationtest.local.properties"",
                    getDatabase());
        } else {
            assumeNotNull(this.getDatabase());
        }
    }
",non-flaky,5
159640,liquibase_liquibase,AbstractIntegrationTest.testRunChangeLog,"    @Test
    public void testRunChangeLog() throws Exception {
        assumeNotNull(this.getDatabase());

        runCompleteChangeLog();
    }
",non-flaky,5
159641,liquibase_liquibase,AbstractIntegrationTest.testRunUpdateOnOldChangelogTableFormat,"    @Test
    public void testRunUpdateOnOldChangelogTableFormat() throws Exception {
        assumeNotNull(this.getDatabase());
        Liquibase liquibase = createLiquibase(completeChangeLog);
        clearDatabase();

        String nullableKeyword = database.requiresExplicitNullForColumns() ? "" NULL"" : """";

        String sql = ""CREATE TABLE "" +
                database.escapeTableName(
                        database.getDefaultCatalogName(), database.getDefaultSchemaName(), ""DATABASECHANGELOG""
                ) +
                "" (id varchar(150) NOT NULL, "" +
                ""author VARCHAR(150) NOT NULL, "" +
                ""filename VARCHAR(255) NOT NULL, "" +
                ""dateExecuted "" +
                DataTypeFactory.getInstance().fromDescription(
                        ""datetime"", database
                ).toDatabaseDataType(database) + "" NOT NULL, "" +
                ""md5sum VARCHAR(32)"" + nullableKeyword + "", "" +
                ""description VARCHAR(255)"" + nullableKeyword + "", "" +
                ""comments VARCHAR(255)"" + nullableKeyword + "", "" +
                ""tag VARCHAR(255)"" + nullableKeyword + "", "" +
                ""liquibase VARCHAR(10)"" + nullableKeyword + "", "" +
                ""PRIMARY KEY (id, author, filename))"";
        Scope.getCurrentScope().getLog(getClass()).info(LogType.WRITE_SQL, sql);

        Connection conn = ((JdbcConnection) database.getConnection()).getUnderlyingConnection();
        boolean savedAcSetting = conn.getAutoCommit();
        conn.setAutoCommit(false);
        conn.createStatement().execute(sql);
        conn.commit();
        conn.setAutoCommit(savedAcSetting);

        liquibase = createLiquibase(completeChangeLog);
        liquibase.setChangeLogParameter( ""loginuser"", getUsername());
        liquibase.update(this.contexts);

    }
",non-flaky,5
159642,liquibase_liquibase,AbstractIntegrationTest.testOutputChangeLog,"    @Test
    public void testOutputChangeLog() throws Exception {
        assumeNotNull(this.getDatabase());

        StringWriter output = new StringWriter();
        Liquibase liquibase;
        clearDatabase();

        liquibase = createLiquibase(completeChangeLog);
        liquibase.setChangeLogParameter(""loginuser"", getUsername());
        liquibase.update(this.contexts, output);

        String outputResult = output.getBuffer().toString();
        assertNotNull(""generated output change log must not be empty"", outputResult);
        assertTrue(""generated output change log is at least 100 bytes long"", outputResult.length() > 100);

        // TODO should better written to a file so CI servers can pick it up as test artifacts.
        System.out.println(outputResult);
        assertTrue(""create databasechangelog command not found in: \n"" + outputResult, outputResult.contains(""CREATE TABLE ""+database.escapeTableName(database.getLiquibaseCatalogName(), database.getLiquibaseSchemaName(), database.getDatabaseChangeLogTableName())));
        assertTrue(""create databasechangeloglock command not found in: \n"" + outputResult, outputResult.contains(""CREATE TABLE ""+database.escapeTableName(database.getLiquibaseCatalogName(), database.getLiquibaseSchemaName(), database.getDatabaseChangeLogLockTableName())));

        assertTrue(""generated output contains a correctly encoded Euro sign"", outputResult.contains(""""));

        DatabaseSnapshot snapshot = SnapshotGeneratorFactory.getInstance().createSnapshot(database.getDefaultSchema(), database, new SnapshotControl(database));
        assertEquals(""no database objects were actually created during creation of the output changelog"",
                0, snapshot.get(Schema.class).iterator().next().getDatabaseObjects(Table.class).size());
    }
",non-flaky,5
159643,liquibase_liquibase,AbstractIntegrationTest.testUpdateTwice,"    @Test
    public void testUpdateTwice() throws Exception {
        assumeNotNull(this.getDatabase());

        Liquibase liquibase = createLiquibase(completeChangeLog);
        clearDatabase();

        liquibase = createLiquibase(completeChangeLog);
        liquibase.setChangeLogParameter( ""loginuser"", getUsername());
        liquibase.update(this.contexts);
        liquibase.update(this.contexts);
    }
",non-flaky,5
159644,liquibase_liquibase,AbstractIntegrationTest.testUpdateClearUpdate,"    @Test
    public void testUpdateClearUpdate() throws Exception {
        assumeNotNull(this.getDatabase());

        Liquibase liquibase = createLiquibase(completeChangeLog);
        clearDatabase();

        liquibase = createLiquibase(completeChangeLog);
        liquibase.setChangeLogParameter( ""loginuser"", getUsername());
        liquibase.update(this.contexts);
        clearDatabase();

        liquibase = createLiquibase(completeChangeLog);
        liquibase.setChangeLogParameter( ""loginuser"", getUsername());
        liquibase.update(this.contexts);
    }
",non-flaky,5
159645,liquibase_liquibase,AbstractIntegrationTest.testRollbackableChangeLog,"    @Test
    public void testRollbackableChangeLog() throws Exception {
        assumeNotNull(this.getDatabase());

        Liquibase liquibase = createLiquibase(rollbackChangeLog);
        clearDatabase();

        liquibase = createLiquibase(rollbackChangeLog);
        liquibase.update(this.contexts);

        liquibase = createLiquibase(rollbackChangeLog);
        liquibase.rollback(new Date(0), this.contexts);

        liquibase = createLiquibase(rollbackChangeLog);
        liquibase.update(this.contexts);

        liquibase = createLiquibase(rollbackChangeLog);
        liquibase.rollback(new Date(0), this.contexts);
    }
",non-flaky,5
159646,liquibase_liquibase,AbstractIntegrationTest.testRollbackableChangeLogScriptOnExistingDatabase,"    @Test
    public void testRollbackableChangeLogScriptOnExistingDatabase() throws Exception {
        assumeNotNull(this.getDatabase());

        Liquibase liquibase = createLiquibase(rollbackChangeLog);
        clearDatabase();

        liquibase = createLiquibase(rollbackChangeLog);
        liquibase.update(this.contexts);

        StringWriter writer = new StringWriter();

        liquibase = createLiquibase(rollbackChangeLog);
        liquibase.rollback(new Date(0), this.contexts, writer);
    }
",non-flaky,5
159647,liquibase_liquibase,AbstractIntegrationTest.testRollbackableChangeLogScriptOnFutureDatabase,"    @Test
    public void testRollbackableChangeLogScriptOnFutureDatabase() throws Exception {
        assumeNotNull(this.getDatabase());

        StringWriter writer = new StringWriter();

        Liquibase liquibase = createLiquibase(rollbackChangeLog);
        clearDatabase();

        liquibase = createLiquibase(rollbackChangeLog);
        liquibase.futureRollbackSQL(new Contexts(this.contexts), new LabelExpression(), writer);
    }
",non-flaky,5
159648,liquibase_liquibase,AbstractIntegrationTest.testTag,"    @Test
    public void testTag() throws Exception {
        assumeNotNull(this.getDatabase());

        Liquibase liquibase = createLiquibase(completeChangeLog);
        clearDatabase();

        liquibase = createLiquibase(completeChangeLog);
        liquibase.setChangeLogParameter( ""loginuser"", getUsername());
        liquibase.update(this.contexts);

        liquibase.tag(""Test Tag"");
    }
",non-flaky,5
159649,liquibase_liquibase,AbstractIntegrationTest.testDiff,"    @Test
    public void testDiff() throws Exception {
        assumeNotNull(this.getDatabase());

        runCompleteChangeLog();

        CompareControl compareControl = new CompareControl();
        compareControl.addSuppressedField(Column.class, ""defaultValue"");  //database returns different data even if the same
        compareControl.addSuppressedField(Column.class, ""autoIncrementInformation""); //database returns different data even if the same
        DiffResult diffResult = DiffGeneratorFactory.getInstance().compare(database, database, compareControl);

        try {
            assertTrue(""comapring a database with itself should return a result of 'DBs are equal'"",
                    diffResult.areEqual());
        } catch (AssertionError e) {
            new DiffToReport(diffResult, System.err).print();
            throw e;
        }
    }
",non-flaky,5
159650,liquibase_liquibase,AbstractIntegrationTest.testRerunDiffChangeLog,"    @Test
    public void testRerunDiffChangeLog() throws Exception {
        assumeNotNull(this.getDatabase());

        for (int run=0; run < 2; run++) { //run once outputting data as insert, once as csv
            boolean outputCsv = run == 1;
            runCompleteChangeLog();

            SnapshotControl snapshotControl = new SnapshotControl(database);

            DatabaseSnapshot originalSnapshot = SnapshotGeneratorFactory.getInstance().createSnapshot(database.getDefaultSchema(), database, snapshotControl);

            CompareControl compareControl = new CompareControl();
            compareControl.addSuppressedField(Column.class, ""defaultValue"");  //database returns different data even if the same
            compareControl.addSuppressedField(Column.class, ""autoIncrementInformation""); //database returns different data even if the same
            if (database instanceof OracleDatabase) {
                compareControl.addSuppressedField(Column.class, ""type""); //database returns different nvarchar2 info even though they are the same
                compareControl.addSuppressedField(Column.class, ""nullable""); // database returns different nullable on views, e.g. v_person.id
            }
            if (database instanceof PostgresDatabase) {
                compareControl.addSuppressedField(Column.class, ""type""); //database returns different nvarchar2 info even though they are the same
            }

            DiffOutputControl diffOutputControl = new DiffOutputControl();
            File tempFile = tempDirectory.getRoot().createTempFile(""liquibase-test"", "".xml"");

            if (outputCsv) {
                diffOutputControl.setDataDir(new File(tempFile.getParentFile(), ""liquibase-data"").getCanonicalPath().replaceFirst(""\\w:"",""""));
            }

            DiffResult diffResult = DiffGeneratorFactory.getInstance().compare(database, null, compareControl);


            FileOutputStream output = new FileOutputStream(tempFile);
            try {
                new DiffToChangeLog(diffResult, new DiffOutputControl()).print(new PrintStream(output));
                output.flush();
            } finally {
                output.close();
            }

            Liquibase liquibase = createLiquibase(tempFile.getName());
            clearDatabase();

            DatabaseSnapshot emptySnapshot = SnapshotGeneratorFactory.getInstance().createSnapshot(database.getDefaultSchema(), database, new SnapshotControl(database));

            //run again to test changelog testing logic
            liquibase = createLiquibase(tempFile.getName());
            try {
                liquibase.update(this.contexts);
            } catch (ValidationFailedException e) {
                e.printDescriptiveError(System.out);
                throw e;
            }

            DatabaseSnapshot migratedSnapshot = SnapshotGeneratorFactory.getInstance().createSnapshot(database.getDefaultSchema(), database, new SnapshotControl(database));

            DiffResult finalDiffResult = DiffGeneratorFactory.getInstance().compare(originalSnapshot, migratedSnapshot, compareControl);
            try {
                assertTrue(""recreating the database from the generated change log should cause both 'before' and "" +
                                ""'after' snapshots to be equal."",
                        finalDiffResult.areEqual());
            } catch (AssertionError e) {
                new DiffToReport(finalDiffResult, System.err).print();
                throw e;
            }

            //diff to empty and drop all
            DiffResult emptyDiffResult = DiffGeneratorFactory.getInstance().compare(emptySnapshot, migratedSnapshot, compareControl);
            output = new FileOutputStream(tempFile);
            try {
                new DiffToChangeLog(emptyDiffResult, new DiffOutputControl(true, true, true, null)).print(new PrintStream(output));
                output.flush();
            } finally {
                output.close();
            }

            liquibase = createLiquibase(tempFile.getName());
            Scope.getCurrentScope().getLog(getClass()).info(LogType.LOG, ""updating from ""+tempFile.getCanonicalPath());
            try {
                liquibase.update(this.contexts);
            } catch (LiquibaseException e) {
                throw e;
            }

            DatabaseSnapshot emptyAgainSnapshot = SnapshotGeneratorFactory.getInstance().createSnapshot(database.getDefaultSchema(), database, new SnapshotControl(database));
            assertEquals(""a database that was 'updated' to an empty snapshot should only have 2 tables left: "" +
                            ""the database change log table and the lock table."",
                    2, emptyAgainSnapshot.get(Table.class).size());
            assertEquals(""a database that was 'updated' to an empty snapshot should not contain any views."",
                    0, emptyAgainSnapshot.get(View.class).size());
        }
    }
",non-flaky,5
159651,liquibase_liquibase,AbstractIntegrationTest.testRerunDiffChangeLogAltSchema,"    @Test
    public void testRerunDiffChangeLogAltSchema() throws Exception {
        assumeNotNull(this.getDatabase());
        if (database.getShortName().equalsIgnoreCase(""mssql"")) {
            return; // not possible on MSSQL.
        }
        if (!database.supportsSchemas()) {
            return;
        }

        Liquibase liquibase = createLiquibase(includedChangeLog);
        database.setDefaultSchemaName(""lbcat2"");
        clearDatabase();


        LockService lockService = LockServiceFactory.getInstance().getLockService(database);
        lockService.forceReleaseLock();

        liquibase.update(includedChangeLog);

        DatabaseSnapshot originalSnapshot = SnapshotGeneratorFactory.getInstance().createSnapshot(database.getDefaultSchema(), database, new SnapshotControl(database));

        CompareControl compareControl = new CompareControl(
                new CompareControl.SchemaComparison[]{
                        new CompareControl.SchemaComparison(
                                CatalogAndSchema.DEFAULT,
                                new CatalogAndSchema(null, ""lbcat2"")
                        )
                },
                originalSnapshot.getSnapshotControl().getTypesToInclude()
        );
        DiffResult diffResult = DiffGeneratorFactory.getInstance().compare(database, null, compareControl);

        File tempFile = File.createTempFile(""liquibase-test"", "".xml"");

        FileOutputStream output = new FileOutputStream(tempFile);
        try {
            new DiffToChangeLog(diffResult, new DiffOutputControl()).print(new PrintStream(output));
            output.flush();
        } finally {
            output.close();
        }

        liquibase = createLiquibase(tempFile.getName());
        clearDatabase();

        //run again to test changelog testing logic
        Executor executor = ExecutorService.getInstance().getExecutor(database);
        try {
            executor.execute(new DropTableStatement(""lbcat2"", ""lbcat2"", database.getDatabaseChangeLogTableName(), false));
        } catch (DatabaseException e) {
            //ok
        }
        try {
            executor.execute(new DropTableStatement(""lbcat2"", ""lbcat2"", database.getDatabaseChangeLogLockTableName(), false));
        } catch (DatabaseException e) {
            //ok
        }
        database.commit();

        DatabaseConnection connection = DatabaseTestContext.getInstance().getConnection(getJdbcUrl(), username, password);
        database = DatabaseFactory.getInstance().findCorrectDatabaseImplementation(connection);
        database.setDefaultSchemaName(""lbcat2"");
        liquibase = createLiquibase(tempFile.getName());
        try {
            liquibase.update(this.contexts);
        } catch (ValidationFailedException e) {
            e.printDescriptiveError(System.out);
            throw e;
        }

        tempFile.deleteOnExit();

        DatabaseSnapshot finalSnapshot = SnapshotGeneratorFactory.getInstance().createSnapshot(database.getDefaultSchema(), database, new SnapshotControl(database));

        CompareControl finalCompareControl = new CompareControl();
        finalCompareControl.addSuppressedField(Column.class, ""autoIncrementInformation"");
        DiffResult finalDiffResult = DiffGeneratorFactory.getInstance().compare(originalSnapshot, finalSnapshot, finalCompareControl);
        new DiffToReport(finalDiffResult, System.out).print();
        assertTrue(""running the same change log two times against an alternative schema should produce "" +
                        ""equal snapshots."",
                finalDiffResult.areEqual());
    }
",non-flaky,5
159652,liquibase_liquibase,AbstractIntegrationTest.testClearChecksums,"    @Test
    public void testClearChecksums() throws Exception {
        assumeNotNull(this.getDatabase());

        Liquibase liquibase = createLiquibase(completeChangeLog);
        clearDatabase();

        liquibase = createLiquibase(completeChangeLog);
        clearDatabase();

        liquibase = createLiquibase(completeChangeLog);
        liquibase.setChangeLogParameter( ""loginuser"", getUsername());
        liquibase.update(this.contexts);

        liquibase.clearCheckSums();
    }
",non-flaky,5
159653,liquibase_liquibase,AbstractIntegrationTest.testTagEmptyDatabase,"    @Test
    public void testTagEmptyDatabase() throws Exception {
        assumeNotNull(this.getDatabase());

        Liquibase liquibase = createLiquibase(completeChangeLog);
        clearDatabase();

        liquibase = createLiquibase(completeChangeLog);
        liquibase.checkLiquibaseTables(false, null, new Contexts(), new LabelExpression());
        liquibase.tag(""empty"");

        liquibase = createLiquibase(rollbackChangeLog);
        liquibase.update(new Contexts());

        liquibase.rollback(""empty"", new Contexts());

    }
",non-flaky,5
159654,liquibase_liquibase,AbstractIntegrationTest.testUnrunChangeSetsEmptyDatabase,"    @Test
    public void testUnrunChangeSetsEmptyDatabase() throws Exception {
        assumeNotNull(this.getDatabase());

        Liquibase liquibase = createLiquibase(completeChangeLog);
        liquibase.setChangeLogParameter( ""loginuser"", getUsername());
        clearDatabase();

        liquibase = createLiquibase(completeChangeLog);
        liquibase.setChangeLogParameter( ""loginuser"", getUsername());
        List<ChangeSet> list = liquibase.listUnrunChangeSets(new Contexts(this.contexts), new LabelExpression());

        assertTrue(""querying the changelog table on an empty target should return at least 1 un-run change set"", !list.isEmpty());

    }
",non-flaky,5
159655,liquibase_liquibase,AbstractIntegrationTest.testAbsolutePathChangeLog,"    @Test
    public void testAbsolutePathChangeLog() throws Exception {
        assumeNotNull(this.getDatabase());

        String fileUrlToChangeLog = getClass().getResource(""/"" + includedChangeLog).toString();
        assertTrue(fileUrlToChangeLog.startsWith(""file:/""));

        String absolutePathOfChangeLog = fileUrlToChangeLog.replaceFirst(""file:\\/"", """");
        if (System.getProperty(""os.name"").startsWith(""Windows "")) {
            absolutePathOfChangeLog = absolutePathOfChangeLog.replace('/', '\\');
        } else {
            absolutePathOfChangeLog = ""/"" + absolutePathOfChangeLog;
        }
        Liquibase liquibase = createLiquibase(absolutePathOfChangeLog, new FileSystemResourceAccessor());
        clearDatabase();

        liquibase.update(this.contexts);

        liquibase.update(this.contexts); //try again, make sure there are no errors

        clearDatabase();
    }
",non-flaky,5
159656,liquibase_liquibase,AbstractIntegrationTest.testRollbackToChange,"    @Test
    public void testRollbackToChange() throws Exception {
        assumeNotNull(this.getDatabase());

        Liquibase liquibase = createLiquibase(rollbackChangeLog);
        wipeDatabase();

        liquibase = createLiquibase(rollbackChangeLog);
        liquibase.update(this.contexts);

        liquibase = createLiquibase(rollbackChangeLog);
        liquibase.rollback(8, this.contexts);

        liquibase.tag(""testRollbackToChange"");

        liquibase = createLiquibase(rollbackChangeLog);
        liquibase.update(this.contexts);

        liquibase = createLiquibase(rollbackChangeLog);
        liquibase.rollback(""testRollbackToChange"", this.contexts);
    }
",non-flaky,5
159657,liquibase_liquibase,AbstractIntegrationTest.testDbDoc,"    @Test
    public void testDbDoc() throws Exception {
        assumeNotNull(this.getDatabase());

        Liquibase liquibase;
        clearDatabase();

        liquibase = createLiquibase(completeChangeLog);
        liquibase.setChangeLogParameter( ""loginuser"", getUsername());
        liquibase.update(this.contexts);

        Path outputDir = tempDirectory.newFolder().toPath().normalize();
        logger.fine(LogType.LOG, ""Database documentation will be written to this temporary folder: "" + outputDir);

        liquibase = createLiquibase(completeChangeLog);
        liquibase.setChangeLogParameter( ""loginuser"", getUsername());
        liquibase.generateDocumentation(outputDir.toAbsolutePath().toString(), this.contexts);
    }
",non-flaky,5
159658,liquibase_liquibase,AbstractIntegrationTest.testEncodingUpdating2SQL,"    @Test
    public void testEncodingUpdating2SQL() throws Exception {
        assumeNotNull(this.getDatabase());

        Liquibase liquibase = createLiquibase(encodingChangeLog);

        StringWriter writer=new StringWriter();
        liquibase.update(this.contexts,writer);
        assertTrue(""Update to SQL preserves encoding"",
            new RegexMatcher(writer.toString(), new String[] {
                //For the UTF-8 encoded cvs
                ""^.*INSERT.*VALUES.*.*?\\)"",
                """",
                //For the latin1 one
                ""^.*INSERT.*VALUES.*.*?\\)"",
                """"
            }).allMatchedInSequentialOrder());
    }
",non-flaky,5
159659,liquibase_liquibase,AbstractIntegrationTest.testDiffExternalForeignKeys,"   @Test
   public void testDiffExternalForeignKeys() throws Exception {
       assumeNotNull(this.getDatabase());
       clearDatabase();
       Liquibase liquibase = createLiquibase(externalfkInitChangeLog);
       liquibase.update(contexts);

       DiffResult diffResult = liquibase.diff(database, null, new CompareControl());
       DiffResultAssert.assertThat(diffResult).containsMissingForeignKeyWithName(""fk_person_country"");
   }
",non-flaky,5
159660,liquibase_liquibase,AbstractIntegrationTest.testInvalidIncludeDoesntBreakLiquibase,"    @Test
    public void testInvalidIncludeDoesntBreakLiquibase() throws Exception {
        assumeNotNull(this.getDatabase());
        Liquibase liquibase = createLiquibase(invalidReferenceChangeLog);
        try {
            liquibase.update(new Contexts());
            fail(""Did not fail with invalid include"");
        } catch (ChangeLogParseException ignored) {
            //expected
        }

        LockService lockService = LockServiceFactory.getInstance().getLockService(database);
        assertFalse(lockService.hasChangeLogLock());
    }
",non-flaky,5
159661,liquibase_liquibase,AbstractIntegrationTest.testContextsWithHyphensWorkInFormattedSql,"    @Test
    public void testContextsWithHyphensWorkInFormattedSql() throws Exception {
        assumeNotNull(this.getDatabase());
        Liquibase liquibase = createLiquibase(""changelogs/common/sqlstyle/formatted.changelog.sql"");
        liquibase.update(""hyphen-context-using-sql,camelCaseContextUsingSql"");

        SnapshotGeneratorFactory tableSnapshotGenerator = SnapshotGeneratorFactory.getInstance();
        assertNotNull(tableSnapshotGenerator.has(new Table().setName(""hyphen_context""), database));
        assertNotNull(tableSnapshotGenerator.has(new Table().setName(""camel_context""), database));
        assertNotNull(tableSnapshotGenerator.has(new Table().setName(""bar_id""), database));
        assertNotNull(tableSnapshotGenerator.has(new Table().setName(""foo_id""), database));
    }
",non-flaky,5
159662,liquibase_liquibase,AbstractIntegrationTest.testObjectQuotingStrategy,"    @Test
    public void testObjectQuotingStrategy() throws Exception {
        assumeNotNull(this.getDatabase());
        if (!Arrays.asList(""oracle,h2,hsqldb,postgresql,mysql"").contains(database.getShortName())) {
            return;
        }

        Liquibase liquibase = createLiquibase(objectQuotingStrategyChangeLog);
        clearDatabase();
        liquibase.update(contexts);
        clearDatabase();
    }
",non-flaky,5
159663,liquibase_liquibase,AbstractIntegrationTest.testOutputChangeLogIgnoringSchema,"    @Test
    public void testOutputChangeLogIgnoringSchema() throws Exception {
        assumeNotNull(this.getDatabase());

        String schemaName = getDatabase().getDefaultSchemaName();
        if (schemaName == null) {
            return;
        }

        getDatabase().setOutputDefaultSchema(false);
        getDatabase().setOutputDefaultCatalog(false);

        StringWriter output = new StringWriter();
        Liquibase liquibase = createLiquibase(includedChangeLog);
        clearDatabase();

        liquibase = createLiquibase(includedChangeLog);
        liquibase.update(contexts, output);

        String outputResult = output.getBuffer().toString();
        assertNotNull(""generated SQL may not be empty"", outputResult);
        assertTrue(""Expect at least 100 bytes of output in generated SQL"", outputResult.length() > 100);
        CharSequence expected = ""CREATE TABLE ""+getDatabase().escapeTableName(getDatabase().getLiquibaseCatalogName(), getDatabase().getLiquibaseSchemaName(), getDatabase().getDatabaseChangeLogTableName());
        assertTrue(""create databasechangelog command not found in: \n"" + outputResult, outputResult.contains(expected));
        assertTrue(""create databasechangeloglock command not found in: \n"" + outputResult, outputResult.contains(expected));
        assertFalse(""the schema name '"" + schemaName + ""' should be ignored\n\n"" + outputResult, outputResult.contains
                (schemaName+"".""));
    }
",non-flaky,5
159664,liquibase_liquibase,AbstractIntegrationTest.testGenerateChangeLogWithNoChanges,"    @Test
    public void testGenerateChangeLogWithNoChanges() throws Exception {
        assumeNotNull(this.getDatabase());

        runCompleteChangeLog();

        DiffResult diffResult = DiffGeneratorFactory.getInstance().compare(database, database, new CompareControl());

        DiffToChangeLog changeLogWriter = new DiffToChangeLog(diffResult, new DiffOutputControl(false, false, false, null));
        List<ChangeSet> changeSets = changeLogWriter.generateChangeSets();
        assertEquals(""generating two change logs without any changes in between should result in an empty generated "" +
                ""differential change set."", 0, changeSets.size());
    }
",non-flaky,5
159665,liquibase_liquibase,MssqlIntegrationTest.defaultValuesTests,"    @Test
    public void defaultValuesTests() throws Exception {
        clearDatabase();

        assumeNotNull(this.getDatabase());

        Liquibase liquibase = createLiquibase(""changelogs/mssql/issues/default.values.xml"");
        liquibase.update((String) null);

        DatabaseSnapshot snapshot = SnapshotGeneratorFactory.getInstance().createSnapshot(CatalogAndSchema.DEFAULT, this.getDatabase(), new SnapshotControl(getDatabase()));

        for (Table table : snapshot.get(Table.class)) {
            for (Column column : table.getColumns()) {
                if (column.getName().toLowerCase().endsWith(""_default"")) {
                    Object defaultValue = column.getDefaultValue();
                    assertNotNull(""Null default value for "" + table.getName() + ""."" + column.getName(), defaultValue);
                    if (column.getName().toLowerCase().contains(""date"") || column.getName().toLowerCase().contains(""time"")) {
                        if (defaultValue instanceof String) {
                            assertTrue(defaultValue.equals(""2017-12-09 23:52:39.1234567 +01:00""));
                        } else if (defaultValue instanceof DatabaseFunction) {
                            ((DatabaseFunction) defaultValue).getValue().contains(""type datetimeoffset"");
                        } else if (defaultValue instanceof Time) {
                            Calendar calendar = Calendar.getInstance();
                            calendar.setTime(((Date) defaultValue));
                            assertEquals(23, calendar.get(Calendar.HOUR_OF_DAY));
                            assertEquals(52, calendar.get(Calendar.MINUTE));
                            assertEquals(39, calendar.get(Calendar.SECOND));
                        } else {
                            assertTrue(""Unexpected default type ""+defaultValue.getClass().getName()+"" for "" + table.getName() + ""."" + column.getName(), defaultValue instanceof Date);
                            Calendar calendar = Calendar.getInstance();
                            calendar.setTime(((Date) defaultValue));
                            assertEquals(9, calendar.get(Calendar.DAY_OF_MONTH));
                            assertEquals(11, calendar.get(Calendar.MONTH));
                            assertEquals(2017, calendar.get(Calendar.YEAR));
                        }
                    } else if (column.getName().toLowerCase().contains(""char_"")) {
                        assertTrue(""Unexpected default type ""+defaultValue.getClass().getName()+"" for "" + table.getName() + ""."" + column.getName(), defaultValue instanceof String);
                    } else if (column.getName().toLowerCase().contains(""binary_"")) {
                        assertTrue(""Unexpected default type ""+defaultValue.getClass().getName()+"" for "" + table.getName() + ""."" + column.getName(), defaultValue instanceof DatabaseFunction);
                    } else {
                        assertTrue(""Unexpected default type ""+defaultValue.getClass().getName()+"" for "" + table.getName() + ""."" + column.getName(), defaultValue instanceof Number);
                        assertEquals(1, ((Number) defaultValue).intValue());
                    }
                }
            }
        }
    }
",non-flaky,5
159666,liquibase_liquibase,MssqlIntegrationTest.dataTypesTest,"    @Test
    public void dataTypesTest() throws Exception {
        assumeNotNull(this.getDatabase());
        clearDatabase();

        Liquibase liquibase = createLiquibase(""changelogs/mssql/issues/data.types.xml"");
        liquibase.update((String) null);

        DatabaseSnapshot snapshot = SnapshotGeneratorFactory.getInstance().createSnapshot(CatalogAndSchema.DEFAULT, this.getDatabase(), new SnapshotControl(getDatabase()));

        for (Table table : snapshot.get(Table.class)) {
            if (getDatabase().isLiquibaseObject(table)) {
                continue;
            }
            for (Column column : table.getColumns()) {
                String expectedType = column.getName().split(""_"")[0];

                switch(expectedType.toUpperCase()) {
                    // See https://docs.microsoft.com/en-us/sql/t-sql/data-types/ntext-text-and-image-transact-sql
                    // Types text, ntext and image are deprecated and should be translated into
                    // varchar(max), nvarchar(max) and varbinary(max).
                    case ""TEXT"":
                        expectedType=""varchar"";
                        break;
                    case ""NTEXT"":
                        expectedType=""nvarchar"";
                        break;
                    case ""IMAGE"":
                        expectedType=""varbinary"";
                        break;
                    default:
                        // nothing to do
                }

                String foundTypeDefinition = DataTypeFactory.getInstance().from(column.getType(), new MSSQLDatabase()).toDatabaseDataType(getDatabase()).toString();
                // [varbinary] -> varbinary
                foundTypeDefinition = foundTypeDefinition.replaceFirst(""^\\[(.*?)\\]"", ""$1"");
                String foundType = foundTypeDefinition.replaceFirst(""\\(.*"", """").trim();

                assertEquals(""Wrong data type for "" + table.getName() + ""."" + column.getName(),
                    expectedType.toLowerCase(),
                    foundType.toLowerCase()
                );

                if (""varbinary"".equalsIgnoreCase(expectedType)) {
                    if (column.getName().endsWith(""_MAX"")) {
                        assertEquals(""VARBINARY(MAX)"", foundTypeDefinition.toUpperCase());
                    } else {
                        assertEquals(""VARBINARY(1)"", foundTypeDefinition.toUpperCase());
                    }
                }
            }
        }
    }
",non-flaky,5
159667,liquibase_liquibase,MssqlIntegrationTest.dataTypeParamsTest,"    @Test
    public void dataTypeParamsTest() throws Exception {
        assumeNotNull(this.getDatabase());
        clearDatabase();

        Liquibase liquibase = createLiquibase(""changelogs/mssql/issues/data.type.params.xml"");
        liquibase.update((String) null);

        DatabaseSnapshot snapshot = SnapshotGeneratorFactory.getInstance().createSnapshot(CatalogAndSchema.DEFAULT, this.getDatabase(), new SnapshotControl(getDatabase()));

        for (Table table : snapshot.get(Table.class)) {
            if (getDatabase().isLiquibaseObject(table)) {
                continue;
            }
            for (Column column : table.getColumns()) {
                String expectedType = column.getName().split(""_"")[0];

                String foundTypeDefinition = DataTypeFactory.getInstance().from(column.getType(), new MSSQLDatabase()).toDatabaseDataType(getDatabase()).toString();
                assertFalse(""Parameter found in "" + table.getName() + ""."" + column.getName(), foundTypeDefinition.contains(""(""));
            }
        }
    }
",non-flaky,5
159668,liquibase_liquibase,AbstractMssqlIntegrationTest.impossibleDefaultSchema,"    @Test
    public void impossibleDefaultSchema() {
        Exception caughtException = null;
        try {
            getDatabase().setDefaultSchemaName(""lbuser"");
        } catch (Exception ex) {
            caughtException = ex;
        }
        assertNotNull(""Must not allow using a defaultSchemaName that is different from the DB user's login schema."",
            caughtException);

    }
",non-flaky,5
159669,liquibase_liquibase,AbstractMssqlIntegrationTest.smartDataLoad,"    @Test
    public void smartDataLoad() throws Exception {
        assumeNotNull(this.getDatabase());
        Liquibase liquibase = createLiquibase(""changelogs/common/smartDataLoad.changelog.xml"");
        clearDatabase();
        try {
            liquibase.update(this.contexts);
        } catch (ValidationFailedException e) {
            e.printDescriptiveError(System.out);
            throw e;
        }
        try {
            liquibase.rollback(new Date(0), this.contexts);
        } catch (ValidationFailedException e) {
            e.printDescriptiveError(System.out);
            throw e;
        }
    }
",non-flaky,5
159670,liquibase_liquibase,UnlockDatabaseChangeLogExecuteTest.generateSql,"    @Test
    public void generateSql() throws Exception {
        this.statementUnderTest = new UnlockDatabaseChangeLogStatement();
        assertCorrect(""update [databasechangeloglock] set [locked] = 0, [lockedby] = null, [lockgranted] = null where [id] = 1"", MSSQLDatabase.class, SybaseDatabase.class);
        assertCorrect(""update [databasechangeloglock] set [locked] = 0, [lockedby] = null, [lockgranted] = null where [id] = 1"", MSSQLDatabase.class, SybaseASADatabase.class);
        assertCorrect(""update [databasechangeloglock] set [locked] = 'f', [lockedby] = null, [lockgranted] = null where [id] = 1"", InformixDatabase.class);
        assertCorrect(""update [databasechangeloglock] set [locked] = false, [lockedby] = null, [lockgranted] = null where [id] = 1"", PostgresDatabase.class, HsqlDatabase.class, H2Database.class);
        assertCorrectOnRest(""update [databasechangeloglock] set [locked] = 0, [lockedby] = null, [lockgranted] = null where [id] = 1"");
    }
",non-flaky,5
159671,liquibase_liquibase,AddColumnExecutorTest.generateSql_autoIncrement,"    @Test
    public void generateSql_autoIncrement() throws Exception {
        this.statementUnderTest = new AddColumnStatement(null, ""table_name"", ""column_name"", ""int"", null, new AutoIncrementConstraint(""column_name""));

        assertCorrect(""alter table table_name add column_name serial"", InformixDatabase.class);
        assertCorrect(""alter table [table_name] add [column_name] int default autoincrement null"", SybaseASADatabase.class);
        assertCorrect(""alter table [table_name] add [column_name] serial"", PostgresDatabase.class);
        assertCorrect(""alter table [dbo].[table_name] add [column_name] int identity"", MSSQLDatabase.class);
        assertCorrect(""alter table [table_name] add [column_name] int identity null"", SybaseDatabase.class);
        assertCorrect(""not supported. fixme!!"", SQLiteDatabase.class);
        assertCorrect(""alter table table_name add column_name int auto_increment_clause"");
    }
",non-flaky,5
159672,liquibase_liquibase,AddColumnExecutorTest.generateSql_notNull,"    @Test
    public void generateSql_notNull() throws Exception {
        this.statementUnderTest = new AddColumnStatement(null, null, ""table_name"", ""column_name"", ""int"", 42, new NotNullConstraint());
        assertCorrect(""alter table [table_name] add [column_name] int default 42 not null"", SybaseASADatabase.class, SybaseDatabase.class);
        assertCorrect(""alter table table_name add column_name int default 42 not null"", PostgresDatabase.class);
        assertCorrect(""alter table [table_name] add [column_name] [int] constraint df_table_name_column_name default 42 not null"", MSSQLDatabase.class);
        assertCorrect(""alter table table_name add column_name int default 42 not null"", MySQLDatabase.class);
        assertCorrect(""not supported. fixme!!"", SQLiteDatabase.class);
        assertCorrect(""ALTER TABLE [table_name] ADD [column_name] int DEFAULT 42 NOT NULL"");
    }
",non-flaky,5
159673,liquibase_liquibase,AddColumnExecutorTest.fullNoConstraints,"    @Test
    public void fullNoConstraints() throws Exception {
        this.statementUnderTest = new AddColumnStatement(null, null, ""table_name"", ""column_name"", ""int"", 42);


        assertCorrect(""alter table [table_name] add [column_name] int default 42 null"", SybaseDatabase.class);
        assertCorrect(""alter table [table_name] add [column_name] int constraint df_table_name_column_name default 42"", MSSQLDatabase.class);
//        assertCorrect(""alter table [table_name] add [column_name] integer default 42"", SQLiteDatabase.class);
        assertCorrect(""not supported. fixme!!"", SQLiteDatabase.class);
        assertCorrect(""alter table table_name add column_name int default 42"", PostgresDatabase.class, InformixDatabase.class, OracleDatabase.class, DerbyDatabase.class, HsqlDatabase.class, DB2Database.class, H2Database.class, FirebirdDatabase.class);
        assertCorrect(""alter table [table_name] add [column_name] int default 42 null"", SybaseASADatabase.class);
        assertCorrect(""alter table table_name add column_name int default 42 null"", MySQLDatabase.class, MariaDBDatabase.class);
        assertCorrectOnRest(""ALTER TABLE [table_name] ADD [column_name] int DEFAULT 42"");
    }
",non-flaky,5
159674,liquibase_liquibase,AddColumnExecutorTest.autoIncrement,"    @Test
    public void autoIncrement() throws Exception {
        this.statementUnderTest = new AddColumnStatement(null, TABLE_NAME, ""column_name"", ""int"", null, new AutoIncrementConstraint());

        assertCorrect(""ALTER TABLE [dbo].[table_name] ADD [column_name] int auto_increment_clause"", MSSQLDatabase.class);
        assertCorrect(""alter table [table_name] add [column_name] int default autoincrement null"", SybaseASADatabase.class);
        assertCorrect(""alter table [table_name] add [column_name] int identity null"", SybaseDatabase.class);
        assertCorrect(""alter table [table_name] add [column_name] serial"", PostgresDatabase.class, InformixDatabase.class);
        assertCorrect(""not supported. fixme!!"", SQLiteDatabase.class);
        assertCorrectOnRest(""ALTER TABLE [table_name] ADD [column_name] int auto_increment_clause"");
    }
",non-flaky,5
159675,liquibase_liquibase,AddColumnExecutorTest.notNull,"    @Test
    public void notNull() throws Exception {
        this.statementUnderTest = new AddColumnStatement(null, null, TABLE_NAME, ""column_name"", ""int"", 42, new NotNullConstraint());

        assertCorrect(""ALTER TABLE [table_name] ADD [column_name] int DEFAULT 42 NOT NULL"", SybaseASADatabase.class, SybaseDatabase.class);
        assertCorrect(""alter table table_name add column_name int default 42 not null"", InformixDatabase.class);
        assertCorrect(""alter table [table_name] add [column_name] int constraint df_table_name_column_name default 42 not null"", MSSQLDatabase.class);
        assertCorrect(""alter table table_name add column_name int default 42 not null"", OracleDatabase.class, DerbyDatabase.class, HsqlDatabase.class, DB2Database.class, H2Database.class, FirebirdDatabase.class);
        assertCorrect(""not supported. fixme!!"", SQLiteDatabase.class);
        assertCorrectOnRest(""ALTER TABLE [table_name] ADD [column_name] int default 42 not null"");
    }
",non-flaky,5
159676,liquibase_liquibase,AddColumnExecutorTest.generateSql_primaryKey,"    @Test
    public void generateSql_primaryKey() throws Exception {
        this.statementUnderTest = new AddColumnStatement(null, ""table_name"", ""column_name"", ""int"", null, new PrimaryKeyConstraint());

        assertCorrect(""alter table [table_name] add [column_name] int not null primary key"", HsqlDatabase.class);
        assertCorrect(""alter table [table_name] add [column_name] int primary key not null"", SybaseASADatabase.class, SybaseDatabase.class);
        assertCorrect(""alter table [dbo].[table_name] add [column_name] int not null primary key"", MSSQLDatabase.class);
        assertCorrect(""alter table table_name add column_name int not null primary key"", PostgresDatabase.class);
        assertCorrect(""alter table `table_name` add `column_name` int not null primary key"", MySQLDatabase.class);
        assertCorrect(""ALTER TABLE [table_name] ADD [column_name] int PRIMARY KEY NOT NULL"");
    }
",non-flaky,5
159677,liquibase_liquibase,AddColumnExecutorTest.generateSql_foreignKey,"    @Test
    public void generateSql_foreignKey() throws Exception {
        this.statementUnderTest = new AddColumnStatement(null, ""table_name"", ""column_name"", ""int"", null, new PrimaryKeyConstraint(), new ForeignKeyConstraint(""fk_test_fk"", ""table_name(column_name)""));

        assertCorrect(new String[] {""alter table [table_name] add [column_name] int not null primary key"", ""alter table [table_name] add constraint [fk_test_fk] foreign key ([column_name]) references [table_name]([column_name])""}, HsqlDatabase.class);
        assertCorrect(new String[] {""alter table [table_name] add [column_name] int primary key not null"", ""alter table [table_name] add constraint [fk_test_fk] foreign key ([column_name]) references [table_name]([column_name])""}, SybaseASADatabase.class, SybaseDatabase.class);
        assertCorrect(new String[] {""alter table [dbo].[table_name] add [column_name] int not null primary key"", ""alter table [dbo].[table_name] add constraint [fk_test_fk] foreign key ([column_name]) references [dbo].[table_name]([column_name])""}, MSSQLDatabase.class);
        assertCorrect(new String[] {""alter table table_name add column_name int not null primary key"", ""alter table [table_name] add constraint [fk_test_fk] foreign key ([column_name]) references [table_name]([column_name])""}, PostgresDatabase.class);
        assertCorrect(new String[] {""alter table `table_name` add `column_name` int not null primary key"", ""alter table [table_name] add constraint [fk_test_fk] foreign key ([column_name]) references [table_name]([column_name])""}, MySQLDatabase.class);
        assertCorrect(new String[] {""ALTER TABLE [table_name] ADD [column_name] int PRIMARY KEY NOT NULL"", ""alter table [table_name] add constraint  foreign key ([column_name]) references [table_name]([column_name]) constraint [fk_test_fk]""}, InformixDatabase.class);
        assertCorrect(new String[] {""ALTER TABLE [table_name] ADD [column_name] int PRIMARY KEY NOT NULL"", ""alter table [table_name] add constraint [fk_test_fk] foreign key ([column_name]) references [table_name]([column_name])""});
    }
",non-flaky,5
159678,liquibase_liquibase,AddUniqueConstraintExecutorTest.execute_noSchema,"    //    @Test
//    public void execute_noSchema() throws Exception {
//        new DatabaseTestTemplate().testOnAvailableDatabases(
//                new SqlStatementDatabaseTest(null, new AddUniqueConstraintStatement(null, TABLE_NAME, COLUMN_NAME, ""uq_adduqtest"")) {
//
//                    protected void preExecuteAssert(DatabaseSnapshotGenerator snapshot) {
//                        assertFalse(snapshot.getTable(TABLE_NAME).getColumn(COLUMN_NAME).isUnique());
//                    }
//
//                    protected void postExecuteAssert(DatabaseSnapshotGenerator snapshot) {
//                        //todo: enable snapshot and assertion when snapshot can check for unique constraints
//                        //snapshot = new DatabaseSnapshotGenerator(snapshot);
//                    	assertTrue(snapshot.getTable(TABLE_NAME).getColumn(COLUMN_NAME).isUnique());
//                    }
//                });
//    }
",non-flaky,5
159679,liquibase_liquibase,AddUniqueConstraintExecutorTest.execute_withSchema,"//    @Test
//    public void execute_withSchema() throws Exception {
//        new DatabaseTestTemplate().testOnAvailableDatabases(
//                new SqlStatementDatabaseTest(TestContext.ALT_SCHEMA, new AddUniqueConstraintStatement(TestContext.ALT_SCHEMA, TABLE_NAME, COLUMN_NAME, ""uq_adduqtest"")) {
//                    protected void preExecuteAssert(DatabaseSnapshotGenerator snapshot) {
//                        assertFalse(snapshot.getTable(TABLE_NAME).getColumn(COLUMN_NAME).isUnique());
//                    }
//
//                    protected void postExecuteAssert(DatabaseSnapshotGenerator snapshot) {
//                        //todo: enable snapshot and assertion when snapshot can check for unique constraints
//                snapshot = new DatabaseSnapshotGenerator(database, TestContext.ALT_SCHEMA);
//                assertTrue(snapshot.getTable(TABLE_NAME).getColumn(COLUMN_NAME).isUnique());
//                    }
//
//                });
//    }
",non-flaky,5
159680,liquibase_liquibase,AddUniqueConstraintExecutorTest.execute_withTablespace,"//    @Test
//    public void execute_withTablespace() throws Exception {
//        new DatabaseTestTemplate().testOnAvailableDatabases(
//                new SqlStatementDatabaseTest(null, new AddUniqueConstraintStatement(null, TABLE_NAME, COLUMN_NAME, ""uq_adduqtest"").setTablespace(TestContext.ALT_TABLESPACE)) {
//                    protected void preExecuteAssert(DatabaseSnapshotGenerator snapshot) {
//                        assertFalse(snapshot.getTable(TABLE_NAME).getColumn(COLUMN_NAME).isUnique());
//                    }
//
//                    protected void postExecuteAssert(DatabaseSnapshotGenerator snapshot) {
//                        //todo: enable snapshot and assertion when snapshot can check for unique constraints
//                        // snapshot = new DatabaseSnapshotGenerator(database);
////                assertTrue(snapshot.getTable(TABLE_NAME).getColumn(COLUMN_NAME).isUnique());
//                    }
//                });
//    }
",non-flaky,5
159681,liquibase_liquibase,AddUniqueConstraintExecutorTest.execute_noSchema,"    @Test
    public void execute_noSchema() throws Exception {
        this.statementUnderTest = new AddUniqueConstraintStatement(null, null, TABLE_NAME, new ColumnConfig[] { new ColumnConfig().setName(COLUMN_NAME)}, CONSTRAINT_NAME);
        assertCorrect(""alter table [adduqtest] add constraint [uq_test] unique ([coltomakeuq])"", SybaseDatabase.class);
        assertCorrect(""alter table [adduqtest] add constraint [uq_test] unique ([coltomakeuq])"", MSSQLDatabase.class);
        assertCorrect(""alter table [adduqtest] add constraint [uq_test] unique ([coltomakeuq])"", SybaseASADatabase.class);
        assertCorrect(""alter table adduqtest add constraint uq_test unique (coltomakeuq)"", MySQLDatabase.class);
        assertCorrect(""alter table adduqtest add constraint unique (coltomakeuq) constraint uq_test"", InformixDatabase.class);
        assertCorrect(""alter table adduqtest add constraint uq_test unique (coltomakeuq)"", OracleDatabase.class);
        assertCorrect(""alter table \""adduqtest\"" add constraint uq_test unique (\""coltomakeuq\"")"", PostgresDatabase.class);
        assertCorrect(""alter table adduqtest add constraint uq_test unique (coltomakeuq)"", DerbyDatabase.class);
        assertCorrect(""alter table [adduqtest] add constraint [uq_test] unique ([coltomakeuq])"");
    }
",non-flaky,5
159682,liquibase_liquibase,AddUniqueConstraintExecutorTest.execute_noConstraintName,"    @Test
    public void execute_noConstraintName() throws Exception {
        this.statementUnderTest = new AddUniqueConstraintStatement(null, null, TABLE_NAME, new ColumnConfig[] { new ColumnConfig().setName(COLUMN_NAME)}, null);
        assertCorrect(""alter table adduqtest add unique (coltomakeuq)"", MySQLDatabase.class);
        assertCorrect(""alter table adduqtest add constraint unique (coltomakeuq)"", InformixDatabase.class);
        assertCorrect(""alter table adduqtest add unique (coltomakeuq)"", OracleDatabase.class);
        assertCorrect(""alter table \""adduqtest\"" add unique (\""coltomakeuq\"")"", PostgresDatabase.class);
        assertCorrect(""alter table adduqtest add unique (coltomakeuq)"", DerbyDatabase.class);
        assertCorrect(""alter table [adduqtest] add unique ([coltomakeuq])"", SybaseASADatabase.class, SybaseDatabase.class);
        assertCorrect(""alter table [adduqtest] add unique ([coltomakeuq])"", MSSQLDatabase.class);

        assertCorrect(""alter table [adduqtest] add unique ([coltomakeuq])"");
    }
",non-flaky,5
159683,liquibase_liquibase,AddUniqueConstraintExecutorTest.execute_withSchema,"    @Test
    public void execute_withSchema() throws Exception {
        statementUnderTest = new AddUniqueConstraintStatement(
                DatabaseTestContext.ALT_CATALOG,
                DatabaseTestContext.ALT_SCHEMA,
                TABLE_NAME,
                new ColumnConfig[]
                        {new ColumnConfig().setName(COLUMN_NAME)},
                CONSTRAINT_NAME
        );

        assertCorrect(""ALTER TABLE liquibasec.adduqtest ADD CONSTRAINT uq_test UNIQUE (coltomakeuq)"", MySQLDatabase
                .class);
        /*
         * In Informix, this test case is actually impossible. While it is allowed to cross-select data from
          * different databases (using the database:schema.table notation), it is not allowed to send DDL to a
          * different database (even if the database is on the same instance). So, even as the following
          * statement is semantically false, it is syntactically correct.
         */
        assertCorrect(""ALTER TABLE liquibasec:liquibaseb.adduqtest ADD CONSTRAINT UNIQUE (coltomakeuq) CONSTRAINT "" +
                ""uq_test"", InformixDatabase.class);

        assertCorrect(""alter table liquibasec.adduqtest add constraint uq_test unique (coltomakeuq)"", OracleDatabase.class);
        assertCorrect(""alter table liquibaseb.\""adduqtest\"" add constraint uq_test unique (\""coltomakeuq\"")"", PostgresDatabase.class);
        assertCorrect(""alter table liquibasec.adduqtest add constraint uq_test unique (coltomakeuq)"", DerbyDatabase
                .class);
        assertCorrect(""alter table [liquibaseb].[adduqtest] add constraint [uq_test] unique ([coltomakeuq])"",
                SybaseASADatabase.class, SybaseDatabase.class);
        assertCorrect(""alter table [liquibasec].[liquibaseb].[adduqtest] add constraint [uq_test] unique "" +
                ""([coltomakeuq])"", MSSQLDatabase.class);
        assertCorrect(""alter table [adduqtest] add constraint [uq_test] unique ([coltomakeuq])"", FirebirdDatabase.class);

        assertCorrect(""alter table [liquibaseb].[adduqtest] add constraint [uq_test] unique ([coltomakeuq])"", HsqlDatabase.class);
        assertCorrect(""alter table \""liquibasec\"".[adduqtest] add constraint [uq_test] unique ([coltomakeuq])"", DB2Database.class, Db2zDatabase.class);
        assertCorrect(""alter table [liquibaseb].[adduqtest] add constraint [uq_test] unique ([coltomakeuq])"", H2Database.class);
        assertCorrectOnRest(""alter table [liquibasec].[adduqtest] add constraint [uq_test] unique ([coltomakeuq])"");

    }
",non-flaky,5
159684,liquibase_liquibase,AddUniqueConstraintExecutorTest.execute_withTablespace,"    @Test
    public void execute_withTablespace() throws Exception {
        statementUnderTest = new AddUniqueConstraintStatement(null, null, TABLE_NAME, new ColumnConfig[] { new ColumnConfig().setName(COLUMN_NAME)}, CONSTRAINT_NAME).setTablespace(TABLESPACE_NAME);
        assertCorrect(""alter table [adduqtest] add constraint [uq_test] unique ([coltomakeuq])"", SybaseASADatabase.class, SybaseDatabase.class);
        assertCorrect(""alter table [adduqtest] add constraint [uq_test] unique ([coltomakeuq]) on liquibase2"", MSSQLDatabase.class);
        assertCorrect(""alter table adduqtest add constraint unique (coltomakeuq) constraint uq_test"", InformixDatabase.class);
        assertCorrect(""alter table \""adduqtest\"" add constraint uq_test unique (\""coltomakeuq\"") USING INDEX TABLESPACE "" + TABLESPACE_NAME, PostgresDatabase.class);
        assertCorrect(""alter table adduqtest add constraint uq_test unique (coltomakeuq)"", MySQLDatabase.class);
        assertCorrect(""alter table adduqtest add constraint uq_test unique (coltomakeuq)"", MariaDBDatabase.class);
        assertCorrect(""alter table adduqtest add constraint uq_test unique (coltomakeuq)"", DerbyDatabase.class, HsqlDatabase.class, DB2Database.class, H2Database.class, FirebirdDatabase.class);
        assertCorrect(""alter table [adduqtest] add constraint [uq_test] unique ([coltomakeuq])"", Db2zDatabase.class);
        assertCorrectOnRest(""alter table [adduqtest] add constraint [uq_test] unique ([coltomakeuq]) USING INDEX TABLESPACE "" + TABLESPACE_NAME);
    }
",non-flaky,5
159685,liquibase_liquibase,AddUniqueConstraintExecutorTest.execute_withDefferedAndDisabled,"    @Test
    public void execute_withDefferedAndDisabled() throws Exception {
        statementUnderTest = new AddUniqueConstraintStatement(null, null, TABLE_NAME, new ColumnConfig[] { new ColumnConfig().setName(COLUMN_NAME)}, CONSTRAINT_NAME).setDeferrable(true).setInitiallyDeferred(true).setDisabled(true);
        assertCorrect(""alter table [adduqtest] add constraint [uq_test] unique ([coltomakeuq])"", SybaseDatabase.class);
        assertCorrect(""alter table [adduqtest] add constraint [uq_test] unique ([coltomakeuq])"", MSSQLDatabase.class);
        assertCorrect(""alter table [adduqtest] add constraint [uq_test] unique ([coltomakeuq])"", SybaseASADatabase.class);
        assertCorrect(""alter table adduqtest add constraint uq_test unique (coltomakeuq)"", MySQLDatabase.class);
        assertCorrect(""alter table adduqtest add constraint unique (coltomakeuq) constraint uq_test"", InformixDatabase.class);
        assertCorrect(""alter table adduqtest add constraint uq_test unique (coltomakeuq) DEFERRABLE INITIALLY "" +
                ""DEFERRED DISABLE"", OracleDatabase.class);
        assertCorrect(""ALTER TABLE \""adduqtest\"" ADD CONSTRAINT uq_test unique (\""coltomakeuq\"") DEFERRABLE INITIALLY"" +
                "" DEFERRED"", PostgresDatabase.class);
        assertCorrect(""alter table adduqtest add constraint uq_test unique (coltomakeuq)"", DerbyDatabase.class);
        assertCorrect(""alter table [adduqtest] add constraint [uq_test] unique ([coltomakeuq])"");
    }
",non-flaky,5
159686,liquibase_liquibase,MarkChangeSetRanExecuteTest.generateSql_insert,"    @Test
    public void generateSql_insert() throws Exception {
        this.statementUnderTest = new MarkChangeSetRanStatement(new ChangeSet(""a"", ""b"", false, false, ""c"", ""e"", ""f"",
                null), ChangeSet.ExecType.EXECUTED);
        String version = LiquibaseUtil.getBuildVersion().replaceAll(""SNAPSHOT"", ""SNP"");
        assertCorrect(""insert into [databasechangelog] ([id], [author], [filename], [dateexecuted], "" +
                        ""[orderexecuted], [md5sum], [description], [comments], [exectype], [contexts], [labels], "" +
                        ""[liquibase], [deployment_id]) values ('a', 'b', 'c', getdate(), 1, "" +
                        ""'8:d41d8cd98f00b204e9800998ecf8427e', 'empty', '', 'executed', 'e', null, '"" + version + ""',"" +
                        "" null)"",
                MSSQLDatabase.class);
        assertCorrect(""insert into databasechangelog (id, author, filename, dateexecuted, orderexecuted, "" +
                        ""md5sum, description, comments, exectype, contexts, labels, liquibase, deployment_id) values "" +
                        ""('a', 'b', 'c', systimestamp, 1, '8:d41d8cd98f00b204e9800998ecf8427e', 'empty', '', "" +
                        ""'executed', 'e', null, '"" + version + ""', null)"",
                OracleDatabase.class);
        assertCorrect(""insert into [databasechangelog] ([id], [author], [filename], [dateexecuted], "" +
                        ""[orderexecuted], [md5sum], [description], [comments], [exectype], [contexts], [labels], "" +
                        ""[liquibase], [deployment_id]) values ('a', 'b', 'c', getdate(), 1, "" +
                        ""'8:d41d8cd98f00b204e9800998ecf8427e', 'empty', '', 'executed', 'e', null, '"" + version + ""',"" +
                        "" null)"",
                SybaseDatabase.class);
        assertCorrect(""insert into databasechangelog (id, author, filename, dateexecuted, orderexecuted, "" +
                        ""md5sum, description, comments, exectype, contexts, labels, liquibase, deployment_id) values "" +
                        ""('a', 'b', 'c', "" +
                        ""current year to fraction(5), 1, '8:d41d8cd98f00b204e9800998ecf8427e', 'empty', '', "" +
                        ""'executed', "" +
                        ""'e', null, '"" + version + ""', null)"",
                InformixDatabase.class);
        assertCorrect(""insert into databasechangelog (id, author, filename, dateexecuted, orderexecuted, "" +
                        ""md5sum, description, comments, exectype, contexts, labels, liquibase, deployment_id) values "" +
                        ""('a', 'b', 'c', current timestamp, 1, "" +
                        ""'8:d41d8cd98f00b204e9800998ecf8427e', 'empty', '', 'executed', 'e', null, '"" + version + ""',"" +
                        "" null)"",
                DB2Database.class);
        assertCorrect(""insert into databasechangelog (id, author, filename, dateexecuted, orderexecuted, "" +
                        ""md5sum, description, comments, exectype, contexts, labels, liquibase, deployment_id) values "" +
                        ""('a', 'b', 'c', current_timestamp, 1, "" +
                        ""'8:d41d8cd98f00b204e9800998ecf8427e', 'empty', '', 'executed', 'e', null, '"" + version + ""',"" +
                        "" null)"",
                FirebirdDatabase.class, DerbyDatabase.class);
        assertCorrect(""insert into databasechangelog (id, author, filename, dateexecuted, orderexecuted, "" +
                        ""md5sum, description, comments, exectype, contexts, labels, liquibase, deployment_id) values "" +
                        ""('a', 'b', 'c', now, 1, "" +
                        ""'8:d41d8cd98f00b204e9800998ecf8427e', 'empty', '', 'executed', 'e', null, '"" + version + ""',"" +
                        "" null)"",
                HsqlDatabase.class);
        assertCorrect(""insert into databasechangelog (id, author, filename, dateexecuted, orderexecuted, "" +
                        ""md5sum, description, comments, exectype, contexts, labels, liquibase, deployment_id) values "" +
                        ""('a', 'b', 'c', now(), 1, "" +
                        ""'8:d41d8cd98f00b204e9800998ecf8427e', 'empty', '', 'executed', 'e', null, '"" + version + ""',"" +
                        "" null)"",
                SybaseASADatabase.class);
        assertCorrect(""insert into databasechangelog (id, author, filename, dateexecuted, orderexecuted, "" +
                        ""md5sum, `description`, comments, exectype, contexts, labels, liquibase, deployment_id) values "" +
                        ""('a', 'b', 'c', now(), 1, "" +
                        ""'8:d41d8cd98f00b204e9800998ecf8427e', 'empty', '', 'executed', 'e', null, '"" + version + ""',"" +
                        "" null)"",
                MySQLDatabase.class, MariaDBDatabase.class);
        assertCorrect(""insert into databasechangelog (id, author, filename, dateexecuted, orderexecuted, "" +
                        ""md5sum, description, comments, exectype, contexts, labels, liquibase, deployment_id) values "" +
                        ""('a', 'b', 'c', now(), 1, "" +
                        ""'8:d41d8cd98f00b204e9800998ecf8427e', 'empty', '', 'executed', 'e', null, '"" + version + ""',"" +
                        "" null)"",
                PostgresDatabase.class, H2Database.class);
        assertCorrectOnRest(""insert into databasechangelog (id, author, filename, dateexecuted, "" +
                ""orderexecuted, md5sum, description, comments, exectype, contexts, labels, liquibase, deployment_id) "" +
                ""values ('a', 'b', 'c', "" +
                ""current timestamp, 1, '8:d41d8cd98f00b204e9800998ecf8427e', 'empty', '', 'executed', 'e', null, "" +
                ""'"" + version + ""', null)"");
    }
",non-flaky,5
159687,liquibase_liquibase,MarkChangeSetRanExecuteTest.generateSql_update,"    @Test
    public void generateSql_update() throws Exception {
        this.statementUnderTest = new MarkChangeSetRanStatement(new ChangeSet(""a"", ""b"", false, false, ""c"", ""e"", ""f"",
                null), ChangeSet.ExecType.RERAN);
        assertCorrect(""update [databasechangelog] set [dateexecuted] = getdate(), [deployment_id] = null, [exectype] "" +
                        ""= 'reran', [md5sum] = '8:d41d8cd98f00b204e9800998ecf8427e', [orderexecuted] = 2 where [id] ="" +
                        "" 'a' and"" +
                        "" [author] = 'b' and [filename] = 'c'"",
                MSSQLDatabase.class);
        assertCorrect(""update databasechangelog set dateexecuted = systimestamp, deployment_id = null, exectype = "" +
                        ""'reran', md5sum = '8:d41d8cd98f00b204e9800998ecf8427e', orderexecuted = 2 where id = 'a' and"" +
                        "" author "" +
                        ""= 'b' and filename = 'c'"",
                OracleDatabase.class);
        assertCorrect(""update [databasechangelog] set [dateexecuted] = getdate(), [deployment_id] = null, [exectype] "" +
                ""= 'reran', [md5sum] = '8:d41d8cd98f00b204e9800998ecf8427e', [orderexecuted] = 2 where [id] = 'a' and"" +
                "" [author] = 'b' and [filename] = 'c'"", SybaseDatabase.class);
        assertCorrect(""update [databasechangelog] set [dateexecuted] = current year to fraction(5), deployment_id = "" +
                ""null, exectype = 'reran', md5sum = '8:d41d8cd98f00b204e9800998ecf8427e', orderexecuted = 2 where id "" +
                ""= 'a' and author = 'b' and filename = 'c'"", InformixDatabase.class);
        assertCorrect(""update [databasechangelog] set [dateexecuted] = current timestamp, deployment_id = null, "" +
                        ""exectype = 'reran', md5sum = '8:d41d8cd98f00b204e9800998ecf8427e', orderexecuted = 2 where "" +
                        ""id = 'a' and author = 'b' and filename = 'c'"",
                DB2Database.class);
        assertCorrect(""update [databasechangelog] set [dateexecuted] = current_timestamp, deployment_id = null, "" +
                        ""exectype = 'reran', md5sum = '8:d41d8cd98f00b204e9800998ecf8427e', orderexecuted = 2 where "" +
                        ""id = 'a' and author = 'b' and filename = 'c'"",
                FirebirdDatabase.class,
                DerbyDatabase.class);
        assertCorrect(""update [databasechangelog] set [dateexecuted] = NOW(), deployment_id = null, exectype = "" +
                        ""'reran', md5sum = '8:d41d8cd98f00b204e9800998ecf8427e', orderexecuted = 2 where id = 'a' and"" +
                        "" author = 'b' and filename = 'c'"",
                SybaseASADatabase.class);
        assertCorrect(""update [databasechangelog] set [dateexecuted] = NOW(), deployment_id = null, exectype = "" +
                        ""'reran', md5sum = '8:d41d8cd98f00b204e9800998ecf8427e', orderexecuted = 2 where id = 'a' and"" +
                        "" author = 'b' and filename = 'c'"",
                MySQLDatabase.class, MariaDBDatabase.class, HsqlDatabase.class, PostgresDatabase.class, H2Database
                        .class);
        assertCorrectOnRest(""update [databasechangelog] set [dateexecuted] = NOW(), [deployment_id] = null, [exectype] = 'reran', [md5sum] = "" +
                ""'8:d41d8cd98f00b204e9800998ecf8427e', [orderexecuted] = 2 where id = 'a' and author = 'b' and filename = 'c'"");
    }
",non-flaky,5
159688,liquibase_liquibase,CreateDatabaseChangeLogLockTableExecuteTest.generate,"    @Test
    public void generate() throws Exception {
        this.statementUnderTest = new CreateDatabaseChangeLogLockTableStatement();

        assertCorrect(new String[]{""create table [databasechangeloglock] ("" +
                ""[id] int not null, "" +
                ""[locked] boolean not null, "" +
                ""[lockgranted] datetime, "" +
                ""[lockedby] text, "" +
                ""constraint [pk_databasechangeloglock] primary key ([id]))""}, SQLiteDatabase.class);

        assertCorrect(new String[]{""create table [databasechangeloglock] ("" +
                ""[id] int not null, "" +
                ""[locked] bit not null, "" +
                ""[lockgranted] datetime null, "" +
                ""[lockedby] varchar(255) null, "" +
                ""constraint [pk_databasechangeloglock] primary key ([id]))""}, SybaseDatabase.class);

        assertCorrect(new String[]{""create table [databasechangeloglock] ("" +
                ""[id] int not null, "" +
                ""[locked] bit not null, "" +
                ""[lockgranted] datetime null, "" +
                ""[lockedby] varchar(255) null, "" +
                ""constraint [pk_databasechangeloglock] primary key ([id]))""}, SybaseASADatabase.class);

        assertCorrect(new String[]{""create table [databasechangeloglock] ("" +
                ""[id] int not null, "" +
                ""[locked] boolean not null, "" +
                ""[lockgranted] datetime, "" +
                ""[lockedby] varchar(255), "" +
                ""primary key (id))""}, InformixDatabase.class);
    
        assertCorrect(new String[]{""create table [databasechangeloglock] ("" +
                ""[id] [int] not null, "" +
                ""[locked] [bit] not null, "" +
                ""[lockgranted] [datetime2](3), "" +
                ""[lockedby] [nvarchar](255), "" +
                ""constraint [pk_databasechangeloglock] primary key ([id]))""}, MSSQLDatabase.class);

        assertCorrect(new String[]{""create table [databasechangeloglock] ("" +
                ""[id] integer not null, "" +
                ""[locked] smallint not null, "" +
                ""[lockgranted] timestamp, "" +
                ""[lockedby] varchar(255), "" +
                ""constraint [pk_dbchgloglock] primary key ([id]))""}, DB2Database.class);
    
        assertCorrect(new String[]{""create table databasechangeloglock ("" +
                ""id integer not null, "" +
                ""locked number(1) not null, "" +
                ""lockgranted timestamp, "" +
                ""lockedby varchar2(255), "" +
                ""constraint pk_databasechangeloglock primary key (id))""}, OracleDatabase.class);

        assertCorrect(new String[]{""create table [databasechangeloglock] ("" +
                ""[id] int not null, "" +
                ""[locked] boolean not null, "" +
                ""[lockgranted] datetime null, "" +
                ""[lockedby] varchar(255) null, "" +
                ""constraint [pk_databasechangeloglock] primary key ([id]))""}, MySQLDatabase.class);
    
        assertCorrect(new String[]{""create table [databasechangeloglock] ("" +
                ""[id] int not null, "" +
                ""[locked] boolean not null, "" +
                ""[lockgranted] datetime null, "" +
                ""[lockedby] varchar(255) null, "" +
                ""constraint [pk_databasechangeloglock] primary key ([id]))""}, MariaDBDatabase.class);

        assertCorrect(new String[]{""create table [databasechangeloglock] ("" +
                ""[id] int not null, "" +
                ""[locked] boolean not null, "" +
                ""[lockgranted] datetime, "" +
                ""[lockedby] varchar(255), "" +
                ""constraint [databasechangeloglock_pkey] primary key ([id]))""}, PostgresDatabase.class);

        assertCorrect(new String[]{""create table [databasechangeloglock] ("" +
                ""[id] int not null, "" +
                ""[locked] boolean not null, "" +
                ""[lockgranted] datetime, "" +
                ""[lockedby] varchar(255), "" +
                ""constraint [pk_dbchgloglock] primary key ([id]))""}, Db2zDatabase.class);

        // all other RDBMS
        assertCorrect(new String[]{""create table [databasechangeloglock] ("" +
                ""[id] int not null, "" +
                ""[locked] boolean not null, "" +
                ""[lockgranted] datetime, "" +
                ""[lockedby] varchar(255), "" +
                ""constraint [pk_databasechangeloglock] primary key ([id]))""});

    }
",non-flaky,5
159689,liquibase_liquibase,RenameColumnExecuteTest.noSchema,"    @Test
    public void noSchema() throws Exception {
        this.statementUnderTest = new RenameColumnStatement(null, null, TABLE_NAME, COLUMN_NAME, ""new_name"", ""int"");

        assertCorrect(""rename column table_name.column_name to new_name"", DerbyDatabase.class, InformixDatabase.class);
        assertCorrect(""alter table table_name alter column column_name rename to new_name"", H2Database.class, HsqlDatabase.class);
        assertCorrect(""alter table table_name alter column column_name to new_name"", FirebirdDatabase.class);
        assertCorrect(""alter table table_name change column_name new_name int"", MySQLDatabase.class, MariaDBDatabase.class);
        assertCorrect(""exec sp_rename '[table_name].[column_name]', 'new_name'"", MSSQLDatabase.class);
        assertCorrect(""exec sp_rename 'table_name.column_name', 'new_name'"", SybaseDatabase.class);
        assertCorrect(""alter table [table_name] rename column_name to new_name"",SybaseASADatabase.class);
        assertCorrectOnRest(""alter table [table_name] rename column [column_name] to [new_name]"");
    }
",non-flaky,5
159690,liquibase_liquibase,AddAutoIncrementExecuteTest.noSchema,"    @Test
    public void noSchema() throws Exception {
        this.statementUnderTest = new AddAutoIncrementStatement(null, null, TABLE_NAME, COLUMN_NAME, ""int"", null, null, null, null);

        assertCorrect(""alter table [table_name] modify column_name serial"", PostgresDatabase.class);
        assertCorrect(""alter table table_name modify column_name int auto_increment"", MySQLDatabase.class);
        assertCorrect(""ALTER TABLE [table_name] ALTER COLUMN [column_name] SET GENERATED BY DEFAULT AS IDENTITY"", DB2Database.class);
        assertCorrect(""alter table table_name alter column column_name int generated by default as identity"", HsqlDatabase.class);
        assertCorrect(""alter table table_name alter column column_name int auto_increment"", H2Database.class);

        assertCorrect(""ALTER TABLE [table_name] MODIFY [column_name] serial"", InformixDatabase.class);
        assertCorrect(""ALTER TABLE [table_name] ALTER [column_name] SET DEFAULT AUTOINCREMENT"", SybaseASADatabase.class);
        assertCorrect(""ALTER TABLE [table_name] MODIFY [column_name] int identity"", SybaseDatabase.class);
        assertCorrect(""ALTER TABLE [table_name] ALTER column [column_name] SET GENERATED BY DEFAULT AS IDENTITY"", Db2zDatabase.class);

        assertCorrectOnRest(""ALTER TABLE [table_name] MODIFY [column_name] int AUTO_INCREMENT"");
    }
",non-flaky,5
159691,liquibase_liquibase,AddAutoIncrementExecuteTest.execute_stringDefault,"//    @Test
//    public void execute_stringDefault() throws Exception {
//        new DatabaseTestTemplate().testOnAvailableDatabases(
//                new SqlStatementDatabaseTest(null, new AddColumnStatement(null, TABLE_NAME, NEW_COLUMN_NAME, ""varchar(50)"", ""new default"")) {
//                    protected void preExecuteAssert(DatabaseSnapshotGenerator snapshot) {
//                        assertNull(snapshot.getTable(TABLE_NAME).getColumn(NEW_COLUMN_NAME));
//                    }
//
//                    protected void postExecuteAssert(DatabaseSnapshotGenerator snapshot) {
//                        Column columnSnapshot = snapshot.getTable(TABLE_NAME).getColumn(NEW_COLUMN_NAME);
//                        assertNotNull(columnSnapshot);
//                        assertEquals(NEW_COLUMN_NAME.toUpperCase(), columnSnapshot.getName().toUpperCase());
//                        assertEquals(""varchar"".toUpperCase(), columnSnapshot.getShortName().toUpperCase().replaceAll(""VARCHAR2"", ""VARCHAR""));
//                        assertEquals(50, columnSnapshot.getColumnSize());
//                        assertEquals(""new default"", columnSnapshot.getDefaultValue());
//
//                        assertEquals(true, columnSnapshot.isNullable());
//                    }
//                });
//    }
",non-flaky,5
159692,liquibase_liquibase,AddAutoIncrementExecuteTest.execute_intDefault,"//    @Test
//    public void execute_intDefault() throws Exception {
//        new DatabaseTestTemplate().testOnAvailableDatabases(
//                new SqlStatementDatabaseTest(null, new AddColumnStatement(null, TABLE_NAME, NEW_COLUMN_NAME, ""int"", 42)) {
//                    protected void preExecuteAssert(DatabaseSnapshotGenerator snapshot) {
//                        assertNull(snapshot.getTable(TABLE_NAME).getColumn(NEW_COLUMN_NAME));
//                    }
//
//                    protected void postExecuteAssert(DatabaseSnapshotGenerator snapshot) {
//                        Column columnSnapshot = snapshot.getTable(TABLE_NAME).getColumn(NEW_COLUMN_NAME);
//                        assertNotNull(columnSnapshot);
//                        assertEquals(NEW_COLUMN_NAME.toUpperCase(), columnSnapshot.getName().toUpperCase());
//                        if (snapshot.getDatabase() instanceof OracleDatabase) {
//                            assertEquals(""NUMBER"", columnSnapshot.getShortName().toUpperCase());
//                        } else {
//                            assertTrue(columnSnapshot.getShortName().toUpperCase().startsWith(""INT""));
//                        }
//                        assertEquals(42, ((Number) columnSnapshot.getDefaultValue()).intValue());
//
//                        assertEquals(true, columnSnapshot.isNullable());
//                    }
//
//                }
//
//        );
//    }
",non-flaky,5
159693,liquibase_liquibase,AddAutoIncrementExecuteTest.execute_floatDefault,"//    @Test
//    public void execute_floatDefault() throws Exception {
//        new DatabaseTestTemplate().testOnAvailableDatabases(
//                new SqlStatementDatabaseTest(null, new AddColumnStatement(null, TABLE_NAME, NEW_COLUMN_NAME, ""float"", 42.5)) {
//                    protected void preExecuteAssert(DatabaseSnapshotGenerator snapshot) {
//                        assertNull(snapshot.getTable(TABLE_NAME).getColumn(NEW_COLUMN_NAME));
//                    }
//
//                    protected void postExecuteAssert(DatabaseSnapshotGenerator snapshot) {
//                        Column columnSnapshot = snapshot.getTable(TABLE_NAME).getColumn(NEW_COLUMN_NAME);
//                        assertNotNull(columnSnapshot);
//                        assertEquals(NEW_COLUMN_NAME.toUpperCase(), columnSnapshot.getName().toUpperCase());
//                        assertEquals(new Double(42.5), new Double(((Number) columnSnapshot.getDefaultValue()).doubleValue()));
//
//                        assertEquals(true, columnSnapshot.isNullable());
//                    }
//                });
//    }
",non-flaky,5
159694,liquibase_liquibase,AddAutoIncrementExecuteTest.execute_notNull,"//    @Test
//    public void execute_notNull() throws Exception {
//        new DatabaseTestTemplate().testOnAvailableDatabases(
//                new SqlStatementDatabaseTest(null, new AddColumnStatement(null, TABLE_NAME, NEW_COLUMN_NAME, ""int"", 42, new NotNullConstraint())) {
//                    protected void preExecuteAssert(DatabaseSnapshotGenerator snapshot) {
//                        assertNull(snapshot.getTable(TABLE_NAME).getColumn(NEW_COLUMN_NAME));
//                    }
//
//                    protected void postExecuteAssert(DatabaseSnapshotGenerator snapshot) {
//                        Column columnSnapshot = snapshot.getTable(TABLE_NAME).getColumn(NEW_COLUMN_NAME);
//                        assertNotNull(columnSnapshot);
//                        assertEquals(false, columnSnapshot.isNullable());
//                    }
//                }
//
//        );
//    }
",non-flaky,5
159695,liquibase_liquibase,AddAutoIncrementExecuteTest.execute_primaryKey_nonAutoIncrement,"//    @Test
//    public void execute_primaryKey_nonAutoIncrement() throws Exception {
//        new DatabaseTestTemplate().testOnAvailableDatabases(
//                new SqlStatementDatabaseTest(null, new AddColumnStatement(null, TABLE_NAME, NEW_COLUMN_NAME, ""int"", null, new PrimaryKeyConstraint())) {
//
//                    protected boolean expectedException(Database database, DatabaseException exception) {
//                        return (database instanceof DB2Database
//                                || database instanceof DerbyDatabase
//                                || database instanceof H2Database
//                                || database instanceof CacheDatabase);
//                    }
//
//                    protected void preExecuteAssert(DatabaseSnapshotGenerator snapshot) {
//                        assertNull(snapshot.getTable(TABLE_NAME).getColumn(NEW_COLUMN_NAME));
//                    }
//
//                    protected void postExecuteAssert(DatabaseSnapshotGenerator snapshot) {
//                        Column columnSnapshot = snapshot.getTable(TABLE_NAME).getColumn(NEW_COLUMN_NAME);
//                        assertNotNull(columnSnapshot);
//                        assertEquals(false, columnSnapshot.isNullable());
//                        assertTrue(columnSnapshot.isPrimaryKey());
//                        assertEquals(false, columnSnapshot.isAutoIncrement());
//                    }
//                });
//    }
",non-flaky,5
159696,liquibase_liquibase,AddAutoIncrementExecuteTest.execute_altSchema,"//    @Test
//    public void execute_altSchema() throws Exception {
//        new DatabaseTestTemplate().testOnAvailableDatabases(
//                new SqlStatementDatabaseTest(TestContext.ALT_SCHEMA, new AddColumnStatement(TestContext.ALT_SCHEMA, TABLE_NAME, NEW_COLUMN_NAME, ""varchar(50)"", ""new default"")) {
//                    protected void preExecuteAssert(DatabaseSnapshotGenerator snapshot) {
//                        assertNull(snapshot.getTable(TABLE_NAME).getColumn(NEW_COLUMN_NAME));
//                    }
//
//                    protected void postExecuteAssert(DatabaseSnapshotGenerator snapshot) {
//                        Column columnSnapshot = snapshot.getTable(TABLE_NAME).getColumn(NEW_COLUMN_NAME);
//                        assertNotNull(columnSnapshot);
//                        assertEquals(NEW_COLUMN_NAME.toUpperCase(), columnSnapshot.getName().toUpperCase());
//                        assertEquals(""new default"", columnSnapshot.getDefaultValue());
//
//                        assertEquals(true, columnSnapshot.isNullable());
//                    }
//
//                });
//    }
",non-flaky,5
159697,liquibase_liquibase,AddAutoIncrementExecuteTest.execute_primaryKeyAutoIncrement,"//    @Test
//      public void execute_primaryKeyAutoIncrement() throws Exception {
//          new DatabaseTestTemplate().testOnAvailableDatabases(
//                  new SqlStatementDatabaseTest(null, new AddColumnStatement(null, TABLE_NAME, NEW_COLUMN_NAME, ""int"", null, new PrimaryKeyConstraint(), new AutoIncrementConstraint())) {
//
//                      protected boolean expectedException(Database database, DatabaseException exception) {
//                          return (database instanceof DB2Database
//                                  || database instanceof DerbyDatabase
//                                  || database instanceof H2Database
//                                  || database instanceof CacheDatabase
//                                    || !database.supportsAutoIncrement());
//                      }
//
//                      protected void preExecuteAssert(DatabaseSnapshotGenerator snapshot) {
//                          assertNull(snapshot.getTable(TABLE_NAME).getColumn(NEW_COLUMN_NAME));
//                      }
//
//                      protected void postExecuteAssert(DatabaseSnapshotGenerator snapshot) {
//                          Column columnSnapshot = snapshot.getTable(TABLE_NAME).getColumn(NEW_COLUMN_NAME);
//                          assertNotNull(columnSnapshot);
//                          assertEquals(false, columnSnapshot.isNullable());
//                          assertTrue(columnSnapshot.isPrimaryKey());
//                          assertEquals(true, columnSnapshot.isAutoIncrement());
//                      }
//                  });
//      }
",non-flaky,5
159698,liquibase_liquibase,SelectFromDatabaseChangeLogLockExecutorTest.generateSql,"    @Test
    public void generateSql() throws Exception {
        this.statementUnderTest = new SelectFromDatabaseChangeLogLockStatement(""LOCKED"");
        assertCorrect(""select [locked] from [databasechangeloglock] where [id]=1"", MSSQLDatabase.class, SybaseDatabase.class);
        assertCorrect(""select [locked] from [databasechangeloglock] where [id]=1"", SybaseASADatabase.class);
        assertCorrect(""select [locked] from [databasechangeloglock] where [id]=1 for update"", OracleDatabase.class);
        assertCorrectOnRest(""select [locked] from [databasechangeloglock] where [id]=1"");
    }
",non-flaky,5
159699,liquibase_liquibase,SelectFromDatabaseChangeLogLockExecutorTest.generateSql_count,"    @Test
    public void generateSql_count() throws Exception {
        this.statementUnderTest = new SelectFromDatabaseChangeLogLockStatement(new ColumnConfig().setName(""COUNT(*)"", true));
        assertCorrect(""select count(*) from [databasechangeloglock] where [id]=1"", MSSQLDatabase.class, SybaseDatabase.class);
        assertCorrect(""select count(*) from [databasechangeloglock] where [id]=1"", MSSQLDatabase.class, SybaseASADatabase.class);
        assertCorrect(""select count(*) from [databasechangeloglock] where [id]=1 for update"", OracleDatabase.class);
        assertCorrectOnRest(""select count(*) from [databasechangeloglock] where [id]=1"");
    }
",non-flaky,5
159700,liquibase_liquibase,SelectFromDatabaseChangeLogLockExecutorTest.generateSql_multicolumn,"    @Test
    public void generateSql_multicolumn() throws Exception {
        this.statementUnderTest = new SelectFromDatabaseChangeLogLockStatement(""LOCKED"", ""LOCKEDBY"");
        assertCorrect(""select [locked],[lockedby] from [databasechangeloglock] where [id]=1"", MSSQLDatabase.class, SybaseDatabase.class);
        assertCorrect(""select [locked],[lockedby] from [databasechangeloglock] where [id]=1"", MSSQLDatabase.class, SybaseASADatabase.class);
        assertCorrect(""select [locked],[lockedby] from [databasechangeloglock] where [id]=1 for update"", OracleDatabase.class);
        assertCorrectOnRest(""select [locked],[lockedby] from [databasechangeloglock] where [id]=1"");
    }
",non-flaky,5
159701,liquibase_liquibase,LockServiceExecuteTest.nothing,"    @Test
    public void nothing() {

    }
",non-flaky,5
159702,liquibase_liquibase,LockServiceExecuteTest.performTest,"//    @Test
//    public void waitForLock_twoConnections() throws Exception {
//        new DatabaseTestTemplate().testOnAvailableDatabases(new DatabaseTest() {
//            public void performTest(Database database) throws Exception {
////                if (database instanceof H2Database) {
////                    return;
////                }
//
//                String url = DatabaseTestContext.getInstance().getTestUrl(database);
//                System.out.println(url);
//                DatabaseConnection connection2 = DatabaseTestContext.getInstance().openDatabaseConnection(url);
//                Database database2 = DatabaseFactory.getInstance().findCorrectDatabaseImplementation(connection2);
//
//                assertTrue(LockService.getInstance(database).acquireLock());
//                assertTrue(LockService.getInstance(database).hasChangeLogLock());
//                assertFalse(LockService.getInstance(database2).hasChangeLogLock());
//
//                assertFalse(LockService.getInstance(database2).acquireLock());
//                assertFalse(LockService.getInstance(database2).acquireLock());
//
//                LockService.getInstance(database).releaseLock();
//                assertTrue(LockService.getInstance(database2).acquireLock());
//
//            }
",non-flaky,5
159703,liquibase_liquibase,LockServiceExecuteTest.performTest,"//    @Test
//    public void waitForLock_severalAquireLocksCalled() throws Exception {
//        new DatabaseTestTemplate().testOnAvailableDatabases(new DatabaseTest() {
//            public void performTest(Database database) throws Exception {
//                assertTrue(LockService.getInstance(database).acquireLock());
//                assertTrue(LockService.getInstance(database).acquireLock());
//                assertTrue(LockService.getInstance(database).acquireLock());
//                assertTrue(LockService.getInstance(database).acquireLock());
//            }
",non-flaky,5
159704,liquibase_liquibase,LockServiceExecuteTest.performTest,"//    @Test
//    public void waitForLock_emptyDatabase() throws Exception {
//        new DatabaseTestTemplate().testOnAvailableDatabases(
//                new DatabaseTest() {
//
//                    public void performTest(Database database) throws Exception {
//                        Executor executor = ExecutorService.getInstance().getExecutor(database);
//                        try {
//                            LockService.getInstance(database).resetAll();
//
//                            executor.execute(new DropTableStatement(null, database.getDatabaseChangeLogTableName(), false), new ArrayList<SqlVisitor>());
//                        } catch (DatabaseException e) {
//                            ; //must not be there
//                        }
//                        try {
//                            executor.execute(new DropTableStatement(null, database.getDatabaseChangeLogLockTableName(), false), new ArrayList<SqlVisitor>());
//                        } catch (DatabaseException e) {
//                            ; //must not be there
//                        }
//
//                        database.commit();
//
//                        LockService lockManager = LockService.getInstance(database);
//                        lockManager.waitForLock();
//                        lockManager.waitForLock();
//                    }
",non-flaky,5
159705,liquibase_liquibase,LockServiceExecuteTest.performTest,"//    @Test
//    public void waitForLock_loggingDatabase() throws Exception {
//        new DatabaseTestTemplate().testOnAvailableDatabases(
//                new DatabaseTest() {
//
//                    public void performTest(Database database) throws Exception {
//
//                        LockService.getInstance(database).resetAll();
//
//                        Executor executor = ExecutorService.getInstance().getExecutor(database);
//                        try {
//                            executor.execute(new DropTableStatement(null, database.getDatabaseChangeLogTableName(), false), new ArrayList<SqlVisitor>());
//                        } catch (DatabaseException e) {
//                            ; //must not be there
//                        }
//                        try {
//                            executor.execute(new DropTableStatement(null, database.getDatabaseChangeLogLockTableName(), false), new ArrayList<SqlVisitor>());
//                        } catch (DatabaseException e) {
//                            ; //must not be there
//                        }
//
//                        database.commit();
//
//                        ExecutorService.getInstance().setExecutor(database, (new LoggingExecutor(ExecutorService.getInstance().getExecutor(database), new StringWriter(), database)));
//
//                        LockService lockManager = LockService.getInstance(database);
//                        lockManager.waitForLock();
//                    }
",non-flaky,5
159706,liquibase_liquibase,LockServiceExecuteTest.performTest,"//    @Test
//    public void waitForLock_loggingThenExecute() throws Exception {
//        new DatabaseTestTemplate().testOnAvailableDatabases(
//                new DatabaseTest() {
//
//                    public void performTest(Database database) throws Exception {
//
//                        LockService.getInstance(database).resetAll();
//
//                        try {
//                            ExecutorService.getInstance().getExecutor(database).execute(new DropTableStatement(null, database.getDatabaseChangeLogTableName(), false), new ArrayList<SqlVisitor>());
//                        } catch (DatabaseException e) {
//                            ; //must not be there
//                        }
//                        try {
//                            ExecutorService.getInstance().getExecutor(database).execute(new DropTableStatement(null, database.getDatabaseChangeLogLockTableName(), false), new ArrayList<SqlVisitor>());
//                        } catch (DatabaseException e) {
//                            ; //must not be there
//                        }
//
//                        database.commit();
//
////                        Database clearDatabase = database.getClass().getConstructor().newInstance();
////                        clearDatabase.setConnection(database.getConnection());
//
//                        Executor originalTemplate = ExecutorService.getInstance().getExecutor(database);
//                        ExecutorService.getInstance().setExecutor(database, new LoggingExecutor(originalTemplate, new StringWriter(), database));
//
//                        LockService lockManager = LockService.getInstance(database);
//                        lockManager.waitForLock();
//
//                        ExecutorService.getInstance().setExecutor(database, originalTemplate);
//                        lockManager.waitForLock();
//
////                        database.getWriteExecutor().execute(database.getSelectChangeLogLockSQL());
//                    }
",non-flaky,5
159707,liquibase_liquibase,CDILiquibaseTest.shouldntRunWhenShouldRunIsFalse,"    @Test
    public void shouldntRunWhenShouldRunIsFalse() {
        System.setProperty(""liquibase.shouldRun"", ""false"");
        validateRunningState(false);
    }
",non-flaky,5
159708,liquibase_liquibase,CDILiquibaseTest.shouldRunWhenShouldRunIsTrue,"    @Test
    public void shouldRunWhenShouldRunIsTrue() {
        System.setProperty(""liquibase.shouldRun"", ""true"");
        validateRunningState(true);
    }
",non-flaky,5
159709,liquibase_liquibase,CDILiquibaseTest.shouldntRunWhenConfigShouldRunIsFalse,"    @Test
    public void shouldntRunWhenConfigShouldRunIsFalse() {
        System.setProperty(""liquibase.config.shouldRun"", ""false"");
        validateRunningState(false);
    }
",non-flaky,5
159710,liquibase_liquibase,CDILiquibaseTest.shouldRunWhenConfigShouldRunIsTrue,"    @Test
    public void shouldRunWhenConfigShouldRunIsTrue() {
        System.setProperty(""liquibase.config.shouldRun"", ""true"");
        validateRunningState(true);
    }
",non-flaky,5
159711,liquibase_liquibase,SchemesCDIConfigBuilderTest.testCreateCDILiquibaseConfig,"//    @Test
//    public void testCreateCDILiquibaseConfig() throws Exception {
//        Set<Bean<?>> beans = new LinkedHashSet<Bean<?>>();
//        beans.add(mockBean(new A1()));
//        beans.add(mockBean(new B2()));
//
//        when(bm.getBeans(eq(Object.class), eq(new SchemesCDIConfigBuilder.AnnotationLiteralDefault()))).thenReturn(beans);
//
//        CDILiquibaseConfig config = schemesCDIConfigBuilder.createCDILiquibaseConfig();
//
//        Assert.assertNotNull(config);
//        Assert.assertEquals(""liquibase.cdi.schema.xml"", config.getChangeLog());
//    }
",non-flaky,5
160320,triplea-game_triplea,AbstractPropertyReaderTestCase.setupPropertyReader,"    @BeforeEach
    public void setupPropertyReader() throws Exception {
      propertyReader = newSingletonPropertyReader(PRESENT_PROPERTY_VALUE);
    }
",non-flaky,5
160321,triplea-game_triplea,AbstractPropertyReaderTestCase.shouldThrowExceptionWhenKeyIsNull,"    @Test
    public void shouldThrowExceptionWhenKeyIsNull() {
      assertThrows(NullPointerException.class, () -> propertyReader.readProperty(null));
    }
",non-flaky,5
160322,triplea-game_triplea,AbstractPropertyReaderTestCase.shouldThrowExceptionWhenKeyIsEmptyOrOnlyWhitespace,"    @Test
    public void shouldThrowExceptionWhenKeyIsEmptyOrOnlyWhitespace() {
      assertThrows(IllegalArgumentException.class, () -> propertyReader.readProperty(""""));
      assertThrows(IllegalArgumentException.class, () -> propertyReader.readProperty(""    ""));
    }
",non-flaky,5
160323,triplea-game_triplea,AbstractPropertyReaderTestCase.shouldReturnValueWhenKeyIsPresent,"    @Test
    public void shouldReturnValueWhenKeyIsPresent() {
      assertThat(propertyReader.readProperty(PRESENT_PROPERTY_KEY), is(PRESENT_PROPERTY_VALUE));
    }
",non-flaky,5
160324,triplea-game_triplea,AbstractPropertyReaderTestCase.shouldReturnTrimmedValueWhenKeyIsPresentAndValueHasLeadingAndTrailingWhitespace,"    @Test
    public void shouldReturnTrimmedValueWhenKeyIsPresentAndValueHasLeadingAndTrailingWhitespace()
        throws Exception {
      final PropertyReader propertyReader =
          newSingletonPropertyReader(""  "" + PRESENT_PROPERTY_VALUE + ""  "");

      assertThat(propertyReader.readProperty(PRESENT_PROPERTY_KEY), is(PRESENT_PROPERTY_VALUE));
    }
",non-flaky,5
160325,triplea-game_triplea,AbstractPropertyReaderTestCase.shouldReturnEmptyWhenKeyIsAbsent,"    @Test
    public void shouldReturnEmptyWhenKeyIsAbsent() {
      assertThat(propertyReader.readProperty(ABSENT_PROPERTY_KEY), is(emptyString()));
    }
",non-flaky,5
160326,triplea-game_triplea,AbstractPropertyReaderTestCase.shouldReturnValueWhenKeyIsPresent,"    @Test
    public void shouldReturnValueWhenKeyIsPresent() throws Exception {
      final String value = ""value"";
      final PropertyReader propertyReader = newSingletonPropertyReader(value);

      assertThat(
          propertyReader.readPropertyOrDefault(PRESENT_PROPERTY_KEY, ""defaultValue""), is(value));
    }
",non-flaky,5
160327,triplea-game_triplea,AbstractPropertyReaderTestCase.shouldReturnDefaultValueWhenKeyIsAbsent,"    @Test
    public void shouldReturnDefaultValueWhenKeyIsAbsent() throws Exception {
      final String defaultValue = ""defaultValue"";
      final PropertyReader propertyReader = newEmptyPropertyReader();

      assertThat(
          propertyReader.readPropertyOrDefault(ABSENT_PROPERTY_KEY, defaultValue),
          is(defaultValue));
    }
",non-flaky,5
160328,triplea-game_triplea,AbstractPropertyReaderTestCase.shouldReturnValueWhenKeyIsPresent,"    @Test
    public void shouldReturnValueWhenKeyIsPresent() throws Exception {
      final boolean value = true;
      final PropertyReader propertyReader = newSingletonPropertyReader(String.valueOf(value));

      assertThat(
          propertyReader.readBooleanPropertyOrDefault(PRESENT_PROPERTY_KEY, false), is(value));
    }
",non-flaky,5
160329,triplea-game_triplea,AbstractPropertyReaderTestCase.shouldReturnDefaultValueWhenKeyIsAbsent,"    @Test
    public void shouldReturnDefaultValueWhenKeyIsAbsent() throws Exception {
      final boolean defaultValue = true;
      final PropertyReader propertyReader = newEmptyPropertyReader();

      assertThat(
          propertyReader.readBooleanPropertyOrDefault(ABSENT_PROPERTY_KEY, defaultValue),
          is(defaultValue));
    }
",non-flaky,5
160330,triplea-game_triplea,AbstractPropertyReaderTestCase.shouldReturnValueWhenKeyIsPresent,"    @Test
    public void shouldReturnValueWhenKeyIsPresent() throws Exception {
      final int value = 42;
      final PropertyReader propertyReader = newSingletonPropertyReader(String.valueOf(value));

      assertThat(propertyReader.readIntegerPropertyOrDefault(PRESENT_PROPERTY_KEY, -1), is(value));
    }
",non-flaky,5
160331,triplea-game_triplea,AbstractPropertyReaderTestCase.shouldReturnDefaultValueWhenKeyIsPresentAndValueIsNotAnInteger,"    @Test
    public void shouldReturnDefaultValueWhenKeyIsPresentAndValueIsNotAnInteger() throws Exception {
      final int defaultValue = 777;
      final PropertyReader propertyReader = newSingletonPropertyReader(""other"");

      assertThat(
          propertyReader.readIntegerPropertyOrDefault(PRESENT_PROPERTY_KEY, defaultValue),
          is(defaultValue));
    }
",non-flaky,5
160332,triplea-game_triplea,AbstractPropertyReaderTestCase.shouldReturnDefaultValueWhenKeyIsAbsent,"    @Test
    public void shouldReturnDefaultValueWhenKeyIsAbsent() throws Exception {
      final int defaultValue = 777;
      final PropertyReader propertyReader = newEmptyPropertyReader();

      assertThat(
          propertyReader.readIntegerPropertyOrDefault(ABSENT_PROPERTY_KEY, defaultValue),
          is(defaultValue));
    }
",non-flaky,5
160333,triplea-game_triplea,MessengerIntegrationTest.connectionRemoved,"  @Test
          public void connectionRemoved(final INode to) {
            serverCount.decrementAndGet();
          }
",non-flaky,5
160334,triplea-game_triplea,MessengerIntegrationTest.messageReceived,"  @Test
    public void messageReceived(final Serializable msg, final INode from) {
      synchronized (lock) {
        messages.add(msg);
        senders.add(from);
        lock.notifyAll();
      }
    }
",non-flaky,5
160335,triplea-game_triplea,ChatIntegrationTest.updatePlayerList,"  @Test
    public void updatePlayerList(final Collection<ChatParticipant> players) {
      playerCount.set(players.size());
    }
",non-flaky,5
160336,triplea-game_triplea,RemoteMessengerTest.increment,"  @Test
    public int increment(final int testVal) {
      senderNode = MessageContext.getSender();
      return testVal + 1;
    }
",non-flaky,5
160337,triplea-game_triplea,ChannelMessengerTest.testNoParams,"  @Test
    public void testNoParams() {
      incrementCount();
    }
",non-flaky,5
160338,triplea-game_triplea,ThreadPoolTest.run,"  @Test
    public void run() {
      Interruptibles.sleep(0L, 1);
      done = true;
    }
",non-flaky,5
160339,triplea-game_triplea,LobbyLoginValidatorTest.createLobbyLoginValidator,"    @BeforeEach
    public void createLobbyLoginValidator() throws Exception {
      lobbyLoginValidator =
          new LobbyLoginValidator(
              databaseDao,
              new RsaAuthenticator(TestSecurityUtils.loadRsaKeyPair()),
              () -> bcryptSalt,
              failedLoginThrottle,
              tempPasswordVerification,
              new AllowLoginRules(databaseDao),
              AllowCreateUserRules.builder()
                  .userDao(userDao)
                  .nameValidator(PlayerNameValidation::validate)
                  .emailValidator(PlayerEmailValidation::validate)
                  .build());
    }
",non-flaky,5
160340,triplea-game_triplea,LobbyLoginValidatorTest.givenNoBans,"    @BeforeEach
    public void givenNoBans() {
      givenNoMacIsBanned();
      givenNoUsernameIsBanned();
      when(databaseDao.getBadWordDao()).thenReturn(badWordDao);
    }
",non-flaky,5
170452,eclipse_jetty.project,ObjectMBeanTest.before,"    @BeforeEach
    public void before()
    {
        container = new MBeanContainer(ManagementFactory.getPlatformMBeanServer());
    }
",non-flaky,5
170453,eclipse_jetty.project,ObjectMBeanTest.after,"    @AfterEach
    public void after()
    {
        container.destroy();
        container = null;
    }
",non-flaky,5
170454,eclipse_jetty.project,ObjectMBeanTest.testMBeanForNull,"    @Test
    public void testMBeanForNull()
    {
        Object mBean = container.mbeanFor(null);
        assertNull(mBean);
    }
",non-flaky,5
170455,eclipse_jetty.project,ObjectMBeanTest.testMBeanForString,"    @Test
    public void testMBeanForString()
    {
        String obj = ""foo"";
        Object mbean = container.mbeanFor(obj);
        assertNotNull(mbean);
        container.beanAdded(null, obj);
        ObjectName objectName = container.findMBean(obj);
        assertNotNull(objectName);
    }
",non-flaky,5
170456,eclipse_jetty.project,ObjectMBeanTest.testMBeanForStringArray,"    @Test
    public void testMBeanForStringArray()
    {
        String[] obj = {""a"", ""b""};
        Object mbean = container.mbeanFor(obj);
        assertNotNull(mbean);
        container.beanAdded(null, obj);
        ObjectName objectName = container.findMBean(obj);
        assertNotNull(objectName);
    }
",non-flaky,5
170457,eclipse_jetty.project,ObjectMBeanTest.testMBeanForIntArray,"    @Test
    public void testMBeanForIntArray()
    {
        int[] obj = {0, 1, 2};
        Object mbean = container.mbeanFor(obj);
        assertNotNull(mbean);
        container.beanAdded(null, obj);
        ObjectName objectName = container.findMBean(obj);
        assertNotNull(objectName);
    }
",non-flaky,5
170458,eclipse_jetty.project,ObjectMBeanTest.testMetaDataCaching,"    @Test
    public void testMetaDataCaching()
    {
        Derived derived = new Derived();
        ObjectMBean derivedMBean = (ObjectMBean)container.mbeanFor(derived);
        ObjectMBean derivedMBean2 = (ObjectMBean)container.mbeanFor(derived);
        assertNotSame(derivedMBean, derivedMBean2);
        assertSame(derivedMBean.metaData(), derivedMBean2.metaData());
    }
",non-flaky,5
170459,eclipse_jetty.project,ObjectMBeanTest.testDerivedAttributes,"    @Test
    public void testDerivedAttributes() throws Exception
    {
        Derived derived = new Derived();
        Managed managed = derived.getManagedInstance();
        ObjectMBean derivedMBean = (ObjectMBean)container.mbeanFor(derived);
        ObjectMBean managedMBean = (ObjectMBean)container.mbeanFor(managed);

        container.beanAdded(null, derived);
        container.beanAdded(null, managed);

        MBeanInfo derivedInfo = derivedMBean.getMBeanInfo();
        assertNotNull(derivedInfo);
        MBeanInfo managedInfo = managedMBean.getMBeanInfo();
        assertNotNull(managedInfo);

        assertEquals(""com.acme.Derived"", derivedInfo.getClassName(), ""name does not match"");
        assertEquals(""Test the mbean stuff"", derivedInfo.getDescription(), ""description does not match"");
        assertEquals(5, derivedInfo.getAttributes().length, ""attribute count does not match"");
        assertEquals(""Full Name"", derivedMBean.getAttribute(""fname""), ""attribute values does not match"");

        derivedMBean.setAttribute(new Attribute(""fname"", ""Fuller Name""));
        assertEquals(""Fuller Name"", derivedMBean.getAttribute(""fname""), ""set attribute value does not match"");
        assertEquals(""goop"", derivedMBean.getAttribute(""goop""), ""proxy attribute values do not match"");
    }
",non-flaky,5
170460,eclipse_jetty.project,ObjectMBeanTest.testDerivedOperations,"    @Test
    public void testDerivedOperations() throws Exception
    {
        Derived derived = new Derived();
        ObjectMBean mbean = (ObjectMBean)container.mbeanFor(derived);

        container.beanAdded(null, derived);

        MBeanInfo info = mbean.getMBeanInfo();
        assertEquals(5, info.getOperations().length, ""operation count does not match"");

        MBeanOperationInfo[] operationInfos = info.getOperations();
        boolean publish = false;
        boolean doodle = false;
        boolean good = false;
        for (MBeanOperationInfo operationInfo : operationInfos)
        {
            if (""publish"".equals(operationInfo.getName()))
            {
                publish = true;
                assertEquals(""publish something"", operationInfo.getDescription(), ""description doesn't match"");
            }

            if (""doodle"".equals(operationInfo.getName()))
            {
                doodle = true;
                assertEquals(""Doodle something"", operationInfo.getDescription(), ""description doesn't match"");
                MBeanParameterInfo[] parameterInfos = operationInfo.getSignature();
                assertEquals(""A description of the argument"", parameterInfos[0].getDescription(), ""parameter description doesn't match"");
                assertEquals(""doodle"", parameterInfos[0].getName(), ""parameter name doesn't match"");
            }

            // This is a proxied operation on the MBean wrapper.
            if (""good"".equals(operationInfo.getName()))
            {
                good = true;
                assertEquals(""test of proxy operations"", operationInfo.getDescription(), ""description does not match"");
                assertEquals(""not bad"", mbean.invoke(""good"", new Object[]{}, new String[]{}), ""execution contexts wrong"");
            }
        }

        assertTrue(publish, ""publish operation was not not found"");
        assertTrue(doodle, ""doodle operation was not not found"");
        assertTrue(good, ""good operation was not not found"");
    }
",non-flaky,5
170461,eclipse_jetty.project,ObjectMBeanTest.testMethodNameMining,"    @Test
    public void testMethodNameMining()
    {
        assertEquals(""fullName"", MetaData.toAttributeName(""getFullName""));
        assertEquals(""fullName"", MetaData.toAttributeName(""getfullName""));
        assertEquals(""fullName"", MetaData.toAttributeName(""isFullName""));
        assertEquals(""fullName"", MetaData.toAttributeName(""isfullName""));
        assertEquals(""fullName"", MetaData.toAttributeName(""setFullName""));
        assertEquals(""fullName"", MetaData.toAttributeName(""setfullName""));
        assertEquals(""fullName"", MetaData.toAttributeName(""FullName""));
        assertEquals(""fullName"", MetaData.toAttributeName(""fullName""));
    }
",non-flaky,5
170462,eclipse_jetty.project,MBeanContainerLifeCycleTest.prepare,"    @BeforeEach
    public void prepare() throws Exception
    {
        container = new ContainerLifeCycle();
        mbeanServer = ManagementFactory.getPlatformMBeanServer();
        MBeanContainer mbeanContainer = new MBeanContainer(mbeanServer);
        container.addBean(mbeanContainer);
        container.start();
    }
",non-flaky,5
170463,eclipse_jetty.project,MBeanContainerLifeCycleTest.dispose,"    @AfterEach
    public void dispose() throws Exception
    {
        container.stop();
    }
",non-flaky,5
170464,eclipse_jetty.project,MBeanContainerLifeCycleTest.testAddBeanRegistersMBeanRemoveBeanUnregistersMBean,"    @Test
    public void testAddBeanRegistersMBeanRemoveBeanUnregistersMBean() throws Exception
    {
        // Adding a bean to the container should register the MBean.
        QueuedThreadPool bean = new QueuedThreadPool();
        container.addBean(bean);

        String pkg = bean.getClass().getPackage().getName();
        Set<ObjectName> objectNames = mbeanServer.queryNames(ObjectName.getInstance(pkg + "":*""), null);
        assertEquals(1, objectNames.size());

        // Removing the bean should unregister the MBean.
        container.removeBean(bean);
        objectNames = mbeanServer.queryNames(ObjectName.getInstance(pkg + "":*""), null);
        assertEquals(0, objectNames.size());
    }
",non-flaky,5
170465,eclipse_jetty.project,MBeanContainerLifeCycleTest.testStoppingContainerDoesNotUnregistersMBeans,"    @Test
    public void testStoppingContainerDoesNotUnregistersMBeans() throws Exception
    {
        QueuedThreadPool bean = new QueuedThreadPool();
        container.addBean(bean, true);

        String pkg = bean.getClass().getPackage().getName();
        Set<ObjectName> objectNames = mbeanServer.queryNames(ObjectName.getInstance(pkg + "":*""), null);
        // QueuedThreadPool and ThreadPoolBudget.
        assertEquals(2, objectNames.size());

        container.stop();

        objectNames = mbeanServer.queryNames(ObjectName.getInstance(pkg + "":*""), null);
        assertEquals(2, objectNames.size());

        // Remove the MBeans to start clean on the next test.
        objectNames.forEach(objectName ->
        {
            try
            {
                mbeanServer.unregisterMBean(objectName);
            }
            catch (Throwable ignored)
            {
            }
        });
    }
",non-flaky,5
170466,eclipse_jetty.project,MBeanContainerLifeCycleTest.testDestroyingContainerUnregistersMBeans,"    @Test
    public void testDestroyingContainerUnregistersMBeans() throws Exception
    {
        QueuedThreadPool bean = new QueuedThreadPool();
        container.addBean(bean, true);

        String pkg = bean.getClass().getPackage().getName();
        Set<ObjectName> objectNames = mbeanServer.queryNames(ObjectName.getInstance(pkg + "":*""), null);
        // QueuedThreadPool and ThreadPoolBudget.
        assertEquals(2, objectNames.size());

        container.stop();
        container.destroy();

        objectNames = mbeanServer.queryNames(ObjectName.getInstance(pkg + "":*""), null);
        assertEquals(0, objectNames.size());
    }
",non-flaky,5
170467,eclipse_jetty.project,PojoTest.testOpenPojo,"    @Test
    public void testOpenPojo()
    {
        Validator validator = ValidatorBuilder.create().with(new SetterTester()).with(new GetterTester()).build();
        List<Class> classes = Arrays.asList(MBeanContainer.class, ObjectMBean.class);
        for (Class clazz : classes)
        {
            validator.validate(PojoClassFactory.getPojoClass(clazz));
        }
    }
",non-flaky,5
170468,eclipse_jetty.project,ObjectMBeanUtilTest.setUp,"    @BeforeEach
    public void setUp()
    {
        container = new MBeanContainer(ManagementFactory.getPlatformMBeanServer());
        derivedExtended = new DerivedExtended();
        objectMBean = (ObjectMBean)container.mbeanFor(derivedExtended);
        objectMBeanInfo = objectMBean.getMBeanInfo();
    }
",non-flaky,5
170469,eclipse_jetty.project,ObjectMBeanUtilTest.testBasicOperations,"    @Test
    public void testBasicOperations()
    {
        assertEquals(derivedExtended, objectMBean.getManagedObject(), ""Managed objects should be equal"");
        assertNull(objectMBean.getObjectName(), ""This method call always returns null in the actual code"");
        assertNull(objectMBean.getObjectNameBasis(), ""This method call always returns null in the actual code"");
        assertNull(objectMBean.getObjectContextBasis(), ""This method call always returns null in the actual code"");
        assertEquals(container, objectMBean.getMBeanContainer(), ""Mbean container should be equal"");
        assertEquals(""Test the mbean extended stuff"", objectMBeanInfo.getDescription(), ""Mbean description must be equal to : Test the mbean extended stuff"");
    }
",non-flaky,5
170470,eclipse_jetty.project,ObjectMBeanUtilTest.testGetAttributeMBeanException,"    @Test
    public void testGetAttributeMBeanException() throws Exception
    {
        Attribute attribute = new Attribute(""doodle4"", ""charu"");
        objectMBean.setAttribute(attribute);

        MBeanException e = assertThrows(MBeanException.class, () -> objectMBean.getAttribute(""doodle4""));

        assertNotNull(e, ""An InvocationTargetException must have occurred by now as doodle4() internally throwing exception"");
    }
",non-flaky,5
170471,eclipse_jetty.project,ObjectMBeanUtilTest.testGetAttributeAttributeNotFoundException,"    @Test
    public void testGetAttributeAttributeNotFoundException()
    {
        AttributeNotFoundException e = assertThrows(AttributeNotFoundException.class, () -> objectMBean.getAttribute(""ffname""));

        assertNotNull(e, ""An AttributeNotFoundException must have occurred by now as there is no attribute with the name ffname in bean"");
    }
",non-flaky,5
170472,eclipse_jetty.project,ObjectMBeanUtilTest.testSetAttributeWithCorrectAttrName,"    @Test
    public void testSetAttributeWithCorrectAttrName() throws Exception
    {
        Attribute attribute = new Attribute(""fname"", ""charu"");
        objectMBean.setAttribute(attribute);

        String value = (String)objectMBean.getAttribute(""fname"");

        assertEquals(""charu"", value, ""Attribute(fname) value must be equal to charu"");
    }
",non-flaky,5
170473,eclipse_jetty.project,ObjectMBeanUtilTest.testSetAttributeNullCheck,"    @Test
    public void testSetAttributeNullCheck() throws Exception
    {
        objectMBean.setAttribute(null);

        AttributeNotFoundException e = assertThrows(AttributeNotFoundException.class, () -> objectMBean.getAttribute(null));

        assertNotNull(e, ""An AttributeNotFoundException must have occurred by now as there is no attribute with the name null"");
    }
",non-flaky,5
170474,eclipse_jetty.project,ObjectMBeanUtilTest.testSetAttributeAttributeWithWrongAttrName,"    @Test
    public void testSetAttributeAttributeWithWrongAttrName()
    {
        attribute = new Attribute(""fnameee"", ""charu"");

        AttributeNotFoundException e = assertThrows(AttributeNotFoundException.class, () -> objectMBean.setAttribute(attribute));

        assertNotNull(e, ""An AttributeNotFoundException must have occurred by now as there is no attribute "" + ""with the name ffname in bean"");
    }
",non-flaky,5
170475,eclipse_jetty.project,ObjectMBeanUtilTest.testSetAttributesWithCorrectValues,"    @Test
    public void testSetAttributesWithCorrectValues()
    {
        AttributeList attributes = getAttributes(""fname"", ""vijay"");
        objectMBean.setAttributes(attributes);

        attributes = objectMBean.getAttributes(new String[]{""fname""});

        assertEquals(1, attributes.size());
        assertEquals(""vijay"", ((Attribute)(attributes.get(0))).getValue(), ""Fname value must be equal to vijay"");
    }
",non-flaky,5
170476,eclipse_jetty.project,ObjectMBeanUtilTest.testSetAttributesForArrayTypeAttribute,"    @Test
    public void testSetAttributesForArrayTypeAttribute() throws Exception
    {
        Derived[] deriveds = getArrayTypeAttribute();

        derivedManaged.setAddresses(deriveds);
        mBeanDerivedManaged.getMBeanInfo();

        assertNotNull(mBeanDerivedManaged.getAttribute(""addresses""), ""Address object shouldn't be null"");
    }
",non-flaky,5
170477,eclipse_jetty.project,ObjectMBeanUtilTest.testSetAttributesForCollectionTypeAttribute,"    @Test
    public void testSetAttributesForCollectionTypeAttribute() throws Exception
    {
        ArrayList<Derived> aliasNames = new ArrayList<>(Arrays.asList(getArrayTypeAttribute()));

        derivedManaged.setAliasNames(aliasNames);
        mBeanDerivedManaged.getMBeanInfo();

        assertNotNull(mBeanDerivedManaged.getAttribute(""aliasNames""), ""Address object shouldn't be null"");
        assertNull(mBeanDerivedManaged.getAttribute(""derived""), ""Derived object shouldn't registered with container so its value will be null"");
    }
",non-flaky,5
170478,eclipse_jetty.project,ObjectMBeanUtilTest.testSetAttributesException,"    @Test
    public void testSetAttributesException()
    {
        AttributeList attributes = getAttributes(""fnameee"", ""charu"");

        attributes = objectMBean.setAttributes(attributes);

        // Original code eating the exception and returning zero size list
        assertEquals(0, attributes.size(), ""As there is no attribute with the name fnameee, this should return empty"");
    }
",non-flaky,5
170479,eclipse_jetty.project,ObjectMBeanUtilTest.testInvokeMBeanException,"    @Test
    public void testInvokeMBeanException()
    {
        ReflectionException e = assertThrows(ReflectionException.class, () -> objectMBean.invoke(""doodle2"", new Object[0], new String[0]));

        assertNotNull(e, ""An ReflectionException must have occurred by now as doodle2() in Derived bean is private"");
    }
",non-flaky,5
170480,eclipse_jetty.project,ObjectMBeanUtilTest.testInvokeReflectionException,"    @Test
    public void testInvokeReflectionException()
    {
        MBeanException e = assertThrows(MBeanException.class, () -> objectMBean.invoke(""doodle1"", new Object[0], new String[0]));

        assertNotNull(e, ""MBeanException is null"");
    }
",non-flaky,5
170481,eclipse_jetty.project,ObjectMBeanUtilTest.testInvoke,"    @Test
    public void testInvoke() throws Exception
    {
        String value = (String)objectMBean.invoke(""good"", new Object[0], new String[0]);

        assertEquals(""not bad"", value, ""Method(good) invocation on objectMBean must return not bad"");
    }
",non-flaky,5
170482,eclipse_jetty.project,ObjectMBeanUtilTest.testInvokeNoSuchMethodException,"    @Test
    public void testInvokeNoSuchMethodException()
    {
        // DerivedMBean contains a managed method with the name good,
        // we must call this method without any arguments.
        ReflectionException e = assertThrows(ReflectionException.class, () ->
            objectMBean.invoke(""good"", new Object[0], new String[]{
                ""int aone""
            }));

        assertNotNull(e, ""A ReflectionException must have occurred by now as we cannot call a method with wrong signature"");
    }
",non-flaky,5
170483,eclipse_jetty.project,ObjectMBeanUtilTest.testToAttributeName,"    @Test
    public void testToAttributeName()
    {
        assertEquals(""fullName"", MetaData.toAttributeName(""isfullName""));
    }
",non-flaky,5
170484,eclipse_jetty.project,ConnectorServerTest.tearDown,"    @AfterEach
    public void tearDown() throws Exception
    {
        if (connectorServer != null)
            connectorServer.stop();
    }
",non-flaky,5
170485,eclipse_jetty.project,ConnectorServerTest.testAddressAfterStart,"    @Test
    public void testAddressAfterStart() throws Exception
    {
        connectorServer = new ConnectorServer(new JMXServiceURL(""service:jmx:rmi:///jndi/rmi:///jmxrmi""), objectName);
        connectorServer.start();

        JMXServiceURL address = connectorServer.getAddress();
        assertTrue(address.toString().matches(""service:jmx:rmi://[^:]+:\\d+/jndi/rmi://[^:]+:\\d+/jmxrmi""));
    }
",non-flaky,5
170486,eclipse_jetty.project,ConnectorServerTest.testNoRegistryHostBindsToHost,"    @Test
    public void testNoRegistryHostBindsToHost() throws Exception
    {
        connectorServer = new ConnectorServer(new JMXServiceURL(""service:jmx:rmi:///jndi/rmi:///jmxrmi""), objectName);
        connectorServer.start();

        // Verify that I can connect to the RMI registry using a non-loopback address.
        new Socket(InetAddress.getLocalHost(), 1099).close();
        assertThrows(ConnectException.class, () ->
        {
            // Verify that I cannot connect to the RMI registry using the loopback address.
            new Socket(InetAddress.getLoopbackAddress(), 1099).close();
        });
    }
",non-flaky,5
170487,eclipse_jetty.project,ConnectorServerTest.testNoRegistryHostNonDefaultRegistryPort,"    @Test
    public void testNoRegistryHostNonDefaultRegistryPort() throws Exception
    {
        ServerSocket serverSocket = new ServerSocket(0);
        int registryPort = serverSocket.getLocalPort();
        serverSocket.close();
        connectorServer = new ConnectorServer(new JMXServiceURL(""service:jmx:rmi:///jndi/rmi://:"" + registryPort + ""/jmxrmi""), objectName);
        connectorServer.start();

        // Verify that I can connect to the RMI registry using a non-loopback address.
        new Socket(InetAddress.getLocalHost(), registryPort).close();
        assertThrows(ConnectException.class, () ->
        {
            // Verify that I cannot connect to the RMI registry using the loopback address.
            new Socket(InetAddress.getLoopbackAddress(), registryPort).close();
        });
    }
",non-flaky,5
170488,eclipse_jetty.project,ConnectorServerTest.testAnyRegistryHostBindsToAny,"    @Test
    public void testAnyRegistryHostBindsToAny() throws Exception
    {
        ServerSocket serverSocket = new ServerSocket(0);
        int registryPort = serverSocket.getLocalPort();
        serverSocket.close();
        connectorServer = new ConnectorServer(new JMXServiceURL(""service:jmx:rmi:///jndi/rmi://0.0.0.0:"" + registryPort + ""/jmxrmi""), objectName);
        connectorServer.start();

        // Verify that I can connect to the RMI registry using a non-loopback address.
        new Socket(InetAddress.getLocalHost(), registryPort).close();
        // Verify that I can connect to the RMI registry using the loopback address.
        new Socket(InetAddress.getLoopbackAddress(), registryPort).close();
    }
",non-flaky,5
170489,eclipse_jetty.project,ConnectorServerTest.testLocalhostRegistryBindsToLoopback,"    @Test
    public void testLocalhostRegistryBindsToLoopback() throws Exception
    {
        connectorServer = new ConnectorServer(new JMXServiceURL(""service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi""), objectName);
        connectorServer.start();

        InetAddress localHost = InetAddress.getLocalHost();
        if (!localHost.isLoopbackAddress())
        {
            assertThrows(ConnectException.class, () ->
            {
                // Verify that I cannot connect to the RMIRegistry using a non-loopback address.
                new Socket(localHost, 1099);
            });
        }

        InetAddress loopback = InetAddress.getLoopbackAddress();
        new Socket(loopback, 1099).close();
    }
",non-flaky,5
170490,eclipse_jetty.project,ConnectorServerTest.testNoRMIHostBindsToHost,"    @Test
    public void testNoRMIHostBindsToHost() throws Exception
    {
        connectorServer = new ConnectorServer(new JMXServiceURL(""service:jmx:rmi:///jndi/rmi:///jmxrmi""), objectName);
        connectorServer.start();

        // Verify that I can connect to the RMI server using a non-loopback address.
        new Socket(InetAddress.getLocalHost(), connectorServer.getAddress().getPort()).close();
        assertThrows(ConnectException.class, () ->
        {
            // Verify that I cannot connect to the RMI server using the loopback address.
            new Socket(InetAddress.getLoopbackAddress(), connectorServer.getAddress().getPort()).close();
        });
    }
",non-flaky,5
170491,eclipse_jetty.project,ConnectorServerTest.testAnyRMIHostBindsToAny,"    @Test
    public void testAnyRMIHostBindsToAny() throws Exception
    {
        connectorServer = new ConnectorServer(new JMXServiceURL(""service:jmx:rmi://0.0.0.0/jndi/rmi:///jmxrmi""), objectName);
        connectorServer.start();

        // Verify that I can connect to the RMI server using a non-loopback address.
        new Socket(InetAddress.getLocalHost(), connectorServer.getAddress().getPort()).close();
        // Verify that I can connect to the RMI server using the loopback address.
        new Socket(InetAddress.getLoopbackAddress(), connectorServer.getAddress().getPort()).close();
    }
",non-flaky,5
170492,eclipse_jetty.project,ConnectorServerTest.testLocalhostRMIBindsToLoopback,"    @Test
    public void testLocalhostRMIBindsToLoopback() throws Exception
    {
        connectorServer = new ConnectorServer(new JMXServiceURL(""service:jmx:rmi://localhost/jndi/rmi://localhost:1099/jmxrmi""), objectName);
        connectorServer.start();
        JMXServiceURL address = connectorServer.getAddress();

        InetAddress localHost = InetAddress.getLocalHost();
        if (!localHost.isLoopbackAddress())
        {
            assertThrows(ConnectException.class, () ->
            {
                // Verify that I cannot connect to the RMIRegistry using a non-loopback address.
                new Socket(localHost, address.getPort());
            });
        }

        InetAddress loopback = InetAddress.getLoopbackAddress();
        new Socket(loopback, address.getPort()).close();
    }
",non-flaky,5
170493,eclipse_jetty.project,ConnectorServerTest.testRMIServerPort,"    @Test
    public void testRMIServerPort() throws Exception
    {
        ServerSocket server = new ServerSocket(0);
        int port = server.getLocalPort();
        server.close();

        connectorServer = new ConnectorServer(new JMXServiceURL(""service:jmx:rmi://localhost:"" + port + ""/jndi/rmi:///jmxrmi""), objectName);
        connectorServer.start();

        JMXServiceURL address = connectorServer.getAddress();
        assertEquals(port, address.getPort());

        InetAddress loopback = InetAddress.getLoopbackAddress();
        new Socket(loopback, port).close();
    }
",non-flaky,5
170494,eclipse_jetty.project,ConnectorServerTest.testRMIServerAndRMIRegistryOnSameHostAndSamePort,"    @Test
    public void testRMIServerAndRMIRegistryOnSameHostAndSamePort() throws Exception
    {
        // RMI can multiplex connections on the same address and port for different
        // RMI objects, in this case the RMI registry and the RMI server. In this
        // case, the RMIServerSocketFactory will be invoked only once.
        // The case with different address and same port is already covered by TCP,
        // that can listen to 192.168.0.1:1099 and 127.0.0.1:1099 without problems.

        String host = ""localhost"";
        ServerSocket serverSocket = new ServerSocket(0);
        int port = serverSocket.getLocalPort();
        serverSocket.close();

        connectorServer = new ConnectorServer(new JMXServiceURL(""rmi"", host, port, ""/jndi/rmi://"" + host + "":"" + port + ""/jmxrmi""), objectName);
        connectorServer.start();

        JMXServiceURL address = connectorServer.getAddress();
        assertEquals(port, address.getPort());
    }
",non-flaky,5
170495,eclipse_jetty.project,ConnectorServerTest.testJMXOverTLS,"    @Test
    public void testJMXOverTLS() throws Exception
    {
        SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();
        String keyStorePath = MavenTestingUtils.getTestResourcePath(""keystore.p12"").toString();
        String keyStorePassword = ""storepwd"";
        sslContextFactory.setKeyStorePath(keyStorePath);
        sslContextFactory.setKeyStorePassword(keyStorePassword);
        sslContextFactory.start();

        // The RMIClientSocketFactory is stored within the RMI stub.
        // When using TLS, the stub is deserialized in a possibly different
        // JVM that does not have access to the server keystore, and there
        // is no way to provide TLS configuration during the deserialization
        // of the stub. Therefore the client must provide system properties
        // to specify the TLS configuration. For this test it needs the
        // trustStore because the server certificate is self-signed.
        // The server needs to contact the RMI registry and therefore also
        // needs these system properties.
        System.setProperty(""javax.net.ssl.trustStore"", keyStorePath);
        System.setProperty(""javax.net.ssl.trustStorePassword"", keyStorePassword);

        connectorServer = new ConnectorServer(new JMXServiceURL(""rmi"", null, 1100, ""/jndi/rmi://localhost:1100/jmxrmi""), null, objectName, sslContextFactory);
        connectorServer.start();

        // The client needs to talk TLS to the RMI registry to download
        // the RMI server stub, and this is independent from JMX.
        // The RMI server stub then contains the SslRMIClientSocketFactory
        // needed to talk to the RMI server.
        Map<String, Object> clientEnv = new HashMap<>();
        clientEnv.put(ConnectorServer.RMI_REGISTRY_CLIENT_SOCKET_FACTORY_ATTRIBUTE, new SslRMIClientSocketFactory());
        try (JMXConnector client = JMXConnectorFactory.connect(connectorServer.getAddress(), clientEnv))
        {
            client.getMBeanServerConnection().queryNames(null, null);
        }
    }
",non-flaky,5
170496,eclipse_jetty.project,MBeanContainerTest.setUp,"    @BeforeEach
    public void setUp()
    {
        mbeanServer = ManagementFactory.getPlatformMBeanServer();
        mbeanContainer = new MBeanContainer(mbeanServer);
    }
",non-flaky,5
170497,eclipse_jetty.project,MBeanContainerTest.testMakeName,"    @Test
    public void testMakeName()
    {
        beanName = ""mngd:bean"";

        beanName = mbeanContainer.makeName(beanName);

        assertEquals(""mngd_bean"", beanName, ""Bean name should be mngd_bean"");
    }
",non-flaky,5
170498,eclipse_jetty.project,MBeanContainerTest.testFindBean,"    @Test
    public void testFindBean()
    {
        managed = getManaged();

        objectName = mbeanContainer.findMBean(managed);
        assertNotNull(objectName);

        assertEquals(managed, mbeanContainer.findBean(objectName), ""Bean must be added"");
        assertNull(mbeanContainer.findBean(null), ""It must return null as there is no bean with the name null"");
    }
",non-flaky,5
170499,eclipse_jetty.project,MBeanContainerTest.testMBeanContainer,"    @Test
    public void testMBeanContainer()
    {
        assertNotNull(mbeanContainer, ""Container shouldn't be null"");
    }
",non-flaky,5
170500,eclipse_jetty.project,MBeanContainerTest.testGetMBeanServer,"    @Test
    public void testGetMBeanServer()
    {
        assertEquals(mbeanServer, mbeanContainer.getMBeanServer(), ""MBean server Instance must be equal"");
    }
",non-flaky,5
170501,eclipse_jetty.project,MBeanContainerTest.testDomain,"    @Test
    public void testDomain()
    {
        String domain = ""Test"";

        mbeanContainer.setDomain(domain);

        assertEquals(domain, mbeanContainer.getDomain(), ""Domain name must be Test"");
    }
",non-flaky,5
170502,eclipse_jetty.project,MBeanContainerTest.testBeanAdded,"    @Test
    public void testBeanAdded()
    {
        setBeanAdded();

        objectName = mbeanContainer.findMBean(managed);

        assertTrue(mbeanServer.isRegistered(objectName), ""Bean must have been registered"");
    }
",non-flaky,5
170503,eclipse_jetty.project,MBeanContainerTest.testBeanAddedNullCheck,"    @Test
    public void testBeanAddedNullCheck()
    {
        setBeanAdded();
        Integer mbeanCount = mbeanServer.getMBeanCount();

        mbeanContainer.beanAdded(null, null);

        assertEquals(mbeanCount, mbeanServer.getMBeanCount(), ""MBean count must not change after beanAdded(null, null) call"");
    }
",non-flaky,5
170504,eclipse_jetty.project,MBeanContainerTest.testBeanRemoved,"    @Test
    public void testBeanRemoved()
    {
        setUpBeanRemoved();

        mbeanContainer.beanRemoved(null, managed);

        assertNull(mbeanContainer.findMBean(managed), ""Bean shouldn't be registered with container as we removed the bean"");
    }
",non-flaky,5
170505,eclipse_jetty.project,MBeanContainerTest.testBeanRemovedInstanceNotFoundException,"    @Test
    public void testBeanRemovedInstanceNotFoundException() throws Exception
    {
        // given
        setUpBeanRemoved();
        objectName = mbeanContainer.findMBean(managed);

        // when
        mbeanContainer.getMBeanServer().unregisterMBean(objectName);

        // then
        assertFalse(mbeanServer.isRegistered(objectName), ""Bean must not have been registered as we unregistered the bean"");
        // this flow covers InstanceNotFoundException. Actual code just eating
        // the exception. i.e Actual code just printing the stacktrace, whenever
        // an exception of type InstanceNotFoundException occurs.
        mbeanContainer.beanRemoved(null, managed);
    }
",non-flaky,5
170506,eclipse_jetty.project,MBeanContainerTest.testDump,"    @Test
    public void testDump()
    {
        assertNotNull(mbeanContainer.dump(), ""Dump operation shouldn't return null if operation is success"");
    }
",non-flaky,5
170507,eclipse_jetty.project,MBeanContainerTest.testDestroy,"    @Test
    public void testDestroy()
    {
        setUpDestroy();

        objectName = mbeanContainer.findMBean(managed);
        mbeanContainer.destroy();

        assertFalse(mbeanContainer.getMBeanServer().isRegistered(objectName), ""Unregistered bean - managed"");
    }
",non-flaky,5
170508,eclipse_jetty.project,MBeanContainerTest.testDestroyInstanceNotFoundException,"    @Test
    public void testDestroyInstanceNotFoundException() throws Exception
    {
        setUpDestroy();

        objectName = mbeanContainer.findMBean(managed);
        mbeanContainer.getMBeanServer().unregisterMBean(objectName);

        assertFalse(mbeanContainer.getMBeanServer().isRegistered(objectName), ""Unregistered bean - managed"");
        // this flow covers InstanceNotFoundException. Actual code just eating
        // the exception. i.e Actual code just printing the stacktrace, whenever
        // an exception of type InstanceNotFoundException occurs.
        mbeanContainer.destroy();
    }
",non-flaky,5
170509,eclipse_jetty.project,MBeanContainerTest.testNonManagedLifecycleNotUnregistered,"    @Test
    public void testNonManagedLifecycleNotUnregistered() throws Exception
    {
        testNonManagedObjectNotUnregistered(new ContainerLifeCycle());
    }
",non-flaky,5
170510,eclipse_jetty.project,MBeanContainerTest.testNonManagedPojoNotUnregistered,"    @Test
    public void testNonManagedPojoNotUnregistered() throws Exception
    {
        testNonManagedObjectNotUnregistered(new Object());
    }
",non-flaky,5
170511,eclipse_jetty.project,TestAnnotationParser.handle,"    @Test
    public void testSampleAnnotation() throws Exception
    {
        String[] classNames = new String[]{""org.eclipse.jetty.annotations.ClassA""};
        AnnotationParser parser = new AnnotationParser();

        class SampleAnnotationHandler extends AnnotationParser.AbstractHandler
        {
            private List<String> methods = Arrays.asList(""a"", ""b"", ""c"", ""d"", ""l"");

            @Override
            public void handle(ClassInfo info, String annotation)
            {
                if (annotation == null || !""org.eclipse.jetty.annotations.Sample"".equals(annotation))
                    return;

                assertEquals(""org.eclipse.jetty.annotations.ClassA"", info.getClassName());
            }
",non-flaky,5
170512,eclipse_jetty.project,TestAnnotationParser.handle,"    @Test
    public void testMultiAnnotation() throws Exception
    {
        String[] classNames = new String[]{""org.eclipse.jetty.annotations.ClassB""};
        AnnotationParser parser = new AnnotationParser();

        class MultiAnnotationHandler extends AnnotationParser.AbstractHandler
        {
            @Override
            public void handle(ClassInfo info, String annotation)
            {
                if (annotation == null || !""org.eclipse.jetty.annotations.Multi"".equals(annotation))
                    return;
                assertTrue(""org.eclipse.jetty.annotations.ClassB"".equals(info.getClassName()));
            }
",non-flaky,5
170513,eclipse_jetty.project,TestAnnotationParser.testHiddenFilesInJar,"    @Test
    public void testHiddenFilesInJar() throws Exception
    {
        File badClassesJar = MavenTestingUtils.getTestResourceFile(""bad-classes.jar"");
        AnnotationParser parser = new AnnotationParser();
        Set<Handler> emptySet = Collections.emptySet();
        parser.parse(emptySet, badClassesJar.toURI());
        // only the valid classes inside bad-classes.jar should be parsed. If any invalid classes are parsed and exception would be thrown here
    }
",non-flaky,5
170514,eclipse_jetty.project,TestAnnotationParser.testModuleInfoClassInJar,"    @Test
    public void testModuleInfoClassInJar() throws Exception
    {
        File badClassesJar = MavenTestingUtils.getTestResourceFile(""jdk9/slf4j-api-1.8.0-alpha2.jar"");
        AnnotationParser parser = new AnnotationParser();
        Set<Handler> emptySet = Collections.emptySet();
        parser.parse(emptySet, badClassesJar.toURI());
        // Should throw no exceptions, and happily skip the module-info.class files
    }
",non-flaky,5
170515,eclipse_jetty.project,TestAnnotationParser.testJep238MultiReleaseInJar,"    @Test
    public void testJep238MultiReleaseInJar() throws Exception
    {
        File badClassesJar = MavenTestingUtils.getTestResourceFile(""jdk9/log4j-api-2.9.0.jar"");
        AnnotationParser parser = new AnnotationParser();
        Set<Handler> emptySet = Collections.emptySet();
        parser.parse(emptySet, badClassesJar.toURI());
        // Should throw no exceptions, and skip the META-INF/versions/9/* files
    }
",non-flaky,5
170516,eclipse_jetty.project,TestAnnotationParser.testJep238MultiReleaseInJarJDK10,"    @Test
    public void testJep238MultiReleaseInJarJDK10() throws Exception
    {
        File jdk10Jar = MavenTestingUtils.getTestResourceFile(""jdk10/multirelease-10.jar"");
        AnnotationParser parser = new AnnotationParser();
        DuplicateClassScanHandler handler = new DuplicateClassScanHandler();
        Set<Handler> handlers = Collections.singleton(handler);
        parser.parse(handlers, new PathResource(jdk10Jar));
        // Should throw no exceptions
    }
",non-flaky,5
170517,eclipse_jetty.project,TestAnnotationParser.testBasedirExclusion,"    @Test
    public void testBasedirExclusion() throws Exception
    {
        // Build up basedir, which itself has a path segment that violates java package and classnaming.
        // The basedir should have no effect on annotation scanning.
        // Intentionally using a base director name that starts with a "".""
        // This mimics what you see in jenkins, hudson, hadoop, solr, camel, and selenium for their 
        // installed and/or managed webapps
        File basedir = testdir.getPathFile("".base/workspace/classes"").toFile();
        FS.ensureEmpty(basedir);

        // Copy in class that is known to have annotations.
        copyClass(ClassA.class, basedir);

        // Setup Tracker
        TrackingAnnotationHandler tracker = new TrackingAnnotationHandler(Sample.class.getName());

        // Setup annotation scanning
        AnnotationParser parser = new AnnotationParser();

        // Parse
        parser.parse(Collections.singleton(tracker), basedir.toURI());

        // Validate
        assertThat(""Found Class"", tracker.foundClasses, contains(ClassA.class.getName()));
    }
",non-flaky,5
170518,eclipse_jetty.project,TestAnnotationParser.testScanDuplicateClassesInJars,"    @Test
    public void testScanDuplicateClassesInJars() throws Exception
    {
        Resource testJar = Resource.newResource(MavenTestingUtils.getTestResourceFile(""tinytest.jar""));
        Resource testJar2 = Resource.newResource(MavenTestingUtils.getTestResourceFile(""tinytest_copy.jar""));
        AnnotationParser parser = new AnnotationParser();
        DuplicateClassScanHandler handler = new DuplicateClassScanHandler();
        Set<Handler> handlers = Collections.singleton(handler);
        parser.parse(handlers, testJar);
        parser.parse(handlers, testJar2);
        List<String> locations = handler.getParsedList(""org.acme.ClassOne"");
        assertNotNull(locations);
        assertEquals(2, locations.size());
        assertTrue(!(locations.get(0).equals(locations.get(1))));
    }
",non-flaky,5
170519,eclipse_jetty.project,TestAnnotationParser.testScanDuplicateClasses,"    @Test
    public void testScanDuplicateClasses() throws Exception
    {
        Resource testJar = Resource.newResource(MavenTestingUtils.getTestResourceFile(""tinytest.jar""));
        File testClasses = new File(MavenTestingUtils.getTargetDir(), ""test-classes"");
        AnnotationParser parser = new AnnotationParser();
        DuplicateClassScanHandler handler = new DuplicateClassScanHandler();
        Set<Handler> handlers = Collections.singleton(handler);
        parser.parse(handlers, testJar);
        parser.parse(handlers, Resource.newResource(testClasses));
        List<String> locations = handler.getParsedList(""org.acme.ClassOne"");
        assertNotNull(locations);
        assertEquals(2, locations.size());
        assertTrue(!(locations.get(0).equals(locations.get(1))));
    }
",non-flaky,5
170520,eclipse_jetty.project,TestAnnotationConfiguration.setup,"    @BeforeEach
    public void setup() throws Exception
    {
        web25 = MavenTestingUtils.getTestResourceFile(""web25.xml"");
        web31false = MavenTestingUtils.getTestResourceFile(""web31false.xml"");
        web31true = MavenTestingUtils.getTestResourceFile(""web31true.xml"");

        // prepare an sci that will be on the webapp's classpath
        jarDir = new File(MavenTestingUtils.getTestResourcesDir().getParentFile(), ""jar"");
        testSciJar = new File(jarDir, ""test-sci.jar"");
        assertTrue(testSciJar.exists());

        testContainerSciJar = new File(jarDir, ""test-sci-for-container-path.jar"");
        testWebInfClassesJar = new File(jarDir, ""test-sci-for-webinf.jar"");

        // unpack some classes to pretend that are in WEB-INF/classes
        unpacked = new File(MavenTestingUtils.getTargetTestingDir(), ""test-sci-for-webinf"");
        unpacked.mkdirs();
        FS.cleanDirectory(unpacked);
        JAR.unpack(testWebInfClassesJar, unpacked);
        webInfClasses = Resource.newResource(unpacked);

        containerLoader = new URLClassLoader(new URL[]{
            testContainerSciJar.toURI().toURL()
        }, Thread.currentThread().getContextClassLoader());

        targetClasses = Resource.newResource(MavenTestingUtils.getTargetDir().toURI()).addPath(""/test-classes"");

        classes = Arrays.asList(new Resource[]{webInfClasses, targetClasses});

        webAppLoader = new URLClassLoader(new URL[]{
            testSciJar.toURI().toURL(), targetClasses.getURI().toURL(), webInfClasses.getURI().toURL()
        },
            containerLoader);
    }
",non-flaky,5
170521,eclipse_jetty.project,TestAnnotationConfiguration.testAnnotationScanControl,"    @Test
    public void testAnnotationScanControl() throws Exception
    {
        //check that a 2.5 webapp with configurationDiscovered will discover annotations
        TestableAnnotationConfiguration config25 = new TestableAnnotationConfiguration();
        WebAppContext context25 = new WebAppContext();
        context25.setClassLoader(Thread.currentThread().getContextClassLoader());
        context25.setAttribute(AnnotationConfiguration.MULTI_THREADED, Boolean.FALSE);
        context25.setAttribute(AnnotationConfiguration.MAX_SCAN_WAIT, 0);
        context25.setConfigurationDiscovered(false);
        context25.getMetaData().setWebDescriptor(new WebDescriptor(Resource.newResource(web25)));
        context25.getServletContext().setEffectiveMajorVersion(2);
        context25.getServletContext().setEffectiveMinorVersion(5);
        config25.configure(context25);
        config25.assertAnnotationDiscovery(false);

        //check that a 2.5 webapp discover annotations
        TestableAnnotationConfiguration config25b = new TestableAnnotationConfiguration();
        WebAppContext context25b = new WebAppContext();
        context25b.setClassLoader(Thread.currentThread().getContextClassLoader());
        context25b.setAttribute(AnnotationConfiguration.MULTI_THREADED, Boolean.FALSE);
        context25b.setAttribute(AnnotationConfiguration.MAX_SCAN_WAIT, 0);
        context25b.getMetaData().setWebDescriptor(new WebDescriptor(Resource.newResource(web25)));
        context25b.getServletContext().setEffectiveMajorVersion(2);
        context25b.getServletContext().setEffectiveMinorVersion(5);
        config25b.configure(context25b);
        config25b.assertAnnotationDiscovery(true);

        //check that a 3.x webapp with metadata true won't discover annotations
        TestableAnnotationConfiguration config31 = new TestableAnnotationConfiguration();
        WebAppContext context31 = new WebAppContext();
        context31.setClassLoader(Thread.currentThread().getContextClassLoader());
        context31.setAttribute(AnnotationConfiguration.MULTI_THREADED, Boolean.FALSE);
        context31.setAttribute(AnnotationConfiguration.MAX_SCAN_WAIT, 0);
        context31.getMetaData().setWebDescriptor(new WebDescriptor(Resource.newResource(web31true)));
        context31.getServletContext().setEffectiveMajorVersion(3);
        context31.getServletContext().setEffectiveMinorVersion(1);
        config31.configure(context31);
        config31.assertAnnotationDiscovery(false);

        //check that a 3.x webapp with metadata false will discover annotations
        TestableAnnotationConfiguration config31b = new TestableAnnotationConfiguration();
        WebAppContext context31b = new WebAppContext();
        context31b.setClassLoader(Thread.currentThread().getContextClassLoader());
        context31b.setAttribute(AnnotationConfiguration.MULTI_THREADED, Boolean.FALSE);
        context31b.setAttribute(AnnotationConfiguration.MAX_SCAN_WAIT, 0);
        context31b.getMetaData().setWebDescriptor(new WebDescriptor(Resource.newResource(web31false)));
        context31b.getServletContext().setEffectiveMajorVersion(3);
        context31b.getServletContext().setEffectiveMinorVersion(1);
        config31b.configure(context31b);
        config31b.assertAnnotationDiscovery(true);
    }
",non-flaky,5
170522,eclipse_jetty.project,TestAnnotationConfiguration.testServerAndWebappSCIs,"    @Test
    public void testServerAndWebappSCIs() throws Exception
    {
        ClassLoader old = Thread.currentThread().getContextClassLoader();
        Thread.currentThread().setContextClassLoader(webAppLoader);

        try
        {
            AnnotationConfiguration config = new AnnotationConfiguration();
            WebAppContext context = new WebAppContext();
            List<ServletContainerInitializer> scis;

            //test 3.1 webapp loads both server and app scis
            context.setClassLoader(webAppLoader);
            context.getMetaData().addWebInfResource(Resource.newResource(testSciJar.toURI().toURL()));
            context.getMetaData().setWebDescriptor(new WebDescriptor(Resource.newResource(web31true)));
            context.getMetaData().setWebInfClassesResources(classes);
            context.getServletContext().setEffectiveMajorVersion(3);
            context.getServletContext().setEffectiveMinorVersion(1);
            scis = config.getNonExcludedInitializers(context);
            assertNotNull(scis);
            assertEquals(3, scis.size());
            assertEquals(""com.acme.ServerServletContainerInitializer"", scis.get(0).getClass().getName()); //container path
            assertEquals(""com.acme.webinf.WebInfClassServletContainerInitializer"", scis.get(1).getClass().getName()); // web-inf
            assertEquals(""com.acme.initializer.FooInitializer"", scis.get(2).getClass().getName()); //web-inf jar no web-fragment
        }
        finally
        {
            Thread.currentThread().setContextClassLoader(old);
        }
    }
",non-flaky,5
170523,eclipse_jetty.project,TestAnnotationConfiguration.createServletContainerInitializerAnnotationHandlers,"    @Test
    public void testClassScanHandlersForSCIs() throws Exception
    {
        //test that SCIs with a @HandlesTypes that is an annotation registers
        //handlers for the scanning phase that will capture the class hierarchy,
        //and also capture all classes that contain the annotation
        ClassLoader old = Thread.currentThread().getContextClassLoader();
        Thread.currentThread().setContextClassLoader(webAppLoader);

        try
        {
            class MyAnnotationConfiguration extends AnnotationConfiguration
            {

                @Override
                public void createServletContainerInitializerAnnotationHandlers(WebAppContext context, List<ServletContainerInitializer> scis) throws Exception
                {
                    super.createServletContainerInitializerAnnotationHandlers(context, scis);
                    //check class hierarchy scanner handler is registered
                    assertNotNull(_classInheritanceHandler);
                    //check 
                    assertEquals(1, _containerInitializerAnnotationHandlers.size());
                    ContainerInitializerAnnotationHandler handler = _containerInitializerAnnotationHandlers.get(0);
                    assertThat(handler._holder.toString(), containsString(""com.acme.initializer.FooInitializer""));
                    assertEquals(""com.acme.initializer.Foo"", handler._annotation.getName());
                }
",non-flaky,5
170524,eclipse_jetty.project,TestAnnotationConfiguration.testMetaDataCompleteSCIs,"    @Test
    public void testMetaDataCompleteSCIs() throws Exception
    {
        ClassLoader old = Thread.currentThread().getContextClassLoader();
        Thread.currentThread().setContextClassLoader(webAppLoader);

        try
        {
            AnnotationConfiguration config = new AnnotationConfiguration();
            WebAppContext context = new WebAppContext();
            List<ServletContainerInitializer> scis;
            // test a 3.1 webapp with metadata-complete=false loads both server
            // and webapp scis
            context.setClassLoader(webAppLoader);
            context.getMetaData().setWebDescriptor(new WebDescriptor(Resource.newResource(web31false)));
            context.getMetaData().setWebInfClassesResources(classes);
            context.getMetaData().addWebInfResource(Resource.newResource(testSciJar.toURI().toURL()));
            context.getServletContext().setEffectiveMajorVersion(3);
            context.getServletContext().setEffectiveMinorVersion(1);
            scis = config.getNonExcludedInitializers(context);
            assertNotNull(scis);
            assertEquals(3, scis.size());
            assertEquals(""com.acme.ServerServletContainerInitializer"", scis.get(0).getClass().getName()); // container
            // path
            assertEquals(""com.acme.webinf.WebInfClassServletContainerInitializer"", scis.get(1).getClass().getName()); // web-inf
            assertEquals(""com.acme.initializer.FooInitializer"", scis.get(2).getClass().getName()); // web-inf
            // jar
            // no
            // web-fragment
        }
        finally
        {
            Thread.currentThread().setContextClassLoader(old);
        }
    }
",non-flaky,5
170525,eclipse_jetty.project,TestAnnotationConfiguration.testRelativeOrderingWithSCIs,"    @Test
    public void testRelativeOrderingWithSCIs() throws Exception
    {
        // test a 3.1 webapp with RELATIVE ORDERING loads sci from
        // equivalent of WEB-INF/classes first as well as container path

        ClassLoader old = Thread.currentThread().getContextClassLoader();

        File orderedFragmentJar = new File(jarDir, ""test-sci-with-ordering.jar"");
        assertTrue(orderedFragmentJar.exists());
        URLClassLoader orderedLoader = new URLClassLoader(new URL[]{
            orderedFragmentJar.toURI().toURL(), testSciJar.toURI().toURL(),
            targetClasses.getURI().toURL(), webInfClasses.getURI().toURL()
        },
            containerLoader);
        Thread.currentThread().setContextClassLoader(orderedLoader);

        try
        {
            AnnotationConfiguration config = new AnnotationConfiguration();
            WebAppContext context = new WebAppContext();
            List<ServletContainerInitializer> scis;
            context.setClassLoader(orderedLoader);
            context.getMetaData().setWebDescriptor(new WebDescriptor(Resource.newResource(web31true)));
            RelativeOrdering ordering = new RelativeOrdering(context.getMetaData());
            context.getMetaData().setOrdering(ordering);
            context.getMetaData().addWebInfResource(Resource.newResource(orderedFragmentJar.toURI().toURL()));
            context.getMetaData().addWebInfResource(Resource.newResource(testSciJar.toURI().toURL()));
            context.getMetaData().setWebInfClassesResources(classes);
            context.getMetaData().orderFragments();
            context.getServletContext().setEffectiveMajorVersion(3);
            context.getServletContext().setEffectiveMinorVersion(1);
            scis = config.getNonExcludedInitializers(context);
            assertNotNull(scis);
            assertEquals(4, scis.size());
            assertEquals(""com.acme.ServerServletContainerInitializer"", scis.get(0).getClass().getName()); //container path
            assertEquals(""com.acme.webinf.WebInfClassServletContainerInitializer"", scis.get(1).getClass().getName()); // web-inf
            assertEquals(""com.acme.ordering.AcmeServletContainerInitializer"", scis.get(2).getClass().getName()); // first
            assertEquals(""com.acme.initializer.FooInitializer"", scis.get(3).getClass().getName()); //other in ordering
        }
        finally
        {
            Thread.currentThread().setContextClassLoader(old);
        }
    }
",non-flaky,5
170526,eclipse_jetty.project,TestAnnotationConfiguration.testDiscoveredFalseWithSCIs,"    @Test
    public void testDiscoveredFalseWithSCIs() throws Exception
    {
        ClassLoader old = Thread.currentThread().getContextClassLoader();
        Thread.currentThread().setContextClassLoader(webAppLoader);
        try
        {
            //test 2.5 webapp with configurationDiscovered=false loads only server scis
            AnnotationConfiguration config = new AnnotationConfiguration();
            WebAppContext context = new WebAppContext();
            List<ServletContainerInitializer> scis;
            context.setConfigurationDiscovered(false);
            context.setClassLoader(webAppLoader);
            context.getMetaData().setWebDescriptor(new WebDescriptor(Resource.newResource(web25)));
            context.getMetaData().setWebInfClassesResources(classes);
            context.getMetaData().addWebInfResource(Resource.newResource(testSciJar.toURI().toURL()));
            context.getServletContext().setEffectiveMajorVersion(2);
            context.getServletContext().setEffectiveMinorVersion(5);
            scis = config.getNonExcludedInitializers(context);
            assertNotNull(scis);
            for (ServletContainerInitializer s : scis)
            {
                //should not have any of the web-inf lib scis in here
                assertFalse(s.getClass().getName().equals(""com.acme.ordering.AcmeServletContainerInitializer""));
                assertFalse(s.getClass().getName().equals(""com.acme.initializer.FooInitializer""));
                //NOTE: should also not have the web-inf classes scis in here either, but due to the
                //way the test is set up, the sci we're pretending is in web-inf classes will actually
                //NOT be loaded by the webapp's classloader, but rather by the junit classloader, so
                //it looks as if it is a container class.
            }
        }
        finally
        {
            Thread.currentThread().setContextClassLoader(old);
        }
    }
",non-flaky,5
170527,eclipse_jetty.project,TestAnnotationConfiguration.testDiscoveredTrueWithSCIs,"    @Test
    public void testDiscoveredTrueWithSCIs() throws Exception
    {
        ClassLoader old = Thread.currentThread().getContextClassLoader();
        Thread.currentThread().setContextClassLoader(webAppLoader);
        try
        {
            //test 2.5 webapp with configurationDiscovered=true loads both server and webapp scis
            AnnotationConfiguration config = new AnnotationConfiguration();
            WebAppContext context = new WebAppContext();
            List<ServletContainerInitializer> scis;
            context.setConfigurationDiscovered(true);
            context.setClassLoader(webAppLoader);
            context.getMetaData().setWebDescriptor(new WebDescriptor(Resource.newResource(web25)));
            context.getMetaData().setWebInfClassesResources(classes);
            context.getMetaData().addWebInfResource(Resource.newResource(testSciJar.toURI().toURL()));
            context.getServletContext().setEffectiveMajorVersion(2);
            context.getServletContext().setEffectiveMinorVersion(5);
            scis = config.getNonExcludedInitializers(context);
            assertNotNull(scis);
            assertEquals(3, scis.size());
            assertEquals(""com.acme.ServerServletContainerInitializer"", scis.get(0).getClass().getName()); //container path
            assertEquals(""com.acme.webinf.WebInfClassServletContainerInitializer"", scis.get(1).getClass().getName()); // web-inf
            assertEquals(""com.acme.initializer.FooInitializer"", scis.get(2).getClass().getName()); //web-inf jar no web-fragment
        }
        finally
        {
            Thread.currentThread().setContextClassLoader(old);
        }
    }
",non-flaky,5
170528,eclipse_jetty.project,TestSecurityAnnotationConversions.testDenyAllOnClass,"    @Test
    public void testDenyAllOnClass() throws Exception
    {

        WebAppContext wac = makeWebAppContext(DenyServlet.class.getCanonicalName(), ""denyServlet"", new String[]{
            ""/foo/*"", ""*.foo""
        });

        //Assume we found 1 servlet with a @HttpConstraint with value=EmptyRoleSemantic.DENY security annotation
        ServletSecurityAnnotationHandler annotationHandler = new ServletSecurityAnnotationHandler(wac);
        AnnotationIntrospector introspector = new AnnotationIntrospector(wac);
        introspector.registerHandler(annotationHandler);

        //set up the expected outcomes:
        //1 ConstraintMapping per ServletMapping pathSpec
        Constraint expectedConstraint = new Constraint();
        expectedConstraint.setAuthenticate(true);
        expectedConstraint.setDataConstraint(Constraint.DC_NONE);

        ConstraintMapping[] expectedMappings = new ConstraintMapping[2];

        expectedMappings[0] = new ConstraintMapping();
        expectedMappings[0].setConstraint(expectedConstraint);
        expectedMappings[0].setPathSpec(""/foo/*"");

        expectedMappings[1] = new ConstraintMapping();
        expectedMappings[1].setConstraint(expectedConstraint);
        expectedMappings[1].setPathSpec(""*.foo"");

        introspector.introspect(new DenyServlet(), null);

        compareResults(expectedMappings, ((ConstraintAware)wac.getSecurityHandler()).getConstraintMappings());
    }
",non-flaky,5
170529,eclipse_jetty.project,TestSecurityAnnotationConversions.testPermitAll,"    @Test
    public void testPermitAll() throws Exception
    {
        //Assume we found 1 servlet with a @ServletSecurity security annotation
        WebAppContext wac = makeWebAppContext(PermitServlet.class.getCanonicalName(), ""permitServlet"", new String[]{
            ""/foo/*"", ""*.foo""
        });

        ServletSecurityAnnotationHandler annotationHandler = new ServletSecurityAnnotationHandler(wac);
        AnnotationIntrospector introspector = new AnnotationIntrospector(wac);
        introspector.registerHandler(annotationHandler);

        //set up the expected outcomes - no constraints at all as per Servlet Spec 3.1 pg 129
        //1 ConstraintMapping per ServletMapping pathSpec

        ConstraintMapping[] expectedMappings = new ConstraintMapping[]{};
        PermitServlet permit = new PermitServlet();
        introspector.introspect(permit, null);

        compareResults(expectedMappings, ((ConstraintAware)wac.getSecurityHandler()).getConstraintMappings());
    }
",non-flaky,5
170530,eclipse_jetty.project,TestSecurityAnnotationConversions.testRolesAllowedWithTransportGuarantee,"    @Test
    public void testRolesAllowedWithTransportGuarantee() throws Exception
    {
        //Assume we found 1 servlet with annotation with roles defined and
        //and a TransportGuarantee

        WebAppContext wac = makeWebAppContext(RolesServlet.class.getCanonicalName(), ""rolesServlet"", new String[]{
            ""/foo/*"", ""*.foo""
        });

        ServletSecurityAnnotationHandler annotationHandler = new ServletSecurityAnnotationHandler(wac);
        AnnotationIntrospector introspector = new AnnotationIntrospector(wac);
        introspector.registerHandler(annotationHandler);

        //set up the expected outcomes:compareResults
        //1 ConstraintMapping per ServletMapping
        Constraint expectedConstraint = new Constraint();
        expectedConstraint.setAuthenticate(true);
        expectedConstraint.setRoles(new String[]{""tom"", ""dick"", ""harry""});
        expectedConstraint.setDataConstraint(Constraint.DC_CONFIDENTIAL);

        ConstraintMapping[] expectedMappings = new ConstraintMapping[2];
        expectedMappings[0] = new ConstraintMapping();
        expectedMappings[0].setConstraint(expectedConstraint);
        expectedMappings[0].setPathSpec(""/foo/*"");

        expectedMappings[1] = new ConstraintMapping();
        expectedMappings[1].setConstraint(expectedConstraint);
        expectedMappings[1].setPathSpec(""*.foo"");
        introspector.introspect(new RolesServlet(), null);
        compareResults(expectedMappings, ((ConstraintAware)wac.getSecurityHandler()).getConstraintMappings());
    }
",non-flaky,5
170531,eclipse_jetty.project,TestSecurityAnnotationConversions.testMethodAnnotation,"    @Test
    public void testMethodAnnotation() throws Exception
    {
        //ServletSecurity annotation with HttpConstraint of TransportGuarantee.CONFIDENTIAL, and a list of rolesAllowed, and
        //an HttpMethodConstraint for GET method that permits all and has TransportGuarantee.NONE (ie is default)

        WebAppContext wac = makeWebAppContext(Method1Servlet.class.getCanonicalName(), ""method1Servlet"", new String[]{
            ""/foo/*"", ""*.foo""
        });

        //set up the expected outcomes: - a Constraint for the RolesAllowed on the class
        //with userdata constraint of DC_CONFIDENTIAL
        //and mappings for each of the pathSpecs
        Constraint expectedConstraint1 = new Constraint();
        expectedConstraint1.setAuthenticate(true);
        expectedConstraint1.setRoles(new String[]{""tom"", ""dick"", ""harry""});
        expectedConstraint1.setDataConstraint(Constraint.DC_CONFIDENTIAL);

        //a Constraint for the PermitAll on the doGet method with a userdata
        //constraint of DC_CONFIDENTIAL inherited from the class
        Constraint expectedConstraint2 = new Constraint();
        expectedConstraint2.setDataConstraint(Constraint.DC_NONE);

        ConstraintMapping[] expectedMappings = new ConstraintMapping[4];
        expectedMappings[0] = new ConstraintMapping();
        expectedMappings[0].setConstraint(expectedConstraint1);
        expectedMappings[0].setPathSpec(""/foo/*"");
        expectedMappings[0].setMethodOmissions(new String[]{""GET""});
        expectedMappings[1] = new ConstraintMapping();
        expectedMappings[1].setConstraint(expectedConstraint1);
        expectedMappings[1].setPathSpec(""*.foo"");
        expectedMappings[1].setMethodOmissions(new String[]{""GET""});

        expectedMappings[2] = new ConstraintMapping();
        expectedMappings[2].setConstraint(expectedConstraint2);
        expectedMappings[2].setPathSpec(""/foo/*"");
        expectedMappings[2].setMethod(""GET"");
        expectedMappings[3] = new ConstraintMapping();
        expectedMappings[3].setConstraint(expectedConstraint2);
        expectedMappings[3].setPathSpec(""*.foo"");
        expectedMappings[3].setMethod(""GET"");

        AnnotationIntrospector introspector = new AnnotationIntrospector(wac);
        ServletSecurityAnnotationHandler annotationHandler = new ServletSecurityAnnotationHandler(wac);
        introspector.registerHandler(annotationHandler);
        introspector.introspect(new Method1Servlet(), null);
        compareResults(expectedMappings, ((ConstraintAware)wac.getSecurityHandler()).getConstraintMappings());
    }
",non-flaky,5
170532,eclipse_jetty.project,TestSecurityAnnotationConversions.testMethodAnnotation2,"    @Test
    public void testMethodAnnotation2() throws Exception
    {
        //A ServletSecurity annotation that has HttpConstraint of CONFIDENTIAL with defined roles, but a
        //HttpMethodConstraint for GET that permits all, but also requires CONFIDENTIAL
        WebAppContext wac = makeWebAppContext(Method2Servlet.class.getCanonicalName(), ""method2Servlet"", new String[]{
            ""/foo/*"", ""*.foo""
        });

        AnnotationIntrospector introspector = new AnnotationIntrospector(wac);
        ServletSecurityAnnotationHandler annotationHandler = new ServletSecurityAnnotationHandler(wac);
        introspector.registerHandler(annotationHandler);

        //set up the expected outcomes: - a Constraint for the RolesAllowed on the class
        //with userdata constraint of DC_CONFIDENTIAL
        //and mappings for each of the pathSpecs
        Constraint expectedConstraint1 = new Constraint();
        expectedConstraint1.setAuthenticate(true);
        expectedConstraint1.setRoles(new String[]{""tom"", ""dick"", ""harry""});
        expectedConstraint1.setDataConstraint(Constraint.DC_CONFIDENTIAL);

        //a Constraint for the Permit on the GET method with a userdata
        //constraint of DC_CONFIDENTIAL
        Constraint expectedConstraint2 = new Constraint();
        expectedConstraint2.setDataConstraint(Constraint.DC_CONFIDENTIAL);

        ConstraintMapping[] expectedMappings = new ConstraintMapping[4];
        expectedMappings[0] = new ConstraintMapping();
        expectedMappings[0].setConstraint(expectedConstraint1);
        expectedMappings[0].setPathSpec(""/foo/*"");
        expectedMappings[0].setMethodOmissions(new String[]{""GET""});
        expectedMappings[1] = new ConstraintMapping();
        expectedMappings[1].setConstraint(expectedConstraint1);
        expectedMappings[1].setPathSpec(""*.foo"");
        expectedMappings[1].setMethodOmissions(new String[]{""GET""});

        expectedMappings[2] = new ConstraintMapping();
        expectedMappings[2].setConstraint(expectedConstraint2);
        expectedMappings[2].setPathSpec(""/foo/*"");
        expectedMappings[2].setMethod(""GET"");
        expectedMappings[3] = new ConstraintMapping();
        expectedMappings[3].setConstraint(expectedConstraint2);
        expectedMappings[3].setPathSpec(""*.foo"");
        expectedMappings[3].setMethod(""GET"");

        introspector.introspect(new Method2Servlet(), null);
        compareResults(expectedMappings, ((ConstraintAware)wac.getSecurityHandler()).getConstraintMappings());
    }
",non-flaky,5
170533,eclipse_jetty.project,TestAnnotationDecorator.testAnnotationDecorator,"    @Test
    public void testAnnotationDecorator() throws Exception
    {
        assertThrows(NullPointerException.class, () ->
        {
            new AnnotationDecorator(null);
        });

        WebAppContext context = new WebAppContext();
        AnnotationDecorator decorator = new AnnotationDecorator(context);
        ServletE servlet = new ServletE();
        //test without BaseHolder metadata
        decorator.decorate(servlet);
        LifeCycleCallbackCollection callbacks = (LifeCycleCallbackCollection)context.getAttribute(LifeCycleCallbackCollection.LIFECYCLE_CALLBACK_COLLECTION);
        assertNotNull(callbacks);
        assertFalse(callbacks.getPreDestroyCallbacks().isEmpty());

        //reset
        context.removeAttribute(LifeCycleCallbackCollection.LIFECYCLE_CALLBACK_COLLECTION);

        //test with BaseHolder metadata, should not introspect with metdata-complete==true
        context.getMetaData().setWebDescriptor(new TestWebDescriptor(MetaData.Complete.True));
        assertTrue(context.getMetaData().isMetaDataComplete());
        ServletHolder holder = new ServletHolder(new Source(Source.Origin.DESCRIPTOR, """"));
        holder.setHeldClass(ServletE.class);
        context.getServletHandler().addServlet(holder);
        DecoratedObjectFactory.associateInfo(holder);
        decorator = new AnnotationDecorator(context);
        decorator.decorate(servlet);
        DecoratedObjectFactory.disassociateInfo();
        callbacks = (LifeCycleCallbackCollection)context.getAttribute(LifeCycleCallbackCollection.LIFECYCLE_CALLBACK_COLLECTION);
        assertNull(callbacks);

        //reset
        context.removeAttribute(LifeCycleCallbackCollection.LIFECYCLE_CALLBACK_COLLECTION);

        //test with BaseHolder metadata, should introspect with metadata-complete==false
        context.getMetaData().setWebDescriptor(new TestWebDescriptor(MetaData.Complete.False));
        DecoratedObjectFactory.associateInfo(holder);
        decorator = new AnnotationDecorator(context);
        decorator.decorate(servlet);
        DecoratedObjectFactory.disassociateInfo();
        callbacks = (LifeCycleCallbackCollection)context.getAttribute(LifeCycleCallbackCollection.LIFECYCLE_CALLBACK_COLLECTION);
        assertNotNull(callbacks);
        assertFalse(callbacks.getPreDestroyCallbacks().isEmpty());
    }
",non-flaky,5
170534,eclipse_jetty.project,TestAnnotationInheritance.destroy,"    @AfterEach
    public void destroy() throws Exception
    {
        classNames.clear();
        InitialContext ic = new InitialContext();
        Context comp = (Context)ic.lookup(""java:comp"");
        comp.destroySubcontext(""env"");
    }
",non-flaky,5
170535,eclipse_jetty.project,TestAnnotationInheritance.testParseClassNames,"    @Test
    public void testParseClassNames() throws Exception
    {
        classNames.add(ClassA.class.getName());
        classNames.add(ClassB.class.getName());

        SampleHandler handler = new SampleHandler();
        AnnotationParser parser = new AnnotationParser();
        parser.parse(Collections.singleton(handler), classNames);

        //check we got  2 class annotations
        assertEquals(2, handler.annotatedClassNames.size());

        //check we got all annotated methods on each class
        assertEquals(7, handler.annotatedMethods.size());
        assertTrue(handler.annotatedMethods.contains(""org.eclipse.jetty.annotations.ClassA.a""));
        assertTrue(handler.annotatedMethods.contains(""org.eclipse.jetty.annotations.ClassA.b""));
        assertTrue(handler.annotatedMethods.contains(""org.eclipse.jetty.annotations.ClassA.c""));
        assertTrue(handler.annotatedMethods.contains(""org.eclipse.jetty.annotations.ClassA.d""));
        assertTrue(handler.annotatedMethods.contains(""org.eclipse.jetty.annotations.ClassA.l""));
        assertTrue(handler.annotatedMethods.contains(""org.eclipse.jetty.annotations.ClassB.a""));
        assertTrue(handler.annotatedMethods.contains(""org.eclipse.jetty.annotations.ClassB.c""));

        //check we got all annotated fields on each class
        assertEquals(1, handler.annotatedFields.size());
        assertEquals(""org.eclipse.jetty.annotations.ClassA.m"", handler.annotatedFields.get(0));
    }
",non-flaky,5
170536,eclipse_jetty.project,TestAnnotationInheritance.testParseClass,"    @Test
    public void testParseClass() throws Exception
    {
        SampleHandler handler = new SampleHandler();
        AnnotationParser parser = new AnnotationParser();
        parser.parse(Collections.singleton(handler), ClassB.class, true);

        //check we got  2 class annotations
        assertEquals(2, handler.annotatedClassNames.size());

        //check we got all annotated methods on each class
        assertEquals(7, handler.annotatedMethods.size());
        assertTrue(handler.annotatedMethods.contains(""org.eclipse.jetty.annotations.ClassA.a""));
        assertTrue(handler.annotatedMethods.contains(""org.eclipse.jetty.annotations.ClassA.b""));
        assertTrue(handler.annotatedMethods.contains(""org.eclipse.jetty.annotations.ClassA.c""));
        assertTrue(handler.annotatedMethods.contains(""org.eclipse.jetty.annotations.ClassA.d""));
        assertTrue(handler.annotatedMethods.contains(""org.eclipse.jetty.annotations.ClassA.l""));
        assertTrue(handler.annotatedMethods.contains(""org.eclipse.jetty.annotations.ClassB.a""));
        assertTrue(handler.annotatedMethods.contains(""org.eclipse.jetty.annotations.ClassB.c""));

        //check we got all annotated fields on each class
        assertEquals(1, handler.annotatedFields.size());
        assertEquals(""org.eclipse.jetty.annotations.ClassA.m"", handler.annotatedFields.get(0));
    }
",non-flaky,5
170537,eclipse_jetty.project,TestAnnotationInheritance.testTypeInheritanceHandling,"    @Test
    public void testTypeInheritanceHandling() throws Exception
    {
        Map<String, Set<String>> map = new ConcurrentHashMap<>();

        AnnotationParser parser = new AnnotationParser();
        ClassInheritanceHandler handler = new ClassInheritanceHandler(map);

        class Foo implements InterfaceD
        {
        }

        classNames.clear();
        classNames.add(ClassA.class.getName());
        classNames.add(ClassB.class.getName());
        classNames.add(InterfaceD.class.getName());
        classNames.add(Foo.class.getName());

        parser.parse(Collections.singleton(handler), classNames);

        assertNotNull(map);
        assertFalse(map.isEmpty());
        assertEquals(2, map.size());

        assertThat(map, hasKey(""org.eclipse.jetty.annotations.ClassA""));
        assertThat(map, hasKey(""org.eclipse.jetty.annotations.InterfaceD""));
        Set<String> classes = map.get(""org.eclipse.jetty.annotations.ClassA"");
        assertThat(classes, contains(""org.eclipse.jetty.annotations.ClassB""));

        classes = map.get(""org.eclipse.jetty.annotations.InterfaceD"");
        assertThat(classes, containsInAnyOrder(""org.eclipse.jetty.annotations.ClassB"",
            Foo.class.getName()));
    }
",non-flaky,5
170538,eclipse_jetty.project,TestAnnotationIntrospector.testIsIntrospectable,"    @Test
    public void testIsIntrospectable() throws Exception
    {
        try (StacklessLogging ignore = new StacklessLogging(AnnotationIntrospector.class))
        {
            WebAppContext wac = new WebAppContext();
            AnnotationIntrospector introspector = new AnnotationIntrospector(wac);
            //can't introspect nothing
            assertFalse(introspector.isIntrospectable(null, null));

            //can introspect if no metadata to say otherwise
            assertTrue(introspector.isIntrospectable(new Object(), null));

            //can introspect if metdata isn't a BaseHolder
            assertTrue(introspector.isIntrospectable(new Object(), new Object()));

            //an EMBEDDED sourced servlet can be introspected
            ServletHolder holder = new ServletHolder();
            holder.setHeldClass(ServletE.class);
            assertTrue(introspector.isIntrospectable(new ServletE(), holder));

            //a JAVAX API sourced servlet can be introspected
            holder = new ServletHolder(Source.JAVAX_API);
            holder.setHeldClass(ServletE.class);
            assertTrue(introspector.isIntrospectable(new ServletE(), holder));

            //an ANNOTATION sourced servlet can be introspected
            holder = new ServletHolder(new Source(Source.Origin.ANNOTATION, ServletE.class.getName()));
            holder.setHeldClass(ServletE.class);
            assertTrue(introspector.isIntrospectable(new ServletE(), holder));

            //a DESCRIPTOR sourced servlet can be introspected if web.xml metdata-complete==false
            File file = MavenTestingUtils.getTestResourceFile(""web31false.xml"");
            Resource resource = Resource.newResource(file);
            wac.getMetaData().setWebDescriptor(new WebDescriptor(resource));
            holder = new ServletHolder(new Source(Source.Origin.DESCRIPTOR, resource.toString()));
            assertTrue(introspector.isIntrospectable(new ServletE(), holder));

            //a DESCRIPTOR sourced servlet can be introspected if web-fragment.xml medata-complete==false && web.xml metadata-complete==false
            file = MavenTestingUtils.getTestResourceFile(""web-fragment4false.xml"");
            resource = Resource.newResource(file);
            wac.getMetaData().addFragmentDescriptor(Resource.newResource(file.getParentFile()), new FragmentDescriptor(resource));
            holder = new ServletHolder(new Source(Source.Origin.DESCRIPTOR, resource.toString()));
            assertTrue(introspector.isIntrospectable(new ServletE(), holder));

            //a DESCRIPTOR sourced servlet cannot be introspected if web-fragment.xml medata-complete==true (&& web.xml metadata-complete==false)
            file = MavenTestingUtils.getTestResourceFile(""web-fragment4true.xml"");
            resource = Resource.newResource(file);
            wac.getMetaData().addFragmentDescriptor(Resource.newResource(file.getParentFile()), new FragmentDescriptor(resource));
            holder = new ServletHolder(new Source(Source.Origin.DESCRIPTOR, resource.toString()));
            assertFalse(introspector.isIntrospectable(new ServletE(), holder));

            //a DESCRIPTOR sourced servlet cannot be introspected if web.xml medata-complete==true
            file = MavenTestingUtils.getTestResourceFile(""web31true.xml"");
            resource = Resource.newResource(file);
            wac.getMetaData().setWebDescriptor(new WebDescriptor(resource));
            holder = new ServletHolder(new Source(Source.Origin.DESCRIPTOR, resource.toString()));
            assertFalse(introspector.isIntrospectable(new ServletE(), holder));
        }
    }
",non-flaky,5
170539,eclipse_jetty.project,TestDiscoveredServletContainerInitializerHolder.test,"    @Test
    public void test() throws Exception
    {
        //SCI with @HandlesTypes[Ordinary, Sample]
        SampleServletContainerInitializer sci = new SampleServletContainerInitializer();
        
        DiscoveredServletContainerInitializerHolder holder = 
            new DiscoveredServletContainerInitializerHolder(new Source(Source.Origin.ANNOTATION, sci.getClass().getName()),
            sci);

        //add the @HandlesTypes to the holder
        holder.addStartupClasses(Ordinary.class, Sample.class);
        
        //pretend scanned and discovered that ASample has the Sample annotation
        holder.addStartupClasses(ASample.class.getName());
        
        //pretend we scanned the entire class hierarchy and found:
        //   com.acme.tom and com.acme.dick both extend Ordinary
        //   ASample has subclass BSample
        Map<String, Set<String>> classMap = new HashMap<>();
        classMap.put(Ordinary.class.getName(), new HashSet(Arrays.asList(""com.acme.tom"", ""com.acme.dick"")));
        classMap.put(ASample.class.getName(), new HashSet(Arrays.asList(BSample.class.getName())));
        holder.resolveClasses(classMap);
        
        //we should now have the following classes that will be passed to the SampleServletContainerInitializer.onStartup
        String toString = holder.toString();
        assertThat(toString, containsString(""com.acme.tom""));
        assertThat(toString, containsString(""com.acme.dick""));
        assertThat(toString, containsString(ASample.class.getName()));
        assertThat(toString, containsString(BSample.class.getName()));
        assertThat(toString, containsString(""applicable=[],annotated=[]""));
    }
",non-flaky,5
170540,eclipse_jetty.project,TestServletAnnotations.testServletAnnotation,"    @Test
    public void testServletAnnotation() throws Exception
    {
        List<String> classes = new ArrayList<String>();
        classes.add(""org.eclipse.jetty.annotations.ServletC"");
        AnnotationParser parser = new AnnotationParser();

        WebAppContext wac = new WebAppContext();
        List<DiscoveredAnnotation> results = new ArrayList<DiscoveredAnnotation>();

        TestWebServletAnnotationHandler handler = new TestWebServletAnnotationHandler(wac, results);

        parser.parse(Collections.singleton(handler), classes);

        assertEquals(1, results.size());
        assertTrue(results.get(0) instanceof WebServletAnnotation);

        results.get(0).apply();

        ServletHolder[] holders = wac.getServletHandler().getServlets();
        assertNotNull(holders);
        assertEquals(1, holders.length);

        // Verify servlet annotations
        ServletHolder cholder = holders[0];
        assertThat(""Servlet Name"", cholder.getName(), is(""CServlet""));
        assertThat(""InitParameter[x]"", cholder.getInitParameter(""x""), is(""y""));
        assertThat(""Init Order"", cholder.getInitOrder(), is(2));
        assertThat(""Async Supported"", cholder.isAsyncSupported(), is(false));

        // Verify mappings
        ServletMapping[] mappings = wac.getServletHandler().getServletMappings();
        assertNotNull(mappings);
        assertEquals(1, mappings.length);
        String[] paths = mappings[0].getPathSpecs();
        assertNotNull(paths);
        assertEquals(2, paths.length);
    }
",non-flaky,5
170541,eclipse_jetty.project,TestServletAnnotations.testWebServletAnnotationOverrideDefault,"    @Test
    public void testWebServletAnnotationOverrideDefault() throws Exception
    {
        //if the existing servlet mapping TO A DIFFERENT SERVLET IS from a default descriptor we
        //DO allow the annotation to replace the mapping.

        WebAppContext wac = new WebAppContext();
        ServletHolder defaultServlet = new ServletHolder();
        defaultServlet.setClassName(""org.eclipse.jetty.servlet.DefaultServlet"");
        defaultServlet.setName(""default"");
        wac.getServletHandler().addServlet(defaultServlet);

        ServletMapping m = new ServletMapping();
        m.setPathSpec(""/"");
        m.setServletName(""default"");
        m.setFromDefaultDescriptor(true);  //this mapping will be from a default descriptor
        wac.getServletHandler().addServletMapping(m);

        WebServletAnnotation annotation = new WebServletAnnotation(wac, ""org.eclipse.jetty.annotations.ServletD"", null);
        annotation.apply();

        //test that as the original servlet mapping had only 1 pathspec, then the whole
        //servlet mapping should be deleted as that pathspec will be remapped to the DServlet
        ServletMapping[] resultMappings = wac.getServletHandler().getServletMappings();
        assertNotNull(resultMappings);
        assertEquals(1, resultMappings.length);
        assertEquals(2, resultMappings[0].getPathSpecs().length);
        resultMappings[0].getServletName().equals(""DServlet"");
        for (String s : resultMappings[0].getPathSpecs())
        {
            assertThat(s, anyOf(is(""/""), is(""/bah/*"")));
        }
    }
",non-flaky,5
170542,eclipse_jetty.project,TestServletAnnotations.testWebServletAnnotationReplaceDefault,"    @Test
    public void testWebServletAnnotationReplaceDefault() throws Exception
    {
        //if the existing servlet mapping TO A DIFFERENT SERVLET IS from a default descriptor we
        //DO allow the annotation to replace the mapping.
        WebAppContext wac = new WebAppContext();
        ServletHolder defaultServlet = new ServletHolder();
        defaultServlet.setClassName(""org.eclipse.jetty.servlet.DefaultServlet"");
        defaultServlet.setName(""default"");
        wac.getServletHandler().addServlet(defaultServlet);

        ServletMapping m = new ServletMapping();
        m.setPathSpec(""/"");
        m.setServletName(""default"");
        m.setFromDefaultDescriptor(true);  //this mapping will be from a default descriptor
        wac.getServletHandler().addServletMapping(m);

        ServletMapping m2 = new ServletMapping();
        m2.setPathSpec(""/other"");
        m2.setServletName(""default"");
        m2.setFromDefaultDescriptor(true);  //this mapping will be from a default descriptor
        wac.getServletHandler().addServletMapping(m2);

        WebServletAnnotation annotation = new WebServletAnnotation(wac, ""org.eclipse.jetty.annotations.ServletD"", null);
        annotation.apply();

        //test that only the mapping for ""/"" was removed from the mappings to the default servlet
        ServletMapping[] resultMappings = wac.getServletHandler().getServletMappings();
        assertNotNull(resultMappings);
        assertEquals(2, resultMappings.length);
        for (ServletMapping r : resultMappings)
        {
            if (r.getServletName().equals(""default""))
            {
                assertEquals(1, r.getPathSpecs().length);
                assertEquals(""/other"", r.getPathSpecs()[0]);
            }
            else if (r.getServletName().equals(""DServlet""))
            {
                assertEquals(2, r.getPathSpecs().length);
                for (String p : r.getPathSpecs())
                {
                    if (!p.equals(""/"") && !p.equals(""/bah/*""))
                        fail(""Unexpected path"");
                }
            }
            else
                fail(""Unexpected servlet mapping: "" + r);
        }
    }
",non-flaky,5
170543,eclipse_jetty.project,TestServletAnnotations.testWebServletAnnotationNotOverride,"    @Test
    public void testWebServletAnnotationNotOverride() throws Exception
    {
        //if the existing servlet mapping TO A DIFFERENT SERVLET IS NOT from a default descriptor we
        //DO NOT allow the annotation to replace the mapping
        WebAppContext wac = new WebAppContext();
        ServletHolder servlet = new ServletHolder();
        servlet.setClassName(""org.eclipse.jetty.servlet.FooServlet"");
        servlet.setName(""foo"");
        wac.getServletHandler().addServlet(servlet);
        ServletMapping m = new ServletMapping();
        m.setPathSpec(""/"");
        m.setServletName(""foo"");
        wac.getServletHandler().addServletMapping(m);

        WebServletAnnotation annotation = new WebServletAnnotation(wac, ""org.eclipse.jetty.annotations.ServletD"", null);
        annotation.apply();

        ServletMapping[] resultMappings = wac.getServletHandler().getServletMappings();
        assertEquals(2, resultMappings.length);
        for (ServletMapping r : resultMappings)
        {
            if (r.getServletName().equals(""DServlet""))
            {
                assertEquals(2, r.getPathSpecs().length);
            }
            else if (r.getServletName().equals(""foo""))
            {
                assertEquals(1, r.getPathSpecs().length);
            }
            else
                fail(""Unexpected servlet name: "" + r);
        }
    }
",non-flaky,5
170544,eclipse_jetty.project,TestServletAnnotations.testWebServletAnnotationIgnore,"    @Test
    public void testWebServletAnnotationIgnore() throws Exception
    {
        //an existing servlet OF THE SAME NAME has even 1 non-default mapping we can't use
        //any of the url mappings in the annotation
        WebAppContext wac = new WebAppContext();
        ServletHolder servlet = new ServletHolder();
        servlet.setClassName(""org.eclipse.jetty.servlet.OtherDServlet"");
        servlet.setName(""DServlet"");
        wac.getServletHandler().addServlet(servlet);

        ServletMapping m = new ServletMapping();
        m.setPathSpec(""/default"");
        m.setFromDefaultDescriptor(true);
        m.setServletName(""DServlet"");
        wac.getServletHandler().addServletMapping(m);

        ServletMapping m2 = new ServletMapping();
        m2.setPathSpec(""/other"");
        m2.setServletName(""DServlet"");
        wac.getServletHandler().addServletMapping(m2);

        WebServletAnnotation annotation = new WebServletAnnotation(wac, ""org.eclipse.jetty.annotations.ServletD"", null);
        annotation.apply();

        ServletMapping[] resultMappings = wac.getServletHandler().getServletMappings();
        assertEquals(2, resultMappings.length);

        for (ServletMapping r : resultMappings)
        {
            assertEquals(1, r.getPathSpecs().length);
            if (!r.getPathSpecs()[0].equals(""/default"") && !r.getPathSpecs()[0].equals(""/other""))
                fail(""Unexpected path in mapping: "" + r);
        }
    }
",non-flaky,5
170545,eclipse_jetty.project,TestServletAnnotations.testWebServletAnnotationNoMappings,"    @Test
    public void testWebServletAnnotationNoMappings() throws Exception
    {
        //an existing servlet OF THE SAME NAME has no mappings, therefore all mappings in the annotation
        //should be accepted
        WebAppContext wac = new WebAppContext();
        ServletHolder servlet = new ServletHolder();
        servlet.setName(""foo"");
        wac.getServletHandler().addServlet(servlet);

        WebServletAnnotation annotation = new WebServletAnnotation(wac, ""org.eclipse.jetty.annotations.ServletD"", null);
        annotation.apply();

        ServletMapping[] resultMappings = wac.getServletHandler().getServletMappings();
        assertEquals(1, resultMappings.length);
        assertEquals(2, resultMappings[0].getPathSpecs().length);
        for (String s : resultMappings[0].getPathSpecs())
        {
            assertThat(s, anyOf(is(""/""), is(""/bah/*"")));
        }
    }
",non-flaky,5
170546,eclipse_jetty.project,TestServletAnnotations.testDeclareRoles,"    @Test
    public void testDeclareRoles()
        throws Exception
",non-flaky,5
170547,eclipse_jetty.project,TestResourceAnnotations.init,"    @BeforeEach
    public void init() throws Exception
    {
        server = new Server();
        wac = new WebAppContext();
        wac.setServer(server);
        injections = new InjectionCollection();
        wac.setAttribute(InjectionCollection.INJECTION_COLLECTION, injections);
        InitialContext ic = new InitialContext();
        comp = (Context)ic.lookup(""java:comp"");
        env = comp.createSubcontext(""env"");
    }
",non-flaky,5
170548,eclipse_jetty.project,TestResourceAnnotations.destroy,"    @AfterEach
    public void destroy() throws Exception
    {
        comp.destroySubcontext(""env"");
    }
",non-flaky,5
170549,eclipse_jetty.project,TestResourceAnnotations.testResourceAnnotations,"    @Test
    public void testResourceAnnotations()
        throws Exception
",non-flaky,5
170550,eclipse_jetty.project,TestResourceAnnotations.testResourcesAnnotation,"    @Test
    public void testResourcesAnnotation()
        throws Exception
",non-flaky,5
170551,eclipse_jetty.project,TestRunAsAnnotation.testRunAsAnnotation,"    @Test
    public void testRunAsAnnotation() throws Exception
    {
        WebAppContext wac = new WebAppContext();
        
        //pre-add a servlet but not by descriptor
        ServletHolder holder = new ServletHolder();
        holder.setName(""foo1"");
        holder.setHeldClass(ServletC.class);
        holder.setInitOrder(1); //load on startup
        wac.getServletHandler().addServletWithMapping(holder, ""/foo/*"");
        
        //add another servlet of the same class, but as if by descriptor
        ServletHolder holder2 = new ServletHolder();
        holder2.setName(""foo2"");
        holder2.setHeldClass(ServletC.class);
        holder2.setInitOrder(1);
        wac.getServletHandler().addServletWithMapping(holder2, ""/foo2/*"");
        Resource fakeXml = Resource.newResource(new File(MavenTestingUtils.getTargetTestingDir(""run-as""), ""fake.xml""));
        wac.getMetaData().setOrigin(holder2.getName() + "".servlet.run-as"", new WebDescriptor(fakeXml));
        
        AnnotationIntrospector parser = new AnnotationIntrospector(wac);
        RunAsAnnotationHandler handler = new RunAsAnnotationHandler(wac);
        parser.registerHandler(handler);
        parser.introspect(new ServletC(), null);
        
        assertEquals(""admin"", holder.getRunAsRole());
        assertEquals(null, holder2.getRunAsRole());
    }
",non-flaky,5
175737,GoogleCloudPlatform_google-cloud-eclipse,MultipleConnectionsTest.testDefaultSettings,"	@Test
	public void testDefaultSettings() throws CoreException {
		connector = new SocketListenMultiConnector();
		Map<String, Connector.Argument> defaults = connector.getDefaultArguments();
		assertTrue(defaults.containsKey(""connectionLimit""));
		assertEquals(1, ((Connector.IntegerArgument) defaults.get(""connectionLimit"")).intValue());
	}
",non-flaky,5
175738,GoogleCloudPlatform_google-cloud-eclipse,MultipleConnectionsTest.testDefaultBehaviour,"	@Test
	public void testDefaultBehaviour() throws CoreException, InterruptedException {
		connector = new SocketListenMultiConnector();
		Map<String, String> arguments = new HashMap<>();
		arguments.put(""port"", Integer.toString(port));
		connector.connect(arguments, new NullProgressMonitor(), launch);
		Thread.sleep(200);

		assertTrue(""first connect should succeed"", connect());
		assertFalse(""second connect should fail"", connect());
	}
",non-flaky,5
175739,GoogleCloudPlatform_google-cloud-eclipse,MultipleConnectionsTest.testSingleConnectionBehaviour,"	@Test
	public void testSingleConnectionBehaviour() throws CoreException, InterruptedException {
		connector = new SocketListenMultiConnector();
		Map<String, String> arguments = new HashMap<>();
		arguments.put(""port"", Integer.toString(port));
		arguments.put(""connectionLimit"", ""1"");
		connector.connect(arguments, new NullProgressMonitor(), launch);
		Thread.sleep(200);

		assertTrue(""first connect should succeed"", connect());
		assertFalse(""second connect should fail"", connect());
	}
",non-flaky,5
175740,GoogleCloudPlatform_google-cloud-eclipse,MultipleConnectionsTest.testTwoConnectionsBehaviour,"	@Test
	public void testTwoConnectionsBehaviour() throws CoreException, InterruptedException {
		connector = new SocketListenMultiConnector();
		Map<String, String> arguments = new HashMap<>();
		arguments.put(""port"", Integer.toString(port));
		arguments.put(""connectionLimit"", ""2"");
		connector.connect(arguments, new NullProgressMonitor(), launch);
		Thread.sleep(200);

		assertTrue(""first connect should succeed"", connect());
		assertTrue(""second connect should succeed"", connect());
	}
",non-flaky,5
175741,GoogleCloudPlatform_google-cloud-eclipse,MultipleConnectionsTest.testUnlimitedConnectionsBehaviour,"	@Test
	public void testUnlimitedConnectionsBehaviour() throws CoreException, InterruptedException {
		connector = new SocketListenMultiConnector();
		Map<String, String> arguments = new HashMap<>();
		arguments.put(""port"", Integer.toString(port));
		arguments.put(""connectionLimit"", ""0"");
		connector.connect(arguments, new NullProgressMonitor(), launch);
		Thread.sleep(200);

		for (int i = 0; i < 10; i++) {
			assertTrue(""connection "" + i + "" should succeed"", connect());
		}
	}
",non-flaky,5
175742,GoogleCloudPlatform_google-cloud-eclipse,MessagesTest.testCloudSdkNotConfigured,"  @Test
  public void testCloudSdkNotConfigured() {
    Assert.assertEquals(""Deploy failed."", Messages.getString(""deploy.failed.error.message""));
  }
",non-flaky,5
175743,GoogleCloudPlatform_google-cloud-eclipse,MessagesTest.testSpecifyVersionTooltip,"  @Test
  public void testSpecifyVersionTooltip() {
    Assert.assertEquals(
        ""If checked, stops the previously running version when ""
        + ""deploying a new version that receives all traffic."",
        Messages.getString(""tooltip.stop.previous.version""));
  }
",non-flaky,5
175744,GoogleCloudPlatform_google-cloud-eclipse,AppEngineDeployPreferencesPanelTest.testAutoSelectSingleAccount,"  @Test
  public void testAutoSelectSingleAccount() {
    when(loginService.getAccounts()).thenReturn(oneAccountSet);
    deployPanel = createPanel(true /* requireValues */);
    assertThat(deployPanel.getSelectedCredential(), is(credential));

    // verify not in error
    IStatus status = getAccountSelectorValidationStatus();
    assertTrue(""account selector is in error: "" + status.getMessage(), status.isOK());

    assertThat(""auto-selected value should be propagated back to model"",
        deployPanel.model.getAccountEmail(), is(account1.getEmail()));
  }
",non-flaky,5
175745,GoogleCloudPlatform_google-cloud-eclipse,AppEngineDeployPreferencesPanelTest.testAutoSelectSingleAccount_loadGcpProjects,"  @Test
  public void testAutoSelectSingleAccount_loadGcpProjects()
      throws ProjectRepositoryException, InterruptedException {
    when(loginService.getAccounts()).thenReturn(oneAccountSet);
    initializeProjectRepository();
    deployPanel = createPanel(true /* requireValues */);
    assertNotNull(deployPanel.latestGcpProjectQueryJob);
    deployPanel.latestGcpProjectQueryJob.join();

    Table projectTable = getProjectSelector().getViewer().getTable();
    assertThat(projectTable.getItemCount(), is(2));
  }
",non-flaky,5
175746,GoogleCloudPlatform_google-cloud-eclipse,AppEngineDeployPreferencesPanelTest.testValidationMessageWhenNotSignedIn,"  @Test
  public void testValidationMessageWhenNotSignedIn() {
    deployPanel = createPanel(true /* requireValues */);
    IStatus status = getAccountSelectorValidationStatus();
    assertThat(status.getMessage(), is(""Sign in to Google.""));
  }
",non-flaky,5
175747,GoogleCloudPlatform_google-cloud-eclipse,AppEngineDeployPreferencesPanelTest.testValidationMessageWhenSignedIn,"  @Test
  public void testValidationMessageWhenSignedIn() {
    // Return two accounts because the account selector will auto-select if there exists only one.
    when(loginService.getAccounts()).thenReturn(twoAccountSet);

    deployPanel = createPanel(true /* requireValues */);
    IStatus status = getAccountSelectorValidationStatus();
    assertThat(status.getMessage(), is(""Select an account.""));
  }
",non-flaky,5
175748,GoogleCloudPlatform_google-cloud-eclipse,AppEngineDeployPreferencesPanelTest.testUncheckStopPreviousVersionButtonWhenDisabled,"  @Test
  public void testUncheckStopPreviousVersionButtonWhenDisabled() {
    deployPanel = createPanel(true /* requireValues */);

    Button promoteButton = getButtonWithText(""Promote the deployed version to receive all traffic"");
    Button stopButton = getButtonWithText(""Stop previous version"");
    SWTBotCheckBox promote = new SWTBotCheckBox(promoteButton);
    SWTBotCheckBox stop = new SWTBotCheckBox(stopButton);

    // Initially, everything is checked and enabled.
    assertTrue(promoteButton.getSelection());
    assertTrue(stopButton.getSelection());
    assertTrue(stopButton.getEnabled());

    promote.click();
    assertFalse(promoteButton.getSelection());
    assertFalse(stopButton.getSelection());
    assertFalse(stopButton.getEnabled());

    promote.click();
    assertTrue(promoteButton.getSelection());
    assertTrue(stopButton.getSelection());
    assertTrue(stopButton.getEnabled());

    stop.click();
    assertTrue(promoteButton.getSelection());
    assertFalse(stopButton.getSelection());
    assertTrue(stopButton.getEnabled());

    promote.click();
    assertFalse(promoteButton.getSelection());
    assertFalse(stopButton.getSelection());
    assertFalse(stopButton.getEnabled());

    promote.click();
    assertTrue(promoteButton.getSelection());
    assertFalse(stopButton.getSelection());
    assertTrue(stopButton.getEnabled());
  }
",non-flaky,5
175749,GoogleCloudPlatform_google-cloud-eclipse,AppEngineDeployPreferencesPanelTest.testProjectSavedInPreferencesSelected,"  @Test
  public void testProjectSavedInPreferencesSelected()
      throws ProjectRepositoryException, InterruptedException, BackingStoreException {
    IEclipsePreferences node =
        new ProjectScope(project).getNode(DeployPreferences.PREFERENCE_STORE_QUALIFIER);
    try {
      node.put(""project.id"", ""projectId1"");
      node.put(""account.email"", EMAIL_1);
      initializeProjectRepository();
      when(loginService.getAccounts()).thenReturn(twoAccountSet);
      deployPanel = createPanel(true /* requireValues */);
      deployPanel.latestGcpProjectQueryJob.join();

      ProjectSelector projectSelector = getProjectSelector();
      IStructuredSelection selection = projectSelector.getViewer().getStructuredSelection();
      assertThat(selection.size(), is(1));
      assertThat(((GcpProject) selection.getFirstElement()).getId(), is(""projectId1""));
    } finally {
      node.clear();
    }
  }
",non-flaky,5
175750,GoogleCloudPlatform_google-cloud-eclipse,AppEngineDeployPreferencesPanelTest.testProjectNotSelectedIsAnErrorWhenRequireValuesIsTrue,"  @Test
  public void testProjectNotSelectedIsAnErrorWhenRequireValuesIsTrue() {
    deployPanel = createPanel(true /* requireValues */);
    assertThat(getProjectSelectionValidator().getSeverity(), is(IStatus.ERROR));
  }
",non-flaky,5
175751,GoogleCloudPlatform_google-cloud-eclipse,AppEngineDeployPreferencesPanelTest.testProjectNotSelectedIsNotAnErrorWhenRequireValuesIsFalse,"  @Test
  public void testProjectNotSelectedIsNotAnErrorWhenRequireValuesIsFalse() {
    deployPanel = createPanel(false /* requireValues */);
    assertThat(getProjectSelectionValidator().getSeverity(), is(IStatus.INFO));
  }
",non-flaky,5
175752,GoogleCloudPlatform_google-cloud-eclipse,AppEngineDeployPreferencesPanelTest.testProjectsExistThenNoProjectNotFoundError,"  @Test
  public void testProjectsExistThenNoProjectNotFoundError()
      throws ProjectRepositoryException, InterruptedException {
    when(loginService.getAccounts()).thenReturn(oneAccountSet);
    initializeProjectRepository();
    deployPanel = createPanel(false /* requireValues */);
    selectAccount(account1);
    deployPanel.latestGcpProjectQueryJob.join();
    assertThat(getProjectSelectionValidator().getSeverity(), is(IStatus.OK));
  }
",non-flaky,5
175753,GoogleCloudPlatform_google-cloud-eclipse,AppEngineDeployPreferencesPanelTest.testRefreshProjectsForSelectedCredential,"  @Test
  public void testRefreshProjectsForSelectedCredential()
      throws ProjectRepositoryException, InterruptedException {
    when(loginService.getAccounts()).thenReturn(twoAccountSet);
    initializeProjectRepository();

    deployPanel = createPanel(false /* requireValues */);
    Table projectTable = getProjectSelector().getViewer().getTable();
    assertNull(deployPanel.latestGcpProjectQueryJob);
    assertThat(projectTable.getItemCount(), is(0));

    selectAccount(account1);
    assertNotNull(deployPanel.latestGcpProjectQueryJob);
    deployPanel.latestGcpProjectQueryJob.join();
    assertThat(projectTable.getItemCount(), is(2));
    assertThat(((GcpProject) projectTable.getItem(0).getData()).getId(), is(""projectId1""));
    assertThat(((GcpProject) projectTable.getItem(1).getData()).getId(), is(""projectId2""));
  }
",non-flaky,5
175754,GoogleCloudPlatform_google-cloud-eclipse,AppEngineDeployPreferencesPanelTest.testRefreshProjectsForSelectedCredential_switchAccounts,"  @Test
  public void testRefreshProjectsForSelectedCredential_switchAccounts()
      throws ProjectRepositoryException, InterruptedException {
    when(loginService.getAccounts()).thenReturn(twoAccountSet);
    initializeProjectRepository();

    deployPanel = createPanel(false /* requireValues */);
    Table projectTable = getProjectSelector().getViewer().getTable();
    assertNull(deployPanel.latestGcpProjectQueryJob);
    assertThat(projectTable.getItemCount(), is(0));

    selectAccount(account1);
    Job jobForAccount1 = deployPanel.latestGcpProjectQueryJob;
    jobForAccount1.join();
    assertThat(projectTable.getItemCount(), is(2));

    selectAccount(account2);
    assertNotEquals(jobForAccount1, deployPanel.latestGcpProjectQueryJob);
    deployPanel.latestGcpProjectQueryJob.join();
    assertThat(projectTable.getItemCount(), is(1));
    assertThat(((GcpProject) projectTable.getItem(0).getData()).getId(), is(""projectId2""));
  }
",non-flaky,5
175755,GoogleCloudPlatform_google-cloud-eclipse,AppEngineDeployPreferencesPanelTest.testNoProjectSelectedWhenSwitchingAccounts,"  @Test
  public void testNoProjectSelectedWhenSwitchingAccounts()
      throws ProjectRepositoryException, InterruptedException {
    when(loginService.getAccounts()).thenReturn(twoAccountSet);
    initializeProjectRepository();

    deployPanel = createPanel(false /* requireValues */);
    selectAccount(account1);
    deployPanel.latestGcpProjectQueryJob.join();

    Table projectTable = getProjectSelector().getViewer().getTable();
    assertThat(projectTable.getItemCount(), is(2));
    projectTable.setSelection(0);
    assertThat(projectTable.getSelectionCount(), is(1));

    selectAccount(account2);
    deployPanel.latestGcpProjectQueryJob.join();

    assertThat(projectTable.getItemCount(), is(1));
    assertThat(projectTable.getSelectionCount(), is(0));
  }
",non-flaky,5
175756,GoogleCloudPlatform_google-cloud-eclipse,PluginXmlTest.testLimitedVisibility,"  @Test
  public void testLimitedVisibility() {
    NodeList pages = getDocument().getElementsByTagName(""page"");
    Assert.assertEquals(2, pages.getLength());
    NodeList enabledWhen = getDocument().getElementsByTagName(""enabledWhen"");
    Assert.assertEquals(4, enabledWhen.getLength());
    NodeList tests = getDocument().getElementsByTagName(""test"");
    Assert.assertEquals(4, tests.getLength());
    NodeList adapts = getDocument().getElementsByTagName(""adapt"");
    Assert.assertEquals(4, adapts.getLength());

    for (int i = 0; i < enabledWhen.getLength(); i++) {
      Element element = (Element) enabledWhen.item(i);
      Node parent = element.getParentNode();
      assertThat(parent.getNodeName(), either(is(""page"")).or(is(""handler"")));
    }

    Element standardAdapt = (Element) adapts.item(0);
    verifyAdapt(standardAdapt, AppEngineStandardFacet.ID);
    Element flexAdapt = (Element) adapts.item(1);
    verifyAdapt(flexAdapt, AppEngineFlexFacet.ID);
  }
",non-flaky,5
175757,GoogleCloudPlatform_google-cloud-eclipse,GcpProjectQueryJobTest.testNullCredential,"  @Test(expected = NullPointerException.class)
  public void testNullCredential() {
    new GcpProjectQueryJob(null /* credential */, projectRepository, projectSelector,
        dataBindingContext, isLatestQueryJob);
  }
",non-flaky,5
175758,GoogleCloudPlatform_google-cloud-eclipse,GcpProjectQueryJobTest.testRun_setsProjects,"  @Test
  public void testRun_setsProjects() throws InterruptedException, ProjectRepositoryException {
    queryJob.schedule();
    queryJob.join();

    verify(projectRepository).getProjects(credential);
    verify(isLatestQueryJob).apply(queryJob);
    verify(projectSelector).isDisposed();
    verify(projectSelector).setProjects(projects);
  }
",non-flaky,5
175759,GoogleCloudPlatform_google-cloud-eclipse,GcpProjectQueryJobTest.testRun_abandonIfDisposed,"  @Test
  public void testRun_abandonIfDisposed() throws InterruptedException, ProjectRepositoryException {
    when(projectSelector.isDisposed()).thenReturn(true);

    queryJob.schedule();
    queryJob.join();

    verify(projectRepository).getProjects(credential);
    verify(projectSelector, never()).setProjects(projects);
  }
",non-flaky,5
175760,GoogleCloudPlatform_google-cloud-eclipse,GcpProjectQueryJobTest.testRun_abandonIfNotLatestJob,"  @Test
  public void testRun_abandonIfNotLatestJob()
      throws InterruptedException, ProjectRepositoryException {
    when(isLatestQueryJob.apply(queryJob)).thenReturn(false);

    queryJob.schedule();
    queryJob.join();

    verify(projectRepository).getProjects(credential);
    verify(projectSelector, never()).setProjects(projects);
  }
",non-flaky,5
175761,GoogleCloudPlatform_google-cloud-eclipse,GcpProjectQueryJobTest.testRun_abandonStaleJob,"  @Test
  public void testRun_abandonStaleJob() throws InterruptedException, ProjectRepositoryException {
    // Prepare another concurrent query job.
    Credential staleCredential = mock(Credential.class);

    List<GcpProject> anotherProjectList = mock(List.class);
    ProjectRepository projectRepository2 = mock(ProjectRepository.class);
    when(projectRepository2.getProjects(staleCredential)).thenReturn(anotherProjectList);

    Predicate<Job> notLatest = mock(Predicate.class);
    Job staleJob = new GcpProjectQueryJob(staleCredential, projectRepository2,
        projectSelector, dataBindingContext, notLatest);

    // This second job is stale, i.e., it was fired, but user has selected another credential.
    when(notLatest.apply(staleJob)).thenReturn(false);

    queryJob.schedule();
    queryJob.join();
    // Make the stale job complete even after ""queryJob"" finishes.
    staleJob.schedule();
    staleJob.join();

    verify(projectRepository).getProjects(credential);
    verify(projectRepository2).getProjects(staleCredential);

    verify(projectSelector).setProjects(projects);
    verify(projectSelector, never()).setProjects(anotherProjectList);
  }
",non-flaky,5
175762,GoogleCloudPlatform_google-cloud-eclipse,BlankDeployPreferencesPanelTest.testGetHelpContextId,"  @Test
  public void testGetHelpContextId() {
    assertNull(new BlankDeployPreferencesPanel(shellTestResource.getShell()).getHelpContextId());
  }
",non-flaky,5
175763,GoogleCloudPlatform_google-cloud-eclipse,DeployPropertyPageTest.testCorrectPanelIsShownForFacetedProject,"  @Test
  public void testCorrectPanelIsShownForFacetedProject() {
    DeployPropertyPage page = new DeployPropertyPage(loginService, googleApiFactory);
    Shell parent = shellTestResource.getShell();
    page.setElement(getProject());
    page.createControl(parent);
    page.setVisible(true);
    Composite preferencePageComposite = (Composite) parent.getChildren()[0];
    for (Control control : preferencePageComposite.getChildren()) {
      if (control instanceof Composite) {
        Composite maybeDeployPageComposite = (Composite) control;
        Layout layout = maybeDeployPageComposite.getLayout();
        if (layout instanceof StackLayout) {
          StackLayout stackLayout = (StackLayout) layout;
          assertThat(stackLayout.topControl, instanceOf(getPanelClass()));
          return;
        }
      }
    }
    fail(""Did not find the deploy preferences panel"");
  }
",non-flaky,5
175764,GoogleCloudPlatform_google-cloud-eclipse,StandardDeployPreferencesPanelTest.testGetHelpContextId,"  @Test
  public void testGetHelpContextId() {
    IProject project = mock(IProject.class);
    when(project.getName()).thenReturn("""");
    StandardDeployPreferencesPanel panel = new StandardDeployPreferencesPanel(
        shellResource.getShell(), project, mock(IGoogleLoginService.class), mock(Runnable.class),
        false, mock(ProjectRepository.class));

    assertEquals(
        ""com.google.cloud.tools.eclipse.appengine.deploy.ui.DeployAppEngineStandardProjectContext"",
        panel.getHelpContextId());
  }
",non-flaky,5
175765,GoogleCloudPlatform_google-cloud-eclipse,FlexDeployPreferencesPanelTest.testGetHelpContextId,"  @Test
  public void testGetHelpContextId() {
    FlexDeployPreferencesPanel panel = createPanel(true /* requireValues */);

    assertEquals(
        ""com.google.cloud.tools.eclipse.appengine.deploy.ui.DeployAppEngineFlexProjectContext"",
        panel.getHelpContextId());
  }
",non-flaky,5
175766,GoogleCloudPlatform_google-cloud-eclipse,FlexDeployPreferencesPanelTest.testDefaultAppYamlPathSet,"  @Test
  public void testDefaultAppYamlPathSet() {
    FlexDeployPreferencesPanel panel = createPanel(true /* requireValues */);

    Text appYamlField = findAppYamlField(panel);
    assertEquals(""src/main/appengine/app.yaml"", appYamlField.getText());
    assertTrue(getAppYamlPathValidationStatus(panel).isOK());
  }
",non-flaky,5
175767,GoogleCloudPlatform_google-cloud-eclipse,FlexDeployPreferencesPanelTest.testAppYamlPathValidation_nonExistingAppYaml,"  @Test
  public void testAppYamlPathValidation_nonExistingAppYaml() {
    FlexDeployPreferencesPanel panel = createPanel(true /* requireValues */);

    Text appYamlField = findAppYamlField(panel);
    appYamlField.setText(""non/existing/app.yaml"");
    assertFalse(getAppYamlPathValidationStatus(panel).isOK());
  }
",non-flaky,5
175768,GoogleCloudPlatform_google-cloud-eclipse,FlexDeployPreferencesPanelTest.testAppYamlPathValidation_noValidationIfRequireValuesIsFalse,"  @Test
  public void testAppYamlPathValidation_noValidationIfRequireValuesIsFalse() {
    FlexDeployPreferencesPanel panel = createPanel(false /* requireValues */);

    Text appYamlField = findAppYamlField(panel);
    appYamlField.setText(""non/existing/app.yaml"");
    assertNull(getAppYamlPathValidationStatus(panel));
  }
",non-flaky,5
175769,GoogleCloudPlatform_google-cloud-eclipse,FlexDeployPreferencesPanelTest.testAppYamlPathValidation_absolutePathWorks,"  @Test
  public void testAppYamlPathValidation_absolutePathWorks() {
    FlexDeployPreferencesPanel panel = createPanel(true /* requireValues */);
    Text appYamlField = findAppYamlField(panel);

    IPath absolutePath = project.getLocation().append(""src/main/appengine/app.yaml"");
    assertTrue(absolutePath.isAbsolute());

    appYamlField.setText(absolutePath.toString());
    assertTrue(getAppYamlPathValidationStatus(panel).isOK());
  }
",non-flaky,5
175770,GoogleCloudPlatform_google-cloud-eclipse,FlexDeployPreferencesDialogTest.testFlexPricingLabel,"  @Test
  public void testFlexPricingLabel() {
    dialog.setBlockOnOpen(false);
    dialog.open();
    Composite dialogArea = (Composite) dialog.createDialogArea(shellResource.getShell());

    assertNotNull(findGcpPricingLink(dialogArea));
  }
",non-flaky,5
175771,GoogleCloudPlatform_google-cloud-eclipse,AppYamlValidatorTest.testContructor_nonAbsoluteBasePath,"  @Test
  public void testContructor_nonAbsoluteBasePath() {
    try {
      when(appYamlPath.getValue()).thenReturn(""app.yaml"");
      new AppYamlValidator(new Path(""non/absolute/base/path""), appYamlPath);
      fail();
    } catch (IllegalArgumentException ex) {
      assertEquals(""basePath is not absolute."", ex.getMessage());
    }
  }
",non-flaky,5
175772,GoogleCloudPlatform_google-cloud-eclipse,AppYamlValidatorTest.testValidate_relativePathAndNoAppYaml,"  @Test
  public void testValidate_relativePathAndNoAppYaml() {
    when(appYamlPath.getValue()).thenReturn(""relative/path/app.yaml"");

    IStatus result = pathValidator.validate();
    assertEquals(IStatus.ERROR, result.getSeverity());
    assertEquals(""app.yaml does not exist."", result.getMessage());
  }
",non-flaky,5
175773,GoogleCloudPlatform_google-cloud-eclipse,AppYamlValidatorTest.testValidate_absolutePathAndNoAppYaml,"  @Test
  public void testValidate_absolutePathAndNoAppYaml() {
    String absolutePath = basePath + ""/sub/directory/app.yaml"";
    when(appYamlPath.getValue()).thenReturn(absolutePath);

    IStatus result = pathValidator.validate();
    assertEquals(IStatus.ERROR, result.getSeverity());
    assertEquals(""app.yaml does not exist."", result.getMessage());
  }
",non-flaky,5
175774,GoogleCloudPlatform_google-cloud-eclipse,AppYamlValidatorTest.testValidate_relativePathAndInvalidFileName,"  @Test
  public void testValidate_relativePathAndInvalidFileName() {
    when(appYamlPath.getValue()).thenReturn(""relative/path/my-app.yaml"");

    IStatus result = pathValidator.validate();
    assertEquals(IStatus.ERROR, result.getSeverity());
    assertEquals(""File name is not app.yaml: ""
        + new Path(basePath + ""/relative/path/my-app.yaml"").toOSString(),
        result.getMessage());
  }
",non-flaky,5
175775,GoogleCloudPlatform_google-cloud-eclipse,AppYamlValidatorTest.testValidate_absolutePathInvalidFileName,"  @Test
  public void testValidate_absolutePathInvalidFileName() {
    String absolutePath = basePath + ""/sub/directory/my-app.yaml"";
    when(appYamlPath.getValue()).thenReturn(absolutePath);

    IStatus result = pathValidator.validate();
    assertEquals(IStatus.ERROR, result.getSeverity());
    assertEquals(""File name is not app.yaml: ""
        + new Path(basePath + ""/sub/directory/my-app.yaml"").toOSString(),
        result.getMessage());
  }
",non-flaky,5
175776,GoogleCloudPlatform_google-cloud-eclipse,AppYamlValidatorTest.testValidate_relativePathNotFile,"  @Test
  public void testValidate_relativePathNotFile() {
    createAppYamlAsDirectory(basePath);
    when(appYamlPath.getValue()).thenReturn(""app.yaml"");

    IStatus result = pathValidator.validate();
    assertEquals(IStatus.ERROR, result.getSeverity());
    assertEquals(""Not a file: "" + new Path(basePath + ""/app.yaml"").toOSString(),
        result.getMessage());
  }
",non-flaky,5
175777,GoogleCloudPlatform_google-cloud-eclipse,AppYamlValidatorTest.testValidate_absolutePathNotFile,"  @Test
  public void testValidate_absolutePathNotFile() {
    createAppYamlAsDirectory(basePath);

    String absolutePath = basePath + ""/app.yaml"";
    when(appYamlPath.getValue()).thenReturn(absolutePath);

    IStatus result = pathValidator.validate();
    assertEquals(IStatus.ERROR, result.getSeverity());
    assertEquals(""Not a file: "" + new Path(basePath + ""/app.yaml"").toOSString(),
        result.getMessage());
  }
",non-flaky,5
175778,GoogleCloudPlatform_google-cloud-eclipse,AppYamlValidatorTest.testValidate_relativePathWithAppYaml,"  @Test
  public void testValidate_relativePathWithAppYaml() throws IOException {
    createAppYamlFile(basePath + ""/some/directory"", ""runtime: java"");

    when(appYamlPath.getValue()).thenReturn(""some/directory/app.yaml"");
    IStatus result = pathValidator.validate();
    assertTrue(result.isOK());
  }
",non-flaky,5
175779,GoogleCloudPlatform_google-cloud-eclipse,AppYamlValidatorTest.testValidate_absolutePathWithAppYaml,"  @Test
  public void testValidate_absolutePathWithAppYaml() throws IOException {
    File absolutePath = tempFolder.newFolder(""another"", ""folder"");
    File appYaml = createAppYamlFile(absolutePath.toString(), ""runtime: java"");

    when(appYamlPath.getValue()).thenReturn(appYaml.toString());
    IStatus result = pathValidator.validate();
    assertTrue(result.isOK());
  }
",non-flaky,5
175780,GoogleCloudPlatform_google-cloud-eclipse,AppYamlValidatorTest.testValidateRuntime_javaRuntime,"  @Test
  public void testValidateRuntime_javaRuntime() throws IOException {
    File appYaml = createAppYamlFile(tempFolder.getRoot().toString(), ""runtime: java"");
    IStatus result = AppYamlValidator.validateRuntime(appYaml);
    assertTrue(result.isOK());
  }
",non-flaky,5
175781,GoogleCloudPlatform_google-cloud-eclipse,AppYamlValidatorTest.testValidateRuntime_malformedAppYaml,"  @Test
  public void testValidateRuntime_malformedAppYaml() throws IOException {
    File appYaml = createAppYamlFile(tempFolder.getRoot().toString(), "": m a l f o r m e d !"");
    IStatus result = AppYamlValidator.validateRuntime(appYaml);
    assertEquals(IStatus.ERROR, result.getSeverity());
    assertEquals(""Malformed app.yaml."", result.getMessage());
  }
",non-flaky,5
175782,GoogleCloudPlatform_google-cloud-eclipse,AppYamlValidatorTest.testValidateRuntime_noRuntime,"  @Test
  public void testValidateRuntime_noRuntime() throws IOException {
    File appYaml = createAppYamlFile(tempFolder.getRoot().toString(), ""env: flex"");
    IStatus result = AppYamlValidator.validateRuntime(appYaml);
    assertEquals(IStatus.ERROR, result.getSeverity());
    assertEquals(""\""runtime: null\"" in app.yaml is not \""java\""."", result.getMessage());
  }
",non-flaky,5
175783,GoogleCloudPlatform_google-cloud-eclipse,AppYamlValidatorTest.testValidateRuntime_nullRuntime,"  @Test
  public void testValidateRuntime_nullRuntime() throws IOException {
    File appYaml = createAppYamlFile(tempFolder.getRoot().toString(), ""runtime:"");
    IStatus result = AppYamlValidator.validateRuntime(appYaml);
    assertEquals(IStatus.ERROR, result.getSeverity());
    assertEquals(""\""runtime: null\"" in app.yaml is not \""java\""."", result.getMessage());
  }
",non-flaky,5
175784,GoogleCloudPlatform_google-cloud-eclipse,AppYamlValidatorTest.testValidateRuntime_notJavaRuntime,"  @Test
  public void testValidateRuntime_notJavaRuntime() throws IOException {
    File appYaml = createAppYamlFile(tempFolder.getRoot().toString(), ""runtime: python"");
    IStatus result = AppYamlValidator.validateRuntime(appYaml);
    assertEquals(IStatus.ERROR, result.getSeverity());
    assertEquals(""\""runtime: python\"" in app.yaml is not \""java\""."", result.getMessage());
  }
",non-flaky,5
175785,GoogleCloudPlatform_google-cloud-eclipse,AppYamlValidatorTest.testValidateRuntime_customRuntime,"  @Test
  public void testValidateRuntime_customRuntime() throws IOException {
    File appYaml = createAppYamlFile(tempFolder.getRoot().toString(), ""runtime: custom"");
    IStatus result = AppYamlValidator.validateRuntime(appYaml);
    assertEquals(IStatus.ERROR, result.getSeverity());
    assertEquals(""\""runtime: custom\"" is not yet supported by Cloud Tools for Eclipse."",
        result.getMessage());
  }
",non-flaky,5
175786,GoogleCloudPlatform_google-cloud-eclipse,AppYamlValidatorTest.testValidateRuntime_ioException,"  @Test
  public void testValidateRuntime_ioException() {
    File nonExisting = new File(""/non/existing/file"");
    IStatus result = AppYamlValidator.validateRuntime(nonExisting);
    assertEquals(IStatus.ERROR, result.getSeverity());
    assertTrue(result.getMessage().startsWith(""Cannot read app.yaml:""));
  }
",non-flaky,5
175787,GoogleCloudPlatform_google-cloud-eclipse,AppEngineApplicationQueryJobTest.testRun_projectHasNoApplication,"  @Test
  public void testRun_projectHasNoApplication()
      throws ProjectRepositoryException, InterruptedException {
    when(projectRepository.getAppEngineApplication(credential, ""projectId""))
        .thenReturn(AppEngine.NO_APPENGINE_APPLICATION);
    assertNull(project.getAppEngine());

    queryJob.schedule();
    queryJob.join();

    verify(projectRepository).getAppEngineApplication(credential, ""projectId"");
    verify(isLatestQueryJob).apply(queryJob);
    verify(projectSelector).isDisposed();
    verify(projectSelection).isEmpty();
    verify(projectSelector).setStatusLink(EXPECTED_MESSAGE_WHEN_NO_APPLICATION, EXPECTED_LINK);

    assertEquals(AppEngine.NO_APPENGINE_APPLICATION, project.getAppEngine());
  }
",non-flaky,5
175788,GoogleCloudPlatform_google-cloud-eclipse,AppEngineApplicationQueryJobTest.testRun_projectHasApplication,"  @Test
  public void testRun_projectHasApplication()
      throws ProjectRepositoryException, InterruptedException {
    AppEngine appEngine = AppEngine.withId(""unique-id"");
    when(projectRepository.getAppEngineApplication(credential, ""projectId"")).thenReturn(appEngine);

    queryJob.schedule();
    queryJob.join();

    verify(isLatestQueryJob, never()).apply(queryJob);
    verify(projectSelector, never()).isDisposed();
    verify(projectSelector, never()).setStatusLink(anyString(), anyString());

    assertTrue(appEngine == project.getAppEngine());
  }
",non-flaky,5
175789,GoogleCloudPlatform_google-cloud-eclipse,AppEngineApplicationQueryJobTest.testRun_queryError,"  @Test
  public void testRun_queryError() throws ProjectRepositoryException, InterruptedException {
    when(projectRepository.getAppEngineApplication(credential, ""projectId""))
        .thenThrow(new ProjectRepositoryException(""testException""));

    queryJob.schedule();
    queryJob.join();

    verify(isLatestQueryJob).apply(queryJob);
    verify(projectSelector).isDisposed();
    verify(projectSelector).setStatusLink(EXPECTED_MESSAGE_WHEN_EXCEPTION, null);

    assertNull(project.getAppEngine());
  }
",non-flaky,5
175790,GoogleCloudPlatform_google-cloud-eclipse,AppEngineApplicationQueryJobTest.testRun_abandonIfDisposed,"  @Test
  public void testRun_abandonIfDisposed() throws InterruptedException, ProjectRepositoryException {
    when(projectSelector.isDisposed()).thenReturn(true);
    when(projectRepository.getAppEngineApplication(credential, ""projectId""))
        .thenReturn(AppEngine.NO_APPENGINE_APPLICATION);

    queryJob.schedule();
    queryJob.join();

    verify(projectSelector).isDisposed();
    verify(projectSelector, never()).setStatusLink(anyString(), anyString());
  }
",non-flaky,5
175791,GoogleCloudPlatform_google-cloud-eclipse,AppEngineApplicationQueryJobTest.testRun_abandonIfNotLatestJob,"  @Test
  public void testRun_abandonIfNotLatestJob()
      throws InterruptedException, ProjectRepositoryException {
    when(isLatestQueryJob.apply(queryJob)).thenReturn(false);
    when(projectRepository.getAppEngineApplication(credential, ""projectId""))
        .thenReturn(AppEngine.NO_APPENGINE_APPLICATION);

    queryJob.schedule();
    queryJob.join();

    verify(isLatestQueryJob).apply(queryJob);
    verify(projectSelector, never()).setStatusLink(anyString(), anyString());
  }
",non-flaky,5
175792,GoogleCloudPlatform_google-cloud-eclipse,AppEngineApplicationQueryJobTest.testRun_abandonIfProjectSelectorHasNoSelection,"  @Test
  public void testRun_abandonIfProjectSelectorHasNoSelection()
      throws ProjectRepositoryException, InterruptedException {
    when(projectRepository.getAppEngineApplication(credential, ""projectId""))
        .thenReturn(AppEngine.NO_APPENGINE_APPLICATION);
    when(projectSelection.isEmpty()).thenReturn(true);

    queryJob.schedule();
    queryJob.join();

    verify(isLatestQueryJob).apply(queryJob);
    verify(projectSelector, never()).setStatusLink(anyString(), anyString());
  }
",non-flaky,5
175793,GoogleCloudPlatform_google-cloud-eclipse,AppEngineApplicationQueryJobTest.testRun_abandonStaleJob,"  @Test
  public void testRun_abandonStaleJob() throws InterruptedException, ProjectRepositoryException {
    when(projectRepository.getAppEngineApplication(credential, ""projectId""))
        .thenReturn(AppEngine.NO_APPENGINE_APPLICATION);

    // Prepare another concurrent query job.
    Credential staleCredential = mock(Credential.class);

    GcpProject staleProject = new GcpProject(""name"", ""staleProjectId"");
    ProjectRepository projectRepository2 = mock(ProjectRepository.class);
    when(projectRepository2.getAppEngineApplication(staleCredential, ""staleProjectId""))
        .thenThrow(new ProjectRepositoryException(""testException""));

    Predicate<Job> notLatest = mock(Predicate.class);
    Job staleJob = new AppEngineApplicationQueryJob(staleProject, staleCredential,
        projectRepository2, projectSelector, EXPECTED_LINK, notLatest);

    // This second job is stale, i.e., it was fired, but user has selected another credential.
    when(notLatest.apply(staleJob)).thenReturn(false);

    queryJob.schedule();
    queryJob.join();
    // Make the stale job complete even after ""queryJob"" finishes.
    staleJob.schedule();
    staleJob.join();

    verify(projectRepository).getAppEngineApplication(credential, ""projectId"");
    verify(projectRepository2).getAppEngineApplication(staleCredential, ""staleProjectId"");

    verify(projectSelector).setStatusLink(EXPECTED_MESSAGE_WHEN_NO_APPLICATION, EXPECTED_LINK);
    verify(projectSelector, never()).setStatusLink(EXPECTED_MESSAGE_WHEN_EXCEPTION, null);
  }
",non-flaky,5
175794,GoogleCloudPlatform_google-cloud-eclipse,RelativeFileFieldSetterTest.testConstructor_nonAbsoluteBasePath,"  @Test
  public void testConstructor_nonAbsoluteBasePath() {
    try {
      new RelativeFileFieldSetter(field, new Path(""non/absolute/base/path""), dialog);
      fail();
    } catch (IllegalArgumentException ex) {}
  }
",non-flaky,5
175795,GoogleCloudPlatform_google-cloud-eclipse,RelativeFileFieldSetterTest.testFileDialogCanceled,"  @Test
  public void testFileDialogCanceled() {
    when(field.getText()).thenReturn("""");
    when(dialog.open()).thenReturn(null /* means canceled */);

    new RelativeFileFieldSetter(field, basePath, dialog).widgetSelected(event);
    verify(field, never()).setText(anyString());
  }
",non-flaky,5
175796,GoogleCloudPlatform_google-cloud-eclipse,RelativeFileFieldSetterTest.testSetField,"  @Test
  public void testSetField() {
    when(field.getText()).thenReturn("""");
    when(dialog.open()).thenReturn(basePath + ""/sub/directory/app.yaml"");

    new RelativeFileFieldSetter(field, basePath, dialog).widgetSelected(event);
    verify(field).setText(""sub/directory/app.yaml"");
  }
",non-flaky,5
175797,GoogleCloudPlatform_google-cloud-eclipse,RelativeFileFieldSetterTest.testSetField_userSuppliesPathOutsideBase,"  @Test
  public void testSetField_userSuppliesPathOutsideBase() {
    when(field.getText()).thenReturn("""");
    when(dialog.open()).thenReturn(""/path/outside/base/app.yaml"");

    new RelativeFileFieldSetter(field, new Path(""/base/path""), dialog).widgetSelected(event);
    verify(field).setText(""../../path/outside/base/app.yaml"");
  }
",non-flaky,5
175798,GoogleCloudPlatform_google-cloud-eclipse,RelativeFileFieldSetterTest.testFileDialogFilterSet_relativePathInField,"  @Test
  public void testFileDialogFilterSet_relativePathInField() {
    when(field.getText()).thenReturn(""src/main/appengine/app.yaml"");
    when(dialog.open()).thenReturn(null);

    new RelativeFileFieldSetter(field, basePath, dialog).widgetSelected(event);
    // ""basePath"" is the first physically existing directory.
    verify(dialog).setFilterPath(basePath.toString());

    basePath.append(""src"").toFile().mkdir();
    new RelativeFileFieldSetter(field, basePath, dialog).widgetSelected(event);
    verify(dialog).setFilterPath(basePath + ""/src"");
  }
",non-flaky,5
175799,GoogleCloudPlatform_google-cloud-eclipse,RelativeFileFieldSetterTest.testFileDialogFilterSet_absolutePathInField,"  @Test
  public void testFileDialogFilterSet_absolutePathInField() {
    when(field.getText()).thenReturn(basePath + ""/deploy/temp/app.yaml"");
    when(dialog.open()).thenReturn(null);

    new RelativeFileFieldSetter(field, basePath, dialog).widgetSelected(event);
    // ""basePath"" is the first physically existing directory.
    verify(dialog).setFilterPath(basePath.toString());

    basePath.append(""deploy"").toFile().mkdir();
    new RelativeFileFieldSetter(field, basePath, dialog).widgetSelected(event);
    verify(dialog).setFilterPath(basePath + ""/deploy"");
  }
",non-flaky,5
175800,GoogleCloudPlatform_google-cloud-eclipse,ProjectSelectorSelectionChangedListenerTest.testSelectionChanged_emptySelection,"  @Test
  public void testSelectionChanged_emptySelection() {
    when(event.getSelection()).thenReturn(new StructuredSelection());
    listener.selectionChanged(event);
    verify(projectSelector).clearStatusLink();
  }
",non-flaky,5
175801,GoogleCloudPlatform_google-cloud-eclipse,ProjectSelectorSelectionChangedListenerTest.testSelectionChanged_repositoryException,"  @Test
  public void testSelectionChanged_repositoryException()
      throws ProjectRepositoryException, InterruptedException {
    initSelectionAndAccountSelector();
    when(projectRepository.getAppEngineApplication(any(Credential.class), anyString()))
        .thenThrow(new ProjectRepositoryException(""testException""));

    listener.selectionChanged(event);
    listener.latestQueryJob.join();
    verify(projectSelector).clearStatusLink();  // Should clear initially.
    verify(projectSelector).setStatusLink(EXPECTED_MESSAGE_WHEN_EXCEPTION, null /* tooltip */);
  }
",non-flaky,5
175802,GoogleCloudPlatform_google-cloud-eclipse,ProjectSelectorSelectionChangedListenerTest.testSelectionChanged_noAppEngineApplication,"  @Test
  public void testSelectionChanged_noAppEngineApplication()
      throws ProjectRepositoryException, InterruptedException {
    initSelectionAndAccountSelector();
    when(projectRepository.getAppEngineApplication(any(Credential.class), anyString()))
        .thenReturn(AppEngine.NO_APPENGINE_APPLICATION);

    listener.selectionChanged(event);
    listener.latestQueryJob.join();
    verify(projectSelector).clearStatusLink();  // Should clear initially.
    verify(projectSelector).setStatusLink(EXPECTED_MESSAGE_WHEN_NO_APPLICATION, EXPECTED_LINK);
  }
",non-flaky,5
175803,GoogleCloudPlatform_google-cloud-eclipse,ProjectSelectorSelectionChangedListenerTest.testSelectionChanged_hasAppEngineApplication,"  @Test
  public void testSelectionChanged_hasAppEngineApplication()
      throws ProjectRepositoryException, InterruptedException {
    initSelectionAndAccountSelector();
    when(projectRepository.getAppEngineApplication(any(Credential.class), anyString()))
        .thenReturn(AppEngine.withId(""id""));

    listener.selectionChanged(event);
    listener.latestQueryJob.join();
    verify(projectSelector).clearStatusLink();
  }
",non-flaky,5
175804,GoogleCloudPlatform_google-cloud-eclipse,ProjectSelectorSelectionChangedListenerTest.testSelectionChanged_doNotRunQueryJobIfCached,"  @Test
  public void testSelectionChanged_doNotRunQueryJobIfCached() throws ProjectRepositoryException {
    GcpProject gcpProject = new GcpProject(""projectName"", ""projectId"");
    initSelectionAndAccountSelector(gcpProject);
    gcpProject.setAppEngine(AppEngine.withId(""id""));

    listener.selectionChanged(event);
    assertNull(listener.latestQueryJob);
    verify(projectRepository, never()).getAppEngineApplication(any(Credential.class), anyString());
    verify(projectSelector).clearStatusLink();
  }
",non-flaky,5
175805,GoogleCloudPlatform_google-cloud-eclipse,ProjectSelectorSelectionChangedListenerTest.testSelectionChanged_whenCachedResultIsNoAppEngineApplication,"  @Test
  public void testSelectionChanged_whenCachedResultIsNoAppEngineApplication()
      throws ProjectRepositoryException {
    GcpProject gcpProject = new GcpProject(""projectName"", ""projectId"");
    initSelectionAndAccountSelector(gcpProject);
    gcpProject.setAppEngine(AppEngine.NO_APPENGINE_APPLICATION);

    listener.selectionChanged(event);
    assertNull(listener.latestQueryJob);
    verify(projectRepository, never()).getAppEngineApplication(any(Credential.class), anyString());
    verify(projectSelector).setStatusLink(EXPECTED_MESSAGE_WHEN_NO_APPLICATION, EXPECTED_LINK);
  }
",non-flaky,5
175806,GoogleCloudPlatform_google-cloud-eclipse,ProjectSelectorSelectionChangedListenerTest.testSelectionChanged_changeSelectedProject,"  @Test
  public void testSelectionChanged_changeSelectedProject()
      throws ProjectRepositoryException, InterruptedException {
    when(projectRepository.getAppEngineApplication(any(Credential.class), eq(""oldProjectId"")))
        .thenThrow(new ProjectRepositoryException(""testException""));
    when(projectRepository.getAppEngineApplication(any(Credential.class), eq(""projectId"")))
        .thenReturn(AppEngine.NO_APPENGINE_APPLICATION);

    initSelectionAndAccountSelector(new GcpProject(""oldProjectName"", ""oldProjectId""));
    listener.selectionChanged(event);

    Job oldJob = listener.latestQueryJob;
    assertNotNull(oldJob);
    oldJob.join();

    initSelectionAndAccountSelector();
    listener.selectionChanged(event);

    Job newJob = listener.latestQueryJob;
    assertNotNull(newJob);
    assertNotEquals(oldJob, newJob);
    newJob.join();

    verify(projectRepository).getAppEngineApplication(any(Credential.class), eq(""oldProjectId""));
    verify(projectRepository).getAppEngineApplication(any(Credential.class), eq(""projectId""));
    verify(projectSelector).setStatusLink(EXPECTED_MESSAGE_WHEN_NO_APPLICATION, EXPECTED_LINK);
  }
",non-flaky,5
175807,GoogleCloudPlatform_google-cloud-eclipse,MessagesTest.testUrlOpenErrorDialogTitle,"  @Test
  public void testUrlOpenErrorDialogTitle() {
    assertEquals(""Error"", Messages.getString(""openurllistener.error.title""));
  }
",non-flaky,5
175808,GoogleCloudPlatform_google-cloud-eclipse,MessagesTest.testUrlOpenErrorDialogMessage,"  @Test
  public void testUrlOpenErrorDialogMessage() {
    assertEquals(""Could not open URL"", Messages.getString(""openurllistener.error.message""));
  }
",non-flaky,5
175809,GoogleCloudPlatform_google-cloud-eclipse,MessagesTest.testInvalidUrlErrorMessage,"  @Test
  public void testInvalidUrlErrorMessage() {
    assertEquals(""Invalid URL: http://www.example.com"", 
        Messages.getString(""invalid.url"", ""http://www.example.com""));
  }
",non-flaky,5
175810,GoogleCloudPlatform_google-cloud-eclipse,SharedImagesTest.testCreateRefreshIcon,"  @Test
  public void testCreateRefreshIcon() {
    assertNotNull(SharedImages.REFRESH_IMAGE_DESCRIPTOR.createImage(shell.getDisplay()));
  }
",non-flaky,5
175811,GoogleCloudPlatform_google-cloud-eclipse,PluginXmlTest.testExtensionPoint,"  @Test
  public void testExtensionPoint() {
    NodeList extensions = getDocument().getElementsByTagName(""extension"");
    assertEquals(1, extensions.getLength());
    Element extension = (Element) extensions.item(0);
    assertEquals(""org.eclipse.ui.commands"", extension.getAttribute(""point""));

    NodeList commandDefinitions = extension.getElementsByTagName(""command"");
    assertEquals(1, commandDefinitions.getLength());
    Element configExtension = (Element) commandDefinitions.item(0);
    assertEquals(OpenDropDownMenuHandler.class.getName(),
        configExtension.getAttribute(""defaultHandler""));
    assertEquals(""com.google.cloud.tools.eclipse.ui.util.showPopup"",
        configExtension.getAttribute(""id""));
  }
",non-flaky,5
175812,GoogleCloudPlatform_google-cloud-eclipse,FontUtilTest.testConvertFontToBold,"  @Test
  public void testConvertFontToBold() {
    Label label = new Label(shellTestResource.getShell(), SWT.NONE);
    for (FontData fontData : label.getFont().getFontData()) {
      assertThat(fontData.getStyle(), is(not(SWT.BOLD)));
    }
    FontUtil.convertFontToBold(label);
    for (FontData fontData : label.getFont().getFontData()) {
      assertThat(fontData.getStyle(), is(SWT.BOLD));
    }
  }
",non-flaky,5
175813,GoogleCloudPlatform_google-cloud-eclipse,FontUtilTest.testConvertFontToItalic,"  @Test
  public void testConvertFontToItalic() {
    Label label = new Label(shellTestResource.getShell(), SWT.NONE);
    for (FontData fontData : label.getFont().getFontData()) {
      assertThat(fontData.getStyle(), is(not(SWT.ITALIC)));
    }
    FontUtil.convertFontToItalic(label);
    for (FontData fontData : label.getFont().getFontData()) {
      assertThat(fontData.getStyle(), is(SWT.ITALIC));
    }
  }
",non-flaky,5
175814,GoogleCloudPlatform_google-cloud-eclipse,OpenUriSelectionListenerTest.testWidgetSelected_InvalidURI,"  @Test
  public void testWidgetSelected_InvalidURI() {
    SelectionEvent selectionEvent = getEvent(INVALID_URI);

    new OpenUriSelectionListener(queryParameterProvider, errorHandler, browserSupport).widgetSelected(selectionEvent);
    verify(errorHandler).handle(captor.capture(), any(URI.class));
    assertThat(captor.getValue(), instanceOf(URISyntaxException.class));
  }
",non-flaky,5
175815,GoogleCloudPlatform_google-cloud-eclipse,OpenUriSelectionListenerTest.testWidgetDefaultSelected_InvalidURI,"  @Test
  public void testWidgetDefaultSelected_InvalidURI() {
    SelectionEvent selectionEvent = getEvent(INVALID_URI);

    new OpenUriSelectionListener(queryParameterProvider, errorHandler, browserSupport).widgetDefaultSelected(selectionEvent);
    verify(errorHandler).handle(captor.capture(), any(URI.class));
    assertThat(captor.getValue(), instanceOf(URISyntaxException.class));
  }
",non-flaky,5
175816,GoogleCloudPlatform_google-cloud-eclipse,OpenUriSelectionListenerTest.testWidgetSelected_MalformedURL,"  @Test
  public void testWidgetSelected_MalformedURL() {
    SelectionEvent selectionEvent = getEvent(MALFORMED_URL);

    new OpenUriSelectionListener(queryParameterProvider, errorHandler, browserSupport).widgetSelected(selectionEvent);
    verify(errorHandler).handle(captor.capture(), any(URI.class));
    assertThat(captor.getValue(), instanceOf(MalformedURLException.class));
  }
",non-flaky,5
175817,GoogleCloudPlatform_google-cloud-eclipse,OpenUriSelectionListenerTest.testWidgetDefaultSelected_MalformedURL,"  @Test
  public void testWidgetDefaultSelected_MalformedURL() {
    SelectionEvent selectionEvent = getEvent(MALFORMED_URL);

    new OpenUriSelectionListener(queryParameterProvider, errorHandler, browserSupport).widgetDefaultSelected(selectionEvent);
    verify(errorHandler).handle(captor.capture(), any(URI.class));
    assertThat(captor.getValue(), instanceOf(MalformedURLException.class));
  }
",non-flaky,5
175818,GoogleCloudPlatform_google-cloud-eclipse,OpenUriSelectionListenerTest.testWidgetSelected_errorInvokingBrowser,"  @Test
  public void testWidgetSelected_errorInvokingBrowser() throws PartInitException {
    SelectionEvent selectionEvent = getEvent(VALID_URI);
    doThrow(new PartInitException(""fake exception"")).when(browser).openURL(any(URL.class));

    new OpenUriSelectionListener(queryParameterProvider, errorHandler, browserSupport).widgetSelected(selectionEvent);
    verify(errorHandler).handle(captor.capture(), any(URI.class));
    assertThat(captor.getValue(), instanceOf(PartInitException.class));
  }
",non-flaky,5
175819,GoogleCloudPlatform_google-cloud-eclipse,OpenUriSelectionListenerTest.testWidgetDefaultSelected_errorInvokingBrowser,"  @Test
  public void testWidgetDefaultSelected_errorInvokingBrowser() throws PartInitException {
    SelectionEvent selectionEvent = getEvent(VALID_URI);
    doThrow(new PartInitException(""fake exception"")).when(browser).openURL(any(URL.class));

    new OpenUriSelectionListener(queryParameterProvider, errorHandler, browserSupport)
      .widgetDefaultSelected(selectionEvent);
    verify(errorHandler).handle(captor.capture(), any(URI.class));
    assertThat(captor.getValue(), instanceOf(PartInitException.class));
  }
",non-flaky,5
175820,GoogleCloudPlatform_google-cloud-eclipse,OpenUriSelectionListenerTest.testWidgetSelected_successful,"  @Test
  public void testWidgetSelected_successful() throws PartInitException, MalformedURLException {
    SelectionEvent selectionEvent = getEvent(VALID_URI);
    when(queryParameterProvider.getParameters()).thenReturn(Collections.singletonMap(URL_PARAM_PROJECT, PROJECT_ID));

    new OpenUriSelectionListener(queryParameterProvider, errorHandler, browserSupport).widgetSelected(selectionEvent);
    verify(errorHandler, never()).handle(any(Exception.class), any(URI.class));
    verify(browser).openURL(new URL(VALID_URI + ""?project="" + PROJECT_ID));
  }
",non-flaky,5
175821,GoogleCloudPlatform_google-cloud-eclipse,OpenUriSelectionListenerTest.testWidgetDefaultSelected_successful,"  @Test
  public void testWidgetDefaultSelected_successful() throws PartInitException, MalformedURLException {
    SelectionEvent selectionEvent = getEvent(VALID_URI);
    when(queryParameterProvider.getParameters()).thenReturn(Collections.singletonMap(URL_PARAM_PROJECT, PROJECT_ID));

    new OpenUriSelectionListener(queryParameterProvider, errorHandler, browserSupport)
      .widgetDefaultSelected(selectionEvent);
    verify(errorHandler, never()).handle(any(Exception.class), any(URI.class));
    verify(browser).openURL(new URL(VALID_URI + ""?project="" + PROJECT_ID));
  }
",non-flaky,5
175822,GoogleCloudPlatform_google-cloud-eclipse,BooleanConverterTest.testNegate,"  @Test
  public void testNegate() {
    assertTrue((Boolean) BooleanConverter.negate().convert(Boolean.FALSE));
    assertFalse((Boolean) BooleanConverter.negate().convert(Boolean.TRUE));
  }
",non-flaky,5
175823,GoogleCloudPlatform_google-cloud-eclipse,BucketNameValidatorTest.testValidation_nonStringInput,"  @Test
  public void testValidation_nonStringInput() {
    IStatus status = validator.validate(new Object());
    assertThat(status.getSeverity(), is(IStatus.ERROR));
    assertThat(status.getMessage(), is(""Invalid bucket name""));
  }
",non-flaky,5
175824,GoogleCloudPlatform_google-cloud-eclipse,BucketNameValidatorTest.testValidation_emptyString,"  @Test
  public void testValidation_emptyString() {
    assertThat(validator.validate("""").getSeverity(), is(IStatus.OK));
  }
",non-flaky,5
175825,GoogleCloudPlatform_google-cloud-eclipse,BucketNameValidatorTest.testValidation_upperCaseLetter,"  @Test
  public void testValidation_upperCaseLetter() {
    IStatus status = validator.validate(""THISWOULDBEVALIDIFLOWERCASE"");
    assertThat(status.getSeverity(), is(IStatus.ERROR));
    assertThat(status.getMessage(), is(""Invalid bucket name: THISWOULDBEVALIDIFLOWERCASE""));
  }
",non-flaky,5
175826,GoogleCloudPlatform_google-cloud-eclipse,BucketNameValidatorTest.testValidation_startWithDot,"  @Test
  public void testValidation_startWithDot() {
    assertThat(validator.validate("".bucket"").getSeverity(), is(IStatus.ERROR));
  }
",non-flaky,5
175827,GoogleCloudPlatform_google-cloud-eclipse,BucketNameValidatorTest.testValidation_endWithDot,"  @Test
  public void testValidation_endWithDot() {
    assertThat(validator.validate(""bucket."").getSeverity(), is(IStatus.ERROR));
  }
",non-flaky,5
175828,GoogleCloudPlatform_google-cloud-eclipse,BucketNameValidatorTest.testValidation_startWithHyphen,"  @Test
  public void testValidation_startWithHyphen() {
    assertThat(validator.validate(""-bucket"").getSeverity(), is(IStatus.ERROR));
  }
",non-flaky,5
175829,GoogleCloudPlatform_google-cloud-eclipse,BucketNameValidatorTest.testValidation_endWithHyphen,"  @Test
  public void testValidation_endWithHyphen() {
    assertThat(validator.validate(""bucket-"").getSeverity(), is(IStatus.ERROR));
  }
",non-flaky,5
175830,GoogleCloudPlatform_google-cloud-eclipse,BucketNameValidatorTest.testValidation_startWithUnderscore,"  @Test
  public void testValidation_startWithUnderscore() {
    assertThat(validator.validate(""_bucket"").getSeverity(), is(IStatus.ERROR));
  }
",non-flaky,5
175831,GoogleCloudPlatform_google-cloud-eclipse,BucketNameValidatorTest.testValidation_endWithUnderscore,"  @Test
  public void testValidation_endWithUnderscore() {
    assertThat(validator.validate(""bucket_"").getSeverity(), is(IStatus.ERROR));
  }
",non-flaky,5
175832,GoogleCloudPlatform_google-cloud-eclipse,BucketNameValidatorTest.testValidation_maxLengthWithoutDot,"  @Test
  public void testValidation_maxLengthWithoutDot() {
    assertThat(validator.validate(LENGTH_63).getSeverity(), is(IStatus.OK));
  }
",non-flaky,5
175833,GoogleCloudPlatform_google-cloud-eclipse,BucketNameValidatorTest.testValidation_tooLongNameWithoutDot,"  @Test
  public void testValidation_tooLongNameWithoutDot() {
    assertThat(validator.validate(LENGTH_63 + ""4"").getSeverity(), is(IStatus.ERROR));
  }
",non-flaky,5
175834,GoogleCloudPlatform_google-cloud-eclipse,BucketNameValidatorTest.testValidation_validNameWithDot,"  @Test
  public void testValidation_validNameWithDot() {
    assertThat(validator.validate(LENGTH_64_WITH_DOT).getSeverity(), is(IStatus.OK));
  }
",non-flaky,5
175835,GoogleCloudPlatform_google-cloud-eclipse,BucketNameValidatorTest.testValidation_tooLongNameWithDot,"  @Test
  public void testValidation_tooLongNameWithDot() {
    assertThat(validator.validate(LENGTH_222 + ""9"").getSeverity(), is(IStatus.ERROR));
  }
",non-flaky,5
175836,GoogleCloudPlatform_google-cloud-eclipse,BucketNameValidatorTest.testValidation_maxLengthWithDot,"  @Test
  public void testValidation_maxLengthWithDot() {
    assertThat(validator.validate(LENGTH_222).getSeverity(), is(IStatus.OK));
  }
",non-flaky,5
176832,OryxProject_oryx,RandomManagerTest.testRandomState,"  @Test
  public void testRandomState() {
    // Really, a test that the random generator state is reset in tests
    RandomGenerator generator = RandomManager.getRandom();
    assertEquals(1553355631, generator.nextInt());
    assertNotEquals(1553355631, generator.nextInt());
  }
",non-flaky,5
176833,OryxProject_oryx,RandomManagerRandomTest.testRandomState,"  @Test
  public void testRandomState() {
    RandomGenerator generator = RandomManager.getRandom();
    double unseededValue = generator.nextDouble();
    RandomManager.useTestSeed();
    double seededValue = generator.nextDouble();
    assertNotEquals(unseededValue, seededValue);
    assertEquals(seededValue, RandomManager.getRandom().nextDouble());
  }
",non-flaky,5
176834,OryxProject_oryx,LinearSystemSolverTest.testSolveFToD,"  @Test
  public void testSolveFToD() {
    RealMatrix a = new Array2DRowRealMatrix(new double[][] {
        {1.3, -2.0, 3.0},
        {2.0, 0.0, 5.0},
        {0.0, -1.5, 5.5},
    });
    Solver solver = new LinearSystemSolver().getSolver(a);
    assertNotNull(solver);
    double[] y = solver.solveFToD(new float[] {1.0f, 2.0f, 6.5f});
    assertArrayEquals(
        new double[] {-1.9560439560439564,0.002197802197802894,1.1824175824175824}, y);
  }
",non-flaky,5
176835,OryxProject_oryx,LinearSystemSolverTest.testSolveDToD,"  @Test
  public void testSolveDToD() {
    RealMatrix a = new Array2DRowRealMatrix(new double[][] {
        {1.3, -2.0, 3.0},
        {2.0, 0.0, 5.0},
        {0.0, -1.5, 5.5},
    });
    Solver solver = new LinearSystemSolver().getSolver(a);
    assertNotNull(solver);
    double[] y = solver.solveDToD(new double[]{1.0, 2.0, 6.5});
    assertArrayEquals(
        new double[] {-1.9560439560439564,0.002197802197802894,1.1824175824175824}, y);
  }
",non-flaky,5
176836,OryxProject_oryx,LinearSystemSolverTest.testIsNonSingular,"  @Test
  public void testIsNonSingular() {
    RealMatrix nonSingular = new Array2DRowRealMatrix(new double[][] {
        {1.3, -2.0, 3.0},
        {2.0, 0.0, 5.0},
        {0.0, -1.5, 5.5},
    });
    assertTrue(new LinearSystemSolver().isNonSingular(nonSingular));
    RealMatrix singular = new Array2DRowRealMatrix(new double[][] {
        {1.3, -2.0, 3.0},
        {2.6, -4.0, 6.0},
        {0.0, -1.5, 5.5},
    });
    assertFalse(new LinearSystemSolver().isNonSingular(singular));
  }
",non-flaky,5
176837,OryxProject_oryx,LinearSystemSolverTest.testApparentRank,"  @Test
  public void testApparentRank() {
    RealMatrix nearSingular = new Array2DRowRealMatrix(new double[][] {
        {1.31, -2.0, 3.0},
        {2.6, -4.01, 6.01},
        {0.0, -1.5, 5.5},
    });
    try {
      new LinearSystemSolver().getSolver(nearSingular);
    } catch (SingularMatrixSolverException smse) {
      assertEquals(2, smse.getApparentRank());
    }
  }
",non-flaky,5
176838,OryxProject_oryx,VectorMathTest.testDotFF,"  @Test
  public void testDotFF() {
    assertEquals(5.35, VectorMath.dot(VEC1, VEC2), FLOAT_EPSILON);
  }
",non-flaky,5
176839,OryxProject_oryx,VectorMathTest.testDotDF,"  @Test
  public void testDotDF() {
    assertEquals(5.35, VectorMath.dot(VEC1D, VEC2), FLOAT_EPSILON);
  }
",non-flaky,5
176840,OryxProject_oryx,VectorMathTest.testToFloats,"  @Test
  public void testToFloats() {
    assertArrayEquals(new float[] {1.2f}, VectorMath.toFloats(1.2), FLOAT_EPSILON);
  }
",non-flaky,5
176841,OryxProject_oryx,VectorMathTest.testToDoubles,"  @Test
  public void testToDoubles() {
    assertArrayEquals(new double[] {1.2}, VectorMath.toDoubles(1.2f), FLOAT_EPSILON);
  }
",non-flaky,5
176842,OryxProject_oryx,VectorMathTest.testParseVector,"  @Test
  public void testParseVector() {
    assertArrayEquals(
        new double[] {-1.0, 2.01, 3.5},
        VectorMath.parseVector(new String[] {""-1.0"", ""2.01"", ""3.5""}));
  }
",non-flaky,5
176843,OryxProject_oryx,VectorMathTest.testSmall,"  @Test
  public void testSmall() {
    float[] a = { 1.0e-24f };
    assertEquals(1.0e-24 * 1.0e-24, VectorMath.dot(a, a));
  }
",non-flaky,5
176844,OryxProject_oryx,VectorMathTest.testBig,"  @Test
  public void testBig() {
    float[] a = { 1.0e20f };
    assertEquals((double) 1.0e20f * (double) 1.0e20f, VectorMath.dot(a, a));
  }
",non-flaky,5
176845,OryxProject_oryx,VectorMathTest.testNorm,"  @Test
  public void testNorm() {
    assertEquals(0.0, VectorMath.norm(new float[] {0.0f}), FLOAT_EPSILON);
    assertEquals(3.674234614174767, VectorMath.norm(VEC1), FLOAT_EPSILON);
    assertEquals(10.72800074571213, VectorMath.norm(VEC2), FLOAT_EPSILON);
  }
",non-flaky,5
176846,OryxProject_oryx,VectorMathTest.testTransposeTimesSelf,"  @Test
  public void testTransposeTimesSelf() {
    Map<Integer,float[]> a = new HashMap<>();
    a.put(-1, new float[] {1.3f, -2.0f, 3.0f});
    a.put(1, new float[] {2.0f, 0.0f, 5.0f});
    a.put(3, new float[] {0.0f, -1.5f, 5.5f});
    RealMatrix ata = VectorMath.transposeTimesSelf(a.values());
    RealMatrix expected = new Array2DRowRealMatrix(new double[][] {
        {5.69, -2.6, 13.9},
        {-2.6, 6.25, -14.25},
        {13.9, -14.25, 64.25}
    });
    for (int row = 0; row < 3; row++) {
      for (int col = 0; col < 3; col++) {
        assertEquals(expected.getEntry(row, col), ata.getEntry(row, col), FLOAT_EPSILON);
      }
    }
  }
",non-flaky,5
176847,OryxProject_oryx,DoubleWeightedMeanTest.testNone,"  @Test
  public void testNone() {
    DoubleWeightedMean mean = new DoubleWeightedMean();
    assertEquals(0, mean.getN());
    assertTrue(Double.isNaN(mean.getResult()));
  }
",non-flaky,5
176848,OryxProject_oryx,DoubleWeightedMeanTest.testOne,"  @Test
  public void testOne() {
    DoubleWeightedMean mean = new DoubleWeightedMean();
    mean.increment(1.5);
    assertEquals(1, mean.getN());
    assertEquals(1.5, mean.getResult());
    assertEquals(""1.5"", mean.toString());
  }
",non-flaky,5
176849,OryxProject_oryx,DoubleWeightedMeanTest.testWeighted,"  @Test
  public void testWeighted() {
    DoubleWeightedMean mean = new DoubleWeightedMean();
    mean.increment(0.2, 4.0);
    mean.increment(-0.1, 2.0);
    assertEquals(2, mean.getN());
    assertEquals(0.1, mean.getResult());
  }
",non-flaky,5
176850,OryxProject_oryx,DoubleWeightedMeanTest.testNegative,"  @Test
  public void testNegative() {
    DoubleWeightedMean mean = new DoubleWeightedMean();
    mean.increment(-0.1, 2.1);
    mean.increment(0.1, 2.1);
    assertEquals(2, mean.getN());
    assertEquals(0.0, mean.getResult());
  }
",non-flaky,5
176851,OryxProject_oryx,DoubleWeightedMeanTest.testComplex,"  @Test
  public void testComplex() {
    DoubleWeightedMean mean = new DoubleWeightedMean();
    for (int i = 1; i <= 5; i++) {
      mean.increment(1.0 / (i + 1), i);
    }
    assertEquals(5, mean.getN());
    assertEquals((1.0/2.0 + 2.0/3.0 + 3.0/4.0 + 4.0/5.0 + 5.0/6.0) / 15.0, mean.getResult());
  }
",non-flaky,5
176852,OryxProject_oryx,DoubleWeightedMeanTest.testCopyEquals,"  @Test
  public void testCopyEquals() {
    DoubleWeightedMean mean = new DoubleWeightedMean();
    mean.increment(0.2, 4.0);
    mean.increment(-0.1, 2.0);
    DoubleWeightedMean copy = mean.copy();
    assertEquals(copy, mean);
    assertEquals(copy.hashCode(), mean.hashCode());
    DoubleWeightedMean zero = new DoubleWeightedMean();
    mean.clear();
    assertEquals(zero, mean);
  }
",non-flaky,5
176853,OryxProject_oryx,JVMUtilsTest.close,"  @Test
  public void testShutdownHook() {
    // Can't really test this except to verify that no exception is thrown now or at shutdown
    JVMUtils.closeAtShutdown(new Closeable() {
      @Override
      public void close() {
        // do nothing
      }
",non-flaky,5
176854,OryxProject_oryx,JVMUtilsTest.testUsedMemory,"  @Test
  public void testUsedMemory() {
    // Reasonable guess
    assertTrue(JVMUtils.getUsedMemory() >= 1L << 20);
  }
",non-flaky,5
176855,OryxProject_oryx,LoggingTest.doRun,"  @Test(expected = IllegalStateException.class)
  public void testLoggingRunnableException() {
    new LoggingRunnable() {
      @Override
      public void doRun() throws IOException {
        throw buildIOE();
      }
",non-flaky,5
176856,OryxProject_oryx,LoggingTest.doCall,"  @Test
  public void testLoggingCallable() {
    Integer result = new LoggingCallable<Integer>() {
      @Override
      public Integer doCall() {
        return 3;
      }
",non-flaky,5
176857,OryxProject_oryx,LoggingTest.doCall,"  @Test(expected = IllegalStateException.class)
  public void testLoggingCallableException() {
    new LoggingCallable<Void>() {
      @Override
      public Void doCall() throws IOException {
        throw buildIOE();
      }
",non-flaky,5
176858,OryxProject_oryx,LoggingTest.doCall,"  @Test(expected = IllegalStateException.class)
  public void testLoggingVoidCallableException() {
    new LoggingVoidCallable() {
      @Override
      public void doCall() throws IOException {
        throw buildIOE();
      }
",non-flaky,5
176859,OryxProject_oryx,LangUtilsTest.testHashDouble,"  @Test
  public void testHashDouble() {
    for (int i = 0; i < 1000; i++) {
      assertEquals(Double.valueOf(i).hashCode(), LangUtils.hashDouble(i));
    }
  }
",non-flaky,5
176860,OryxProject_oryx,AutoLockTest.testClose,"  @Test
  public void testClose() {
    ReentrantLock lock = new ReentrantLock();
    assertFalse(lock.isHeldByCurrentThread());
    AutoLock al = new AutoLock(lock);
    assertTrue(lock.isHeldByCurrentThread());
    al.close();
    assertFalse(lock.isHeldByCurrentThread());
  }
",non-flaky,5
176861,OryxProject_oryx,AutoLockTest.testAutoClose,"  @Test
  public void testAutoClose() {
    ReentrantLock lock = new ReentrantLock();
    assertFalse(lock.isHeldByCurrentThread());
    try (AutoLock al = new AutoLock(lock)) {
      assertTrue(lock.isHeldByCurrentThread());
    }
    assertFalse(lock.isHeldByCurrentThread());
  }
",non-flaky,5
176862,OryxProject_oryx,ClassUtilsTest.testLoadClass,"  @Test
  public void testLoadClass() {
    assertSame(ArrayList.class, ClassUtils.loadClass(ArrayList.class.getName()));
  }
",non-flaky,5
176863,OryxProject_oryx,ClassUtilsTest.testLoadClass2,"  @Test
  public void testLoadClass2() {
    assertSame(ArrayList.class, ClassUtils.loadClass(ArrayList.class.getName(), List.class));
  }
",non-flaky,5
176864,OryxProject_oryx,ClassUtilsTest.testLoadInstanceOf,"  @Test
  public void testLoadInstanceOf() {
    assertTrue(ClassUtils.loadInstanceOf(HashSet.class) instanceof HashSet);
  }
",non-flaky,5
176865,OryxProject_oryx,ClassUtilsTest.testLoadInstanceOf2,"  @Test
  public void testLoadInstanceOf2() {
    assertTrue(ClassUtils.loadInstanceOf(HashSet.class.getName(), Set.class) instanceof HashSet);
  }
",non-flaky,5
176866,OryxProject_oryx,ClassUtilsTest.testInstantiateWithArgs,"  @Test
  public void testInstantiateWithArgs() {
    Number n = ClassUtils.loadInstanceOf(Integer.class.getName(),
        Number.class,
        new Class<?>[]{int.class},
        new Object[]{3});
    assertEquals(3, n.intValue());
  }
",non-flaky,5
176867,OryxProject_oryx,ClassUtilsTest.testNoSuchMethod,"  @Test(expected = IllegalArgumentException.class)
  public void testNoSuchMethod() {
    ClassUtils.loadInstanceOf(Long.class.getName(), Long.class);
  }
",non-flaky,5
176868,OryxProject_oryx,ClassUtilsTest.tesInvocationException,"  @Test(expected = IllegalStateException.class)
  public void tesInvocationException() {
    ClassUtils.loadInstanceOf(String.class.getName(),
                              String.class,
                              new Class<?>[] { char[].class },
                              new Object[] { null });
  }
",non-flaky,5
176869,OryxProject_oryx,ClassUtilsTest.testExists,"  @Test
  public void testExists() {
    assertTrue(ClassUtils.classExists(""java.lang.String""));
    assertTrue(ClassUtils.classExists(""com.cloudera.oryx.common.lang.ClassUtils""));
    assertFalse(ClassUtils.classExists(""java.Foo""));
  }
",non-flaky,5
176870,OryxProject_oryx,PMMLUtilsTest.testSkeleton,"  @Test
  public void testSkeleton() {
    PMML pmml = PMMLUtils.buildSkeletonPMML();
    assertEquals(""Oryx"", pmml.getHeader().getApplication().getName());
    assertNotNull(pmml.getHeader().getTimestamp());
  }
",non-flaky,5
176871,OryxProject_oryx,PMMLUtilsTest.testReadWrite,"  @Test
  public void testReadWrite() throws Exception {
    Path tempModelFile = Files.createTempFile(getTempDir(), ""model"", "".pmml.gz"");
    PMML model = buildDummyModel();
    PMMLUtils.write(model, tempModelFile);
    assertTrue(Files.exists(tempModelFile));
    PMML model2 = PMMLUtils.read(tempModelFile);
    List<Model> models = model2.getModels();
    assertEquals(1, models.size());
    assertTrue(models.get(0) instanceof TreeModel);
    TreeModel treeModel = (TreeModel) models.get(0);
    assertEquals(123.0, treeModel.getNode().getRecordCount().doubleValue());
    assertEquals(MiningFunctionType.CLASSIFICATION, treeModel.getFunctionName());
  }
",non-flaky,5
176872,OryxProject_oryx,PMMLUtilsTest.testToString,"  @Test
  public void testToString() throws Exception {
    PMML model = buildDummyModel();
    model.getHeader().setTimestamp(null);
    assertEquals(""<?xml version=\""1.0\"" encoding=\""UTF-8\"" standalone=\""yes\""?>\n"" +
                 ""<PMML version=\""4.2.1\"" xmlns=\""http://www.dmg.org/PMML-4_2\"">\n"" +
                 ""    <Header>\n"" +
                 ""        <Application name=\""Oryx\""/>\n"" +
                 ""    </Header>\n"" +
                 ""    <TreeModel functionName=\""classification\"">\n"" +
                 ""        <Node recordCount=\""123.0\""/>\n"" +
                 ""    </TreeModel>\n"" +
                 ""</PMML>\n"",
                 PMMLUtils.toString(model));
  }
",non-flaky,5
176873,OryxProject_oryx,PMMLUtilsTest.testFromString,"  @Test
  public void testFromString() throws Exception {
    PMML model = buildDummyModel();
    PMML model2 = PMMLUtils.fromString(PMMLUtils.toString(model));
    assertEquals(model.getHeader().getApplication().getName(),
                 model2.getHeader().getApplication().getName());
    assertEquals(model.getModels().get(0).getFunctionName(),
                 model2.getModels().get(0).getFunctionName());
  }
",non-flaky,5
176874,OryxProject_oryx,IOUtilsTest.testDeleteRecursively,"  @Test
  public void testDeleteRecursively() throws IOException {
    Path testDir = createTestDirs();
    IOUtils.deleteRecursively(testDir);
    assertFalse(Files.exists(testDir));
    assertFalse(Files.exists(testDir.resolve(""subFile1"")));
  }
",non-flaky,5
176875,OryxProject_oryx,IOUtilsTest.testListFiles,"  @Test
  public void testListFiles() throws IOException {
    Path testDir = createTestDirs();
    List<Path> files = IOUtils.listFiles(testDir, ""*"");
    assertEquals(2, files.size());
    assertTrue(files.contains(testDir.resolve(""subFile1"")));
    assertFalse(files.contains(testDir.resolve("".hidden"")));
    assertTrue(files.contains(testDir.resolve(""subDir1"")));
  }
",non-flaky,5
176876,OryxProject_oryx,IOUtilsTest.testListFiles2,"  @Test
  public void testListFiles2() throws IOException {
    Path testDir = createTestDirs();
    List<Path> files = IOUtils.listFiles(testDir, """");
    assertEquals(2, files.size());
    assertTrue(files.contains(testDir.resolve(""subFile1"")));
    assertFalse(files.contains(testDir.resolve("".hidden"")));
    assertTrue(files.contains(testDir.resolve(""subDir1"")));
  }
",non-flaky,5
176877,OryxProject_oryx,IOUtilsTest.testListSubdirs,"  @Test
  public void testListSubdirs() throws IOException {
    Path testDir = createTestDirs();
    List<Path> files = IOUtils.listFiles(testDir, ""*/*"");
    assertEquals(2, files.size());
    assertTrue(files.contains(testDir.resolve(""subDir1"").resolve(""subFile2"")));
    assertTrue(files.contains(testDir.resolve(""subDir1"").resolve(""subDir2"")));
  }
",non-flaky,5
176878,OryxProject_oryx,IOUtilsTest.testListSubdirs2,"  @Test
  public void testListSubdirs2() throws IOException {
    Path testDir = createTestDirs();
    List<Path> files = IOUtils.listFiles(testDir, ""*/subFile*"");
    assertEquals(1, files.size());
    assertTrue(files.contains(testDir.resolve(""subDir1"").resolve(""subFile2"")));
  }
",non-flaky,5
176879,OryxProject_oryx,IOUtilsTest.testOrder,"  @Test
  public void testOrder() throws IOException {
    Path testDir = createTestDirs();
    List<Path> files = IOUtils.listFiles(testDir, ""*/*"");
    assertEquals(testDir.resolve(""subDir1"").resolve(""subDir2""), files.get(0));
    assertEquals(testDir.resolve(""subDir1"").resolve(""subFile2""), files.get(1));
  }
",non-flaky,5
176880,OryxProject_oryx,IOUtilsTest.testReadLines,"  @Test
  public void testReadLines() throws IOException {
    Path tempDir = getTempDir();
    Path textFile = tempDir.resolve(""file.txt"");
    Files.write(textFile, Arrays.asList(""foo"", ""bar"", ""baz""), StandardCharsets.UTF_8);
    Iterator<String> it = IOUtils.readLines(textFile).iterator();
    assertTrue(it.hasNext());
    assertEquals(""foo"", it.next());
    assertTrue(it.hasNext());
    assertEquals(""bar"", it.next());
    assertTrue(it.hasNext());
    assertEquals(""baz"", it.next());
    assertFalse(it.hasNext());
  }
",non-flaky,5
176881,OryxProject_oryx,IOUtilsTest.testChooseFreePort,"  @Test
  public void testChooseFreePort() throws IOException {
    int freePort = IOUtils.chooseFreePort();
    assertTrue(freePort >= 1024 && freePort < 65536);
    try (ServerSocket socket = new ServerSocket(freePort, 0)) {
      assertEquals(freePort, socket.getLocalPort());
    }
  }
",non-flaky,5
176882,OryxProject_oryx,IOUtilsTest.testDistinctFreePorts,"  @Test
  public void testDistinctFreePorts() throws IOException {
    // This whole thing probably won't work unless successive calls really do return
    // different ports instead of reusing free ephemeral ports.
    Set<Integer> ports = new HashSet<>();
    for (int i = 0; i < 10; i++) {
      ports.add(IOUtils.chooseFreePort());
    }
    assertEquals(10, ports.size());
  }
",non-flaky,5
176883,OryxProject_oryx,ConfigUtilsTest.testDefaultConfig,"  @Test
  public void testDefaultConfig() {
    Config config = ConfigUtils.getDefault();
    assertEquals(""yarn-client"", config.getString(""oryx.batch.streaming.master""));
  }
",non-flaky,5
176884,OryxProject_oryx,ConfigUtilsTest.testSerialize,"  @Test
  public void testSerialize() {
    String serialized = ConfigUtils.serialize(ConfigUtils.getDefault());
    assertTrue(serialized.contains(""update-class""));
    Config deserialized = ConfigUtils.deserialize(serialized);
    assertEquals(
        ConfigUtils.getDefault().getString(""oryx.serving.api.port""),
        deserialized.getString(""oryx.serving.api.port""));
  }
",non-flaky,5
176885,OryxProject_oryx,ConfigUtilsTest.testOptionalString,"  @Test
  public void testOptionalString() {
    assertNull(ConfigUtils.getOptionalString(ConfigUtils.getDefault(), ""nonexistent""));
  }
",non-flaky,5
176886,OryxProject_oryx,ConfigUtilsTest.testOptionalStringList,"  @Test
  public void testOptionalStringList() {
    assertNull(ConfigUtils.getOptionalStringList(ConfigUtils.getDefault(), ""nonexistent""));
  }
",non-flaky,5
176887,OryxProject_oryx,ConfigUtilsTest.testOverlayOn,"  @Test
  public void testOverlayOn() {
    Map<String,Object> overlay = new HashMap<>();
    overlay.put(""foo"", ""bar"");
    Config config = ConfigUtils.overlayOn(overlay, ConfigUtils.getDefault());
    assertEquals(""bar"", config.getString(""foo""));
  }
",non-flaky,5
176888,OryxProject_oryx,ConfigUtilsTest.testSetPath,"  @Test
  public void testSetPath() throws Exception {
    Path cwd = Paths.get(""."");
    Map<String,Object> map = new HashMap<>();
    ConfigUtils.set(map, ""cwd"", cwd);
    ConfigUtils.set(map, ""temp"", Paths.get(""/tmp""));
    assertEquals(""\"""" + cwd.toRealPath(LinkOption.NOFOLLOW_LINKS).toUri() + ""\"""", map.get(""cwd""));
    assertEquals(""\""file:///tmp/\"""", map.get(""temp""));
  }
",non-flaky,5
176889,OryxProject_oryx,ConfigUtilsTest.testRedact,"  @Test
  public void testRedact() {
    String redacted = ConfigUtils.redact(""  password=foo \nPassword=foo\nPASSWORD = foo\n"" +
                                             "" the-password= foo \nThe-Password =foo"");
    assertFalse(redacted.contains(""foo""));
    assertTrue(redacted.contains(""*****""));
    assertTrue(redacted.contains(""password=""));
    assertTrue(redacted.contains(""Password=""));
    assertTrue(redacted.contains(""PASSWORD = ""));
    assertTrue(redacted.contains(""the-password= ""));
    assertTrue(redacted.contains(""The-Password =""));
  }
",non-flaky,5
176890,OryxProject_oryx,PairTest.testEquals,"  @Test
  public void testEquals() {
    assertEquals(new Pair<>(3.0, ""foo""), new Pair<>(3.0, ""foo""));
    assertEquals(new Pair<>(null, null), new Pair<>(null, null));
    assertFalse(new Pair<>(3.0, ""foo"").equals(new Pair<>(4.0, ""foo"")));
    assertNotEquals(new Pair<>(3.0, ""foo""), new Pair<>(""foo"", 3.0));
    assertNotEquals(""3.0,foo"", new Pair<>(3.0, ""foo""));
  }
",non-flaky,5
176891,OryxProject_oryx,PairTest.testHashCode,"  @Test
  public void testHashCode() {
    assertEquals(new Pair<>(3.0, ""foo"").hashCode(), new Pair<>(3.0, ""foo"").hashCode());
    assertEquals(new Pair<>(null, null).hashCode(), new Pair<>(null, null).hashCode());
  }
",non-flaky,5
176892,OryxProject_oryx,PairTest.testToString,"  @Test
  public void testToString() {
    assertEquals(""3.0,foo"", new Pair<>(3.0, ""foo"").toString());
  }
",non-flaky,5
176893,OryxProject_oryx,AndPredicateTest.testAnd,"  @Test
  public void testAnd() {
    NotContainsPredicate<String> a = new NotContainsPredicate<>(Arrays.asList(""foo""));
    NotContainsPredicate<String> b = new NotContainsPredicate<>(Arrays.asList(""bar"", ""baz""));
    AndPredicate<String> and = new AndPredicate<>(a, b);
    assertFalse(and.test(""foo""));
    assertFalse(and.test(""bar""));
    assertFalse(and.test(""baz""));
    assertTrue(and.test(""bing""));
  }
",non-flaky,5
176894,OryxProject_oryx,NotContainsPredicateTest.testPredicate,"  @Test
  public void testPredicate() {
    Collection<Integer> contains = Arrays.asList(1, 3, 5);
    NotContainsPredicate<Integer> predicate = new NotContainsPredicate<>(contains);
    assertTrue(predicate.test(2));
    assertFalse(predicate.test(5));
  }
",non-flaky,5
176895,OryxProject_oryx,PairComparatorsTest.testByFirst,"  @Test
  public void testByFirst() {
    List<Pair<Integer,String>> pairs = Arrays.asList(
        new Pair<>(3, ""foo""),
        new Pair<>(4, ""bing""),
        new Pair<>(1, ""baz""),
        new Pair<>(2, ""whizz"")
    );
    Collections.sort(pairs, PairComparators.<Integer>byFirst());
    assertEquals(1, pairs.get(0).getFirst().intValue());
    assertEquals(2, pairs.get(1).getFirst().intValue());
    assertEquals(""baz"", pairs.get(0).getSecond());
    assertEquals(""whizz"", pairs.get(1).getSecond());
  }
",non-flaky,5
176896,OryxProject_oryx,PairComparatorsTest.testBySecond,"  @Test
  public void testBySecond() {
    List<Pair<Integer,String>> pairs = Arrays.asList(
        new Pair<>(3, ""foo""),
        new Pair<>(4, ""bing""),
        new Pair<>(1, ""baz""),
        new Pair<>(2, ""whizz"")
    );
    Collections.sort(pairs, PairComparators.<String>bySecond());
    assertEquals(1, pairs.get(0).getFirst().intValue());
    assertEquals(4, pairs.get(1).getFirst().intValue());
    assertEquals(""baz"", pairs.get(0).getSecond());
    assertEquals(""bing"", pairs.get(1).getSecond());
  }
",non-flaky,5
176897,OryxProject_oryx,KeyOnlyBiPredicateTest.test,"  @Test
  public void testKeyOnly() {
    ObjObjMap<String,String> map = HashObjObjMaps.newMutableMap(
        new String[]{""foo"", ""bar"", ""baz""},
        new String[]{""1"", ""3"", ""4""}
    );
    map.removeIf(new KeyOnlyBiPredicate<String, String>(new Predicate<String>() {
      @Override
      public boolean test(String s) {
        return s.startsWith(""b"");
      }
",non-flaky,5
176898,OryxProject_oryx,TextUtilsTest.testParseJSON,"  @Test
  public void testParseJSON() throws Exception {
    assertArrayEquals(new String[] {""a"", ""1"", ""foo""},
                      TextUtils.parseJSONArray(""[\""a\"",\""1\"",\""foo\""]""));
    assertArrayEquals(new String[] {""a"", ""1"", ""foo"", """"},
                      TextUtils.parseJSONArray(""[\""a\"",\""1\"",\""foo\"",\""\""]""));
    assertArrayEquals(new String[] {""2.3""}, TextUtils.parseJSONArray(""[\""2.3\""]""));
    assertArrayEquals(new String[] {}, TextUtils.parseJSONArray(""[]""));
  }
",non-flaky,5
176899,OryxProject_oryx,TextUtilsTest.testParseDelimited,"  @Test
  public void testParseDelimited() throws Exception {
    assertArrayEquals(new String[] {""a"", ""1"", ""foo""}, TextUtils.parseDelimited(""a,1,foo"", ','));
    assertArrayEquals(new String[] {""a"", ""1"", ""foo"", """"},
                      TextUtils.parseDelimited(""a,1,foo,"", ','));
    assertArrayEquals(new String[] {""2.3""}, TextUtils.parseDelimited(""2.3"", ','));
    assertArrayEquals(new String[] {""\""a\""""}, TextUtils.parseDelimited(""\""\""\""a\""\""\"""", ','));
    assertArrayEquals(new String[] {""\"""", ""\""\""""},
                      TextUtils.parseDelimited(""\""\""\""\"" \""\""\""\""\""\"""", ' '));
    // Different from JSON, sort of:
    assertArrayEquals(new String[] {""""}, TextUtils.parseDelimited("""", ','));
    assertArrayEquals(new String[] {""a"", ""1,"", "",foo""},
                      TextUtils.parseDelimited(""a\t1,\t,foo"", '\t'));
    assertArrayEquals(new String[] {""a"", ""1"", ""foo"", """"},
                      TextUtils.parseDelimited(""a 1 foo "", ' '));
    assertArrayEquals(new String[] {""-1.0"", ""a\"" \""b""},
                      TextUtils.parseDelimited(""-1.0 a\""\\ \""b"", ' '));
    assertArrayEquals(new String[] {""-1.0"", ""a\""b\""c""},
                      TextUtils.parseDelimited(""-1.0 \""a\\\""b\\\""c\"""", ' '));

  }
",non-flaky,5
176900,OryxProject_oryx,TextUtilsTest.testParsePMMLDelimited,"  @Test
  public void testParsePMMLDelimited() {
    assertArrayEquals(new String[] {""1"", ""22"", ""3""}, TextUtils.parsePMMLDelimited(""1 22 3""));
    assertArrayEquals(new String[] {""ab"", ""a b"", ""with \""quotes\"" ""},
                      TextUtils.parsePMMLDelimited(""ab  \""a b\""   \""with \\\""quotes\\\"" \"" ""));
    assertArrayEquals(new String[] {""\"" \""""},
                      TextUtils.parsePMMLDelimited(""\""\\\"" \\\""\""""));
    assertArrayEquals(new String[] {"" c\"" d \""e "", "" c\"" d \""e ""},
                      TextUtils.parsePMMLDelimited("" \"" c\\\"" d \\\""e \"" \"" c\\\"" d \\\""e \"" ""));
  }
",non-flaky,5
176901,OryxProject_oryx,TextUtilsTest.testJoinDelimited,"  @Test
  public void testJoinDelimited() {
    assertEquals(""1,2,3"", TextUtils.joinDelimited(Arrays.asList(""1"", ""2"", ""3""), ','));
    assertEquals(""\""a,b\"""", TextUtils.joinDelimited(Arrays.asList(""a,b""), ','));
    assertEquals(""\""\""\""a\""\""\"""", TextUtils.joinDelimited(Arrays.asList(""\""a\""""), ','));
    assertEquals(""1 2 3"", TextUtils.joinDelimited(Arrays.asList(""1"", ""2"", ""3""), ' '));
    assertEquals(""\""1 \"" \""2 \"" 3"", TextUtils.joinDelimited(Arrays.asList(""1 "", ""2 "", ""3""), ' '));
    assertEquals(""\""\""\""a\""\""\"""", TextUtils.joinDelimited(Arrays.asList(""\""a\""""), ' '));
    assertEquals(""\""\""\""\"" \""\""\""\""\""\"""",
                 TextUtils.joinDelimited(Arrays.asList(""\"""", ""\""\""""), ' '));
    assertEquals("""", TextUtils.joinDelimited(Collections.emptyList(), '\t'));
  }
",non-flaky,5
176902,OryxProject_oryx,TextUtilsTest.testJoinPMMLDelimited,"  @Test
  public void testJoinPMMLDelimited() {
    assertEquals(""ab \""a b\"" \""with \\\""quotes\\\"" \"""",
                 TextUtils.joinPMMLDelimited(Arrays.asList(""ab"", ""a b"", ""with \""quotes\"" "")));
    assertEquals(""1 22 3"",
                 TextUtils.joinPMMLDelimited(Arrays.asList(""1"", ""22"", ""3"")));
    assertEquals(""\"" c\\\"" d \\\""e \"" \"" c\\\"" d \\\""e \"""",
                 TextUtils.joinPMMLDelimited(Arrays.asList("" c\"" d \""e "", "" c\"" d \""e "")));
  }
",non-flaky,5
176903,OryxProject_oryx,TextUtilsTest.testJoinPMMLDelimitedNumbers,"  @Test
  public void testJoinPMMLDelimitedNumbers() {
    assertEquals(""-1.0 2.01 3.5"",
                 TextUtils.joinPMMLDelimitedNumbers(Arrays.asList(-1.0, 2.01, 3.5)));
  }
",non-flaky,5
176904,OryxProject_oryx,TextUtilsTest.testJoinJSON,"  @Test
  public void testJoinJSON() {
    assertEquals(""[\""1\"",\""2\"",\""3\""]"", TextUtils.joinJSON(Arrays.asList(""1"", ""2"", ""3"")));
    assertEquals(""[\""1 \"",\""2 \"",\""3\""]"", TextUtils.joinJSON(Arrays.asList(""1 "", ""2 "", ""3"")));
    assertEquals(""[]"", TextUtils.joinJSON(Collections.emptyList()));
  }
",non-flaky,5
176905,OryxProject_oryx,TextUtilsTest.testJSONList,"  @Test
  public void testJSONList() {
    List<Object> list = new ArrayList<>();
    list.add(""foo"");
    list.add(2);
    assertEquals(""[\""A\"",[\""foo\"",2],\""B\""]"", TextUtils.joinJSON(Arrays.asList(""A"", list, ""B"")));
  }
",non-flaky,5
176906,OryxProject_oryx,TextUtilsTest.testJSONMap,"  @Test
  public void testJSONMap() {
    Map<Object,Object> map = new HashMap<>();
    map.put(1, ""bar"");
    map.put(""foo"", 2);
    assertEquals(""[\""A\"",{\""1\"":\""bar\"",\""foo\"":2},\""B\""]"",
                 TextUtils.joinJSON(Arrays.asList(""A"", map, ""B"")));
  }
",non-flaky,5
176907,OryxProject_oryx,RatingToTupleDoubleTest.testFunction,"  @Test
  public void testFunction() {
    Tuple2<Tuple2<Integer,Integer>,Double> tuple =
        new RatingToTupleDouble().call(new Rating(1, 2, 3.0));
    assertEquals(1, tuple._1()._1().intValue());
    assertEquals(2, tuple._1()._2().intValue());
    assertEquals(3.0, tuple._2().doubleValue());
  }
",non-flaky,5
176908,OryxProject_oryx,ALSHyperParamTuningIT.testHyperParameterTuning,"  @Test
  public void testHyperParameterTuning() throws Exception {
    Path tempDir = getTempDir();
    Path dataDir =  tempDir.resolve(""data"");
    Path modelDir = tempDir.resolve(""model"");

    Map<String,Object> overlayConfig = new HashMap<>();
    overlayConfig.put(""oryx.batch.update-class"", ALSUpdate.class.getName());
    ConfigUtils.set(overlayConfig, ""oryx.batch.storage.data-dir"", dataDir);
    ConfigUtils.set(overlayConfig, ""oryx.batch.storage.model-dir"", modelDir);
    overlayConfig.put(""oryx.batch.streaming.generation-interval-sec"", GEN_INTERVAL_SEC);
    overlayConfig.put(""oryx.batch.streaming.block-interval-sec"", BLOCK_INTERVAL_SEC);
    // Choose pairs of values where the best is predictable
    overlayConfig.put(""oryx.als.hyperparams.features"", ""[1,"" + TEST_FEATURES + ""]"");
    overlayConfig.put(""oryx.ml.eval.candidates"", 2);
    overlayConfig.put(""oryx.ml.eval.parallelism"", 2);
    Config config = ConfigUtils.overlayOn(overlayConfig, getConfig());

    startMessaging();

    startServerProduceConsumeTopics(config,
                                    new FeaturesALSDataGenerator(TEST_ELEMENTS,
                                                                 TEST_ELEMENTS,
                                                                 TEST_FEATURES),
                                    DATA_TO_WRITE,
                                    WRITE_INTERVAL_MSEC);

    List<Path> modelInstanceDirs = IOUtils.listFiles(modelDir, ""*"");

    checkIntervals(modelInstanceDirs.size(), DATA_TO_WRITE, WRITE_INTERVAL_MSEC, GEN_INTERVAL_SEC);

    Path latestModelDir = modelInstanceDirs.get(modelInstanceDirs.size() - 1);
    Path modelFile = latestModelDir.resolve(MLUpdate.MODEL_FILE_NAME);
    assertTrue(""No such model file: "" + modelFile, Files.exists(modelFile));

    PMML pmml = PMMLUtils.read(modelFile);
    assertEquals(8, pmml.getExtensions().size());
    assertNotNull(AppPMMLUtils.getExtensionValue(pmml, ""X""));
    assertNotNull(AppPMMLUtils.getExtensionValue(pmml, ""Y""));
    Map<String,Object> expected = new HashMap<>();
    expected.put(""features"", TEST_FEATURES);
    expected.put(""lambda"", 0.001);
    expected.put(""implicit"", true);
    expected.put(""alpha"", 1.0);
    checkExtensions(pmml, expected);
  }
",non-flaky,5
176909,OryxProject_oryx,ALSModelContentIT.testModelContent,"  @Test
  public void testModelContent() throws Exception {
    Path tempDir = getTempDir();
    Path modelDir = tempDir.resolve(""model"");

    Map<String,Object> overlayConfig = new HashMap<>();
    overlayConfig.put(""oryx.batch.update-class"", ALSUpdate.class.getName());
    ConfigUtils.set(overlayConfig, ""oryx.batch.storage.data-dir"", tempDir.resolve(""data""));
    ConfigUtils.set(overlayConfig, ""oryx.batch.storage.model-dir"", modelDir);
    overlayConfig.put(""oryx.batch.streaming.generation-interval-sec"", 10);
    overlayConfig.put(""oryx.batch.streaming.block-interval-sec"", 1);
    overlayConfig.put(""oryx.ml.eval.test-fraction"", 0);
    overlayConfig.put(""oryx.als.implicit"", false);
    overlayConfig.put(""oryx.als.hyperparams.lambda"", 0.0001);
    overlayConfig.put(""oryx.als.hyperparams.features"", 2);
    Config config = ConfigUtils.overlayOn(overlayConfig, getConfig());

    startMessaging();

    ModelContentDataGenerator generator = new ModelContentDataGenerator();
    List<Pair<String, String>> updates = startServerProduceConsumeTopics(
        config,
        generator,
        generator.getSentData().size(),
        20);

    Collection<String> modelUsers = null;
    Collection<String> modelItems = null;
    Map<String,Collection<String>> knownUsersItems = new HashMap<>();

    for (Pair<String, String> km : updates) {
      String type = km.getFirst();
      String value = km.getSecond();
      log.debug(""{} = {}"", type, value);

      if (""UP"".equals(type)) {

        List<?> update = MAPPER.readValue(value, List.class);
        if (""X"".equals(update.get(0).toString())) {
          String userID = update.get(1).toString();
          @SuppressWarnings(""unchecked"")
          Collection<String> userKnownItems = (Collection<String>) update.get(3);
          knownUsersItems.put(userID, new ArrayList<>(userKnownItems));
        }

      } else { // ""MODEL""

        PMML pmml = PMMLUtils.fromString(value);
        modelUsers = AppPMMLUtils.getExtensionContent(pmml, ""XIDs"");
        modelItems = AppPMMLUtils.getExtensionContent(pmml, ""YIDs"");

      }

    }

    assertContainsSame(Arrays.asList(""A0"", ""B1"", ""C2""), modelUsers);
    assertContainsSame(Arrays.asList(""A0"", ""B1"", ""C2"", ""D3""), modelItems);
    assertContainsSame(Arrays.asList(""A0"", ""B1"", ""C2"", ""D3""), knownUsersItems.get(""A0""));
    assertContainsSame(Arrays.asList(""C2"", ""D3""), knownUsersItems.get(""B1""));
    assertContainsSame(Arrays.asList(""D3""), knownUsersItems.get(""C2""));
  }
",non-flaky,5
176910,OryxProject_oryx,ALSUpdateIT.testALS,"  @Test
  public void testALS() throws Exception {
    Path tempDir = getTempDir();
    Path dataDir =  tempDir.resolve(""data"");
    Path modelDir = tempDir.resolve(""model"");

    Map<String,Object> overlayConfig = new HashMap<>();
    overlayConfig.put(""oryx.batch.update-class"", ALSUpdate.class.getName());
    ConfigUtils.set(overlayConfig, ""oryx.batch.storage.data-dir"", dataDir);
    ConfigUtils.set(overlayConfig, ""oryx.batch.storage.model-dir"", modelDir);
    overlayConfig.put(""oryx.batch.streaming.generation-interval-sec"", GEN_INTERVAL_SEC);
    overlayConfig.put(""oryx.batch.streaming.block-interval-sec"", BLOCK_INTERVAL_SEC);
    overlayConfig.put(""oryx.als.implicit"", false);
    overlayConfig.put(""oryx.als.hyperparams.lambda"", LAMBDA);
    overlayConfig.put(""oryx.als.hyperparams.features"", FEATURES);
    Config config = ConfigUtils.overlayOn(overlayConfig, getConfig());

    startMessaging();

    List<Pair<String,String>> updates = startServerProduceConsumeTopics(
        config,
        new RandomALSDataGenerator(NUM_USERS_ITEMS, NUM_USERS_ITEMS, 1, 5),
        DATA_TO_WRITE,
        WRITE_INTERVAL_MSEC);

    List<Path> modelInstanceDirs = IOUtils.listFiles(modelDir, ""*"");

    int generations = modelInstanceDirs.size();
    checkIntervals(generations, DATA_TO_WRITE, WRITE_INTERVAL_MSEC, GEN_INTERVAL_SEC);

    List<Collection<String>> userIDs = new ArrayList<>();
    userIDs.add(Collections.<String>emptySet()); // Add dummy empty set as prior value
    List<Collection<String>> productIDs = new ArrayList<>();
    productIDs.add(Collections.<String>emptySet()); // Add dummy empty set as prior value

    for (Path modelInstanceDir : modelInstanceDirs) {
      Path modelFile = modelInstanceDir.resolve(MLUpdate.MODEL_FILE_NAME);
      assertTrue(""Model file should exist: "" + modelFile, Files.exists(modelFile));
      assertTrue(""Model file should not be empty: "" + modelFile, Files.size(modelFile) > 0);
      PMMLUtils.read(modelFile); // Shouldn't throw exception
      Path xDir = modelInstanceDir.resolve(""X"");
      assertTrue(Files.exists(xDir));
      userIDs.add(checkFeatures(xDir, userIDs.get(userIDs.size() - 1)));
      Path yDir = modelInstanceDir.resolve(""Y"");
      assertTrue(Files.exists(yDir));
      productIDs.add(checkFeatures(yDir, productIDs.get(productIDs.size() - 1)));
    }
    // Remove dummy empty sets
    userIDs.remove(0);
    productIDs.remove(0);

    Collection<String> expectedUsers = null;
    Collection<String> expectedProducts = null;
    Collection<String> seenUsers = null;
    Collection<String> seenProducts = null;
    Collection<String> lastModelUsers = null;
    Collection<String> lastModelProducts = null;
    int whichGeneration = -1;
    for (Pair<String,String> km : updates) {

      String type = km.getFirst();
      String value = km.getSecond();

      log.debug(""{} = {}"", type, value);

      boolean isModel = ""MODEL"".equals(type);
      boolean isUpdate = ""UP"".equals(type);
      assertTrue(isModel || isUpdate);

      if (isUpdate) {

        assertNotNull(seenUsers);
        assertNotNull(seenProducts);

        List<?> update = MAPPER.readValue(value, List.class);
        // First field is X or Y, depending on whether it's a user or item vector
        String whichMatrixField = update.get(0).toString();
        boolean isUser = ""X"".equals(whichMatrixField);
        boolean isProduct = ""Y"".equals(whichMatrixField);
        // Next is user/item ID
        String id = update.get(1).toString();
        assertTrue(isUser || isProduct);
        if (isUser) {
          seenUsers.add(id);
        } else {
          seenProducts.add(id);
        }
        // Verify that feature vector are valid floats
        for (float f : MAPPER.convertValue(update.get(2), float[].class)) {
          assertTrue(!Float.isNaN(f) && !Float.isInfinite(f));
        }

        if (isUser) {
          // Only known-items for users exist now, not known users for items
          @SuppressWarnings(""unchecked"")
          Collection<String> knownUsersItems = (Collection<String>) update.get(3);
          assertFalse(knownUsersItems.isEmpty());
          for (String known : knownUsersItems) {
            int i = ALSUtilsTest.stringIDtoID(known);
            assertTrue(i >= 0 && i < NUM_USERS_ITEMS);
          }
        }

      } else {

        PMML pmml = PMMLUtils.fromString(value);

        checkHeader(pmml.getHeader());

        assertEquals(7, pmml.getExtensions().size());
        Map<String,Object> expected = new HashMap<>();
        expected.put(""features"", FEATURES);
        expected.put(""lambda"", LAMBDA);
        expected.put(""implicit"", false);
        checkExtensions(pmml, expected);

        // See if users/item sets seen in updates match what was expected from output
        assertContainsSame(expectedUsers, seenUsers);
        assertContainsSame(expectedProducts, seenProducts);

        // Also check key sets reported in model
        assertContainsSame(expectedUsers, lastModelUsers);
        assertContainsSame(expectedProducts, lastModelProducts);

        // Update for next round
        whichGeneration++;
        expectedUsers = userIDs.get(whichGeneration);
        expectedProducts = productIDs.get(whichGeneration);
        seenUsers = new HashSet<>();
        seenProducts = new HashSet<>();
        lastModelUsers = AppPMMLUtils.getExtensionContent(pmml, ""XIDs"");
        lastModelProducts = AppPMMLUtils.getExtensionContent(pmml, ""YIDs"");

      }
    }

  }
",non-flaky,5
176911,OryxProject_oryx,KMeansUpdateIT.testKMeans,"  @Test
  public void testKMeans() throws Exception {
    Path tempDir = getTempDir();
    Path dataDir = tempDir.resolve(""data"");
    Path modelDir = tempDir.resolve(""model"");

    Map<String,Object> overlayConfig = new HashMap<>();
    overlayConfig.put(""oryx.batch.update-class"", KMeansUpdate.class.getName());
    ConfigUtils.set(overlayConfig, ""oryx.batch.storage.data-dir"", dataDir);
    ConfigUtils.set(overlayConfig, ""oryx.batch.storage.model-dir"", modelDir);
    overlayConfig.put(""oryx.batch.streaming.generation-interval-sec"", GEN_INTERVAL_SEC);
    overlayConfig.put(""oryx.batch.streaming.block-interval-sec"", BLOCK_INTERVAL_SEC);
    overlayConfig.put(""oryx.kmeans.hyperparams.k"", NUM_CLUSTERS);
    overlayConfig.put(""oryx.kmeans.iterations"", 5);
    overlayConfig.put(""oryx.input-schema.num-features"", NUM_FEATURES);
    overlayConfig.put(""oryx.input-schema.categorical-features"", ""[]"");
    overlayConfig.put(""oryx.kmeans.evaluation-strategy"", EVALUATION_STRATEGY);

    Config config = ConfigUtils.overlayOn(overlayConfig, getConfig());

    startMessaging();

    List<Pair<String, String>> updates = startServerProduceConsumeTopics(
        config,
        new RandomKMeansDataGenerator(NUM_FEATURES),
        DATA_TO_WRITE,
        WRITE_INTERVAL_MSEC);

    List<Path> modelInstanceDirs = IOUtils.listFiles(modelDir, ""*"");

    int generations = modelInstanceDirs.size();
    checkIntervals(generations, DATA_TO_WRITE, WRITE_INTERVAL_MSEC, GEN_INTERVAL_SEC);

    for (Path modelInstanceDir : modelInstanceDirs) {
      Path modelFile = modelInstanceDir.resolve(MLUpdate.MODEL_FILE_NAME);
      assertTrue(""Model file should exist: "" + modelFile, Files.exists(modelFile));
      assertTrue(""Model file should not be empty: "" + modelFile, Files.size(modelFile) > 0);
      PMMLUtils.read(modelFile); // Shouldn't throw exception
    }

    InputSchema schema = new InputSchema(config);

    for (Pair<String,String> km : updates) {

      String type = km.getFirst();
      String value = km.getSecond();

      assertEquals(""MODEL"", type);

      PMML pmml = PMMLUtils.fromString(value);

      checkHeader(pmml.getHeader());

      checkDataDictionary(schema, pmml.getDataDictionary());

      Model rootModel = pmml.getModels().get(0);

      ClusteringModel clusteringModel = (ClusteringModel) rootModel;

      // Check if Basic hyperparameters match
      assertEquals(NUM_CLUSTERS, clusteringModel.getNumberOfClusters().intValue());
      assertEquals(NUM_CLUSTERS, clusteringModel.getClusters().size());
      assertEquals(NUM_FEATURES, clusteringModel.getClusteringFields().size());
      assertEquals(ComparisonMeasure.Kind.DISTANCE,
                   clusteringModel.getComparisonMeasure().getKind());
      assertEquals(NUM_FEATURES, clusteringModel.getClusters().get(0).getArray().getN().intValue());
      for (Cluster cluster : clusteringModel.getClusters()) {
        assertTrue(cluster.getSize() > 0);
      }
    }
  }
",non-flaky,5
176912,OryxProject_oryx,KMeansHyperParamTuningIT.testKMeans,"  @Test
  public void testKMeans() throws Exception {
    Path tempDir = getTempDir();
    Path dataDir = tempDir.resolve(""data"");
    Path modelDir = tempDir.resolve(""model"");

    Map<String,Object> overlayConfig = new HashMap<>();
    overlayConfig.put(""oryx.batch.update-class"", KMeansUpdate.class.getName());
    ConfigUtils.set(overlayConfig, ""oryx.batch.storage.data-dir"", dataDir);
    ConfigUtils.set(overlayConfig, ""oryx.batch.storage.model-dir"", modelDir);
    overlayConfig.put(""oryx.batch.streaming.generation-interval-sec"", GEN_INTERVAL_SEC);
    overlayConfig.put(""oryx.batch.streaming.block-interval-sec"", BLOCK_INTERVAL_SEC);
    overlayConfig.put(""oryx.kmeans.hyperparams.k"", ""[2,100]"");
    overlayConfig.put(""oryx.kmeans.iterations"", 20);
    overlayConfig.put(""oryx.kmeans.runs"", 20);
    overlayConfig.put(""oryx.input-schema.num-features"", NUM_FEATURES);
    overlayConfig.put(""oryx.input-schema.categorical-features"", ""[]"");
    overlayConfig.put(""oryx.ml.eval.candidates"", 3);
    overlayConfig.put(""oryx.ml.eval.parallelism"", 2);
    overlayConfig.put(""oryx.kmeans.evaluation-strategy"", EVALUATION_STRATEGY);

    Config config = ConfigUtils.overlayOn(overlayConfig, getConfig());

    startMessaging();

    startServerProduceConsumeTopics(
        config,
        new RandomKMeansDataGenerator(NUM_FEATURES),
        DATA_TO_WRITE,
        WRITE_INTERVAL_MSEC);

    List<Path> modelInstanceDirs = IOUtils.listFiles(modelDir, ""*"");

    checkIntervals(modelInstanceDirs.size(), DATA_TO_WRITE, WRITE_INTERVAL_MSEC, GEN_INTERVAL_SEC);

    Path latestModelDir = modelInstanceDirs.get(modelInstanceDirs.size() - 1);
    Path modelFile = latestModelDir.resolve(MLUpdate.MODEL_FILE_NAME);
    assertTrue(""No such model file: "" + modelFile, Files.exists(modelFile));

    PMML pmml = PMMLUtils.read(modelFile);
    Model rootModel = pmml.getModels().get(0);
    ClusteringModel clusteringModel = (ClusteringModel) rootModel;

    // Should have picked highest k
    assertEquals(100, clusteringModel.getNumberOfClusters().intValue());
  }
",non-flaky,5
176913,OryxProject_oryx,KMeansEvalIT.testFetchSampleEvalData,"  @Test
  public void testFetchSampleEvalData() {
    JavaRDD<Vector> evalData = SilhouetteCoefficient.fetchSampleData(getRddOfVectors());
    assertEquals(6, evalData.count());
  }
",non-flaky,5
176914,OryxProject_oryx,KMeansEvalIT.testDunnIndexForClustering,"  @Test
  public void testDunnIndexForClustering() {
    List<ClusterInfo> clusters = getClusters();
    DunnIndex dunnIndex = new DunnIndex(clusters);
    double eval = dunnIndex.evaluate(getRddOfVectors());
    log.info(""Dunn Index for {} clusters: {}"", clusters.size(), eval);
    assertEquals(1.7142857142857142, eval);
  }
",non-flaky,5
176915,OryxProject_oryx,KMeansEvalIT.testDaviesBouldinIndexForClustering,"  @Test
  public void testDaviesBouldinIndexForClustering() {
    List<ClusterInfo> clusters = getClusters();
    DaviesBouldinIndex daviesBouldinIndex = new DaviesBouldinIndex(clusters);
    double eval = daviesBouldinIndex.evaluate(getRddOfVectors());
    log.info(""Davies Bouldin Index for {} clusters: {}"", clusters.size(), eval);
    assertEquals(0.638888888888889, eval);
  }
",non-flaky,5
176916,OryxProject_oryx,KMeansEvalIT.testSilhouetteCoefficientForClustering,"  @Test
  public void testSilhouetteCoefficientForClustering() {
    List<ClusterInfo> clusters = getClusters();
    SilhouetteCoefficient silhouetteCoefficient = new SilhouetteCoefficient(clusters);
    double eval = silhouetteCoefficient.evaluate(getRddOfVectors());
    log.info(""Silhouette Coefficient for {} clusters: {}"", clusters.size(), eval);
    assertEquals(0.48484126984126985, eval);
  }
",non-flaky,5
176917,OryxProject_oryx,KMeansEvalIT.testComputeSilhouetteCoefficient,"  @Test
  public void testComputeSilhouetteCoefficient() {
    assertEquals(5.0, SilhouetteCoefficient.calcSilhouetteCoefficient(-0.8, 0.2));
    assertEquals(-1.25, SilhouetteCoefficient.calcSilhouetteCoefficient(0.8, -0.2));
    assertEquals(0.0, SilhouetteCoefficient.calcSilhouetteCoefficient(1.5, 1.5));
    assertEquals(1.0, SilhouetteCoefficient.calcSilhouetteCoefficient(1.5, Double.POSITIVE_INFINITY));
    assertEquals(-1.0, SilhouetteCoefficient.calcSilhouetteCoefficient(Double.POSITIVE_INFINITY, 1.5));
  }
",non-flaky,5
176918,OryxProject_oryx,RDFNumericHyperParamTuningIT.testRDF,"  @Test
  public void testRDF() throws Exception {
    Path tempDir = getTempDir();
    Path dataDir = tempDir.resolve(""data"");
    Path modelDir = tempDir.resolve(""model"");

    Map<String,Object> overlayConfig = new HashMap<>();
    overlayConfig.put(""oryx.batch.update-class"", RDFUpdate.class.getName());
    ConfigUtils.set(overlayConfig, ""oryx.batch.storage.data-dir"", dataDir);
    ConfigUtils.set(overlayConfig, ""oryx.batch.storage.model-dir"", modelDir);
    overlayConfig.put(""oryx.batch.streaming.generation-interval-sec"", GEN_INTERVAL_SEC);
    overlayConfig.put(""oryx.batch.streaming.block-interval-sec"", BLOCK_INTERVAL_SEC);
    overlayConfig.put(""oryx.rdf.num-trees"", NUM_TREES);
    // Low values like 1 are deliberately bad, won't work
    overlayConfig.put(""oryx.rdf.hyperparams.max-depth"", ""[1,"" + MAX_DEPTH + ""]"");
    overlayConfig.put(""oryx.rdf.hyperparams.max-split-candidates"", MAX_SPLIT_CANDIDATES);
    overlayConfig.put(""oryx.rdf.hyperparams.impurity"", IMPURITY);
    overlayConfig.put(""oryx.input-schema.num-features"", 5);
    overlayConfig.put(""oryx.input-schema.numeric-features"", ""[\""4\""]"");
    overlayConfig.put(""oryx.input-schema.id-features"", ""[\""0\""]"");
    overlayConfig.put(""oryx.input-schema.target-feature"", ""\""4\"""");
    overlayConfig.put(""oryx.ml.eval.candidates"", 2);
    overlayConfig.put(""oryx.ml.eval.parallelism"", 2);
    Config config = ConfigUtils.overlayOn(overlayConfig, getConfig());

    startMessaging();

    startServerProduceConsumeTopics(
        config,
        new RandomNumericRDFDataGenerator(3),
        DATA_TO_WRITE,
        WRITE_INTERVAL_MSEC);

    List<Path> modelInstanceDirs = IOUtils.listFiles(modelDir, ""*"");

    checkIntervals(modelInstanceDirs.size(), DATA_TO_WRITE, WRITE_INTERVAL_MSEC, GEN_INTERVAL_SEC);

    Path latestModelDir = modelInstanceDirs.get(modelInstanceDirs.size() - 1);
    Path modelFile = latestModelDir.resolve(MLUpdate.MODEL_FILE_NAME);
    assertTrue(""No such model file: "" + modelFile, Files.exists(modelFile));

    PMML pmml = PMMLUtils.read(modelFile);

    assertEquals(3, pmml.getExtensions().size());
    Map<String,Object> expected = new HashMap<>();
    expected.put(""maxSplitCandidates"", MAX_SPLIT_CANDIDATES);
    expected.put(""maxDepth"", MAX_DEPTH);
    expected.put(""impurity"", IMPURITY);
    checkExtensions(pmml, expected);

    Pair<DecisionForest,CategoricalValueEncodings> forestEncoding = RDFPMMLUtils.read(pmml);
    DecisionForest forest = forestEncoding.getFirst();
    CategoricalValueEncodings encoding = forestEncoding.getSecond();

    for (int f1 = 0; f1 <= 1; f1++) {
      for (int f2 = 0; f2 <= 1; f2++) {
        for (int f3 = 0; f3 <= 1; f3++) {
          NumericPrediction prediction = (NumericPrediction) forest.predict(new Example(null,
              null,
              CategoricalFeature.forEncoding(encoding.getValueEncodingMap(1).get(f1 == 1 ? ""A"" : ""B"")),
              CategoricalFeature.forEncoding(encoding.getValueEncodingMap(2).get(f2 == 1 ? ""A"" : ""B"")),
              CategoricalFeature.forEncoding(encoding.getValueEncodingMap(3).get(f3 == 1 ? ""A"" : ""B""))));
          int expectedCount = f1 + f2 + f3;
          if (expectedCount == 3) {
            // TODO this might be a bug in Spark RDF. The tree never creates a node for all
            // positive classes even though it should. Plenty of nodes, info gain, etc.
            assertEquals(2, Math.round(prediction.getPrediction()));
          } else {
            assertEquals(expectedCount, Math.round(prediction.getPrediction()));
          }
        }
      }
    }

  }
",non-flaky,5
176919,OryxProject_oryx,RDFUpdateIT.testRDF,"  @Test
  public void testRDF() throws Exception {
    Path tempDir = getTempDir();
    Path dataDir = tempDir.resolve(""data"");
    Path modelDir = tempDir.resolve(""model"");

    Map<String,Object> overlayConfig = new HashMap<>();
    overlayConfig.put(""oryx.batch.update-class"", RDFUpdate.class.getName());
    ConfigUtils.set(overlayConfig, ""oryx.batch.storage.data-dir"", dataDir);
    ConfigUtils.set(overlayConfig, ""oryx.batch.storage.model-dir"", modelDir);
    overlayConfig.put(""oryx.batch.streaming.generation-interval-sec"", GEN_INTERVAL_SEC);
    overlayConfig.put(""oryx.batch.streaming.block-interval-sec"", BLOCK_INTERVAL_SEC);
    overlayConfig.put(""oryx.rdf.num-trees"", NUM_TREES);
    overlayConfig.put(""oryx.rdf.hyperparams.max-depth"", MAX_DEPTH);
    overlayConfig.put(""oryx.rdf.hyperparams.max-split-candidates"", MAX_SPLIT_CANDIDATES);
    overlayConfig.put(""oryx.rdf.hyperparams.impurity"", IMPURITY);
    overlayConfig.put(""oryx.input-schema.num-features"", 5);
    overlayConfig.put(""oryx.input-schema.categorical-features"", ""[\""4\""]"");
    overlayConfig.put(""oryx.input-schema.id-features"", ""[\""0\""]"");
    overlayConfig.put(""oryx.input-schema.target-feature"", ""\""4\"""");

    Config config = ConfigUtils.overlayOn(overlayConfig, getConfig());

    startMessaging();

    List<Pair<String, String>> updates = startServerProduceConsumeTopics(
        config,
        new RandomCategoricalRDFDataGenerator(3),
        DATA_TO_WRITE,
        WRITE_INTERVAL_MSEC);

    List<Path> modelInstanceDirs = IOUtils.listFiles(modelDir, ""*"");

    int generations = modelInstanceDirs.size();
    checkIntervals(generations, DATA_TO_WRITE, WRITE_INTERVAL_MSEC, GEN_INTERVAL_SEC);

    for (Path modelInstanceDir : modelInstanceDirs) {
      Path modelFile = modelInstanceDir.resolve(MLUpdate.MODEL_FILE_NAME);
      assertTrue(""Model file should exist: "" + modelFile, Files.exists(modelFile));
      assertTrue(""Model file should not be empty: "" + modelFile, Files.size(modelFile) > 0);
      PMMLUtils.read(modelFile); // Shouldn't throw exception
    }

    InputSchema schema = new InputSchema(config);

    for (Pair<String,String> km : updates) {

      String type = km.getFirst();
      String value = km.getSecond();

      assertEquals(""MODEL"", type);

      PMML pmml = PMMLUtils.fromString(value);

      checkHeader(pmml.getHeader());

      assertEquals(3, pmml.getExtensions().size());
      Map<String,Object> expected = new HashMap<>();
      expected.put(""maxDepth"", MAX_DEPTH);
      expected.put(""maxSplitCandidates"", MAX_SPLIT_CANDIDATES);
      expected.put(""impurity"", IMPURITY);
      checkExtensions(pmml, expected);

      checkDataDictionary(schema, pmml.getDataDictionary());

      Model rootModel = pmml.getModels().get(0);
      if (rootModel instanceof TreeModel) {
        assertEquals(NUM_TREES, 1);
        TreeModel treeModel = (TreeModel) rootModel;
        checkTreeModel(treeModel);
      } else if (rootModel instanceof MiningModel) {
        MiningModel miningModel = (MiningModel) rootModel;
        Segmentation segmentation = miningModel.getSegmentation();
        if (schema.isClassification()) {
          assertEquals(MultipleModelMethodType.WEIGHTED_MAJORITY_VOTE,
                       segmentation.getMultipleModelMethod());
        } else {
          assertEquals(MultipleModelMethodType.WEIGHTED_AVERAGE,
                       segmentation.getMultipleModelMethod());
        }
        List<Segment> segments = segmentation.getSegments();
        assertEquals(NUM_TREES, segments.size());
        for (int i = 0; i < segments.size(); i++) {
          Segment segment = segments.get(i);
          assertEquals(Integer.toString(i), segment.getId());
          assertTrue(segment.getPredicate() instanceof True);
          assertEquals(1.0, segment.getWeight());
          assertTrue(segment.getModel() instanceof TreeModel);
          checkTreeModel((TreeModel) segment.getModel());
        }

      } else {
        fail(""Wrong model type: "" + rootModel.getClass());
        return;
      }

      if (schema.isClassification()) {
        assertEquals(MiningFunctionType.CLASSIFICATION, rootModel.getFunctionName());
      } else {
        assertEquals(MiningFunctionType.REGRESSION, rootModel.getFunctionName());
      }

      checkMiningSchema(schema, rootModel.getMiningSchema());

    }
  }
",non-flaky,5
176920,OryxProject_oryx,RDFCategoricalHyperParamTuningIT.testRDF,"  @Test
  public void testRDF() throws Exception {
    Path tempDir = getTempDir();
    Path dataDir = tempDir.resolve(""data"");
    Path modelDir = tempDir.resolve(""model"");

    Map<String,Object> overlayConfig = new HashMap<>();
    overlayConfig.put(""oryx.batch.update-class"", RDFUpdate.class.getName());
    ConfigUtils.set(overlayConfig, ""oryx.batch.storage.data-dir"", dataDir);
    ConfigUtils.set(overlayConfig, ""oryx.batch.storage.model-dir"", modelDir);
    overlayConfig.put(""oryx.batch.streaming.generation-interval-sec"", GEN_INTERVAL_SEC);
    overlayConfig.put(""oryx.batch.streaming.block-interval-sec"", BLOCK_INTERVAL_SEC);
    overlayConfig.put(""oryx.rdf.num-trees"", 10);
    overlayConfig.put(""oryx.rdf.hyperparams.max-depth"", MAX_DEPTH);
    // Low values like 1 are deliberately bad, won't work
    overlayConfig.put(""oryx.rdf.hyperparams.max-depth"", ""[1,"" + MAX_DEPTH + ""]"");
    overlayConfig.put(""oryx.rdf.hyperparams.max-split-candidates"", MAX_SPLIT_CANDIDATES);
    overlayConfig.put(""oryx.input-schema.num-features"", 5);
    overlayConfig.put(""oryx.input-schema.categorical-features"", ""[\""4\""]"");
    overlayConfig.put(""oryx.input-schema.id-features"", ""[\""0\""]"");
    overlayConfig.put(""oryx.input-schema.target-feature"", ""\""4\"""");
    overlayConfig.put(""oryx.ml.eval.candidates"", 3);
    overlayConfig.put(""oryx.ml.eval.parallelism"", 2);
    Config config = ConfigUtils.overlayOn(overlayConfig, getConfig());

    startMessaging();

    startServerProduceConsumeTopics(
        config,
        new RandomCategoricalRDFDataGenerator(3),
        DATA_TO_WRITE,
        WRITE_INTERVAL_MSEC);

    List<Path> modelInstanceDirs = IOUtils.listFiles(modelDir, ""*"");

    checkIntervals(modelInstanceDirs.size(), DATA_TO_WRITE, WRITE_INTERVAL_MSEC, GEN_INTERVAL_SEC);

    Path latestModelDir = modelInstanceDirs.get(modelInstanceDirs.size() - 1);
    Path modelFile = latestModelDir.resolve(MLUpdate.MODEL_FILE_NAME);
    assertTrue(""No such model file: "" + modelFile, Files.exists(modelFile));

    PMML pmml = PMMLUtils.read(modelFile);

    assertEquals(3, pmml.getExtensions().size());
    Map<String,Object> expected = new HashMap<>();
    expected.put(""maxSplitCandidates"", MAX_SPLIT_CANDIDATES);
    expected.put(""maxDepth"", MAX_DEPTH);
    expected.put(""impurity"", IMPURITY);
    checkExtensions(pmml, expected);

    Pair<DecisionForest,CategoricalValueEncodings> forestEncoding = RDFPMMLUtils.read(pmml);
    DecisionForest forest = forestEncoding.getFirst();
    CategoricalValueEncodings encoding = forestEncoding.getSecond();
    Map<String,Integer> targetEncoding = encoding.getValueEncodingMap(4);

    int[] zeroOne = { 0, 1 };
    for (int f1 : zeroOne) {
      for (int f2 : zeroOne) {
        for (int f3 : zeroOne) {
          CategoricalPrediction prediction =
              (CategoricalPrediction) forest.predict(new Example(null,
                                                                 null,
                                                                 NumericFeature.forValue(f1),
                                                                 NumericFeature.forValue(f2),
                                                                 NumericFeature.forValue(f3)));
          boolean expectedPositive = f1 == 1 && f2 == 1 && f3 == 1;
          assertEquals(targetEncoding.get(Boolean.toString(expectedPositive)).intValue(),
                       prediction.getMostProbableCategoryEncoding());
        }
      }
    }

  }
",non-flaky,5
176921,OryxProject_oryx,MultiRescorerProviderTest.testMultiRecommendRescorer,"  @Test
  public void testMultiRecommendRescorer() {
    RescorerProvider multi = new MultiRescorerProvider(
        new SimpleModRescorerProvider(2), new SimpleModRescorerProvider(3));
    
    Rescorer provider = multi.getRecommendRescorer(Collections.singletonList(""ABCDE""), null);
    assertNull(provider);

    Rescorer provider2 = multi.getRecommendRescorer(Collections.singletonList(""AB""), null);
    assertNotNull(provider2);
    assertFalse(provider2 instanceof MultiRescorer);
    assertTrue(provider2.isFiltered(""ABC""));
    assertFalse(provider2.isFiltered(""AB""));

    Rescorer provider3 = multi.getRecommendRescorer(Collections.singletonList(""ABCDEF""), null);
    assertNotNull(provider3);
    assertTrue(provider3 instanceof MultiRescorer);
    assertTrue(provider3.isFiltered(""ABC""));
    assertTrue(provider3.isFiltered(""AB""));
    assertFalse(provider3.isFiltered(""ABCDEFABCDEF""));
  }
",non-flaky,5
176922,OryxProject_oryx,MultiRescorerProviderTest.testMultiRecommendToAnonymousRescorer,"  @Test
  public void testMultiRecommendToAnonymousRescorer() {
    RescorerProvider multi = new MultiRescorerProvider(
        new SimpleModRescorerProvider(2), new SimpleModRescorerProvider(3));
    
    Rescorer provider = multi.getRecommendToAnonymousRescorer(
        Collections.singletonList(""ABCDE""), null);
    assertNull(provider);

    Rescorer provider2 =
        multi.getRecommendToAnonymousRescorer(Collections.singletonList(""AB""), null);
    assertNotNull(provider2);
    assertFalse(provider2 instanceof MultiRescorer);
    assertTrue(provider2.isFiltered(""ABC""));
    assertFalse(provider2.isFiltered(""AB""));

    Rescorer provider3 =
        multi.getRecommendToAnonymousRescorer(Collections.singletonList(""ABCDEF""), null);
    assertNotNull(provider3);
    assertTrue(provider3 instanceof MultiRescorer);
    assertTrue(provider3.isFiltered(""ABC""));
    assertTrue(provider3.isFiltered(""AB""));
    assertFalse(provider3.isFiltered(""ABCDEF""));
  }
",non-flaky,5
176923,OryxProject_oryx,MultiRescorerProviderTest.testMultiMostPopularItemsRescorer,"  @Test
  public void testMultiMostPopularItemsRescorer() {
    RescorerProvider multi = new MultiRescorerProvider(
        new SimpleModRescorerProvider(2), new SimpleModRescorerProvider(3));
    Rescorer provider = multi.getMostPopularItemsRescorer(null);
    assertNotNull(provider);
    assertTrue(provider instanceof MultiRescorer);
    assertTrue(provider.isFiltered(""ABC""));
    assertTrue(provider.isFiltered(""AB""));
    assertFalse(provider.isFiltered(""ABCDEF""));
  }
",non-flaky,5
176924,OryxProject_oryx,MultiRescorerProviderTest.testMultiMostActiveUsersRescorer,"  @Test
  public void testMultiMostActiveUsersRescorer() {
    RescorerProvider multi = new MultiRescorerProvider(
        new SimpleModRescorerProvider(2), new SimpleModRescorerProvider(3));
    Rescorer provider = multi.getMostActiveUsersRescorer(null);
    assertNotNull(provider);
    assertTrue(provider instanceof MultiRescorer);
    assertTrue(provider.isFiltered(""ABC""));
    assertTrue(provider.isFiltered(""AB""));
    assertFalse(provider.isFiltered(""ABCDEF""));
  }
",non-flaky,5
176925,OryxProject_oryx,MultiRescorerProviderTest.testMultiMostSimilarItemsRescorer,"  @Test
  public void testMultiMostSimilarItemsRescorer() {
    RescorerProvider multi = new MultiRescorerProvider(
        new SimpleModRescorerProvider(2), new SimpleModRescorerProvider(3));
    Rescorer provider = multi.getMostSimilarItemsRescorer(null);
    assertNotNull(provider);
    assertTrue(provider instanceof MultiRescorer);
    assertTrue(provider.isFiltered(""ABC""));
    assertTrue(provider.isFiltered(""ABCDE""));
    assertFalse(provider.isFiltered(""ABCDEFABCDEF""));
  }
",non-flaky,5
176926,OryxProject_oryx,AbstractRescorerProviderTest.testDefault,"  @Test
  public void testDefault() {
    RescorerProvider noop = new NullProvider1();
    assertNull(noop.getMostActiveUsersRescorer(null));
    assertNull(noop.getMostPopularItemsRescorer(null));
    assertNull(noop.getMostSimilarItemsRescorer(null));
    assertNull(noop.getRecommendRescorer(null, null));
    assertNull(noop.getRecommendToAnonymousRescorer(null, null));
  }
",non-flaky,5
176927,OryxProject_oryx,AbstractRescorerProviderTest.testLoad,"  @Test
  public void testLoad() {
    RescorerProvider provider = AbstractRescorerProvider.loadRescorerProviders(
        ""com.cloudera.oryx.app.als.NullProvider2"");
    assertTrue(provider instanceof NullProvider2);
    RescorerProvider multiProvider = AbstractRescorerProvider.loadRescorerProviders(
        ""com.cloudera.oryx.app.als.NullProvider1,com.cloudera.oryx.app.als.NullProvider2"");
    assertTrue(multiProvider instanceof MultiRescorerProvider);
  }
",non-flaky,5
176928,OryxProject_oryx,AbstractRescorerProviderTest.testNoClass,"  @Test(expected = IllegalArgumentException.class)
  public void testNoClass() {
    AbstractRescorerProvider.loadRescorerProviders(""noSuchClass"");
  }
",non-flaky,5
176929,OryxProject_oryx,AbstractRescorerProviderTest.testWrongClass,"  @Test(expected = ClassCastException.class)
  public void testWrongClass() {
    AbstractRescorerProvider.loadRescorerProviders(
        ""com.cloudera.oryx.app.als.AbstractRescorerProviderTest"");
  }
",non-flaky,5
176930,OryxProject_oryx,ServingLayerTest.testServingLayer,"  @Test
  public void testServingLayer() throws Exception {
    Map<String,Object> overlay = buildOverlay();
    Config config = ConfigUtils.overlayOn(overlay, ConfigUtils.getDefault());
    doTestServingLayer(config);
  }
",non-flaky,5
176931,OryxProject_oryx,ServingLayerTest.testServingLayerSecure,"  @Test
  public void testServingLayerSecure() throws Exception {
    Path keystoreFile = SecureAPIConfigIT.buildKeystoreFile();
    Map<String,Object> overlay = buildOverlay();
    overlay.put(""oryx.serving.api.keystore-file"", ""\"""" + keystoreFile + ""\"""");
    overlay.put(""oryx.serving.api.keystore-password"", ""oryxpass"");
    Config config = ConfigUtils.overlayOn(overlay, ConfigUtils.getDefault());
    try {
      doTestServingLayer(config);
    } finally {
      Files.delete(Paths.get(config.getString(""oryx.serving.api.keystore-file"")));
    }
  }
",non-flaky,5
177952,aosp-mirror_platform_frameworks_support,FileProviderTest.testStrategyUriSimple,"    @Test
    public void testStrategyUriSimple() throws Exception {
        final SimplePathStrategy strat = new SimplePathStrategy(""authority"");
        strat.addRoot(""tag"", mContext.getFilesDir());

        File file = buildPath(mContext.getFilesDir(), ""file.test"");
        assertEquals(""content://authority/tag/file.test"",
                strat.getUriForFile(file).toString());

        file = buildPath(mContext.getFilesDir(), ""subdir"", ""file.test"");
        assertEquals(""content://authority/tag/subdir/file.test"",
                strat.getUriForFile(file).toString());

        file = buildPath(Environment.getExternalStorageDirectory(), ""file.test"");
        try {
            strat.getUriForFile(file);
            fail(""somehow got uri for file outside roots?"");
        } catch (IllegalArgumentException e) {
        }
    }
",non-flaky,5
177953,aosp-mirror_platform_frameworks_support,FileProviderTest.testStrategyUriJumpOutside,"    @Test
    public void testStrategyUriJumpOutside() throws Exception {
        final SimplePathStrategy strat = new SimplePathStrategy(""authority"");
        strat.addRoot(""tag"", mContext.getFilesDir());

        File file = buildPath(mContext.getFilesDir(), "".."", ""file.test"");
        try {
            strat.getUriForFile(file);
            fail(""file escaped!"");
        } catch (IllegalArgumentException e) {
        }
    }
",non-flaky,5
177954,aosp-mirror_platform_frameworks_support,FileProviderTest.testStrategyUriShortestRoot,"    @Test
    public void testStrategyUriShortestRoot() throws Exception {
        SimplePathStrategy strat = new SimplePathStrategy(""authority"");
        strat.addRoot(""tag1"", mContext.getFilesDir());
        strat.addRoot(""tag2"", new File(""/""));

        File file = buildPath(mContext.getFilesDir(), ""file.test"");
        assertEquals(""content://authority/tag1/file.test"",
                strat.getUriForFile(file).toString());

        strat = new SimplePathStrategy(""authority"");
        strat.addRoot(""tag1"", new File(""/""));
        strat.addRoot(""tag2"", mContext.getFilesDir());

        file = buildPath(mContext.getFilesDir(), ""file.test"");
        assertEquals(""content://authority/tag2/file.test"",
                strat.getUriForFile(file).toString());
    }
",non-flaky,5
177955,aosp-mirror_platform_frameworks_support,FileProviderTest.testStrategyFileSimple,"    @Test
    public void testStrategyFileSimple() throws Exception {
        final SimplePathStrategy strat = new SimplePathStrategy(""authority"");
        strat.addRoot(""tag"", mContext.getFilesDir());

        File expectedRoot = mContext.getFilesDir().getCanonicalFile();
        File file = buildPath(expectedRoot, ""file.test"");
        assertEquals(file.getPath(),
                strat.getFileForUri(Uri.parse(""content://authority/tag/file.test"")).getPath());

        file = buildPath(expectedRoot, ""subdir"", ""file.test"");
        assertEquals(file.getPath(), strat.getFileForUri(
                Uri.parse(""content://authority/tag/subdir/file.test"")).getPath());
    }
",non-flaky,5
177956,aosp-mirror_platform_frameworks_support,FileProviderTest.testStrategyFileJumpOutside,"    @Test
    public void testStrategyFileJumpOutside() throws Exception {
        final SimplePathStrategy strat = new SimplePathStrategy(""authority"");
        strat.addRoot(""tag"", mContext.getFilesDir());

        try {
            strat.getFileForUri(Uri.parse(""content://authority/tag/../file.test""));
            fail(""file escaped!"");
        } catch (SecurityException e) {
        }
    }
",non-flaky,5
177957,aosp-mirror_platform_frameworks_support,FileProviderTest.testStrategyEscaping,"    @Test
    public void testStrategyEscaping() throws Exception {
        final SimplePathStrategy strat = new SimplePathStrategy(""authority"");
        strat.addRoot(""t/g"", mContext.getFilesDir());

        File expectedRoot = mContext.getFilesDir().getCanonicalFile();
        File file = buildPath(expectedRoot, ""lol\""wat?foo&bar"", ""wat.txt"");
        final String expected = ""content://authority/t%2Fg/lol%22wat%3Ffoo%26bar/wat.txt"";

        assertEquals(expected,
                strat.getUriForFile(file).toString());
        assertEquals(file.getPath(),
                strat.getFileForUri(Uri.parse(expected)).getPath());
    }
",non-flaky,5
177958,aosp-mirror_platform_frameworks_support,FileProviderTest.testStrategyExtraParams,"    @Test
    public void testStrategyExtraParams() throws Exception {
        final SimplePathStrategy strat = new SimplePathStrategy(""authority"");
        strat.addRoot(""tag"", mContext.getFilesDir());

        File expectedRoot = mContext.getFilesDir().getCanonicalFile();
        File file = buildPath(expectedRoot, ""file.txt"");
        assertEquals(file.getPath(), strat.getFileForUri(
                Uri.parse(""content://authority/tag/file.txt?extra=foo"")).getPath());
    }
",non-flaky,5
177959,aosp-mirror_platform_frameworks_support,FileProviderTest.testStrategyExtraSeparators,"    @Test
    public void testStrategyExtraSeparators() throws Exception {
        final SimplePathStrategy strat = new SimplePathStrategy(""authority"");
        strat.addRoot(""tag"", mContext.getFilesDir());

        // When canonicalized, the path separators are trimmed
        File inFile = new File(mContext.getFilesDir(), ""//foo//bar//"");
        File expectedRoot = mContext.getFilesDir().getCanonicalFile();
        File outFile = new File(expectedRoot, ""/foo/bar"");
        final String expected = ""content://authority/tag/foo/bar"";

        assertEquals(expected,
                strat.getUriForFile(inFile).toString());
        assertEquals(outFile.getPath(),
                strat.getFileForUri(Uri.parse(expected)).getPath());
    }
",non-flaky,5
177960,aosp-mirror_platform_frameworks_support,FileProviderTest.testQueryProjectionNull,"    @Test
    public void testQueryProjectionNull() throws Exception {
        final File file = new File(mContext.getFilesDir(), TEST_FILE);
        final Uri uri = stageFileAndGetUri(file, TEST_DATA);

        // Verify that null brings out default columns
        Cursor cursor = mResolver.query(uri, null, null, null, null);
        try {
            assertEquals(1, cursor.getCount());
            cursor.moveToFirst();
            assertEquals(TEST_FILE, cursor.getString(cursor.getColumnIndex(DISPLAY_NAME)));
            assertEquals(TEST_DATA.length, cursor.getLong(cursor.getColumnIndex(SIZE)));
        } finally {
            cursor.close();
        }
    }
",non-flaky,5
177961,aosp-mirror_platform_frameworks_support,FileProviderTest.testQueryProjectionOrder,"    @Test
    public void testQueryProjectionOrder() throws Exception {
        final File file = new File(mContext.getFilesDir(), TEST_FILE);
        final Uri uri = stageFileAndGetUri(file, TEST_DATA);

        // Verify that swapped order works
        Cursor cursor = mResolver.query(uri, new String[] {
                SIZE, DISPLAY_NAME }, null, null, null);
        try {
            assertEquals(1, cursor.getCount());
            cursor.moveToFirst();
            assertEquals(TEST_DATA.length, cursor.getLong(0));
            assertEquals(TEST_FILE, cursor.getString(1));
        } finally {
            cursor.close();
        }

        cursor = mResolver.query(uri, new String[] {
                DISPLAY_NAME, SIZE }, null, null, null);
        try {
            assertEquals(1, cursor.getCount());
            cursor.moveToFirst();
            assertEquals(TEST_FILE, cursor.getString(0));
            assertEquals(TEST_DATA.length, cursor.getLong(1));
        } finally {
            cursor.close();
        }
    }
",non-flaky,5
177962,aosp-mirror_platform_frameworks_support,FileProviderTest.testQueryExtraColumn,"    @Test
    public void testQueryExtraColumn() throws Exception {
        final File file = new File(mContext.getFilesDir(), TEST_FILE);
        final Uri uri = stageFileAndGetUri(file, TEST_DATA);

        // Verify that extra column doesn't gook things up
        Cursor cursor = mResolver.query(uri, new String[] {
                SIZE, ""foobar"", DISPLAY_NAME }, null, null, null);
        try {
            assertEquals(1, cursor.getCount());
            cursor.moveToFirst();
            assertEquals(TEST_DATA.length, cursor.getLong(0));
            assertEquals(TEST_FILE, cursor.getString(1));
        } finally {
            cursor.close();
        }
    }
",non-flaky,5
177963,aosp-mirror_platform_frameworks_support,FileProviderTest.testReadFile,"    @Test
    public void testReadFile() throws Exception {
        final File file = new File(mContext.getFilesDir(), TEST_FILE);
        final Uri uri = stageFileAndGetUri(file, TEST_DATA);

        assertContentsEquals(TEST_DATA, uri);
    }
",non-flaky,5
177964,aosp-mirror_platform_frameworks_support,FileProviderTest.testWriteFile,"    @Test
    public void testWriteFile() throws Exception {
        final File file = new File(mContext.getFilesDir(), TEST_FILE);
        final Uri uri = stageFileAndGetUri(file, TEST_DATA);

        assertContentsEquals(TEST_DATA, uri);

        final OutputStream out = mResolver.openOutputStream(uri);
        try {
            out.write(TEST_DATA_ALT);
        } finally {
            closeQuietly(out);
        }

        assertContentsEquals(TEST_DATA_ALT, uri);
    }
",non-flaky,5
177965,aosp-mirror_platform_frameworks_support,FileProviderTest.testWriteMissingFile,"    @Test
    public void testWriteMissingFile() throws Exception {
        final File file = new File(mContext.getFilesDir(), TEST_FILE);
        final Uri uri = stageFileAndGetUri(file, null);

        try {
            assertContentsEquals(new byte[0], uri);
            fail(""Somehow read missing file?"");
        } catch(FileNotFoundException e) {
        }

        final OutputStream out = mResolver.openOutputStream(uri);
        try {
            out.write(TEST_DATA_ALT);
        } finally {
            closeQuietly(out);
        }

        assertContentsEquals(TEST_DATA_ALT, uri);
    }
",non-flaky,5
177966,aosp-mirror_platform_frameworks_support,FileProviderTest.testDelete,"    @Test
    public void testDelete() throws Exception {
        final File file = new File(mContext.getFilesDir(), TEST_FILE);
        final Uri uri = stageFileAndGetUri(file, TEST_DATA);

        assertContentsEquals(TEST_DATA, uri);

        assertEquals(1, mResolver.delete(uri, null, null));
        assertEquals(0, mResolver.delete(uri, null, null));

        try {
            assertContentsEquals(new byte[0], uri);
            fail(""Somehow read missing file?"");
        } catch(FileNotFoundException e) {
        }
    }
",non-flaky,5
177967,aosp-mirror_platform_frameworks_support,FileProviderTest.testMetaDataTargets,"    @Test
    public void testMetaDataTargets() {
        Uri actual;

        actual = FileProvider.getUriForFile(mContext, TEST_AUTHORITY,
                new File(""/proc/version""));
        assertEquals(""content://moocow/test_root/proc/version"", actual.toString());

        actual = FileProvider.getUriForFile(mContext, TEST_AUTHORITY,
                new File(""/proc/1/mountinfo""));
        assertEquals(""content://moocow/test_init/mountinfo"", actual.toString());

        actual = FileProvider.getUriForFile(mContext, TEST_AUTHORITY,
                buildPath(mContext.getFilesDir(), ""meow""));
        assertEquals(""content://moocow/test_files/meow"", actual.toString());

        actual = FileProvider.getUriForFile(mContext, TEST_AUTHORITY,
                buildPath(mContext.getFilesDir(), ""thumbs"", ""rawr""));
        assertEquals(""content://moocow/test_thumbs/rawr"", actual.toString());

        actual = FileProvider.getUriForFile(mContext, TEST_AUTHORITY,
                buildPath(mContext.getCacheDir(), ""up"", ""down""));
        assertEquals(""content://moocow/test_cache/up/down"", actual.toString());

        actual = FileProvider.getUriForFile(mContext, TEST_AUTHORITY,
                buildPath(Environment.getExternalStorageDirectory(), ""Android"", ""obb"", ""foobar""));
        assertEquals(""content://moocow/test_external/Android/obb/foobar"", actual.toString());

        File[] externalFilesDirs = ContextCompat.getExternalFilesDirs(mContext, null);
        actual = FileProvider.getUriForFile(mContext, TEST_AUTHORITY,
            buildPath(externalFilesDirs[0], ""foo"", ""bar""));
        assertEquals(""content://moocow/test_external_files/foo/bar"", actual.toString());

        File[] externalCacheDirs = ContextCompat.getExternalCacheDirs(mContext);
        actual = FileProvider.getUriForFile(mContext, TEST_AUTHORITY,
            buildPath(externalCacheDirs[0], ""foo"", ""bar""));
        assertEquals(""content://moocow/test_external_cache/foo/bar"", actual.toString());
    }
",non-flaky,5
177968,aosp-mirror_platform_frameworks_support,ColorUtilsTest.testColorToHSL,"    @Test
    public void testColorToHSL() {
        for (TestEntry entry : sEntryList) {
            verifyColorToHSL(entry.rgb, entry.hsl);
        }
    }
",non-flaky,5
177969,aosp-mirror_platform_frameworks_support,ColorUtilsTest.testHSLToColor,"    @Test
    public void testHSLToColor() {
        for (TestEntry entry : sEntryList) {
            verifyHSLToColor(entry.hsl, entry.rgb);
        }
    }
",non-flaky,5
177970,aosp-mirror_platform_frameworks_support,ColorUtilsTest.testColorToHslLimits,"    @Test
    public void testColorToHslLimits() {
        final float[] hsl = new float[3];

        for (TestEntry entry : sEntryList) {
            ColorUtils.colorToHSL(entry.rgb, hsl);

            assertTrue(hsl[0] >= 0f && hsl[0] <= 360f);
            assertTrue(hsl[1] >= 0f && hsl[1] <= 1f);
            assertTrue(hsl[2] >= 0f && hsl[2] <= 1f);
        }
    }
",non-flaky,5
177971,aosp-mirror_platform_frameworks_support,ColorUtilsTest.testColorToXYZ,"    @Test
    public void testColorToXYZ() {
        for (TestEntry entry : sEntryList) {
            verifyColorToXYZ(entry.rgb, entry.xyz);
        }
    }
",non-flaky,5
177972,aosp-mirror_platform_frameworks_support,ColorUtilsTest.testColorToLAB,"    @Test
    public void testColorToLAB() {
        for (TestEntry entry : sEntryList) {
            verifyColorToLAB(entry.rgb, entry.lab);
        }
    }
",non-flaky,5
177973,aosp-mirror_platform_frameworks_support,ColorUtilsTest.testLABToXYZ,"    @Test
    public void testLABToXYZ() {
        for (TestEntry entry : sEntryList) {
            verifyLABToXYZ(entry.lab, entry.xyz);
        }
    }
",non-flaky,5
177974,aosp-mirror_platform_frameworks_support,ColorUtilsTest.testXYZToColor,"    @Test
    public void testXYZToColor() {
        for (TestEntry entry : sEntryList) {
            verifyXYZToColor(entry.xyz, entry.rgb);
        }
    }
",non-flaky,5
177975,aosp-mirror_platform_frameworks_support,ColorUtilsTest.testLABToColor,"    @Test
    public void testLABToColor() {
        for (TestEntry entry : sEntryList) {
            verifyLABToColor(entry.lab, entry.rgb);
        }
    }
",non-flaky,5
177976,aosp-mirror_platform_frameworks_support,ColorUtilsTest.testMinAlphas,"    @Test
    public void testMinAlphas() {
        for (TestEntry entry : sEntryList) {
            verifyMinAlpha(""Black title"", entry.rgb, entry.blackMinAlpha30,
                    ColorUtils.calculateMinimumAlpha(Color.BLACK, entry.rgb, 3.0f));
            verifyMinAlpha(""Black body"", entry.rgb, entry.blackMinAlpha45,
                    ColorUtils.calculateMinimumAlpha(Color.BLACK, entry.rgb, 4.5f));
            verifyMinAlpha(""White title"", entry.rgb, entry.whiteMinAlpha30,
                    ColorUtils.calculateMinimumAlpha(Color.WHITE, entry.rgb, 3.0f));
            verifyMinAlpha(""White body"", entry.rgb, entry.whiteMinAlpha45,
                    ColorUtils.calculateMinimumAlpha(Color.WHITE, entry.rgb, 4.5f));
        }
    }
",non-flaky,5
177977,aosp-mirror_platform_frameworks_support,ColorUtilsTest.testCircularInterpolationForwards,"    @Test
    public void testCircularInterpolationForwards() {
        assertEquals(0f, ColorUtils.circularInterpolate(0, 180, 0f), 0f);
        assertEquals(90f, ColorUtils.circularInterpolate(0, 180, 0.5f), 0f);
        assertEquals(180f, ColorUtils.circularInterpolate(0, 180, 1f), 0f);
    }
",non-flaky,5
177978,aosp-mirror_platform_frameworks_support,ColorUtilsTest.testCircularInterpolationBackwards,"    @Test
    public void testCircularInterpolationBackwards() {
        assertEquals(180f, ColorUtils.circularInterpolate(180, 0, 0f), 0f);
        assertEquals(90f, ColorUtils.circularInterpolate(180, 0, 0.5f), 0f);
        assertEquals(0f, ColorUtils.circularInterpolate(180, 0, 1f), 0f);
    }
",non-flaky,5
177979,aosp-mirror_platform_frameworks_support,ColorUtilsTest.testCircularInterpolationCrossZero,"    @Test
    public void testCircularInterpolationCrossZero() {
        assertEquals(270f, ColorUtils.circularInterpolate(270, 90, 0f), 0f);
        assertEquals(180f, ColorUtils.circularInterpolate(270, 90, 0.5f), 0f);
        assertEquals(90f, ColorUtils.circularInterpolate(270, 90, 1f), 0f);
    }
",non-flaky,5
177980,aosp-mirror_platform_frameworks_support,BidiFormatterTest.testIsRtlContext,"    @Test
    public void testIsRtlContext() {
        assertEquals(false, LTR_FMT.isRtlContext());
        assertEquals(true, RTL_FMT.isRtlContext());

        assertEquals(false, BidiFormatter.getInstance(Locale.ENGLISH).isRtlContext());
        assertEquals(true, BidiFormatter.getInstance(true).isRtlContext());
    }
",non-flaky,5
177981,aosp-mirror_platform_frameworks_support,BidiFormatterTest.testBuilderIsRtlContext,"    @Test
    public void testBuilderIsRtlContext() {
        assertEquals(false, new BidiFormatter.Builder(false).build().isRtlContext());
        assertEquals(true, new BidiFormatter.Builder(true).build().isRtlContext());
    }
",non-flaky,5
177982,aosp-mirror_platform_frameworks_support,BidiFormatterTest.testIsRtl,"    @Test
    public void testIsRtl() {
        assertEquals(true, BidiFormatter.getInstance(true).isRtl(HE));
        assertEquals(true, BidiFormatter.getInstance(false).isRtl(HE));

        assertEquals(false, BidiFormatter.getInstance(true).isRtl(EN));
        assertEquals(false, BidiFormatter.getInstance(false).isRtl(EN));
    }
",non-flaky,5
177983,aosp-mirror_platform_frameworks_support,BidiFormatterTest.testUnicodeWrap,"    @Test
    public void testUnicodeWrap() {
        // Make sure an input of null doesn't crash anything.
        assertNull(LTR_FMT.unicodeWrap(null));

        // Uniform directionality in opposite context.
        assertEquals(""uniform dir opposite to LTR context"",
                RLE + ""."" + HE + ""."" + PDF + LRM,
                LTR_FMT_EXIT_RESET.unicodeWrap(""."" + HE + "".""));
        assertEquals(""uniform dir opposite to LTR context, stereo reset"",
                LRM + RLE + ""."" + HE + ""."" + PDF + LRM,
                LTR_FMT.unicodeWrap(""."" + HE + "".""));
        assertEquals(""uniform dir opposite to LTR context, stereo reset, no isolation"",
                RLE + ""."" + HE + ""."" + PDF,
                LTR_FMT.unicodeWrap(""."" + HE + ""."", false));
        assertEquals(""neutral treated as opposite to LTR context"",
                RLE + ""."" + PDF + LRM,
                LTR_FMT_EXIT_RESET.unicodeWrap(""."", TextDirectionHeuristicsCompat.RTL));
        assertEquals(""uniform dir opposite to RTL context"",
                LRE + ""."" + EN + ""."" + PDF + RLM,
                RTL_FMT_EXIT_RESET.unicodeWrap(""."" + EN + "".""));
        assertEquals(""uniform dir opposite to RTL context, stereo reset"",
                RLM + LRE + ""."" + EN + ""."" + PDF + RLM,
                RTL_FMT.unicodeWrap(""."" + EN + "".""));
        assertEquals(""uniform dir opposite to RTL context, stereo reset, no isolation"",
                LRE + ""."" + EN + ""."" + PDF,
                RTL_FMT.unicodeWrap(""."" + EN + ""."", false));
        assertEquals(""neutral treated as opposite to RTL context"",
                LRE + ""."" + PDF + RLM,
                RTL_FMT_EXIT_RESET.unicodeWrap(""."", TextDirectionHeuristicsCompat.LTR));

        // We test mixed-directionality cases only with an explicit overall directionality parameter
        // because the estimation logic is outside the sphere of BidiFormatter, and different
        // estimators will treat them differently.

        // Overall directionality matching context, but with opposite exit directionality.
        assertEquals(""exit dir opposite to LTR context"",
                EN + HE + LRM,
                LTR_FMT_EXIT_RESET.unicodeWrap(EN + HE, TextDirectionHeuristicsCompat.LTR));
        assertEquals(""exit dir opposite to LTR context, stereo reset"",
                EN + HE + LRM,
                LTR_FMT.unicodeWrap(EN + HE, TextDirectionHeuristicsCompat.LTR));
        assertEquals(""exit dir opposite to LTR context, stereo reset, no isolation"",
                EN + HE,
                LTR_FMT.unicodeWrap(EN + HE, TextDirectionHeuristicsCompat.LTR, false));

        assertEquals(""exit dir opposite to RTL context"",
                HE + EN + RLM,
                RTL_FMT_EXIT_RESET.unicodeWrap(HE + EN, TextDirectionHeuristicsCompat.RTL));
        assertEquals(""exit dir opposite to RTL context, stereo reset"",
                HE + EN + RLM,
                RTL_FMT.unicodeWrap(HE + EN, TextDirectionHeuristicsCompat.RTL));
        assertEquals(""exit dir opposite to RTL context, stereo reset, no isolation"",
                HE + EN,
                RTL_FMT.unicodeWrap(HE + EN, TextDirectionHeuristicsCompat.RTL, false));

        // Overall directionality matching context, but with opposite entry directionality.
        assertEquals(""entry dir opposite to LTR context"",
                HE + EN,
                LTR_FMT_EXIT_RESET.unicodeWrap(HE + EN, TextDirectionHeuristicsCompat.LTR));
        assertEquals(""entry dir opposite to LTR context, stereo reset"",
                LRM + HE + EN,
                LTR_FMT.unicodeWrap(HE + EN, TextDirectionHeuristicsCompat.LTR));
        assertEquals(""entry dir opposite to LTR context, stereo reset, no isolation"",
                HE + EN,
                LTR_FMT.unicodeWrap(HE + EN, TextDirectionHeuristicsCompat.LTR, false));

        assertEquals(""entry dir opposite to RTL context"",
                EN + HE,
                RTL_FMT_EXIT_RESET.unicodeWrap(EN + HE, TextDirectionHeuristicsCompat.RTL));
        assertEquals(""entry dir opposite to RTL context, stereo reset"",
                RLM + EN + HE,
                RTL_FMT.unicodeWrap(EN + HE, TextDirectionHeuristicsCompat.RTL));
        assertEquals(""entry dir opposite to RTL context, stereo reset, no isolation"",
                EN + HE,
                RTL_FMT.unicodeWrap(EN + HE, TextDirectionHeuristicsCompat.RTL, false));

        // Overall directionality matching context, but with opposite entry and exit directionality.
        assertEquals(""entry and exit dir opposite to LTR context"",
                HE + EN + HE + LRM,
                LTR_FMT_EXIT_RESET.unicodeWrap(HE + EN + HE, TextDirectionHeuristicsCompat.LTR));
        assertEquals(""entry and exit dir opposite to LTR context, stereo reset"",
                LRM + HE + EN + HE + LRM,
                LTR_FMT.unicodeWrap(HE + EN + HE, TextDirectionHeuristicsCompat.LTR));
        assertEquals(""entry and exit dir opposite to LTR context, no isolation"",
                HE + EN + HE,
                LTR_FMT_EXIT_RESET.unicodeWrap(HE + EN + HE, TextDirectionHeuristicsCompat.LTR,
                        false));

        assertEquals(""entry and exit dir opposite to RTL context"",
                EN + HE + EN + RLM,
                RTL_FMT_EXIT_RESET.unicodeWrap(EN + HE + EN, TextDirectionHeuristicsCompat.RTL));
        assertEquals(""entry and exit dir opposite to RTL context, no isolation"",
                EN + HE + EN,
                RTL_FMT_EXIT_RESET.unicodeWrap(EN + HE + EN, TextDirectionHeuristicsCompat.RTL,
                        false));

        // Entry and exit directionality matching context, but with opposite overall directionality.
        assertEquals(""overall dir (but not entry or exit dir) opposite to LTR context"",
                RLE + EN + HE + EN + PDF + LRM,
                LTR_FMT_EXIT_RESET.unicodeWrap(EN + HE + EN, TextDirectionHeuristicsCompat.RTL));
        assertEquals(""overall dir (but not entry or exit dir) opposite to LTR context, stereo reset"",
                LRM + RLE + EN + HE + EN + PDF + LRM,
                LTR_FMT.unicodeWrap(EN + HE + EN, TextDirectionHeuristicsCompat.RTL));
        assertEquals(""overall dir (but not entry or exit dir) opposite to LTR context, no isolation"",
                RLE + EN + HE + EN + PDF,
                LTR_FMT_EXIT_RESET.unicodeWrap(EN + HE + EN, TextDirectionHeuristicsCompat.RTL,
                        false));

        assertEquals(""overall dir (but not entry or exit dir) opposite to RTL context"",
                LRE + HE + EN + HE + PDF + RLM,
                RTL_FMT_EXIT_RESET.unicodeWrap(HE + EN + HE, TextDirectionHeuristicsCompat.LTR));
        assertEquals(""overall dir (but not entry or exit dir) opposite to RTL context, stereo reset"",
                RLM + LRE + HE + EN + HE + PDF + RLM,
                RTL_FMT.unicodeWrap(HE + EN + HE, TextDirectionHeuristicsCompat.LTR));
        assertEquals(""overall dir (but not entry or exit dir) opposite to RTL context, no isolation"",
                LRE + HE + EN + HE + PDF,
                RTL_FMT_EXIT_RESET.unicodeWrap(HE + EN + HE, TextDirectionHeuristicsCompat.LTR,
                        false));
    }
",non-flaky,5
177984,aosp-mirror_platform_frameworks_support,BidiFormatterTest.testCharSequenceApis,"    @Test
    public void testCharSequenceApis() {
        final CharSequence CS_HE = new SpannableString(HE);
        assertEquals(true, BidiFormatter.getInstance(true).isRtl(CS_HE));

        final SpannableString CS_EN_HE = new SpannableString(EN + HE);
        final Object RELATIVE_SIZE_SPAN = new RelativeSizeSpan(1.2f);
        CS_EN_HE.setSpan(RELATIVE_SIZE_SPAN, 0, EN.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE);

        Spanned wrapped;
        Object[] spans;

        wrapped = (Spanned) LTR_FMT.unicodeWrap(CS_EN_HE);
        assertEquals(EN + HE + LRM, wrapped.toString());
        spans = wrapped.getSpans(0, wrapped.length(), Object.class);
        assertEquals(1, spans.length);
        assertEquals(RELATIVE_SIZE_SPAN, spans[0]);
        assertEquals(0, wrapped.getSpanStart(RELATIVE_SIZE_SPAN));
        assertEquals(EN.length(), wrapped.getSpanEnd(RELATIVE_SIZE_SPAN));

        wrapped = (Spanned) LTR_FMT.unicodeWrap(CS_EN_HE, TextDirectionHeuristicsCompat.LTR);
        assertEquals(EN + HE + LRM, wrapped.toString());
        spans = wrapped.getSpans(0, wrapped.length(), Object.class);
        assertEquals(1, spans.length);
        assertEquals(RELATIVE_SIZE_SPAN, spans[0]);
        assertEquals(0, wrapped.getSpanStart(RELATIVE_SIZE_SPAN));
        assertEquals(EN.length(), wrapped.getSpanEnd(RELATIVE_SIZE_SPAN));

        wrapped = (Spanned) LTR_FMT.unicodeWrap(CS_EN_HE, false);
        assertEquals(EN + HE, wrapped.toString());
        spans = wrapped.getSpans(0, wrapped.length(), Object.class);
        assertEquals(1, spans.length);
        assertEquals(RELATIVE_SIZE_SPAN, spans[0]);
        assertEquals(0, wrapped.getSpanStart(RELATIVE_SIZE_SPAN));
        assertEquals(EN.length(), wrapped.getSpanEnd(RELATIVE_SIZE_SPAN));

        wrapped = (Spanned) LTR_FMT.unicodeWrap(CS_EN_HE, TextDirectionHeuristicsCompat.LTR, false);
        assertEquals(EN + HE, wrapped.toString());
        spans = wrapped.getSpans(0, wrapped.length(), Object.class);
        assertEquals(1, spans.length);
        assertEquals(RELATIVE_SIZE_SPAN, spans[0]);
        assertEquals(0, wrapped.getSpanStart(RELATIVE_SIZE_SPAN));
        assertEquals(EN.length(), wrapped.getSpanEnd(RELATIVE_SIZE_SPAN));
    }
",non-flaky,5
177985,aosp-mirror_platform_frameworks_support,CustomTabsIntentTest.testBareboneCustomTabIntent,"    @Test
    public void testBareboneCustomTabIntent() {
        CustomTabsIntent customTabsIntent = new CustomTabsIntent.Builder().build();
        Intent intent = customTabsIntent.intent;
        assertNotNull(intent);
        assertNull(customTabsIntent.startAnimationBundle);

        assertEquals(Intent.ACTION_VIEW, intent.getAction());
        assertTrue(intent.hasExtra(CustomTabsIntent.EXTRA_SESSION));
        if (Build.VERSION.SDK_INT >= 18) {
            assertNull(intent.getExtras().getBinder(CustomTabsIntent.EXTRA_SESSION));
        }
        assertNull(intent.getComponent());
    }
",non-flaky,5
177986,aosp-mirror_platform_frameworks_support,CustomTabsIntentTest.testToolbarColor,"    @Test
    public void testToolbarColor() {
        int color = Color.RED;
        Intent intent = new CustomTabsIntent.Builder().setToolbarColor(color).build().intent;
        assertTrue(intent.hasExtra(CustomTabsIntent.EXTRA_TOOLBAR_COLOR));
        assertEquals(color, intent.getIntExtra(CustomTabsIntent.EXTRA_TOOLBAR_COLOR, 0));
    }
",non-flaky,5
177987,aosp-mirror_platform_frameworks_support,CustomTabsIntentTest.testToolbarColorIsNotAResource,"    @Test
    public void testToolbarColorIsNotAResource() {
        @ColorRes int colorId = android.R.color.background_dark;
        int color = InstrumentationRegistry.getContext().getResources().getColor(colorId);
        Intent intent = new CustomTabsIntent.Builder().setToolbarColor(colorId).build().intent;
        assertFalse(""The color should not be a resource ID"",
                color == intent.getIntExtra(CustomTabsIntent.EXTRA_TOOLBAR_COLOR, 0));
        intent = new CustomTabsIntent.Builder().setToolbarColor(color).build().intent;
        assertEquals(color, intent.getIntExtra(CustomTabsIntent.EXTRA_TOOLBAR_COLOR, 0));
    }
",non-flaky,5
177988,aosp-mirror_platform_frameworks_support,GuidedStepSupportFragmentTest.answer,"    @Test
    public void nextAndBack() throws Throwable {
        final String firstFragmentName = generateMethodTestName(""first"");
        final String secondFragmentName = generateMethodTestName(""second"");
        GuidedStepTestSupportFragment.Provider first = mockProvider(firstFragmentName);
        doAnswer(new Answer<Void>() {
            public Void answer(InvocationOnMock invocation) {
                List actions = (List) invocation.getArguments()[0];
                actions.add(new GuidedAction.Builder().id(1000).title(""OK"").build());
                return null;
            }
",non-flaky,5
177989,aosp-mirror_platform_frameworks_support,GuidedStepSupportFragmentTest.answer,"    @Test
    public void restoreFragments() throws Throwable {
        final String firstFragmentName = generateMethodTestName(""first"");
        final String secondFragmentName = generateMethodTestName(""second"");
        GuidedStepTestSupportFragment.Provider first = mockProvider(firstFragmentName);
        doAnswer(new Answer<Void>() {
            public Void answer(InvocationOnMock invocation) {
                List actions = (List) invocation.getArguments()[0];
                actions.add(new GuidedAction.Builder().id(1000).title(""OK"").build());
                actions.add(new GuidedAction.Builder().id(1001).editable(true).title(""text"")
                        .build());
                actions.add(new GuidedAction.Builder().id(1002).editable(true).title(""text"")
                        .autoSaveRestoreEnabled(false).build());
                return null;
            }
",non-flaky,5
177990,aosp-mirror_platform_frameworks_support,GuidedStepSupportFragmentTest.answer,"    @Test
    public void finishGuidedStepSupportFragment_finishes_activity() throws Throwable {
        final String firstFragmentName = generateMethodTestName(""first"");
        GuidedStepTestSupportFragment.Provider first = mockProvider(firstFragmentName);
        doAnswer(new Answer<Void>() {
            public Void answer(InvocationOnMock invocation) {
                List actions = (List) invocation.getArguments()[0];
                actions.add(new GuidedAction.Builder().id(1001).title(""Finish activity"").build());
                return null;
            }
",non-flaky,5
177991,aosp-mirror_platform_frameworks_support,GuidedStepSupportFragmentTest.answer,"    @Test
    public void finishGuidedStepSupportFragment_finishes_fragments() throws Throwable {
        final String firstFragmentName = generateMethodTestName(""first"");
        GuidedStepTestSupportFragment.Provider first = mockProvider(firstFragmentName);
        doAnswer(new Answer<Void>() {
            public Void answer(InvocationOnMock invocation) {
                List actions = (List) invocation.getArguments()[0];
                actions.add(new GuidedAction.Builder().id(1001).title(""Finish fragments"").build());
                return null;
            }
",non-flaky,5
177992,aosp-mirror_platform_frameworks_support,GuidedStepSupportFragmentTest.answer,"    @Test
    public void subActions() throws Throwable {
        final String firstFragmentName = generateMethodTestName(""first"");
        final String secondFragmentName = generateMethodTestName(""second"");
        final boolean[] expandSubActionInOnCreateView = new boolean[] {false};
        GuidedStepTestSupportFragment.Provider first = mockProvider(firstFragmentName);
        doAnswer(new Answer<Void>() {
            public Void answer(InvocationOnMock invocation) {
                GuidedStepTestSupportFragment.Provider obj = (GuidedStepTestSupportFragment.Provider)
                        invocation.getMock();
                if (expandSubActionInOnCreateView[0]) {
                    obj.getFragment().expandAction(obj.getFragment().findActionById(1000), false);
                }
                return null;
            }
",non-flaky,5
177993,aosp-mirror_platform_frameworks_support,GuidedStepFragmentTest.answer,"    @Test
    public void nextAndBack() throws Throwable {
        final String firstFragmentName = generateMethodTestName(""first"");
        final String secondFragmentName = generateMethodTestName(""second"");
        GuidedStepTestFragment.Provider first = mockProvider(firstFragmentName);
        doAnswer(new Answer<Void>() {
            public Void answer(InvocationOnMock invocation) {
                List actions = (List) invocation.getArguments()[0];
                actions.add(new GuidedAction.Builder().id(1000).title(""OK"").build());
                return null;
            }
",non-flaky,5
177994,aosp-mirror_platform_frameworks_support,GuidedStepFragmentTest.answer,"    @Test
    public void restoreFragments() throws Throwable {
        final String firstFragmentName = generateMethodTestName(""first"");
        final String secondFragmentName = generateMethodTestName(""second"");
        GuidedStepTestFragment.Provider first = mockProvider(firstFragmentName);
        doAnswer(new Answer<Void>() {
            public Void answer(InvocationOnMock invocation) {
                List actions = (List) invocation.getArguments()[0];
                actions.add(new GuidedAction.Builder().id(1000).title(""OK"").build());
                actions.add(new GuidedAction.Builder().id(1001).editable(true).title(""text"")
                        .build());
                actions.add(new GuidedAction.Builder().id(1002).editable(true).title(""text"")
                        .autoSaveRestoreEnabled(false).build());
                return null;
            }
",non-flaky,5
177995,aosp-mirror_platform_frameworks_support,GuidedStepFragmentTest.answer,"    @Test
    public void finishGuidedStepFragment_finishes_activity() throws Throwable {
        final String firstFragmentName = generateMethodTestName(""first"");
        GuidedStepTestFragment.Provider first = mockProvider(firstFragmentName);
        doAnswer(new Answer<Void>() {
            public Void answer(InvocationOnMock invocation) {
                List actions = (List) invocation.getArguments()[0];
                actions.add(new GuidedAction.Builder().id(1001).title(""Finish activity"").build());
                return null;
            }
",non-flaky,5
177996,aosp-mirror_platform_frameworks_support,GuidedStepFragmentTest.answer,"    @Test
    public void finishGuidedStepFragment_finishes_fragments() throws Throwable {
        final String firstFragmentName = generateMethodTestName(""first"");
        GuidedStepTestFragment.Provider first = mockProvider(firstFragmentName);
        doAnswer(new Answer<Void>() {
            public Void answer(InvocationOnMock invocation) {
                List actions = (List) invocation.getArguments()[0];
                actions.add(new GuidedAction.Builder().id(1001).title(""Finish fragments"").build());
                return null;
            }
",non-flaky,5
177997,aosp-mirror_platform_frameworks_support,GuidedStepFragmentTest.answer,"    @Test
    public void subActions() throws Throwable {
        final String firstFragmentName = generateMethodTestName(""first"");
        final String secondFragmentName = generateMethodTestName(""second"");
        final boolean[] expandSubActionInOnCreateView = new boolean[] {false};
        GuidedStepTestFragment.Provider first = mockProvider(firstFragmentName);
        doAnswer(new Answer<Void>() {
            public Void answer(InvocationOnMock invocation) {
                GuidedStepTestFragment.Provider obj = (GuidedStepTestFragment.Provider)
                        invocation.getMock();
                if (expandSubActionInOnCreateView[0]) {
                    obj.getFragment().expandAction(obj.getFragment().findActionById(1000), false);
                }
                return null;
            }
",non-flaky,5
177998,aosp-mirror_platform_frameworks_support,DetailsFragmentTest.canProceed,"    @Test
    public void parallaxTest() throws Throwable {
        final int mDefaultVerticalOffset = -300;
        Intent intent = new Intent();
        intent.putExtra(DetailsTestFragment.VERTICAL_OFFSET, mDefaultVerticalOffset);
        mActivity = activityTestRule.launchActivity(intent);

        final DetailsTestFragment detailsFragment = mActivity.getDetailsFragment();
        DetailsBackgroundParallaxHelper parallaxHelper = detailsFragment.getParallaxHelper();
        final CompositeDrawable drawable = (CompositeDrawable) parallaxHelper.getDrawable();
        final FitWidthBitmapDrawable bitmapDrawable = (FitWidthBitmapDrawable)
                (drawable.getChildAt(0).getDrawable());

        PollingCheck.waitFor(4000, new PollingCheck.PollingCheckCondition() {
            @Override
            public boolean canProceed() {
                return mActivity.getDetailsFragment().getRowsFragment().getAdapter().size() > 1;
            }
",non-flaky,5
177999,aosp-mirror_platform_frameworks_support,DetailsParallaxManagerTest.setupTest,"    @Test
    public void setupTest() {
        double delta = 0.0002;
        DetailsParallaxManager dpm = new DetailsParallaxManager(
                mActivity.getDetailsFragment().getRowsFragment().getVerticalGridView());

        assertNotNull(dpm.getParallax());

        ParallaxRecyclerViewSource.ChildPositionProperty frameTop = dpm.getFrameTop();
        assertEquals(0f, frameTop.getFraction(), delta);
        assertEquals(0f, frameTop.getAdapterPosition(), delta);


        ParallaxRecyclerViewSource.ChildPositionProperty frameBottom = dpm.getFrameBottom();
        assertEquals(1f, frameBottom.getFraction(), delta);
        assertEquals(0f, frameBottom.getAdapterPosition(), delta);
    }
",non-flaky,5
178000,aosp-mirror_platform_frameworks_support,VideoFragmentTest.run,"    @Test
    public void setSurfaceViewCallbackBeforeCreate() {
        Intent intent = new Intent();
        mActivity = activityTestRule.launchActivity(intent);

        InstrumentationRegistry.getInstrumentation().runOnMainSync(new Runnable() {
            @Override
            public void run() {
                mActivity.replaceVideoFragment();
            }
",non-flaky,5
178001,aosp-mirror_platform_frameworks_support,VideoFragmentTest.surfaceCreated,"    @Test
    public void setSurfaceViewCallbackAfterCreate() {
        Intent intent = new Intent();
        mActivity = activityTestRule.launchActivity(intent);

        VideoFragment fragment = (VideoFragment) mActivity.getFragmentManager().findFragmentById(
                R.id.video_fragment);
        assertNotNull(fragment);

        fragment.setSurfaceHolderCallback(new SurfaceHolder.Callback() {
            @Override
            public void surfaceCreated(SurfaceHolder holder) {
            }
",non-flaky,5
178002,aosp-mirror_platform_frameworks_support,BrowseSupportFragmentTest.testTwoBackKeysWithBackStack,"    @Test
    public void testTwoBackKeysWithBackStack() throws Throwable {
        final long dataLoadingDelay = 1000;
        Intent intent = new Intent();
        intent.putExtra(BrowseSupportFragmentTestActivity.EXTRA_LOAD_DATA_DELAY, dataLoadingDelay);
        intent.putExtra(BrowseSupportFragmentTestActivity.EXTRA_ADD_TO_BACKSTACK , true);
        mActivity = activityTestRule.launchActivity(intent);

        Thread.sleep(dataLoadingDelay + TRANSITION_LENGTH);

        assertNotNull(mActivity.getBrowseTestSupportFragment().getMainFragment());
        sendKeys(KeyEvent.KEYCODE_DPAD_RIGHT);
        Thread.sleep(TRANSITION_LENGTH);
        sendKeys(KeyEvent.KEYCODE_BACK, KeyEvent.KEYCODE_BACK);
    }
",non-flaky,5
178003,aosp-mirror_platform_frameworks_support,BrowseSupportFragmentTest.testTwoBackKeysWithoutBackStack,"    @Test
    public void testTwoBackKeysWithoutBackStack() throws Throwable {
        final long dataLoadingDelay = 1000;
        Intent intent = new Intent();
        intent.putExtra(BrowseSupportFragmentTestActivity.EXTRA_LOAD_DATA_DELAY, dataLoadingDelay);
        intent.putExtra(BrowseSupportFragmentTestActivity.EXTRA_ADD_TO_BACKSTACK , false);
        mActivity = activityTestRule.launchActivity(intent);

        Thread.sleep(dataLoadingDelay + TRANSITION_LENGTH);

        assertNotNull(mActivity.getBrowseTestSupportFragment().getMainFragment());
        sendKeys(KeyEvent.KEYCODE_DPAD_RIGHT);
        Thread.sleep(TRANSITION_LENGTH);
        sendKeys(KeyEvent.KEYCODE_BACK, KeyEvent.KEYCODE_BACK);
    }
",non-flaky,5
178004,aosp-mirror_platform_frameworks_support,BrowseSupportFragmentTest.testPressRightBeforeMainFragmentCreated,"    @Test
    public void testPressRightBeforeMainFragmentCreated() throws Throwable {
        final long dataLoadingDelay = 1000;
        Intent intent = new Intent();
        intent.putExtra(BrowseSupportFragmentTestActivity.EXTRA_LOAD_DATA_DELAY, dataLoadingDelay);
        intent.putExtra(BrowseSupportFragmentTestActivity.EXTRA_ADD_TO_BACKSTACK , false);
        mActivity = activityTestRule.launchActivity(intent);

        assertNull(mActivity.getBrowseTestSupportFragment().getMainFragment());
        sendKeys(KeyEvent.KEYCODE_DPAD_RIGHT);
    }
",non-flaky,5
178005,aosp-mirror_platform_frameworks_support,BrowseSupportFragmentTest.run,"    @Test
    public void testSelectCardOnARow() throws Throwable {
        final int selectRow = 10;
        final int selectItem = 20;
        Intent intent = new Intent();
        final long dataLoadingDelay = 1000;
        intent.putExtra(BrowseSupportFragmentTestActivity.EXTRA_LOAD_DATA_DELAY, dataLoadingDelay);
        intent.putExtra(BrowseSupportFragmentTestActivity.EXTRA_ADD_TO_BACKSTACK , true);
        mActivity = activityTestRule.launchActivity(intent);

        Thread.sleep(dataLoadingDelay + TRANSITION_LENGTH);

        Presenter.ViewHolderTask itemTask = Mockito.spy(
                new ItemSelectionTask(mActivity, selectRow));

        final ListRowPresenter.SelectItemViewHolderTask task =
                new ListRowPresenter.SelectItemViewHolderTask(selectItem);
        task.setItemTask(itemTask);

        mActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                mActivity.getBrowseTestSupportFragment().setSelectedPosition(selectRow, true, task);
            }
",non-flaky,5
178006,aosp-mirror_platform_frameworks_support,BrowseSupportFragmentTest.run,"    @Test
    public void activityRecreate_notCrash() throws Throwable {
        final long dataLoadingDelay = 1000;
        Intent intent = new Intent();
        intent.putExtra(BrowseSupportFragmentTestActivity.EXTRA_LOAD_DATA_DELAY, dataLoadingDelay);
        intent.putExtra(BrowseSupportFragmentTestActivity.EXTRA_ADD_TO_BACKSTACK , false);
        intent.putExtra(BrowseSupportFragmentTestActivity.EXTRA_SET_ADAPTER_AFTER_DATA_LOAD, true);
        mActivity = activityTestRule.launchActivity(intent);

        Thread.sleep(dataLoadingDelay + TRANSITION_LENGTH);

        InstrumentationRegistry.getInstrumentation().callActivityOnRestart(mActivity);
        activityTestRule.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                mActivity.recreate();
            }
",non-flaky,5
178007,aosp-mirror_platform_frameworks_support,PlaybackOverlayFragmentTest.workaroundVideoViewStealFocus,"    @Test
    public void workaroundVideoViewStealFocus() {
        Intent intent = new Intent();
        mActivity = activityTestRule.launchActivity(intent);

        assertFalse(mActivity.findViewById(R.id.videoView).hasFocus());
        assertTrue(mActivity.getPlaybackFragment().getView().hasFocus());
    }
",non-flaky,5
178008,aosp-mirror_platform_frameworks_support,PlaybackControlGlueTest.testFastForwardToMaxThenReset,"    @Test
    public void testFastForwardToMaxThenReset() {
        PlaybackControlsRow row = new PlaybackControlsRow();
        glue.setControlsRow(row);
        SparseArrayObjectAdapter adapter = (SparseArrayObjectAdapter)
                row.getPrimaryActionsAdapter();
        PlaybackControlsRow.MultiAction playPause = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlGlue.ACTION_PLAY_PAUSE);
        PlaybackControlsRow.MultiAction fastForward = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlGlue.ACTION_FAST_FORWARD);
        PlaybackControlsRow.MultiAction rewind = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlGlue.ACTION_REWIND);

        assertFalse(glue.isMediaPlaying());
        glue.onActionClicked(playPause);
        assertTrue(glue.isMediaPlaying());
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_NORMAL, glue.getCurrentSpeedId());
        assertEquals(0, fastForward.getIndex());
        assertEquals(0, rewind.getIndex());

        // click multiple times to reach PLAYBACK_SPEED_FAST_L2
        glue.onActionClicked(fastForward);
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_FAST_L0, glue.getCurrentSpeedId());
        assertEquals(1, fastForward.getIndex());
        assertEquals(0, rewind.getIndex());
        glue.onActionClicked(fastForward);
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_FAST_L1, glue.getCurrentSpeedId());
        assertEquals(2, fastForward.getIndex());
        assertEquals(0, rewind.getIndex());
        glue.onActionClicked(fastForward);
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_FAST_L2, glue.getCurrentSpeedId());
        assertEquals(3, fastForward.getIndex());
        assertEquals(0, rewind.getIndex());
        glue.onActionClicked(fastForward);
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_FAST_L2, glue.getCurrentSpeedId());
        assertEquals(3, fastForward.getIndex());
        assertEquals(0, rewind.getIndex());

        // press playPause again put it back to play
        glue.onActionClicked(playPause);
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_NORMAL, glue.getCurrentSpeedId());
        assertEquals(0, fastForward.getIndex());
        assertEquals(0, rewind.getIndex());
    }
",non-flaky,5
178009,aosp-mirror_platform_frameworks_support,PlaybackControlGlueTest.testFastRewindToMaxThenReset,"    @Test
    public void testFastRewindToMaxThenReset() {
        PlaybackControlsRow row = new PlaybackControlsRow();
        glue.setControlsRow(row);
        SparseArrayObjectAdapter adapter = (SparseArrayObjectAdapter)
                row.getPrimaryActionsAdapter();
        PlaybackControlsRow.MultiAction playPause = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlGlue.ACTION_PLAY_PAUSE);
        PlaybackControlsRow.MultiAction fastForward = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlGlue.ACTION_FAST_FORWARD);
        PlaybackControlsRow.MultiAction rewind = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlGlue.ACTION_REWIND);

        assertFalse(glue.isMediaPlaying());
        glue.onActionClicked(playPause);
        assertTrue(glue.isMediaPlaying());
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_NORMAL, glue.getCurrentSpeedId());
        assertEquals(0, fastForward.getIndex());
        assertEquals(0, rewind.getIndex());

        // click multiple times to reach PLAYBACK_SPEED_FAST_L2
        glue.onActionClicked(rewind);
        assertEquals(-PlaybackControlGlue.PLAYBACK_SPEED_FAST_L0, glue.getCurrentSpeedId());
        assertEquals(0, fastForward.getIndex());
        assertEquals(1, rewind.getIndex());
        glue.onActionClicked(rewind);
        assertEquals(-PlaybackControlGlue.PLAYBACK_SPEED_FAST_L1, glue.getCurrentSpeedId());
        assertEquals(0, fastForward.getIndex());
        assertEquals(2, rewind.getIndex());
        glue.onActionClicked(rewind);
        assertEquals(-PlaybackControlGlue.PLAYBACK_SPEED_FAST_L2, glue.getCurrentSpeedId());
        assertEquals(0, fastForward.getIndex());
        assertEquals(3, rewind.getIndex());
        glue.onActionClicked(rewind);
        assertEquals(-PlaybackControlGlue.PLAYBACK_SPEED_FAST_L2, glue.getCurrentSpeedId());
        assertEquals(0, fastForward.getIndex());
        assertEquals(3, rewind.getIndex());

        // press playPause again put it back to play
        glue.onActionClicked(playPause);
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_NORMAL, glue.getCurrentSpeedId());
        assertEquals(0, fastForward.getIndex());
        assertEquals(0, rewind.getIndex());
    }
",non-flaky,5
178010,aosp-mirror_platform_frameworks_support,PlaybackControlGlueTest.testFastForwardAbortKeyCodes,"    @Test
    public void testFastForwardAbortKeyCodes() {
        PlaybackControlsRow row = new PlaybackControlsRow();
        glue.setControlsRow(row);
        SparseArrayObjectAdapter adapter = (SparseArrayObjectAdapter)
                row.getPrimaryActionsAdapter();
        PlaybackControlsRow.MultiAction playPause = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlGlue.ACTION_PLAY_PAUSE);
        PlaybackControlsRow.MultiAction fastForward = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlGlue.ACTION_FAST_FORWARD);
        PlaybackControlsRow.MultiAction rewind = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlGlue.ACTION_REWIND);

        glue.onActionClicked(playPause);
        assertTrue(glue.isMediaPlaying());
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_NORMAL, glue.getCurrentSpeedId());
        assertEquals(0, fastForward.getIndex());
        assertEquals(0, rewind.getIndex());

        // Testing keycodes that will not abort seek
        final int[] noAbortSeekKeyCodes = new int[] {
                KeyEvent.KEYCODE_DPAD_CENTER,
                KeyEvent.KEYCODE_ENTER
        };
        for (int i = 0; i < noAbortSeekKeyCodes.length; i++) {
            glue.onActionClicked(fastForward);
            assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_FAST_L0, glue.getCurrentSpeedId());
            assertEquals(1, fastForward.getIndex());
            assertEquals(0, rewind.getIndex());
            KeyEvent kv = new KeyEvent(KeyEvent.ACTION_DOWN, noAbortSeekKeyCodes[i]);
            glue.onKey(null, noAbortSeekKeyCodes[i], kv);
            assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_FAST_L0, glue.getCurrentSpeedId());
            glue.onActionClicked(playPause);
            assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_NORMAL, glue.getCurrentSpeedId());
        }

        // Testing abortSeekKeyCodes
        final int[] abortSeekKeyCodes = new int[] {
            KeyEvent.KEYCODE_DPAD_UP,
            KeyEvent.KEYCODE_DPAD_DOWN,
            KeyEvent.KEYCODE_DPAD_RIGHT,
            KeyEvent.KEYCODE_DPAD_LEFT,
            KeyEvent.KEYCODE_BACK,
            KeyEvent.KEYCODE_ESCAPE
        };
        for (int i = 0; i < abortSeekKeyCodes.length; i++) {
            glue.onActionClicked(fastForward);
            assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_FAST_L0, glue.getCurrentSpeedId());
            assertEquals(1, fastForward.getIndex());
            assertEquals(0, rewind.getIndex());
            KeyEvent kv = new KeyEvent(KeyEvent.ACTION_DOWN, abortSeekKeyCodes[i]);
            glue.onKey(null, abortSeekKeyCodes[i], kv);
            assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_NORMAL, glue.getCurrentSpeedId());
            assertEquals(0, fastForward.getIndex());
            assertEquals(0, rewind.getIndex());
        }
    }
",non-flaky,5
178011,aosp-mirror_platform_frameworks_support,PlaybackControlGlueTest.testRewindAbortKeyCodes,"    @Test
    public void testRewindAbortKeyCodes() {
        PlaybackControlsRow row = new PlaybackControlsRow();
        glue.setControlsRow(row);
        SparseArrayObjectAdapter adapter = (SparseArrayObjectAdapter)
                row.getPrimaryActionsAdapter();
        PlaybackControlsRow.MultiAction playPause = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlGlue.ACTION_PLAY_PAUSE);
        PlaybackControlsRow.MultiAction fastForward = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlGlue.ACTION_FAST_FORWARD);
        PlaybackControlsRow.MultiAction rewind = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlGlue.ACTION_REWIND);

        glue.onActionClicked(playPause);
        assertTrue(glue.isMediaPlaying());
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_NORMAL, glue.getCurrentSpeedId());
        assertEquals(0, fastForward.getIndex());
        assertEquals(0, rewind.getIndex());

        // Testing keycodes that will not abort seek
        final int[] noAbortSeekKeyCodes = new int[] {
                KeyEvent.KEYCODE_DPAD_CENTER,
                KeyEvent.KEYCODE_ENTER
        };
        for (int i = 0; i < noAbortSeekKeyCodes.length; i++) {
            glue.onActionClicked(rewind);
            assertEquals(-PlaybackControlGlue.PLAYBACK_SPEED_FAST_L0, glue.getCurrentSpeedId());
            assertEquals(0, fastForward.getIndex());
            assertEquals(1, rewind.getIndex());
            KeyEvent kv = new KeyEvent(KeyEvent.ACTION_DOWN, noAbortSeekKeyCodes[i]);
            glue.onKey(null, noAbortSeekKeyCodes[i], kv);
            assertEquals(-PlaybackControlGlue.PLAYBACK_SPEED_FAST_L0, glue.getCurrentSpeedId());
            glue.onActionClicked(playPause);
            assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_NORMAL, glue.getCurrentSpeedId());
        }

        // Testing abortSeekKeyCodes
        final int[] abortSeekKeyCodes = new int[] {
                KeyEvent.KEYCODE_DPAD_UP,
                KeyEvent.KEYCODE_DPAD_DOWN,
                KeyEvent.KEYCODE_DPAD_RIGHT,
                KeyEvent.KEYCODE_DPAD_LEFT,
                KeyEvent.KEYCODE_BACK,
                KeyEvent.KEYCODE_ESCAPE
        };
        for (int i = 0; i < abortSeekKeyCodes.length; i++) {
            glue.onActionClicked(rewind);
            assertEquals(-PlaybackControlGlue.PLAYBACK_SPEED_FAST_L0, glue.getCurrentSpeedId());
            assertEquals(0, fastForward.getIndex());
            assertEquals(1, rewind.getIndex());
            KeyEvent kv = new KeyEvent(KeyEvent.ACTION_DOWN, abortSeekKeyCodes[i]);
            glue.onKey(null, abortSeekKeyCodes[i], kv);
            assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_NORMAL, glue.getCurrentSpeedId());
            assertEquals(0, fastForward.getIndex());
            assertEquals(0, rewind.getIndex());
        }
    }
",non-flaky,5
178012,aosp-mirror_platform_frameworks_support,PlaybackControlGlueTest.testMediaPauseButtonOnFF,"    @Test
    public void testMediaPauseButtonOnFF() {
        PlaybackControlsRow row = new PlaybackControlsRow();
        glue.setControlsRow(row);
        SparseArrayObjectAdapter adapter = (SparseArrayObjectAdapter)
                row.getPrimaryActionsAdapter();
        PlaybackControlsRow.MultiAction playPause = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlGlue.ACTION_PLAY_PAUSE);
        PlaybackControlsRow.MultiAction fastForward = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlGlue.ACTION_FAST_FORWARD);

        glue.onActionClicked(playPause);
        glue.onActionClicked(fastForward);
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_FAST_L0, glue.getCurrentSpeedId());
        glue.onKey(null, KeyEvent.KEYCODE_MEDIA_PAUSE, new KeyEvent(KeyEvent.ACTION_DOWN,
                KeyEvent.KEYCODE_MEDIA_PAUSE));
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_PAUSED, glue.getCurrentSpeedId());
    }
",non-flaky,5
178013,aosp-mirror_platform_frameworks_support,PlaybackControlGlueTest.testMediaPauseButtonOnPlay,"    @Test
    public void testMediaPauseButtonOnPlay() {
        PlaybackControlsRow row = new PlaybackControlsRow();
        glue.setControlsRow(row);
        SparseArrayObjectAdapter adapter = (SparseArrayObjectAdapter)
                row.getPrimaryActionsAdapter();
        PlaybackControlsRow.MultiAction playPause = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlGlue.ACTION_PLAY_PAUSE);

        glue.onActionClicked(playPause);
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_NORMAL, glue.getCurrentSpeedId());
        glue.onKey(null, KeyEvent.KEYCODE_MEDIA_PAUSE, new KeyEvent(KeyEvent.ACTION_DOWN,
                KeyEvent.KEYCODE_MEDIA_PAUSE));
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_PAUSED, glue.getCurrentSpeedId());
    }
",non-flaky,5
178014,aosp-mirror_platform_frameworks_support,PlaybackControlGlueTest.testMediaPauseButtonOnPause,"    @Test
    public void testMediaPauseButtonOnPause() {
        PlaybackControlsRow row = new PlaybackControlsRow();
        glue.setControlsRow(row);
        SparseArrayObjectAdapter adapter = (SparseArrayObjectAdapter)
                row.getPrimaryActionsAdapter();
        PlaybackControlsRow.MultiAction playPause = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlGlue.ACTION_PLAY_PAUSE);

        glue.onActionClicked(playPause);
        glue.onActionClicked(playPause);
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_PAUSED, glue.getCurrentSpeedId());
        glue.onKey(null, KeyEvent.KEYCODE_MEDIA_PAUSE, new KeyEvent(KeyEvent.ACTION_DOWN,
                KeyEvent.KEYCODE_MEDIA_PAUSE));
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_PAUSED, glue.getCurrentSpeedId());
    }
",non-flaky,5
178015,aosp-mirror_platform_frameworks_support,PlaybackControlGlueTest.testMediaPlayButtonOnFF,"    @Test
    public void testMediaPlayButtonOnFF() {
        PlaybackControlsRow row = new PlaybackControlsRow();
        glue.setControlsRow(row);
        SparseArrayObjectAdapter adapter = (SparseArrayObjectAdapter)
                row.getPrimaryActionsAdapter();
        PlaybackControlsRow.MultiAction playPause = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlGlue.ACTION_PLAY_PAUSE);
        PlaybackControlsRow.MultiAction fastForward = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlGlue.ACTION_FAST_FORWARD);

        glue.onActionClicked(playPause);
        glue.onActionClicked(fastForward);
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_FAST_L0, glue.getCurrentSpeedId());
        glue.onKey(null, KeyEvent.KEYCODE_MEDIA_PLAY, new KeyEvent(KeyEvent.ACTION_DOWN,
                KeyEvent.KEYCODE_MEDIA_PLAY));
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_NORMAL, glue.getCurrentSpeedId());
    }
",non-flaky,5
178016,aosp-mirror_platform_frameworks_support,PlaybackControlGlueTest.testMediaPlayButtonOnPlay,"    @Test
    public void testMediaPlayButtonOnPlay() {
        PlaybackControlsRow row = new PlaybackControlsRow();
        glue.setControlsRow(row);
        SparseArrayObjectAdapter adapter = (SparseArrayObjectAdapter)
                row.getPrimaryActionsAdapter();
        PlaybackControlsRow.MultiAction playPause = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlGlue.ACTION_PLAY_PAUSE);

        glue.onActionClicked(playPause);
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_NORMAL, glue.getCurrentSpeedId());
        glue.onKey(null, KeyEvent.KEYCODE_MEDIA_PLAY, new KeyEvent(KeyEvent.ACTION_DOWN,
                KeyEvent.KEYCODE_MEDIA_PLAY));
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_NORMAL, glue.getCurrentSpeedId());
    }
",non-flaky,5
178017,aosp-mirror_platform_frameworks_support,PlaybackControlGlueTest.testMediaPlayButtonOnPause,"    @Test
    public void testMediaPlayButtonOnPause() {
        PlaybackControlsRow row = new PlaybackControlsRow();
        glue.setControlsRow(row);
        SparseArrayObjectAdapter adapter = (SparseArrayObjectAdapter)
                row.getPrimaryActionsAdapter();
        PlaybackControlsRow.MultiAction playPause = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlGlue.ACTION_PLAY_PAUSE);

        glue.onActionClicked(playPause);
        glue.onActionClicked(playPause);
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_PAUSED, glue.getCurrentSpeedId());
        glue.onKey(null, KeyEvent.KEYCODE_MEDIA_PLAY, new KeyEvent(KeyEvent.ACTION_DOWN,
                KeyEvent.KEYCODE_MEDIA_PLAY));
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_NORMAL, glue.getCurrentSpeedId());
    }
",non-flaky,5
178018,aosp-mirror_platform_frameworks_support,PlaybackControlGlueTest.testMediaPlayPauseButtonOnFF,"    @Test
    public void testMediaPlayPauseButtonOnFF() {
        PlaybackControlsRow row = new PlaybackControlsRow();
        glue.setControlsRow(row);
        SparseArrayObjectAdapter adapter = (SparseArrayObjectAdapter)
                row.getPrimaryActionsAdapter();
        PlaybackControlsRow.MultiAction playPause = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlGlue.ACTION_PLAY_PAUSE);
        PlaybackControlsRow.MultiAction fastForward = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlGlue.ACTION_FAST_FORWARD);

        glue.onActionClicked(playPause);
        glue.onActionClicked(fastForward);
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_FAST_L0, glue.getCurrentSpeedId());
        glue.onKey(null, KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE, new KeyEvent(KeyEvent.ACTION_DOWN,
                KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE));
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_NORMAL, glue.getCurrentSpeedId());
    }
",non-flaky,5
178019,aosp-mirror_platform_frameworks_support,PlaybackControlGlueTest.testMediaPlayPauseButtonOnPlay,"    @Test
    public void testMediaPlayPauseButtonOnPlay() {
        PlaybackControlsRow row = new PlaybackControlsRow();
        glue.setControlsRow(row);
        SparseArrayObjectAdapter adapter = (SparseArrayObjectAdapter)
                row.getPrimaryActionsAdapter();
        PlaybackControlsRow.MultiAction playPause = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlGlue.ACTION_PLAY_PAUSE);

        glue.onActionClicked(playPause);
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_NORMAL, glue.getCurrentSpeedId());
        glue.onKey(null, KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE, new KeyEvent(KeyEvent.ACTION_DOWN,
                KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE));
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_PAUSED, glue.getCurrentSpeedId());
    }
",non-flaky,5
178020,aosp-mirror_platform_frameworks_support,PlaybackControlGlueTest.testMediaPlayPauseButtonOnPause,"    @Test
    public void testMediaPlayPauseButtonOnPause() {
        PlaybackControlsRow row = new PlaybackControlsRow();
        glue.setControlsRow(row);
        SparseArrayObjectAdapter adapter = (SparseArrayObjectAdapter)
                row.getPrimaryActionsAdapter();
        PlaybackControlsRow.MultiAction playPause = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlGlue.ACTION_PLAY_PAUSE);

        glue.onActionClicked(playPause);
        glue.onActionClicked(playPause);
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_PAUSED, glue.getCurrentSpeedId());
        glue.onKey(null, KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE, new KeyEvent(KeyEvent.ACTION_DOWN,
                KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE));
        assertEquals(PlaybackControlGlue.PLAYBACK_SPEED_NORMAL, glue.getCurrentSpeedId());
    }
",non-flaky,5
178021,aosp-mirror_platform_frameworks_support,VerticalGridSupportFragmentTest.immediateRemoveFragment,"    @Test
    public void immediateRemoveFragment() throws Throwable {
        Intent intent = new Intent();
        ActivityTestRule<ImmediateRemoveFragmentActivity> activityTestRule =
                new ActivityTestRule<>(ImmediateRemoveFragmentActivity.class, false, false);
        ImmediateRemoveFragmentActivity activity = activityTestRule.launchActivity(intent);

        Thread.sleep(1000);
    }
",non-flaky,5
178022,aosp-mirror_platform_frameworks_support,ListRowDataAdapterTest.itemRangeChangedTest,"    @Test
    public void itemRangeChangedTest() {
        int itemCount = 4;
        ArrayObjectAdapter adapter = new ArrayObjectAdapter(presenterSelector);
        adapter.add(new SectionRow(""section 1""));
        for (int i = 0; i < itemCount; i++) {
            HeaderItem headerItem = new HeaderItem(i, ""header ""+i);
            adapter.add(new ListRow(headerItem, createListRowAdapter()));
        }

        ListRowDataAdapter listRowDataAdapter = new ListRowDataAdapter(adapter);
        listRowDataAdapter.registerObserver(dataObserver);
        SectionRow sectionRow = new SectionRow(""section 11"");
        adapter.replace(0, sectionRow);

        verify(dataObserver, times(1)).onItemRangeChanged(0, 1);
        assertEquals(5, listRowDataAdapter.size());
    }
",non-flaky,5
178023,aosp-mirror_platform_frameworks_support,ListRowDataAdapterTest.adapterSize_nonVisibleRowPresent,"    @Test
    public void adapterSize_nonVisibleRowPresent() {
        int itemCount = 4;
        ArrayObjectAdapter adapter = new ArrayObjectAdapter(presenterSelector);
        adapter.add(new SectionRow(""section 1""));
        for (int i = 0; i < itemCount; i++) {
            HeaderItem headerItem = new HeaderItem(i, ""header ""+i);
            adapter.add(new ListRow(headerItem, createListRowAdapter()));
        }

        ListRowDataAdapter listRowDataAdapter = new ListRowDataAdapter(adapter);
        assertEquals(5, listRowDataAdapter.size());

        List<DividerRow> invisibleRows = new ArrayList<>();
        invisibleRows.add(new DividerRow());
        invisibleRows.add(new DividerRow());
        adapter.addAll(5, invisibleRows);
        verify(dataObserver, times(0)).onItemRangeInserted(anyInt(), anyInt());
        assertEquals(5, listRowDataAdapter.size());
    }
",non-flaky,5
178024,aosp-mirror_platform_frameworks_support,ListRowDataAdapterTest.adapterSize_visibleRowInserted,"    @Test
    public void adapterSize_visibleRowInserted() {
        int itemCount = 4;
        ArrayObjectAdapter adapter = new ArrayObjectAdapter(presenterSelector);
        adapter.add(new SectionRow(""section 1""));
        for (int i = 0; i < itemCount; i++) {
            HeaderItem headerItem = new HeaderItem(i, ""header ""+i);
            adapter.add(new ListRow(headerItem, createListRowAdapter()));
        }

        ListRowDataAdapter listRowDataAdapter = new ListRowDataAdapter(adapter);
        assertEquals(5, listRowDataAdapter.size());

        listRowDataAdapter.registerObserver(dataObserver);
        List<ListRow> visibleRows = new ArrayList<>();
        visibleRows.add(new ListRow(new HeaderItem(0, ""Header 51""), createListRowAdapter()));
        visibleRows.add(new ListRow(new HeaderItem(0, ""Header 52""), createListRowAdapter()));
        visibleRows.add(new ListRow(new HeaderItem(0, ""Header 53""), createListRowAdapter()));
        adapter.addAll(2, visibleRows);
        verify(dataObserver, times(1)).onItemRangeInserted(2, 3);
        assertEquals(8, listRowDataAdapter.size());
    }
",non-flaky,5
178025,aosp-mirror_platform_frameworks_support,ListRowDataAdapterTest.adapterSize_nonVisibleRowInserted,"    @Test
    public void adapterSize_nonVisibleRowInserted() {
        int itemCount = 4;
        ArrayObjectAdapter adapter = new ArrayObjectAdapter(presenterSelector);
        adapter.add(new SectionRow(""section 1""));
        for (int i = 0; i < itemCount; i++) {
            HeaderItem headerItem = new HeaderItem(i, ""header ""+i);
            adapter.add(new ListRow(headerItem, createListRowAdapter()));
        }

        ListRowDataAdapter listRowDataAdapter = new ListRowDataAdapter(adapter);
        assertEquals(5, listRowDataAdapter.size());

        List<DividerRow> invisibleRows = new ArrayList<>();
        invisibleRows.add(new DividerRow());
        invisibleRows.add(new DividerRow());

        listRowDataAdapter.registerObserver(dataObserver);
        adapter.addAll(adapter.size(), invisibleRows);
        verify(dataObserver, times(0)).onItemRangeInserted(anyInt(), anyInt());
        assertEquals(5, listRowDataAdapter.size());

        adapter.add(new DividerRow());
        verify(dataObserver, times(0)).onItemRangeInserted(anyInt(), anyInt());
        assertEquals(5, listRowDataAdapter.size());

        adapter.add(new ListRow(new HeaderItem(0, ""Header 5""), createListRowAdapter()));
        verify(dataObserver, times(1)).onItemRangeInserted(5, 4);
        assertEquals(9, listRowDataAdapter.size());
    }
",non-flaky,5
178026,aosp-mirror_platform_frameworks_support,ListRowDataAdapterTest.adapterSize_visibleRowRemoved,"    @Test
    public void adapterSize_visibleRowRemoved() {
        int itemCount = 4;
        ArrayObjectAdapter adapter = new ArrayObjectAdapter(presenterSelector);
        adapter.add(new SectionRow(""section 1""));
        for (int i = 0; i < itemCount; i++) {
            HeaderItem headerItem = new HeaderItem(i, ""header ""+i);
            adapter.add(new ListRow(headerItem, createListRowAdapter()));
        }

        ListRowDataAdapter listRowDataAdapter = new ListRowDataAdapter(adapter);
        assertEquals(5, listRowDataAdapter.size());
        adapter.add(new DividerRow());
        assertEquals(5, listRowDataAdapter.size());

        listRowDataAdapter.registerObserver(dataObserver);
        adapter.removeItems(2, 2);
        verify(dataObserver, times(1)).onItemRangeRemoved(2, 2);
        assertEquals(3, listRowDataAdapter.size());
    }
",non-flaky,5
178027,aosp-mirror_platform_frameworks_support,ListRowDataAdapterTest.adapterSize_nonVisibleRowRemoved,"    @Test
    public void adapterSize_nonVisibleRowRemoved() {
        int itemCount = 4;
        ArrayObjectAdapter adapter = new ArrayObjectAdapter(presenterSelector);
        adapter.add(new SectionRow(""section 1""));
        for (int i = 0; i < itemCount; i++) {
            HeaderItem headerItem = new HeaderItem(i, ""header ""+i);
            adapter.add(new ListRow(headerItem, createListRowAdapter()));
        }

        ListRowDataAdapter listRowDataAdapter = new ListRowDataAdapter(adapter);
        assertEquals(5, listRowDataAdapter.size());
        adapter.add(new DividerRow());
        assertEquals(5, listRowDataAdapter.size());

        listRowDataAdapter.registerObserver(dataObserver);
        adapter.removeItems(4, 1);
        verify(dataObserver, times(1)).onItemRangeRemoved(4, 1);
        assertEquals(4, listRowDataAdapter.size());

        adapter.removeItems(4, 1);
        verify(dataObserver, times(0)).onItemRangeInserted(anyInt(), anyInt());
        assertEquals(4, listRowDataAdapter.size());
    }
",non-flaky,5
178028,aosp-mirror_platform_frameworks_support,ListRowDataAdapterTest.adapterSize_rowsRemoved,"    @Test
    public void adapterSize_rowsRemoved() {
        int itemCount = 4;
        ArrayObjectAdapter adapter = new ArrayObjectAdapter(presenterSelector);
        adapter.add(new SectionRow(""section 1""));
        for (int i = 0; i < itemCount; i++) {
            HeaderItem headerItem = new HeaderItem(i, ""header ""+i);
            adapter.add(new ListRow(headerItem, createListRowAdapter()));
        }

        ListRowDataAdapter listRowDataAdapter = new ListRowDataAdapter(adapter);
        assertEquals(5, listRowDataAdapter.size());

        adapter.add(new DividerRow());
        assertEquals(5, listRowDataAdapter.size());

        listRowDataAdapter.registerObserver(dataObserver);
        adapter.removeItems(3, 3);
        verify(dataObserver, times(1)).onItemRangeRemoved(3, 2);
        assertEquals(3, listRowDataAdapter.size());
    }
",non-flaky,5
178029,aosp-mirror_platform_frameworks_support,ListRowDataAdapterTest.customObjectAdapterTest,"    @Test
    public void customObjectAdapterTest() {
        int itemCount = 4;
        ArrayObjectAdapter adapter = new CustomAdapter(presenterSelector);
        adapter.add(new SectionRow(""section 1""));
        for (int i = 0; i < itemCount; i++) {
            HeaderItem headerItem = new HeaderItem(i, ""header ""+i);
            adapter.add(new ListRow(headerItem, createListRowAdapter()));
        }

        ListRowDataAdapter listRowDataAdapter = new ListRowDataAdapter(adapter);
        assertEquals(5, listRowDataAdapter.size());

        adapter.add(new DividerRow());
        assertEquals(5, listRowDataAdapter.size());

        listRowDataAdapter.registerObserver(dataObserver);
        adapter.removeItems(3, 3);
        verify(dataObserver, times(1)).onChanged();
        assertEquals(3, listRowDataAdapter.size());

        Mockito.reset(dataObserver);
        adapter.add(new DividerRow());
        verify(dataObserver, times(1)).onChanged();
        assertEquals(3, listRowDataAdapter.size());
    }
",non-flaky,5
178030,aosp-mirror_platform_frameworks_support,GuidedDatePickerTest.testJanuaryToFebruaryTransitionForLeapYear,"    @Test
    public void testJanuaryToFebruaryTransitionForLeapYear() throws Throwable {
        long startTime = System.currentTimeMillis();
        Intent intent = new Intent();

        String title = ""Date Picker Transition Test"";
        String breadcrumb = ""Month Transition Test Demo"";
        String description = ""Testing the transition from Jan to Feb (leap year)"";
        GuidanceStylist.Guidance guidance = new GuidanceStylist.Guidance(title, description,
                breadcrumb, null);

        List<GuidedAction> actionList = new ArrayList<>();

        Calendar cal = Calendar.getInstance();

        cal.set(Calendar.YEAR, 2016);   // 2016 is a leap year
        cal.set(Calendar.MONTH, Calendar.JANUARY);
        cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));
        Date initialDate = cal.getTime();

        GuidedDatePickerAction action = new GuidedDatePickerAction.Builder(
                mContext)
                .id(0)
                .title(""Date"")
                .date(initialDate.getTime())
                .datePickerFormat(""DMY"")
                .build();

        actionList.add(action);

        GuidedStepAttributesTestFragment.clear();
        GuidedStepAttributesTestFragment.GUIDANCE = guidance;
        GuidedStepAttributesTestFragment.ACTION_LIST = actionList;

        initActivity(intent);

        DatePicker mPickerView = (DatePicker) mActivity.findViewById(
                R.id.guidedactions_activator_item);

        verticalScrollToFieldValue(Calendar.MONTH, Calendar.FEBRUARY, new int[] {0, 1, 2},
                mPickerView, KeyEvent.KEYCODE_DPAD_DOWN);
        long executionTime = System.currentTimeMillis() - startTime;
        Log.d(TAG, ""testJanuaryToFebruaryTransitionForLeapYear() Execution time: "" + executionTime);
        Thread.sleep(FINAL_WAIT);
    }
",non-flaky,5
178031,aosp-mirror_platform_frameworks_support,GuidedDatePickerTest.testFebruaryToMarchTransitionForLeapYear,"    @Test
    public void testFebruaryToMarchTransitionForLeapYear() throws Throwable {
        long startTime = System.currentTimeMillis();
        Intent intent = new Intent();

        String title = ""Date Picker Transition Test"";
        String breadcrumb = ""Month Transition Test Demo"";
        String description = ""Testing the transition from Feb to Mar (leap year)"";
        GuidanceStylist.Guidance guidance = new GuidanceStylist.Guidance(title, description,
                breadcrumb, null);

        List<GuidedAction> actionList = new ArrayList<>();

        Calendar cal = Calendar.getInstance();

        cal.set(Calendar.YEAR, 2016);
        cal.set(Calendar.MONTH, Calendar.FEBRUARY);
        cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));
        Date initialDate = cal.getTime();

        GuidedDatePickerAction action = new GuidedDatePickerAction.Builder(
                mContext)
                .id(0)
                .title(""Date"")
                .date(initialDate.getTime())
                .datePickerFormat(""DMY"")
                .build();

        actionList.add(action);

        GuidedStepAttributesTestFragment.clear();
        GuidedStepAttributesTestFragment.GUIDANCE = guidance;
        GuidedStepAttributesTestFragment.ACTION_LIST = actionList;

        initActivity(intent);

        DatePicker mPickerView = (DatePicker) mActivity.findViewById(
                R.id.guidedactions_activator_item);

        verticalScrollToFieldValue(Calendar.MONTH, Calendar.MARCH, new int[] {0, 1, 2},
                mPickerView, KeyEvent.KEYCODE_DPAD_DOWN);
        long executionTime = System.currentTimeMillis() - startTime;
        Log.d(TAG, ""testFebruaryToMarchTransition() Execution time: "" + executionTime);
        Thread.sleep(FINAL_WAIT);
    }
",non-flaky,5
178032,aosp-mirror_platform_frameworks_support,GuidedDatePickerTest.testJanuaryToFebruaryTransitionForNonLeapYear,"    @Test
    public void testJanuaryToFebruaryTransitionForNonLeapYear() throws Throwable {
        long startTime = System.currentTimeMillis();
        Intent intent = new Intent();

        String title = ""Date Picker Transition Test"";
        String breadcrumb = ""Month Transition Test Demo"";
        String description = ""Testing the transition from Jan to Feb (nonleap year)"";
        GuidanceStylist.Guidance guidance = new GuidanceStylist.Guidance(title, description,
                breadcrumb, null);

        List<GuidedAction> actionList = new ArrayList<>();

        Calendar cal = Calendar.getInstance();

        cal.set(Calendar.YEAR, 2017);   // 2017 is a leap year
        cal.set(Calendar.MONTH, Calendar.JANUARY);
        cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));
        Date initialDate = cal.getTime();

        GuidedDatePickerAction action = new GuidedDatePickerAction.Builder(
                mContext)
                .id(0)
                .title(""Date"")
                .date(initialDate.getTime())
                .datePickerFormat(""DMY"")
                .build();

        actionList.add(action);

        GuidedStepAttributesTestFragment.clear();
        GuidedStepAttributesTestFragment.GUIDANCE = guidance;
        GuidedStepAttributesTestFragment.ACTION_LIST = actionList;

        initActivity(intent);

        DatePicker mPickerView = (DatePicker) mActivity.findViewById(
                R.id.guidedactions_activator_item);

        verticalScrollToFieldValue(Calendar.MONTH, Calendar.FEBRUARY, new int[] {0, 1, 2},
                mPickerView, KeyEvent.KEYCODE_DPAD_DOWN);
        long executionTime = System.currentTimeMillis() - startTime;
        Log.d(TAG, ""testJanuaryToFebruaryTransition() Execution time: "" + executionTime);
        Thread.sleep(FINAL_WAIT);
    }
",non-flaky,5
178033,aosp-mirror_platform_frameworks_support,GuidedDatePickerTest.testFebruaryToMarchTransitionForNonLeapYear,"    @Test
    public void testFebruaryToMarchTransitionForNonLeapYear() throws Throwable {
        long startTime = System.currentTimeMillis();
        Intent intent = new Intent();

        String title = ""Date Picker Transition Test"";
        String breadcrumb = ""Month Transition Test Demo"";
        String description = ""Testing the transition from Feb to Mar (nonleap year)"";
        GuidanceStylist.Guidance guidance = new GuidanceStylist.Guidance(title, description,
                breadcrumb, null);

        List<GuidedAction> actionList = new ArrayList<>();

        Calendar cal = Calendar.getInstance();

        cal.set(Calendar.YEAR, 2017);
        cal.set(Calendar.MONTH, Calendar.FEBRUARY);
        cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));
        Date initialDate = cal.getTime();

        GuidedDatePickerAction action = new GuidedDatePickerAction.Builder(
                mContext)
                .id(0)
                .title(""Date"")
                .date(initialDate.getTime())
                .datePickerFormat(""DMY"")
                .build();

        actionList.add(action);

        GuidedStepAttributesTestFragment.clear();
        GuidedStepAttributesTestFragment.GUIDANCE = guidance;
        GuidedStepAttributesTestFragment.ACTION_LIST = actionList;

        initActivity(intent);

        DatePicker mPickerView = (DatePicker) mActivity.findViewById(
                R.id.guidedactions_activator_item);

        verticalScrollToFieldValue(Calendar.MONTH, Calendar.MARCH, new int[] {0, 1, 2},
                mPickerView, KeyEvent.KEYCODE_DPAD_DOWN);
        long executionTime = System.currentTimeMillis() - startTime;
        Log.d(TAG, ""testFebruaryToMarchTransition() Execution time: "" + executionTime);
        Thread.sleep(FINAL_WAIT);
    }
",non-flaky,5
178034,aosp-mirror_platform_frameworks_support,GuidedDatePickerTest.testDecemberToNovemberTransition,"    @Test
    public void testDecemberToNovemberTransition() throws Throwable {
        long startTime = System.currentTimeMillis();
        Intent intent = new Intent();

        String title = ""Date Picker Transition Test"";
        String breadcrumb = ""Month Transition Test Demo"";
        String description = ""Testing the transition from Dec to Nov"";
        GuidanceStylist.Guidance guidance = new GuidanceStylist.Guidance(title, description,
                breadcrumb, null);

        List<GuidedAction> actionList = new ArrayList<>();

        Calendar cal = Calendar.getInstance();

        cal.set(Calendar.YEAR, 2016);
        cal.set(Calendar.MONTH, Calendar.DECEMBER);
        cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));
        Date initialDate = cal.getTime();

        GuidedDatePickerAction action = new GuidedDatePickerAction.Builder(
                mContext)
                .id(0)
                .title(""Date"")
                .date(initialDate.getTime())
                .datePickerFormat(""DMY"")
                .build();

        actionList.add(action);

        GuidedStepAttributesTestFragment.clear();
        GuidedStepAttributesTestFragment.GUIDANCE = guidance;
        GuidedStepAttributesTestFragment.ACTION_LIST = actionList;

        initActivity(intent);

        DatePicker mPickerView = (DatePicker) mActivity.findViewById(
                R.id.guidedactions_activator_item);

        verticalScrollToFieldValue(Calendar.MONTH, Calendar.NOVEMBER, new int[] {0, 1, 2},
                mPickerView, KeyEvent.KEYCODE_DPAD_UP);
        long executionTime = System.currentTimeMillis() - startTime;
        Log.d(TAG, ""testDecemberToNovember() Execution time: "" + executionTime);
        Thread.sleep(FINAL_WAIT);
    }
",non-flaky,5
178035,aosp-mirror_platform_frameworks_support,GuidedDatePickerTest.testNovemberToOctoberTransition,"    @Test
    public void testNovemberToOctoberTransition() throws Throwable {
        long startTime = System.currentTimeMillis();
        Intent intent = new Intent();

        String title = ""Date Picker Transition Test"";
        String breadcrumb = ""Month Transition Test Demo"";
        String description = ""Testing the transition from Nov to Oct"";
        GuidanceStylist.Guidance guidance = new GuidanceStylist.Guidance(title, description,
                breadcrumb, null);

        List<GuidedAction> actionList = new ArrayList<>();

        Calendar cal = Calendar.getInstance();

        cal.set(Calendar.YEAR, 2016);
        cal.set(Calendar.MONTH, Calendar.NOVEMBER);
        cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));
        Date initialDate = cal.getTime();

        GuidedDatePickerAction action = new GuidedDatePickerAction.Builder(
                mContext)
                .id(0)
                .title(""Date"")
                .date(initialDate.getTime())
                .datePickerFormat(""DMY"")
                .build();

        actionList.add(action);

        GuidedStepAttributesTestFragment.clear();
        GuidedStepAttributesTestFragment.GUIDANCE = guidance;
        GuidedStepAttributesTestFragment.ACTION_LIST = actionList;

        initActivity(intent);

        DatePicker mPickerView = (DatePicker) mActivity.findViewById(
                R.id.guidedactions_activator_item);

        verticalScrollToFieldValue(Calendar.MONTH, Calendar.OCTOBER, new int[] {0, 1, 2},
                mPickerView, KeyEvent.KEYCODE_DPAD_UP);
        long executionTime = System.currentTimeMillis() - startTime;
        Log.d(TAG, ""testNovemberToOctober() Execution time: "" + executionTime);
        Thread.sleep(FINAL_WAIT);
    }
",non-flaky,5
178036,aosp-mirror_platform_frameworks_support,GuidedDatePickerTest.testLeapToNonLeapYearTransition,"    @Test
    public void testLeapToNonLeapYearTransition() throws Throwable {
        long startTime = System.currentTimeMillis();
        Intent intent = new Intent();

        String title = ""Date Picker Transition Test"";
        String breadcrumb = ""Leap Year Transition Test Demo"";
        String description = ""Testing Feb transition from leap to nonlneap year"";
        GuidanceStylist.Guidance guidance = new GuidanceStylist.Guidance(title, description,
                breadcrumb, null);

        List<GuidedAction> actionList = new ArrayList<>();

        Calendar cal = Calendar.getInstance();

        cal.set(Calendar.YEAR, 2016);   // 2016 is a leap year
        cal.set(Calendar.MONTH, Calendar.FEBRUARY);
        cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));
        Date initialDate = cal.getTime();

        GuidedDatePickerAction action = new GuidedDatePickerAction.Builder(
                mContext)
                .id(0)
                .title(""Date"")
                .date(initialDate.getTime())
                .datePickerFormat(""DMY"")
                .build();

        actionList.add(action);

        GuidedStepAttributesTestFragment.clear();
        GuidedStepAttributesTestFragment.GUIDANCE = guidance;
        GuidedStepAttributesTestFragment.ACTION_LIST = actionList;

        initActivity(intent);

        DatePicker mPickerView = (DatePicker) mActivity.findViewById(
                R.id.guidedactions_activator_item);

        verticalScrollToFieldValue(Calendar.YEAR, 2017, new int[] {0, 1, 2},
                mPickerView, KeyEvent.KEYCODE_DPAD_DOWN);
        long executionTime = System.currentTimeMillis() - startTime;
        Log.d(TAG, ""testLeapToNonLeapYearTransition() Execution time: "" + executionTime);
        Thread.sleep(FINAL_WAIT);
    }
",non-flaky,5
178037,aosp-mirror_platform_frameworks_support,GuidedDatePickerTest.testNonLeapToLeapYearTransition,"    @Test
    public void testNonLeapToLeapYearTransition() throws Throwable {
        long startTime = System.currentTimeMillis();
        Intent intent = new Intent();

        String title = ""Date Picker Transition Test"";
        String breadcrumb = ""Leap Year Transition Test Demo"";
        String description = ""Testing Feb transition from nonleap to leap year"";
        GuidanceStylist.Guidance guidance = new GuidanceStylist.Guidance(title, description,
                breadcrumb, null);

        List<GuidedAction> actionList = new ArrayList<>();

        Calendar cal = Calendar.getInstance();

        cal.set(Calendar.YEAR, 2017);   // 2017 is a non-leap year
        cal.set(Calendar.MONTH, Calendar.FEBRUARY);
        cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));
        Date initialDate = cal.getTime();

        GuidedDatePickerAction action = new GuidedDatePickerAction.Builder(
                mContext)
                .id(0)
                .title(""Date"")
                .date(initialDate.getTime())
                .datePickerFormat(""DMY"")
                .build();

        actionList.add(action);

        GuidedStepAttributesTestFragment.clear();
        GuidedStepAttributesTestFragment.GUIDANCE = guidance;
        GuidedStepAttributesTestFragment.ACTION_LIST = actionList;

        initActivity(intent);

        DatePicker mPickerView = (DatePicker) mActivity.findViewById(
                R.id.guidedactions_activator_item);

        verticalScrollToFieldValue(Calendar.YEAR, 2016, new int[] {0, 1, 2},
                mPickerView, KeyEvent.KEYCODE_DPAD_UP);
        long executionTime = System.currentTimeMillis() - startTime;
        Log.d(TAG, ""testNonLeapToLeapYearTransition() Execution time: "" + executionTime);
        Thread.sleep(FINAL_WAIT);
    }
",non-flaky,5
178038,aosp-mirror_platform_frameworks_support,GuidedDatePickerTest.testDateRangesMDYFormat,"    @Test
    public void testDateRangesMDYFormat() throws Throwable {

        long startTime = System.currentTimeMillis();

        GuidedDatePickerAction[] datePickerActions = setupDateActionsForMinAndMaxRangeTests();

        scrollToMinAndMaxDates(new int[] {1, 0, 2}, datePickerActions[0]);
        long executionTime = System.currentTimeMillis() - startTime;
        Log.d(TAG, ""testDateRangesMDYFormat() Execution time: "" + executionTime);
        Thread.sleep(FINAL_WAIT);
    }
",non-flaky,5
178039,aosp-mirror_platform_frameworks_support,GuidedDatePickerTest.testDateRangesWithYearEqual,"    @Test
    public void testDateRangesWithYearEqual() throws Throwable {

        long startTime = System.currentTimeMillis();

        GuidedDatePickerAction[] datePickerActions = setupDateActionsForMinAndMaxRangeTests();

        scrollToMinAndMaxDates(new int[] {0, 1, 2}, datePickerActions[2]);
        long executionTime = System.currentTimeMillis() - startTime;
        Log.d(TAG, ""testDateRangesWithYearEqual() Execution time: "" + executionTime);
        Thread.sleep(FINAL_WAIT);
    }
",non-flaky,5
178040,aosp-mirror_platform_frameworks_support,GuidedDatePickerTest.testDateRangesWithMonthAndYearEqual,"    @Test
    public void testDateRangesWithMonthAndYearEqual() throws Throwable {

        long startTime = System.currentTimeMillis();

        GuidedDatePickerAction[] datePickerActions = setupDateActionsForMinAndMaxRangeTests();

        scrollToMinAndMaxDates(new int[] {0, 1, 2}, datePickerActions[3]);
        long executionTime = System.currentTimeMillis() - startTime;
        Log.d(TAG, ""testDateRangesWithMonthAndYearEqual() Execution time: "" + executionTime);
        Thread.sleep(FINAL_WAIT);
    }
",non-flaky,5
178041,aosp-mirror_platform_frameworks_support,GuidedDatePickerTest.testDateRangesWithAllFieldsEqual,"    @Test
    public void testDateRangesWithAllFieldsEqual() throws Throwable {

        long startTime = System.currentTimeMillis();

        GuidedDatePickerAction[] datePickerActions = setupDateActionsForMinAndMaxRangeTests();

        scrollToMinAndMaxDates(new int[] {0, 1, 2}, datePickerActions[4]);
        long executionTime = System.currentTimeMillis() - startTime;
        Log.d(TAG, ""testDateRangesWithAllFieldsEqual() Execution time: "" + executionTime);
        Thread.sleep(FINAL_WAIT);
    }
",non-flaky,5
178042,aosp-mirror_platform_frameworks_support,GuidedStepAttributesTest.testFocusDisabledOnActions,"    @Test
    public void testFocusDisabledOnActions() throws Throwable {

        Intent intent = new Intent();
        Resources res = mContext.getResources();

        final int NUM_SEARCH_ACTIONS = 10;
        final List<Integer> ACTIONS_WITH_DISABLED_FOCUS = new ArrayList<>(
                Arrays.asList(1, 3, 4, 5, 8));
        final int ACTION_ID_SEARCH = 1;
        List<Integer> EXPECTED_ACTIONS_ID_AFTER_EACH_SELECT = new ArrayList<>();

        // we will traverse actions from top to bottom and then back to the top
        for(int i = 0; i < NUM_SEARCH_ACTIONS; i++) {
            if (!ACTIONS_WITH_DISABLED_FOCUS.contains(i))
                EXPECTED_ACTIONS_ID_AFTER_EACH_SELECT.add(i);
        }
        for(int i = EXPECTED_ACTIONS_ID_AFTER_EACH_SELECT.size(); i-- != 0;) {
            EXPECTED_ACTIONS_ID_AFTER_EACH_SELECT.add(EXPECTED_ACTIONS_ID_AFTER_EACH_SELECT.get(i));
        }


        String title = ""Guided Actions Focusable Test"";
        String breadcrumb = ""Focusable Test Demo"";
        String description = """";
        GuidanceStylist.Guidance guidance = new GuidanceStylist.Guidance(title, description,
                breadcrumb, null);

        List<GuidedAction> actionList = new ArrayList<>();
        for (int i = 0; i < NUM_SEARCH_ACTIONS; i++ ) {
            actionList.add(new GuidedAction.Builder(mContext)
                    .id(ACTION_ID_SEARCH)
                    .title(res.getString(R.string.search) + """" + i)
                    .description(res.getString(R.string.search_description) + i)
                    .build()
            );
        }
        for(int action_id : ACTIONS_WITH_DISABLED_FOCUS )
            actionList.get(action_id).setFocusable(false);

        GuidedStepAttributesTestFragment.GUIDANCE = guidance;
        GuidedStepAttributesTestFragment.ACTION_LIST = actionList;

        initActivity(intent);

        int lastSelectedActionId = -1;
        int selectIndex = 0;
        GuidedStepFragment mFragment = (GuidedStepFragment) mActivity.getGuidedStepTestFragment();
        int prevSelectedActionPosition = -1;
        int nextSelectedActionPosition = mFragment.getSelectedActionPosition();
        while ( nextSelectedActionPosition != prevSelectedActionPosition ) {
            lastSelectedActionId = mFragment.getSelectedActionPosition();
            assertTrue(res.getString(R.string.focusable_test_error_message,
                    actionList.get(lastSelectedActionId).getTitle()),
                    lastSelectedActionId == EXPECTED_ACTIONS_ID_AFTER_EACH_SELECT.get(selectIndex));
            selectIndex++;
            sendKey(KeyEvent.KEYCODE_DPAD_DOWN);
            prevSelectedActionPosition = nextSelectedActionPosition;
            nextSelectedActionPosition = mFragment.getSelectedActionPosition();
            Thread.sleep(TRANSITION_LENGTH);
        }

        prevSelectedActionPosition = -1;
        while ( nextSelectedActionPosition != prevSelectedActionPosition ) {
            lastSelectedActionId = mFragment.getSelectedActionPosition();
            assertTrue(res.getString(R.string.focusable_test_error_message,
                    actionList.get(lastSelectedActionId).getTitle()),
                    lastSelectedActionId == EXPECTED_ACTIONS_ID_AFTER_EACH_SELECT.get(selectIndex));
            selectIndex++;
            sendKey(KeyEvent.KEYCODE_DPAD_UP);
            prevSelectedActionPosition = nextSelectedActionPosition;
            nextSelectedActionPosition = mFragment.getSelectedActionPosition();
            Thread.sleep(TRANSITION_LENGTH);
        }

    }
",non-flaky,5
178043,aosp-mirror_platform_frameworks_support,GuidedStepAttributesTest.testDisabledActions,"    @Test
    public void testDisabledActions() throws Throwable {

        Intent intent = new Intent();
        Resources res = mContext.getResources();

        final int NUM_SEARCH_ACTIONS = 10;
        final List<Integer> DISABLED_ACTIONS = new ArrayList<>(
                Arrays.asList(1, 3, 5, 7));
        final int ACTION_ID_REVERT_BUTTON = 0;
        final int ACTION_ID_SEARCH_BEGIN = ACTION_ID_REVERT_BUTTON + 1;
        int ACTION_ID_SEARCH_END = ACTION_ID_SEARCH_BEGIN;

        // sequence of clicked actions simulated in the test
        List<Integer> CLICK_SEQUENCE = new ArrayList<>();

        // Expected Clicked sequence can be different from focused ones since some of the actions
        // are disabled hence not clickable
        List<Integer> EXPECTED_FOCUSED_SEQUENCE = new ArrayList<>();
        List<Integer> EXPECTED_CLICKED_SEQUENCE = new ArrayList<>();
        // Expected actions state according to list of DISABLED_ACTIONS: false for disabled actions
        List<Boolean> EXPECTED_ACTIONS_STATE = new ArrayList<>(
                Arrays.asList(new Boolean[NUM_SEARCH_ACTIONS])
        );
        Collections.fill(EXPECTED_ACTIONS_STATE, Boolean.TRUE);

        for(int i = 0; i < NUM_SEARCH_ACTIONS; i++) {
            CLICK_SEQUENCE.add(i + 1);
        }
        for(int clickedActionId : CLICK_SEQUENCE) {
            EXPECTED_FOCUSED_SEQUENCE.add(clickedActionId);
            if (!DISABLED_ACTIONS.contains(clickedActionId - 1))
                EXPECTED_CLICKED_SEQUENCE.add(clickedActionId);
            else
                EXPECTED_CLICKED_SEQUENCE.add(-1);
        }

        String title = ""Guided Actions Enabled Test"";
        String breadcrumb = ""Enabled Test Demo"";
        String description = """";
        GuidanceStylist.Guidance guidance = new GuidanceStylist.Guidance(title, description,
                breadcrumb, null);

        List<GuidedAction> actionList = new ArrayList<>();
        actionList.add(new GuidedAction.Builder(mContext)
                .id(ACTION_ID_REVERT_BUTTON)
                .title(res.getString(R.string.invert_title))
                .description(res.getString(R.string.revert_description))
                .build()
        );

        for (int i = 0; i < NUM_SEARCH_ACTIONS; i++ ) {
            actionList.add(new GuidedAction.Builder(mContext)
                    .id(ACTION_ID_SEARCH_END++)
                    .title(res.getString(R.string.search) + """" + i)
                    .description(res.getString(R.string.search_description) + i)
                    .build()
            );
        }
        for(int action_id : DISABLED_ACTIONS ) {
            if ( action_id >= 0 && action_id < NUM_SEARCH_ACTIONS ) {
                actionList.get(action_id + 1).setEnabled(false);
                EXPECTED_ACTIONS_STATE.set(action_id, Boolean.FALSE);
            }
        }

        GuidedStepAttributesTestFragment.clear();
        GuidedStepAttributesTestFragment.GUIDANCE = guidance;
        GuidedStepAttributesTestFragment.ACTION_LIST = actionList;
        GuidedStepAttributesTestFragment.setActionClickCallback(ACTION_ID_REVERT_BUTTON,
                sRevertCallback);

        initActivity(intent);

        examineEnabledAndDisabledActions(actionList, CLICK_SEQUENCE, EXPECTED_FOCUSED_SEQUENCE,
                EXPECTED_CLICKED_SEQUENCE);
    }
",non-flaky,5
178044,aosp-mirror_platform_frameworks_support,GuidedStepAttributesTest.run,"    @Test
    public void testToggleEnabledFlags() throws Throwable {

        Intent intent = new Intent();
        Resources res = mContext.getResources();

        final int NUM_SEARCH_ACTIONS = 10;
        final List<Integer> DISABLED_ACTIONS = new ArrayList<>(
                Arrays.asList(1, 3, 5, 7));
        final int ACTION_ID_REVERT_BUTTON = 0;
        final int ACTION_ID_SEARCH_BEGIN = ACTION_ID_REVERT_BUTTON + 1;
        int ACTION_ID_SEARCH_END = ACTION_ID_SEARCH_BEGIN;

        // sequence of clicked actions simulated in the test
        List<Integer> CLICK_SEQUENCE = new ArrayList<>();

        // Expected Clicked sequence can be different from focused ones since some of the actions
        // are disabled hence not clickable
        List<Integer> EXPECTED_FOCUSED_SEQUENCE = new ArrayList<>();
        List<Integer> EXPECTED_CLICKED_SEQUENCE = new ArrayList<>();
        // Expected actions state according to list of DISABLED_ACTIONS: false for disabled actions
        List<Boolean> EXPECTED_ACTIONS_STATE = new ArrayList<>(
                Arrays.asList(new Boolean[NUM_SEARCH_ACTIONS])
        );
        Collections.fill(EXPECTED_ACTIONS_STATE, Boolean.FALSE);

        for(int i = 0; i < NUM_SEARCH_ACTIONS; i++) {
            CLICK_SEQUENCE.add(i + 1);
        }
        for(int clickedActionId : CLICK_SEQUENCE) {
            EXPECTED_FOCUSED_SEQUENCE.add(clickedActionId);
            if (DISABLED_ACTIONS.contains(clickedActionId - 1))
                EXPECTED_CLICKED_SEQUENCE.add(clickedActionId);
            else
                EXPECTED_CLICKED_SEQUENCE.add(-1);
        }

        String title = ""Guided Actions Enabled Test"";
        String breadcrumb = ""Toggle Enabled Flag Test Demo"";
        String description = """";
        GuidanceStylist.Guidance guidance = new GuidanceStylist.Guidance(title, description,
                breadcrumb, null);

        List<GuidedAction> actionList = new ArrayList<>();
        actionList.add(new GuidedAction.Builder(mContext)
                .id(ACTION_ID_REVERT_BUTTON)
                .title(res.getString(R.string.invert_title))
                .description(res.getString(R.string.revert_description))
                .build()
        );

        for (int i = 0; i < NUM_SEARCH_ACTIONS; i++ ) {
            actionList.add(new GuidedAction.Builder(mContext)
                    .id(ACTION_ID_SEARCH_END++)
                    .title(res.getString(R.string.search) + """" + i)
                    .description(res.getString(R.string.search_description) + i)
                    .build()
            );
        }
        for(int action_id : DISABLED_ACTIONS ) {
            if ( action_id >= 0 && action_id < NUM_SEARCH_ACTIONS ) {
                actionList.get(action_id + 1).setEnabled(false);
                EXPECTED_ACTIONS_STATE.set(action_id, Boolean.TRUE);
            }
        }

        GuidedStepAttributesTestFragment.clear();
        GuidedStepAttributesTestFragment.GUIDANCE = guidance;
        GuidedStepAttributesTestFragment.ACTION_LIST = actionList;
        GuidedStepAttributesTestFragment.setActionClickCallback(ACTION_ID_REVERT_BUTTON,
                sRevertCallback);

        initActivity(intent);

        final GuidedStepFragment mFragment = (GuidedStepFragment)
                mActivity.getGuidedStepTestFragment();

        mActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                mFragment.setSelectedActionPosition(0);
            }
",non-flaky,5
178045,aosp-mirror_platform_frameworks_support,GuidedStepAttributesTest.testCheckedActions,"    @Test
    public void testCheckedActions() throws Throwable {

        Intent intent = new Intent();
        Resources res = mContext.getResources();

        final int NUM_RADIO_ACTIONS = 3;
        final int NUM_CHECK_BOX_ACTIONS = 3;
        final int INITIALLY_CHECKED_RADIO_ACTION = 0;
        final List<Integer> INITIALLY_CHECKED_CHECKBOX_ACTIONS = new ArrayList<>(
                Arrays.asList(1, 2)
        );

        List<Integer> CLICK_SEQUENCE = new ArrayList<>();
        for(int i = 0; i < NUM_RADIO_ACTIONS + NUM_CHECK_BOX_ACTIONS; i++) {
            CLICK_SEQUENCE.add(i);
        }

        List<Boolean> EXPECTED_ACTIONS_STATE_AFTER_EACH_CLICK = new ArrayList<>(
                Arrays.asList(new Boolean[CLICK_SEQUENCE.size()])
        );
        Collections.fill(EXPECTED_ACTIONS_STATE_AFTER_EACH_CLICK, Boolean.FALSE);

        // initial state of actions before any clicks happen
        EXPECTED_ACTIONS_STATE_AFTER_EACH_CLICK.set(INITIALLY_CHECKED_RADIO_ACTION, true);
        for(int checkedCheckBox : INITIALLY_CHECKED_CHECKBOX_ACTIONS) {
            EXPECTED_ACTIONS_STATE_AFTER_EACH_CLICK.set(NUM_RADIO_ACTIONS + checkedCheckBox, true);
        }

        String title = ""Guided Actions Checked Test"";
        String breadcrumb = ""Checked Test Demo"";
        String description = """";
        GuidanceStylist.Guidance guidance = new GuidanceStylist.Guidance(title, description,
                breadcrumb, null);

        List<GuidedAction> actionList = new ArrayList<>();
        actionList.add(new GuidedAction.Builder(mContext)
                .title(res.getString(R.string.radio_actions_info_title))
                .description(res.getString(R.string.radio_actions_info_desc))
                .infoOnly(true)
                .enabled(true)
                .focusable(false)
                .build()
        );

        int firstRadioActionIndex = actionList.size();
        for(int i = 0; i < NUM_RADIO_ACTIONS; i++) {
            actionList.add(new GuidedAction.Builder(mContext)
                    .title(res.getString(R.string.checkbox_title) + i)
                    .description(res.getString(R.string.checkbox_desc) + i)
                    .checkSetId(GuidedAction.DEFAULT_CHECK_SET_ID)
                    .build()
            );
            if (i == INITIALLY_CHECKED_RADIO_ACTION)
                actionList.get(firstRadioActionIndex + i).setChecked(true);
        }

        actionList.add(new GuidedAction.Builder(mContext)
                .title(res.getString(R.string.checkbox_actions_info_title))
                .description(res.getString(R.string.checkbox_actions_info_desc))
                .infoOnly(true)
                .enabled(true)
                .focusable(false)
                .build()
        );
        int firstCheckBoxActionIndex = actionList.size();
        for(int i = 0; i < NUM_CHECK_BOX_ACTIONS; i++) {
            actionList.add(new GuidedAction.Builder(mContext)
                    .title(res.getString(R.string.checkbox_title) + i)
                    .description(res.getString(R.string.checkbox_desc) + i)
                    .checkSetId(GuidedAction.CHECKBOX_CHECK_SET_ID)
                    .build()
            );
        }
        for(int i = 0; i < INITIALLY_CHECKED_CHECKBOX_ACTIONS.size(); i++ ) {
            actionList.get(firstCheckBoxActionIndex + INITIALLY_CHECKED_CHECKBOX_ACTIONS.get(i))
                    .setChecked(true);
        }

        GuidedStepAttributesTestFragment.GUIDANCE = guidance;
        GuidedStepAttributesTestFragment.ACTION_LIST = actionList;
        initActivity(intent);

        examineCheckedAndUncheckedActions(actionList, EXPECTED_ACTIONS_STATE_AFTER_EACH_CLICK,
                NUM_RADIO_ACTIONS, NUM_CHECK_BOX_ACTIONS);
    }
",non-flaky,5
178046,aosp-mirror_platform_frameworks_support,GuidedStepAttributesTest.testActionWithTwoSubActions,"    @Test
    public void testActionWithTwoSubActions() throws Throwable {
        ExpectedSubActionResult result = setUpActionsForSubActionsTest();

        final int actionPos = 0;
        final GuidedAction selectedAction = result.actionList.get(actionPos);
        List<Integer> expectedFocusedSeq = result.expectedFocusedSeq.get(actionPos);
        List<Integer> expectedClickedSeq = result.expectedClickedSeq.get(actionPos);

        traverseSubActionsAndVerifyFocusAndClickEvents(selectedAction, actionPos, expectedFocusedSeq,
                expectedClickedSeq);
    }
",non-flaky,5
178047,aosp-mirror_platform_frameworks_support,GuidedStepAttributesTest.testActionWithOneSubAction,"    @Test
    public void testActionWithOneSubAction() throws Throwable {
        ExpectedSubActionResult result = setUpActionsForSubActionsTest();

        final int actionPos = 1;
        final GuidedAction selectedAction = result.actionList.get(actionPos);
        List<Integer> expectedFocusedSeq = result.expectedFocusedSeq.get(actionPos);
        List<Integer> expectedClickedSeq = result.expectedClickedSeq.get(actionPos);

        traverseSubActionsAndVerifyFocusAndClickEvents(selectedAction, actionPos, expectedFocusedSeq,
                expectedClickedSeq);
    }
",non-flaky,5
178048,aosp-mirror_platform_frameworks_support,GuidedStepAttributesTest.testActionWithZeroSubActions,"    @Test
    public void testActionWithZeroSubActions() throws Throwable {
        ExpectedSubActionResult result = setUpActionsForSubActionsTest();

        final int actionPos = 2;
        final GuidedAction selectedAction = result.actionList.get(actionPos);
        List<Integer> expectedFocusedSeq = result.expectedFocusedSeq.get(actionPos);
        List<Integer> expectedClickedSeq = result.expectedClickedSeq.get(actionPos);

        traverseSubActionsAndVerifyFocusAndClickEvents(selectedAction, actionPos, expectedFocusedSeq,
                expectedClickedSeq);
    }
",non-flaky,5
178049,aosp-mirror_platform_frameworks_support,GuidedStepAttributesTest.testActionWithThreeSubActions,"    @Test
    public void testActionWithThreeSubActions() throws Throwable {
        ExpectedSubActionResult result = setUpActionsForSubActionsTest();

        final int actionPos = 3;
        final GuidedAction selectedAction = result.actionList.get(actionPos);
        List<Integer> expectedFocusedSeq = result.expectedFocusedSeq.get(actionPos);
        List<Integer> expectedClickedSeq = result.expectedClickedSeq.get(actionPos);

        traverseSubActionsAndVerifyFocusAndClickEvents(selectedAction, actionPos, expectedFocusedSeq,
                expectedClickedSeq);
    }
",non-flaky,5
178050,aosp-mirror_platform_frameworks_support,PlaybackControlSupportGlueTest.testFastForwardToMaxThenReset,"    @Test
    public void testFastForwardToMaxThenReset() {
        PlaybackControlsRow row = new PlaybackControlsRow();
        glue.setControlsRow(row);
        SparseArrayObjectAdapter adapter = (SparseArrayObjectAdapter)
                row.getPrimaryActionsAdapter();
        PlaybackControlsRow.MultiAction playPause = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlSupportGlue.ACTION_PLAY_PAUSE);
        PlaybackControlsRow.MultiAction fastForward = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlSupportGlue.ACTION_FAST_FORWARD);
        PlaybackControlsRow.MultiAction rewind = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlSupportGlue.ACTION_REWIND);

        assertFalse(glue.isMediaPlaying());
        glue.onActionClicked(playPause);
        assertTrue(glue.isMediaPlaying());
        assertEquals(PlaybackControlSupportGlue.PLAYBACK_SPEED_NORMAL, glue.getCurrentSpeedId());
        assertEquals(0, fastForward.getIndex());
        assertEquals(0, rewind.getIndex());

        // click multiple times to reach PLAYBACK_SPEED_FAST_L2
        glue.onActionClicked(fastForward);
        assertEquals(PlaybackControlSupportGlue.PLAYBACK_SPEED_FAST_L0, glue.getCurrentSpeedId());
        assertEquals(1, fastForward.getIndex());
        assertEquals(0, rewind.getIndex());
        glue.onActionClicked(fastForward);
        assertEquals(PlaybackControlSupportGlue.PLAYBACK_SPEED_FAST_L1, glue.getCurrentSpeedId());
        assertEquals(2, fastForward.getIndex());
        assertEquals(0, rewind.getIndex());
        glue.onActionClicked(fastForward);
        assertEquals(PlaybackControlSupportGlue.PLAYBACK_SPEED_FAST_L2, glue.getCurrentSpeedId());
        assertEquals(3, fastForward.getIndex());
        assertEquals(0, rewind.getIndex());
        glue.onActionClicked(fastForward);
        assertEquals(PlaybackControlSupportGlue.PLAYBACK_SPEED_FAST_L2, glue.getCurrentSpeedId());
        assertEquals(3, fastForward.getIndex());
        assertEquals(0, rewind.getIndex());

        // press playPause again put it back to play
        glue.onActionClicked(playPause);
        assertEquals(PlaybackControlSupportGlue.PLAYBACK_SPEED_NORMAL, glue.getCurrentSpeedId());
        assertEquals(0, fastForward.getIndex());
        assertEquals(0, rewind.getIndex());
    }
",non-flaky,5
178051,aosp-mirror_platform_frameworks_support,PlaybackControlSupportGlueTest.testFastRewindToMaxThenReset,"    @Test
    public void testFastRewindToMaxThenReset() {
        PlaybackControlsRow row = new PlaybackControlsRow();
        glue.setControlsRow(row);
        SparseArrayObjectAdapter adapter = (SparseArrayObjectAdapter)
                row.getPrimaryActionsAdapter();
        PlaybackControlsRow.MultiAction playPause = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlSupportGlue.ACTION_PLAY_PAUSE);
        PlaybackControlsRow.MultiAction fastForward = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlSupportGlue.ACTION_FAST_FORWARD);
        PlaybackControlsRow.MultiAction rewind = (PlaybackControlsRow.MultiAction) adapter
                .lookup(PlaybackControlSupportGlue.ACTION_REWIND);

        assertFalse(glue.isMediaPlaying());
        glue.onActionClicked(playPause);
        assertTrue(glue.isMediaPlaying());
        assertEquals(PlaybackControlSupportGlue.PLAYBACK_SPEED_NORMAL, glue.getCurrentSpeedId());
        assertEquals(0, fastForward.getIndex());
        assertEquals(0, rewind.getIndex());

        // click multiple times to reach PLAYBACK_SPEED_FAST_L2
        glue.onActionClicked(rewind);
        assertEquals(-PlaybackControlSupportGlue.PLAYBACK_SPEED_FAST_L0, glue.getCurrentSpeedId());
        assertEquals(0, fastForward.getIndex());
        assertEquals(1, rewind.getIndex());
        glue.onActionClicked(rewind);
        assertEquals(-PlaybackControlSupportGlue.PLAYBACK_SPEED_FAST_L1, glue.getCurrentSpeedId());
        assertEquals(0, fastForward.getIndex());
        assertEquals(2, rewind.getIndex());
        glue.onActionClicked(rewind);
        assertEquals(-PlaybackControlSupportGlue.PLAYBACK_SPEED_FAST_L2, glue.getCurrentSpeedId());
        assertEquals(0, fastForward.getIndex());
        assertEquals(3, rewind.getIndex());
        glue.onActionClicked(rewind);
        assertEquals(-PlaybackControlSupportGlue.PLAYBACK_SPEED_FAST_L2, glue.getCurrentSpeedId());
        assertEquals(0, fastForward.getIndex());
        assertEquals(3, rewind.getIndex());

        // press playPause again put it back to play
        glue.onActionClicked(playPause);
        assertEquals(PlaybackControlSupportGlue.PLAYBACK_SPEED_NORMAL, glue.getCurrentSpeedId());
        assertEquals(0, fastForward.getIndex());
        assertEquals(0, rewind.getIndex());
    }
",non-flaky,5
