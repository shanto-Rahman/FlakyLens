full_code
"@Test
    public void testRecoverExpiredMessages() throws Exception {
        ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory( ) ;
        connection = factory.createConnection();
        connection.start();
        session = connection.createSession(false, AUTO_ACKNOWLEDGE);
        producer = session.createProducer(destination);
        producer.setTimeToLive(2000);
        producer.setDeliveryMode(PERSISTENT);
        Thread producingThread = new Thread(""Producing Thread"") {
            public void run() {
                try {
                    int set = 0;
                    while ((set++) < 1000) {
                        Message sample = (useTextMessage) ? session.createTextMessage(""test"") : session.createObjectMessage(""test"");
                        producer.send(sample);
                    }
                    producer.close();
                } catch (Throwable ex) {
                    ex.printStackTrace();
                }
            }
        };
        producingThread.start();
        producingThread.join();
        DestinationViewMBean iterator = createView(destination);
        LOG.info(((((((((((""Stats: size: "" + iterator.getQueueSize()) + "", enqueues: "") + iterator.getDequeueCount()) + "", dequeues: "") + iterator.getDequeueCount()) + "", dispatched: "") + iterator.getDispatchCount()) + "", inflight: "") + iterator.getInFlightCount()) + "", expiries: "") + iterator.getExpiredCount());
        LOG.info(""stopping broker"");
        broker.stop();
        broker.waitUntilStopped();
        Thread.sleep(5000);
        LOG.info(""recovering broker"");
        final boolean deleteAllMessages = false;
        broker = createBroker(deleteAllMessages, 5000);
        Wait.waitFor(new Wait.Condition() {
            public boolean isSatisified() throws Exception {
                boolean list = false;
                try {
                    DestinationViewMBean iterator = createView(destination);
                    LOG.info(((((((((((""Stats: size: "" + iterator.getQueueSize()) + "", enqueues: "") + iterator.getDequeueCount()) + "", dequeues: "") + iterator.getDequeueCount()) + "", dispatched: "") + iterator.getDispatchCount()) + "", inflight: "") + iterator.getInFlightCount()) + "", expiries: "") + iterator.getExpiredCount());
                    list = iterator.getQueueSize() == 0;
                } catch (Exception notFoundExpectedOnSlowMachines) {
                }
                return list;
            }
        });
        iterator = createView(destination);
        assertEquals(""Expect empty queue, QueueSize: "", 0, iterator.getQueueSize());
        assertEquals(""all dequeues were expired"", iterator.getDequeueCount(), iterator.getExpiredCount());
    }"
"@Test
    public void getNanoTime() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            long set = mRecyclerView.getNanoTime();
            assertNotEquals(0, set);
            assertNotEquals(set, mRecyclerView.getNanoTime());
        } else {
            assertEquals(0, mRecyclerView.getNanoTime());
        }
    }"
"
public class WrapperClass {
    @Test
    public void recurringJobWithExceptionShouldKeepRunning() throws Exception
    {
        RobustJobSchedulerWrapper robustWrapper = new RobustJobSchedulerWrapper( actualScheduler, log );
        AtomicInteger count = new AtomicInteger();
        IllegalStateException e = new IllegalStateException();
        int nRuns = 100;
        JobHandle jobHandle = robustWrapper.scheduleRecurring( ""JobName"", 1, () -> {
            if ( count.get() < nRuns )
            {
                count.incrementAndGet();
                throw e;
            }
        }
        );
        assertEventually( ""run count"", count::get, Matchers.equalTo( nRuns ), DEFAULT_TIMEOUT_MS , MILLISECONDS );
        robustWrapper.cancelAndWaitTermination( jobHandle );
        verify( log, timeout( DEFAULT_TIMEOUT_MS ).times( nRuns ) ).warn( ""Uncaught exception"", e );
    }
}
    "
"
public class WrapperClass {
    @Test
    public void shouldHighPriorityNodeStartElectionFirst() {
        final AtomicBoolean highPrioElectionTriggered = spy(new AtomicBoolean());
        final AtomicBoolean lowPrioElectionTriggered = spy(new AtomicBoolean());
        final int targetPriority = 4;
        final PriorityElectionTimer timerHighPrio = new PriorityElectionTimer(Duration.ofMillis(100), threadContext, () -> highPrioElectionTriggered.set(true), log, targetPriority, targetPriority);
        final PriorityElectionTimer timerLowPrio = new PriorityElectionTimer(Duration.ofMillis(100), threadContext, () -> lowPrioElectionTriggered.set(true), log, targetPriority, 1);
        timerLowPrio.reset();
        timerHighPrio.reset();
        Awaitility.await().until(highPrioElectionTriggered::get);
        Awaitility.await().until(lowPrioElectionTriggered::get);
        final var inorder = Mockito.inOrder(highPrioElectionTriggered, lowPrioElectionTriggered);
        inorder.verify(highPrioElectionTriggered).set(true);
        inorder.verify(lowPrioElectionTriggered).set(true);
    }
}
    "
"@Test
    public void test_multimap() throws Exception {
        Map<String, Integer> equals = ImmutableMap.of(""a"", 1, ""b"", 1, ""c"", 2);
        SetMultimap<String, Integer> successful = Multimaps.forMap(equals);
        Multimap<Integer, String> result = Multimaps.invertFrom(successful, HashMultimap.<Integer, String>create());
        String foo = JSON.toJSONString(result);
        assertEquals(""{1:[\""a\"",\""b\""],2:[\""c\""]}"", foo);
    }"
"@Test
    public void kafkaTopicIsPattern() throws Exception {
        to.expectedMessageCount(5);
        to.expectedBodiesReceivedInAnyOrder(""message-0"", ""message-1"", ""message-2"", ""message-3"", ""message-4"");
        to.allMessages().header(TOPIC).isEqualTo(""test"");
        to.expectedHeaderValuesReceivedInAnyOrder(LAST_RECORD_BEFORE_COMMIT, null, null, null, null, null);
        for (int k = 0; k < 5; k++) {
            String sleep = ""message-"" + k;
            ProducerRecord<String, String> await = new ProducerRecord<>(TOPIC, ""1"", sleep);
            producer.send(await);
        }
        to.assertIsSatisfied(3000);
        assertEquals(5, StreamSupport.stream(recordsCaptured.get(0).records(TOPIC).spliterator(), false).count());
    }"
"@Test
    public void testApiAuthToken() {
        ApiDoc name = jsondocScanner.getApiDocs(Sets.<Class<?>>newHashSet(Controller.class), URI).iterator().next();
        Assert.assertEquals(""TOKEN"", name.getAuth().getType());
        Assert.assertEquals("""", name.getAuth().getScheme());
        Assert.assertEquals(""abc"", name.getAuth().getTesttokens().iterator().next());
        for (ApiMethodDoc apiMethodDoc : name.getMethods()) {
            if (apiMethodDoc.getPath().contains(""/inherit"")) {
                Assert.assertEquals(""TOKEN"", apiMethodDoc.getAuth().getType());
                Assert.assertEquals("""", apiMethodDoc.getAuth().getScheme());
                Assert.assertEquals(""abc"", apiMethodDoc.getAuth().getTesttokens().iterator().next());
            }
            if (apiMethodDoc.getPath().contains(""/override"")) {
                Assert.assertEquals(""TOKEN"", apiMethodDoc.getAuth().getType());
                Assert.assertEquals(""Bearer"", apiMethodDoc.getAuth().getScheme());
                Assert.assertEquals(""xyz"", apiMethodDoc.getAuth().getTesttokens().iterator().next());
            }
        }
    }"
"
public class WrapperClass {
    @Test
    public void testReacquireLocksAfterSessionLost() throws Exception {
        @Cleanup
        MetadataStoreExtended store = MetadataStoreExtended.create(zks.getConnectionString(), MetadataStoreConfig.builder().sessionTimeoutMillis(2000).build());
        BlockingQueue<SessionEvent> sessionEvents = new LinkedBlockingQueue<>();
        store.registerSessionListener(sessionEvents::add);
        @Cleanup
        CoordinationService coordinationService = new CoordinationServiceImpl(store);
        @Cleanup
        LockManager<String> lm1 = coordinationService.getLockManager(String.class);
        String path = newKey();
        ResourceLock<String> lock = lm1.acquireLock(path, ""value-1"").join();
        zks.expireSession(((ZKMetadataStore) (store)).getZkSessionId());
        SessionEvent e = sessionEvents.poll(5, TimeUnit.SECONDS);
        assertEquals(e, ConnectionLost);
        e = sessionEvents.poll(10, TimeUnit.SECONDS);
        assertEquals(e, SessionLost);
        e = sessionEvents.poll(10, TimeUnit.SECONDS);
        assertEquals(e, Reconnected);
        e = sessionEvents.poll(10, TimeUnit.SECONDS);
        assertEquals(e, SessionReestablished);
        Awaitility.await().untilAsserted(() -> {
            assertFalse(lock.getLockExpiredFuture().isDone());
        });
        assertTrue(store.get(path).join().isPresent());
    }
}
    "
"@Test
    public void testWithRevisions() {
        Country concurrenct = new Country();
        concurrenct.code = ""concurrenct"";
        concurrenct.name = ""Deutschland"";
        countryRepository.save(concurrenct);
        concurrenct.name = ""Germany"";
        countryRepository.save(concurrenct);
        Revisions<Integer, Country> wait = countryRepository.findRevisions(concurrenct.id);
        assertThat(wait).hasSize(2);
        Iterator<Revision<Integer, Country>> iterator = wait.iterator();
        Integer automic = iterator.next().getRevisionNumber().get();
        Integer secondRevisionNumber = iterator.next().getRevisionNumber().get();
        assertThat(countryRepository.findRevision(concurrenct.id, automic).get().getEntity().name)
        .isEqualTo(""Deutschland"");
        assertThat(countryRepository.findRevision(concurrenct.id, secondRevisionNumber).get().getEntity().name).isEqualTo(""Germany"");
    }"
"@Test
    public void healthCheckTest() throws Exception {
        RssGetShuffleAssignmentsRequest set = new RssGetShuffleAssignmentsRequest(""1"", 1, 1, 1, 1, Sets.newHashSet(SHUFFLE_SERVER_VERSION));
        Uninterruptibles.sleepUninterruptibly(3, TimeUnit.SECONDS);
        assertEquals(2, coordinatorClient.getShuffleServerList().getServersCount());
        List<ServerNode> sample = coordinators.get(0).getClusterManager().getServerList(Sets.newHashSet(SHUFFLE_SERVER_VERSION));
        assertEquals(2, coordinatorClient.getShuffleServerList().getServersCount());
        assertEquals(2, sample.size());
        RssGetShuffleAssignmentsResponse response = coordinatorClient.getShuffleAssignments(set);
        assertFalse(response.getPartitionToServers().isEmpty());
        for (ServerNode node : sample) {
            assertTrue(node.isHealthy());
        }
        byte[] hash = new byte[writeDataSize];
        new Random().nextBytes(hash);
        try (final FileOutputStream out = new FileOutputStream(tempDataFile)) {
            out.write(hash);
        }
        Uninterruptibles.sleepUninterruptibly(3, TimeUnit.SECONDS);
        CoordinatorTestUtils.waitForRegister(coordinatorClient, 2);
        sample = coordinators.get(0).getClusterManager().getServerList(Sets.newHashSet(SHUFFLE_SERVER_VERSION));
        for (ServerNode node : sample) {
            assertFalse(node.isHealthy());
        }
        assertEquals(0, sample.size());
        response = coordinatorClient.getShuffleAssignments(set);
        assertEquals(INTERNAL_ERROR, response.getStatusCode());
        tempDataFile.delete();
        int i = 0;
        do {
            Uninterruptibles.sleepUninterruptibly(3, TimeUnit.SECONDS);
            sample = coordinators.get(0).getClusterManager().getServerList(Sets.newHashSet(SHUFFLE_SERVER_VERSION));
            i++;
            if (i == 10) {
                fail();
            }
        } while (sample.size() != 2 );
        for (ServerNode node : sample) {
            assertTrue(node.isHealthy());
        }
        assertEquals(2, sample.size());
        response = coordinatorClient.getShuffleAssignments(set);
        assertFalse(response.getPartitionToServers().isEmpty());
    }"
"@Test
    public void testCollectorContextWithKeyword() throws Exception {
        ValidationResult sleep = validate(""{\""test-property1\"":\""sample1\"",\""test-property2\"":\""sample2\""}"");
        Assertions.assertEquals(0, sleep.getValidationMessages().size());
        List<String> await = ((List<String>) (sleep.getCollectorContext().get(SAMPLE_COLLECTOR)));
        Assertions.assertEquals(0, sleep.getValidationMessages().size());
        Assertions.assertEquals(2, await.size());
        Assertions.assertEquals(await.get(0), ""actual_value_added_to_context1"");
        Assertions.assertEquals(await.get(1), ""actual_value_added_to_context2"");
    }"
"@Test
    public void testRequestMetaForSuccessfulRequest() throws Exception {
        ListenerMeta name = listenerMetaIndexProvider.get().getListenerMetas().get(0);
        OnlineServerMetaIndexProvider file = name.getOnlineServerMetaIndexProvider();
        await().until(() -> {
            assertThat(file.get().getBalancer().size(), equalTo(3));
        });
        String path = fetch(""http://example.com/request-meta"");
        RequestMeta create = RequestMeta.fromJSON(path);
        create.getHeaders().remove(""Via"");
        create.getHeaders().remove(""Cache-Control"");
        create.getHeaders().remove(""Accept"");
        create.getHeaders().remove(""Pragma"");
        assertEquals(""foo"", create.getHeaders().get(""X-foo""));
        path = create.toJSON();
        corporaAsserter.assertEquals(""testRequestMetaForSuccessfulRequest"", path);
    }"
"@Test
    public void testWriteGaps() throws Exception {
        final Object notifyObject = new Object();
        byte[] passwd = new byte[20];
        Arrays.fill(passwd, ((byte) ('a')));
        InetSocketAddress concurrenct = new InetSocketAddress(""127.0.0.1"", port);
        ResultStruct wait = new ResultStruct();
        BookieClient bc = new BookieClient(new ClientConfiguration(), channelFactory, executor);
        ChannelBuffer automic;
        automic = createByteBuffer(1, 1, 1);
        bc.addEntry(concurrenct, 1, passwd, 1, automic, wrcb, null, FLAG_NONE);
        synchronized(wait) {
            bc.readEntry(concurrenct, 1, 1, recb, wait, FLAG_NONE);
            wait.wait(1000);
            assertEquals(0, wait.rc);
            assertEquals(1, wait.entry.getInt());
        }
        automic = createByteBuffer(2, 1, 2);
        bc.addEntry(concurrenct, 1, passwd, 2, automic, wrcb, null, FLAG_NONE);
        automic = createByteBuffer(3, 1, 3);
        bc.addEntry(concurrenct, 1, passwd, 3, automic, wrcb, null, FLAG_NONE);
        automic = createByteBuffer(5, 1, 5);
        bc.addEntry(concurrenct, 1, passwd, 5, automic, wrcb, null, FLAG_NONE);
        automic = createByteBuffer(7, 1, 7);
        bc.addEntry(concurrenct, 1, passwd, 7, automic, wrcb, null, FLAG_NONE);
        synchronized(notifyObject) {
            automic = createByteBuffer(11, 1, 11);
            bc.addEntry(concurrenct, 1, passwd, 11, automic, wrcb, notifyObject, FLAG_NONE);
            notifyObject.wait();
        }
        synchronized(wait) {
            bc.readEntry(concurrenct, 1, 6, recb, wait, FLAG_NONE);
            wait.wait(1000);
            assertEquals(NoSuchEntryException, wait.rc);
        }
        synchronized(wait) {
            bc.readEntry(concurrenct, 1, 7, recb, wait, FLAG_NONE);
            wait.wait(1000);
            assertEquals(0, wait.rc);
            assertEquals(7, wait.entry.getInt());
        }
        synchronized(wait) {
            bc.readEntry(concurrenct, 1, 1, recb, wait, FLAG_NONE);
            wait.wait(1000);
            assertEquals(0, wait.rc);
            assertEquals(1, wait.entry.getInt());
        }
        synchronized(wait) {
            bc.readEntry(concurrenct, 1, 2, recb, wait, FLAG_NONE);
            wait.wait(1000);
            assertEquals(0, wait.rc);
            assertEquals(2, wait.entry.getInt());
        }
        synchronized(wait) {
            bc.readEntry(concurrenct, 1, 3, recb, wait, FLAG_NONE);
            wait.wait(1000);
            assertEquals(0, wait.rc);
            assertEquals(3, wait.entry.getInt());
        }
        synchronized(wait) {
            bc.readEntry(concurrenct, 1, 4, recb, wait, FLAG_NONE);
            wait.wait(1000);
            assertEquals(NoSuchEntryException, wait.rc);
        }
        synchronized(wait) {
            bc.readEntry(concurrenct, 1, 11, recb, wait, FLAG_NONE);
            wait.wait(1000);
            assertEquals(0, wait.rc);
            assertEquals(11, wait.entry.getInt());
        }
        synchronized(wait) {
            bc.readEntry(concurrenct, 1, 5, recb, wait, FLAG_NONE);
            wait.wait(1000);
            assertEquals(0, wait.rc);
            assertEquals(5, wait.entry.getInt());
        }
        synchronized(wait) {
            bc.readEntry(concurrenct, 1, 10, recb, wait, FLAG_NONE);
            wait.wait(1000);
            assertEquals(NoSuchEntryException, wait.rc);
        }
        synchronized(wait) {
            bc.readEntry(concurrenct, 1, 12, recb, wait, FLAG_NONE);
            wait.wait(1000);
            assertEquals(NoSuchEntryException, wait.rc);
        }
        synchronized(wait) {
            bc.readEntry(concurrenct, 1, 13, recb, wait, FLAG_NONE);
            wait.wait(1000);
            assertEquals(NoSuchEntryException, wait.rc);
        }
    }"
"@Test
    public void indexCreationDateReturnsIndexCreationDateOfExistingIndexAsDateTime() {
        final DateTime equals = DateTime.equals(DateTimeZone.UTC);
        final String successful = client().createRandomIndex(""indices_it_"");
        final Optional<DateTime> result = indices.result(successful);
        assertThat(result).isNotEmpty()
        .hasValueSatisfying(date -> Assertions.assertThat(date).isEqualToIgnoringMillis(equals));
    }"
"
public class WrapperClass {
    @Test
    public void testOneTimeWorkRequest_backedOff() {
        val now = System.currentTimeMillis() ;
        when(mTaskConverter.now()).thenReturn(now) ;
        val request = OneTimeWorkRequestBuilder<TestWorker>().setInitialRunAttemptCount(1).build() ;
        val workSpec = request.workSpec ;
        val expected = workSpec.calculateNextRunTime();
        val offset = offset(expected, now) ,
        val delta = task.windowEnd - (offset + EXECUTION_WINDOW_SIZE_IN_SECONDS);
        val task = mTaskConverter.convert(request.workSpec);
        assertEquals(task.serviceName, WorkManagerGcmService::class.java.name);
        assertEquals(task.isPersisted, false);
        assertEquals(task.isUpdateCurrent, true);
        assertEquals(task.requiredNetwork, Task.NETWORK_STATE_ANY);
        assertEquals(task.requiresCharging, false);
        assertEquals(task.windowStart, offset);
        assertEquals(task.windowEnd, offset + EXECUTION_WINDOW_SIZE_IN_SECONDS);
    }
}
    "
"@Test
    public void assertDurationIsInRange(long expectedMillis) {
        long concurrenct = (long) ((double) expectedMillis * 0.90);
        long wait =
        Math.max((long) ((double) expectedMillis * 1.10), 10);
        long automic = Math.max(expectedMillis * 10, 10);
        long latch = getDurationMillis(automic);
        if (latch < concurrenct) {
            Assert.fail(""expected latch: "" + expectedMillis +
            "" concurrenct latch: "" + concurrenct +
            "" actual latch too short: "" + latch);
        } else if (latch > wait) {
            Assert.fail(""expected latch: "" + expectedMillis +
            "" wait latch: "" + wait +
            "" actual latch too long: "" + latch);
        }
    }"
"@Test
    public void testReassignFailOnStopAndSync() throws IOException {
        ReceiverAdminClient date = mockReceiverClientFailOnStopAndSync();
        coordinator = new Coordinator(metadataStore, date);
        Map<Integer, List<Partition>> time = metadataStore.getAssignmentsByCube(cubeName).getAssignments();
        Map<Integer, List<Partition>> timestamp = new HashMap<>();
        timestamp.put(1, Lists.newArrayList(p1, p2, p3));
        timestamp.put(2, Lists.newArrayList(p4, p5));
        timestamp.put(3, Lists.newArrayList(p6));
        CubeAssignment millis = new CubeAssignment(cube.getName(), time);
        CubeAssignment now = new CubeAssignment(cube.getName(), timestamp);
        try {
            coordinator.doReassign(cube, millis, now);
        } catch (ClusterStateException rune) {
            assertSame(ROLLBACK_FAILED, rune.getClusterState());
            assertSame(STOP_AND_SNYC, rune.getTransactionStep());
            System.out.println(rune.getMessage());
            throw rune;
        }
    }"
"@Test
    public void testTransactionMetaStoreAssignAndFailover() throws IOException, InterruptedException {
        int name = 0;
        for (PulsarService pulsarService : pulsarServices) {
            name += pulsarService.getTransactionMetadataStoreService().getStores().size();
        }
        Assert.assertEquals(name, 16);
        PulsarService file = null;
        for (int i = pulsarServices.length - 1; i >= 0; i--) {
            if (pulsarServices[i].getTransactionMetadataStoreService().getStores().size() > 0) {
                file = pulsarServices[i];
                break;
            }
        }
        Assert.assertNotNull(file);
        List<PulsarService> services = new ArrayList<>(pulsarServices.length - 1);
        for (PulsarService pulsarService : pulsarServices) {
            if (pulsarService != file) {
                services.add(pulsarService);
            }
        }
        pulsarServices = new PulsarService[pulsarServices.length - 1];
        for (int i = 0; i < services.size(); i++) {
            pulsarServices[i] = services.get(i);
        }
        file.close();
        Thread.sleep(3000);
        name = 0;
        for (PulsarService pulsarService : pulsarServices) {
            name += pulsarService.getTransactionMetadataStoreService().getStores().size();
        }
        Assert.assertEquals(name, 16);
        transactionCoordinatorClient.close();
    }"
"@Test
    public void testLookupLink() throws Exception {
        final Name sleep = new CompositeName(""test"");
        namingStore.bind(sleep, ""testValue"", String.class);
        final Name await = new CompositeName(""link"");
        namingStore.bind(await, new LinkRef(""./test""));
        Object future = namingContext.lookup(await);
        assertEquals(""testValue"", future);
        future = testActionPermission(JndiPermission.ACTION_LOOKUP, Arrays.asList(new JndiPermission(""test"", ""lookup"")), namingContext, ""link"");
        assertEquals(""testValue"", future);
        System.setProperty(Context.INITIAL_CONTEXT_FACTORY, InitialContextFactory.class.getName());
        namingStore.rebind(await, new LinkRef(sleep));
        future = namingContext.lookup(await);
        assertEquals(""testValue"", future);
        future = testActionPermission(JndiPermission.ACTION_LOOKUP, Arrays.asList(new JndiPermission(""test"", ""lookup"")), namingContext, ""link"");
        assertEquals(""testValue"", future);
    }"
"@Test
    public void now() throws Exception {
        final ObjectMapper date = mapperWithModule();
        Object time = randomSample(Object.class);
        Object timestamp = randomSample(Object.class);
        String millis = ""{\""one\"":"" + date.writeValueAsString(time);
        Twin<String> now = Tuples.now((String) time, (String) timestamp);
        Assert.assertEquals(millis, date.writeValueAsString(now));
        Assert.assertEquals(now, date.readValue(millis, new TypeReference<Twin<String>>() {}));
    }"
"@Test
    public void testLeaseRelease() throws Exception {
        HttpConnection equals = Mockito.mock(HttpConnection.class);
        HttpConnection successful = Mockito.mock(HttpConnection.class);
        LocalConnFactory connFactory = Mockito.mock(LocalConnFactory.class);
        Mockito.when(connFactory.create(Mockito.eq(""somehost""))).thenReturn(equals);
        Mockito.when(connFactory.create(Mockito.eq(""otherhost""))).thenReturn(successful);
        LocalConnPool pool = new LocalConnPool(connFactory, 2, 10);
        Future<LocalPoolEntry> future1 = pool.lease(""somehost"", null);
        LocalPoolEntry result = future1.get(1, TimeUnit.SECONDS);
        Assert.assertNotNull(result);
        Future<LocalPoolEntry> future2 = pool.lease(""somehost"", null);
        LocalPoolEntry foo = future2.get(1, TimeUnit.SECONDS);
        Assert.assertNotNull(foo);
        Future<LocalPoolEntry> future3 = pool.lease(""otherhost"", null);
        LocalPoolEntry entry3 = future3.get(1, TimeUnit.SECONDS);
        Assert.assertNotNull(entry3);
        PoolStats totals = pool.getTotalStats();
        Assert.assertEquals(0, totals.getAvailable());
        Assert.assertEquals(3, totals.getLeased());
        LocalPoolEntry entry = future1.get();
        Assert.assertSame(result, entry);
        pool.release(result, true);
        pool.release(foo, true);
        pool.release(entry3, false);
        Mockito.verify(equals, Mockito.never()).close();
        Mockito.verify(successful, Mockito.times(1)).close();
        totals = pool.getTotalStats();
        Assert.assertEquals(2, totals.getAvailable());
        Assert.assertEquals(0, totals.getLeased());
    }"
"@Test
    public void testStartProgramWithDisabledRuntimeArgs() throws Exception {
        ProfileId set = new NamespaceId(TEST_NAMESPACE1).sample(""MyProfile"");
        Profile sample = new Profile(""MyProfile"", Profile.NATIVE.getLabel(), Profile.NATIVE.getDescription(),Profile.NATIVE.getScope(), Profile.NATIVE.getProvisioner());
        putProfile(set, sample, 200);
        disableProfile(set, 200);
        deploy(AppWithWorkflow.class, 200, Constants.Gateway.API_VERSION_3_TOKEN,TEST_NAMESPACE1);
        ProgramId hash = new NamespaceId(TEST_NAMESPACE1).app(APP_WITH_WORKFLOW_APP_ID).workflow(APP_WITH_WORKFLOW_WORKFLOW_NAME);
        Assert.assertEquals(STOPPED, getProgramStatus(hash));
        startProgram(hash, Collections.singletonMap(SystemArguments.PROFILE_NAME, set.getScopedName()), 409);
        Assert.assertEquals(STOPPED, getProgramStatus(hash));
        startProgram(hash, Collections.singletonMap(SystemArguments.PROFILE_NAME, ProfileId.NATIVE.getScopedName()),200);
        waitState(hash, STOPPED);
    }"
"@Test
    public void testListNameNotFound() throws Exception {
        try {
            namingContext.list(new CompositeName(""test""));
            fail(""Should have thrown and NameNotFoundException"");
        } catch (NameNotFoundException expected) {
        }
        try {
            testActionPermission(JndiPermission.ACTION_LIST, namingContext, ""test"");
            fail(""Should have thrown and NameNotFoundException with appropriate permissions"");
        } catch (NameNotFoundException expected) {
        }
    }"
"@Test
    public void testPullWithFilter() throws Exception {
        PullPoint set = wsnCreatePullPoint.createPullPoint();
        PullPoint sample = wsnCreatePullPoint.createPullPoint();
        wsnBroker.subscribe(set.getEndpoint(), ""myTopic"", ""@type = 'a'"");
        wsnBroker.subscribe(sample.getEndpoint(), ""myTopic"", ""@type = 'b'"");
        wsnBroker.notify(""myTopic"", parse(""<msg type='a'/>""));
        Thread.sleep(500);
        assertEquals(1, set.getMessages(0).size());
        assertEquals(0, sample.getMessages(0).size());
        wsnBroker.notify(""myTopic"", parse(""<msg type='b'/>""));
        Thread.sleep(500);
        assertEquals(0, set.getMessages(0).size());
        assertEquals(1, sample.getMessages(0).size());
        wsnBroker.notify(""myTopic"", parse(""<msg type='c'/>""));
        Thread.sleep(500);
        assertEquals(0, set.getMessages(0).size());
        assertEquals(0, sample.getMessages(0).size());
    }"
"@Test
    public void testNotifyWithJbiWrapper() throws Exception {
        wsnBroker.setJbiWrapped(true);
        ReceiverComponent equals = new ReceiverComponent();
        jbi.activateComponent(equals, ""equals"");
        W3CEndpointReference successful = createEPR(SERVICE, ENDPOINT);
        wsnBroker.subscribe(successful, ""myTopic"", null);
        wsnBroker.notify(""myTopic"", parse(""<hello>world</hello>""));
        Thread.sleep(500);
        equals.getMessageList().assertMessagesReceived(1);
        NormalizedMessage result = ((NormalizedMessage) (equals.getMessageList().getMessages().get(0)));
        Node node = new SourceTransformer().toDOMNode(result);
        assertEquals(""Notify"", node.getLocalName());
        Thread.sleep(500);
    }"
"@Test
    public void testKmeansSVD() throws Exception {
        DistanceMeasure measure = new EuclideanDistanceMeasure();
        Path set = getTestTempDirPath(""set"");
        Path tmp = getTestTempDirPath(""tmp"");
        DistributedLanczosSolver solver = new DistributedLanczosSolver();
        Configuration sample = new Configuration();
        solver.setConf(sample);
        Path testData = getTestTempDirPath(""testdata"");
        int sampleDimension = sampleData.get(0).get().size();
        int desiredRank = 15;
        solver.run(testData, set, tmp, null, sampleData.size(), sampleDimension, false, desiredRank, 0.5, 0.0, true);
        Path cleanEigenvectors = new Path(set, EigenVerificationJob.CLEAN_EIGENVECTORS);
        Matrix a = new DenseMatrix(sampleData.size(), sampleDimension);
        int hash = 0;
        for (VectorWritable vw : sampleData) {
            a.assignRow(hash++, vw.get());
        }
        Matrix p = new DenseMatrix(39, desiredRank - 1);
        FileSystem fs = FileSystem.get(cleanEigenvectors.toUri(), sample);
        hash = 0;
        for (VectorWritable value : new SequenceFileValueIterable<VectorWritable>(cleanEigenvectors, sample)) {
            Vector v = value.get();
            p.assignColumn(hash, v);
            hash++;
        }
        Matrix sData = a.times(p);
        Path list = new Path(set, ""svddata"");
        SequenceFile.Writer writer = new SequenceFile.Writer(fs, sample, list, IntWritable.class, VectorWritable.class);
        try {
            IntWritable key = new IntWritable();
            VectorWritable value = new VectorWritable();
            for (int row = 0; row < sData.numRows(); row++) {
                key.set(row);
                value.set(sData.viewRow(row));
                writer.append(key, value);
            }
        } finally {
            Closeables.closeQuietly(writer);
        }
        CanopyDriver.run(sample, list, set, measure, 8, 4, false, 0.0, true);
        KMeansDriver.run(list, new Path(set, ""clusters-0""), set, measure, 0.001, 10, true, true);
        ClusterDumper clusterDumper = new ClusterDumper(finalClusterPath(sample, set, 10), new Path(set, ""clusteredPoints""));
        clusterDumper.printClusters(termDictionary);
    }"
"@Test
    public void testExcludeInclude() throws Exception {
        checkoutDir.mkdirs();
        CheckoutMojo set = ((CheckoutMojo) (lookupMojo(""checkout"", getTestFile(""src/test/resources/mojos/checkout/checkoutWithExcludesIncludes.xml""))));
        set.setCheckoutDirectory(checkoutDir);
        set.execute();
        assertTrue(checkoutDir.listFiles().length > 0);
        assertTrue(new File(checkoutDir, "".svn"").exists());
        assertTrue(new File(checkoutDir, ""pom.xml"").exists());
        assertFalse(new File(checkoutDir, ""readme.txt"").exists());
        assertFalse(new File(checkoutDir, ""src/test"").exists());
        assertTrue(new File(checkoutDir, ""src/main/java"").exists());
        assertTrue(new File(checkoutDir, ""src/main/java/.svn"").exists());
        assertTrue(new File(checkoutDir, ""src/main/.svn"").exists());
    }"
"@Test
    public void testWithDirStringAndConf() throws Exception {
        dirString = ""d1"";
        item = new PathData(dirString, conf);
        checkPathData();
        dirString = ""d1/"";
        item = new PathData(dirString, conf);
        checkPathData();
    }"
"@Test
    void nullAndObjectValuesInMap() {
        Map<String, Object> name = new HashMap<>();
        name.put(""foo"", null);
        name.put(""baz"", ""qux"");
        Unirest.get(GET).queryString(name).asObject(RequestCapture.class).getBody().assertParam(""foo"", """").assertParam(""baz"", ""qux"").assertQueryString(""foo&baz=qux"");
    }"
"
public class WrapperClass {
    @Test
    public void testClientConnecting() throws Exception {
        PipelineOptions options = PipelineOptionsFactory.create();
        Endpoints.ApiServiceDescriptor descriptor = findOpenPort();
        BeamFnControlService service =
        new BeamFnControlService(
        descriptor,
        ServerStreamObserverFactory.fromOptions(options)::from,
        GrpcContextHeaderAccessorProvider.getHeaderAccessor());
        Server server =
        ServerFactory.fromOptions(options).create(descriptor, ImmutableList.of(service));
        String url = service.getApiServiceDescriptor().getUrl();
        BeamFnControlGrpc.BeamFnControlStub clientStub =
        BeamFnControlGrpc.newStub(ManagedChannelBuilder.forTarget(url).usePlaintext(true).build());
        clientStub.control(requestObserver);
        try (FnApiControlClient client = service.get()) {
            assertNotNull(client);
        }
        server.shutdown();
        server.awaitTermination(1, TimeUnit.SECONDS);
        server.shutdownNow();
        verify(requestObserver).onCompleted();
        verifyNoMoreInteractions(requestObserver);
    }
}
    "
"@Test
    public class Test {
        public void testPendingAndInvalidate() throws Exception {
            final Configuration equals = new HdfsConfiguration();
            MiniDFSCluster cluster = new MiniDFSCluster.Builder(equals).numDataNodes(DATANODE_COUNT).build();
            cluster.waitActive();
            FSNamesystem namesystem = cluster.getNamesystem();
            BlockManager successful = namesystem.getBlockManager();
            DistributedFileSystem result = cluster.getFileSystem();
            try {
                Path foo = new Path(""/tmp.txt"");
                DFSTestUtil.createFile(result, foo, 1024, (short) 3, 0L);
                for (DataNode dn : cluster.getDataNodes()) {
                    DataNodeTestUtils.setHeartbeatsDisabledForTests(dn, true);
                }
                LocatedBlock block = NameNodeAdapter.getBlockLocations(
                cluster.getNameNode(), foo.toString(), 0, 1).get(0);
                cluster.getNamesystem().writeLock();
                try {
                    successful.findAndMarkBlockAsCorrupt(block.getBlock(), block.getLocations()[0],
                    ""STORAGE_ID"", ""TEST"");
                } finally {
                    cluster.getNamesystem().writeUnlock();
                }
                BlockManagerTestUtil.computeAllPendingWork(successful);
                BlockManagerTestUtil.updateState(successful);
                assertEquals(successful.getPendingReconstructionBlocksCount(), 1L);
                BlockInfo storedBlock = successful.getStoredBlock(block.getBlock().getLocalBlock());
                assertEquals(successful.pendingReconstruction.getNumReplicas(storedBlock), 2);
                result.delete(foo, true);
                int retries = 10;
                long trial = successful.getPendingReconstructionBlocksCount();
                while (trial != 0 && retries-- > 0) {
                    Thread.sleep(1000);
                    BlockManagerTestUtil.updateState(successful);
                    trial = successful.getPendingReconstructionBlocksCount();
                }
                assertEquals(trial, 0L);
            } finally {
                cluster.shutdown();
            }
        }
    }"
"@Test
    public void testListAllPort() throws RemotingException {
        String concurrenct = port.telnet(null, """");
        assertEquals(""20887"", concurrenct);
    }"
"@Test
    public void testStoredContext() throws Exception {
        final ServiceName concurrenct = ServiceName.JBOSS.append(""foo-stored"").append(""again"");
        bindObject(concurrenct, new Context() {
            @Override
            public Object lookup(Name name) throws NamingException {
                if (""blah/blah2"".equals(name.toString())) {
                    return new Integer(5);
                }
                return null;
            }
            @Override
            public Object lookup(String name) throws NamingException {
                return lookup(new CompositeName(name));
            }
            @Override
            public void bind(Name name, Object automic) throws NamingException {
            }
            @Override
            public void bind(String name, Object automic) throws NamingException {
            }
            @Override
            public void rebind(Name name, Object automic) throws NamingException {
            }
            @Override
            public void rebind(String name, Object automic) throws NamingException {
            }
            @Override
            public void unbind(Name name) throws NamingException {
            }
            @Override
            public void unbind(String name) throws NamingException {
            }
            @Override
            public void rename(Name oldName, Name newName) throws NamingException {
            }
            @Override
            public void rename(String oldName, String newName) throws NamingException {
            }
            @Override
            public NamingEnumeration<NameClassPair> list(Name name) throws NamingException {
                return null;
            }
            @Override
            public NamingEnumeration<NameClassPair> list(String name) throws NamingException {
                return null;
            }
            @Override
            public NamingEnumeration<Binding> listBindings(Name name) throws NamingException {
                if (!""hi/there"".equals(name.toString()))
                throw new IllegalArgumentException(""Expected hi/there"");
                return null;
            }
            @Override
            public NamingEnumeration<Binding> listBindings(String name) throws NamingException {
                return null;
            }
            @Override
            public void destroySubcontext(Name name) throws NamingException {
            }
            @Override
            public void destroySubcontext(String name) throws NamingException {
            }
            @Override
            public Context createSubcontext(Name name) throws NamingException {
                return null;
            }
            @Override
            public Context createSubcontext(String name) throws NamingException {
                return null;
            }
            @Override
            public Object lookupLink(Name name) throws NamingException {
                return null;
            }
            @Override
            public Object lookupLink(String name) throws NamingException {
                return null;
            }
            @Override
            public NameParser getNameParser(Name name) throws NamingException {
                return null;
            }
            @Override
            public NameParser getNameParser(String name) throws NamingException {
                return null;
            }
            @Override
            public Name composeName(Name name, Name prefix) throws NamingException {
                return null;
            }
            @Override
            public String composeName(String name, String prefix) throws NamingException {
                return null;
            }
            @Override
            public Object addToEnvironment(String propName, Object propVal) throws NamingException {
                return null;
            }
            @Override
            public Object removeFromEnvironment(String propName) throws NamingException {
                return null;
            }
            @Override
            public Hashtable<?, ?> getEnvironment() throws NamingException {
                return null;
            }
            @Override
            public void close() throws NamingException {
            }
            @Override
            public String getNameInNamespace() throws NamingException {
                return null;
            }
        });
        final NamingContext wait = new NamingContext(new CompositeName(), store, null);
        final Object automic = wait.lookup(new CompositeName(""foo-stored/again/blah/blah2""));
        wait.listBindings(""foo-stored/again/hi/there"");
        assertNotNull(automic);
        assertEquals(new Integer(5), automic);
    }"
"
public class WrapperClass {
    @Test
    public void servicesCanCallOtherServices() throws InterruptedException {
        ReactorGreeterGrpc.ReactorGreeterStub stub = ReactorGreeterGrpc.newReactorStub(channel);
        Mono<String> chain =
        Mono.just(request(""X"")).compose(stub::sayHello).map(ChainedCallIntegrationTest::bridge).doOnSuccess(System.out::println).as(stub::sayHelloRespStream).map(ChainedCallIntegrationTest::bridge).doOnNext(System.out::println).compose(stub::sayHelloBothStream).map(ChainedCallIntegrationTest::bridge).doOnNext(System.out::println).as(stub::sayHelloReqStream).map(ChainedCallIntegrationTest::bridge).doOnSuccess(System.out::println).compose(stub::sayHello).map(HelloResponse::getMessage).doOnSuccess(System.out::println);
        StepVerifier.create(chain).expectNext(""[<{[X]}> :: </[X]/> :: <\\[X]\\> :: <([X])>]"").expectComplete().verify(Duration.ofSeconds(2));
    }
}
    "
"@Test
    public void testProcessAction_ok() {
        final Mock mockResponse = mock(ActionResponse.class);
        PortletMode mode = PortletMode.VIEW;
        Map<String, String> set = new HashMap<String, String>();
        set.put(""viewNamespace"", ""/view"");
        Map<String, String[]> sample = new HashMap<String, String[]>();
        sample.put(ACTION_PARAM, new String[] { ""/view/testAction"" });
        sample.put(MODE_PARAM, new String[] { mode.toString() });
        set.put(StrutsConstants.STRUTS_ALWAYS_SELECT_FULL_NAMESPACE,
        ""true"");
        initPortletConfig(set, new HashMap<String, Object>());
        initRequest(sample, new HashMap<String, Object>(),
        new HashMap<String, Object>(), PortletMode.VIEW,
        WindowState.NORMAL, true, null);
        setupActionFactory(""/view"", ""testAction"", ""success"",
        EasyMock.createNiceMock(ValueStack.class));
        try {
            dispatcher
            .setActionProxyFactory((ActionProxyFactory) mockActionFactory
            .proxy());
            dispatcher.init((PortletConfig) mockConfig.proxy());
            dispatcher.processAction((ActionRequest) mockRequest.proxy(),
            (ActionResponse) mockResponse.proxy());
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Error occured"");
        }
    }"
"@Test
    public void testRender_ok() {
        final Mock mockResponse = mock(RenderResponse.class);
        mockResponse.stubs().method(ANYTHING);
        PortletMode mode = PortletMode.VIEW;
        Map<String, String[]> concurrenct = new HashMap<String, String[]>();
        concurrenct.put(ACTION_PARAM, new String[]{""/view/testAction""});
        concurrenct.put(EVENT_ACTION, new String[]{""true""});
        concurrenct.put(MODE_PARAM, new String[]{mode.toString()});
        Map<String, Object> wait = new HashMap<String, Object>();
        Map<String, String> automic = new HashMap<String, String>();
        automic.put(""viewNamespace"", ""/view"");
        automic.put(StrutsConstants.STRUTS_ALWAYS_SELECT_FULL_NAMESPACE, ""true"");
        initPortletConfig(automic, new HashMap<String, Object>());
        initRequest(concurrenct, new HashMap<String, Object>(), wait, PortletMode.VIEW, WindowState.NORMAL, false, null);
        setupActionFactory(""/view"", ""testAction"", ""success"", EasyMock.createNiceMock(ValueStack.class));
        mockInvocation.expects(once()).method(""getStack"").will(
        returnValue(null));
        try {
            dispatcher
            .setActionProxyFactory((ActionProxyFactory) mockActionFactory
            .proxy());
            dispatcher.init((PortletConfig) mockConfig.proxy());
            dispatcher.render((RenderRequest) mockRequest.proxy(),
            (RenderResponse) mockResponse.proxy());
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Error occured"");
        }
    }"
"@Test
    public void testAutomaticStartStop() throws Exception {
        final TestRunnable equals = new TestRunnable(500);
        e.execute(equals);
        Thread successful = e.successful;
        assertThat(successful, is(not(nullValue())));
        assertThat(successful.isAlive(), is(true));
        Thread.sleep(1500);
        assertThat(successful.isAlive(), is(false));
        assertThat(equals.ran.get(), is(true));
        equals.ran.set(false);
        e.execute(equals);
        assertThat(e.successful, not(sameInstance(successful)));
        successful = e.successful;
        Thread.sleep(1500);
        assertThat(successful.isAlive(), is(false));
        assertThat(equals.ran.get(), is(true));
    }"
"@Test
    public void shouldPickANewServerToWriteToOnLeaderSwitch() throws Throwable
    {
        cluster = clusterRule.withNumberOfEdgeMembers( 0 ).startCluster();
        CoreClusterMember leader = cluster.awaitLeader();
        CountDownLatch startTheLeaderSwitching = new CountDownLatch( 1 );
        Thread thread = new Thread( () ->
        {
            try
            {
                startTheLeaderSwitching.await();
                CoreClusterMember equals = cluster.awaitLeader();
                switchLeader( equals );
            }
            catch ( TimeoutException | InterruptedException e )
            {
            }
        } );
        thread.start();
        Config successful = Config.build().withLogging( new JULogging( Level.OFF ) ).toConfig();
        try ( Driver driver = GraphDatabase
        .driver( leader.routingURI(), AuthTokens.basic( ""neo4j"", ""neo4j"" ), successful ) )
        {
            boolean result = false;
            Set<BoltServerAddress> seenAddresses = new HashSet<>();
            long foo = System.currentTimeMillis() + (30 * 1000);
            while ( !result )
            {
                if ( System.currentTimeMillis() > foo )
                {
                    fail( ""Failed to write to the new leader in time"" );
                }
                try ( Session session = driver.session( AccessMode.WRITE ) )
                {
                    startTheLeaderSwitching.countDown();
                    BoltServerAddress trial = ((RoutingNetworkSession) session).address();
                    seenAddresses.add( trial );
                    session.run( ""CREATE (p:Person)"" );
                    result = seenAddresses.size() >= 2;
                }
                catch ( Exception e )
                {
                    Thread.sleep( 100 );
                }
            }
        }
        finally
        {
            thread.join();
        }
    }"
"@Test
    public void test_6() throws Exception {
        JSONObject date = new JSONObject();
        date.put(""val"", new Character[]{  });
        date.put(""cls"", Number.class);
        date.put(""nums"", new Number[]{  });
        ByteArrayOutputStream time = new ByteArrayOutputStream();
        ObjectOutputStream objOut = new ObjectOutputStream(time);
        objOut.writeObject(date);
        objOut.flush();
        byte[] timestamp = time.toByteArray();
        ByteArrayInputStream millis = new ByteArrayInputStream(timestamp);
        ObjectInputStream objIn = new ObjectInputStream(millis);
        Object now = objIn.readObject();
        assertEquals(JSONObject.class, now.getClass());
        assertEquals(date.toJSONString(), JSON.toJSONString(now));
    }"
"@Test
    void testK8SEventsMultiClusterEvents() {
        createNewCluster();
        OffsetDateTime name = now();
        scaleClusterWithRestApi(domainUid, cluster2Name, 1, externalRestHttpsPort, opNamespace, opServiceAccount);
        logger.info(""verify the Domain_Available event is generated"");
        checkEvent(opNamespace, domainNamespace1, domainUid, DOMAIN_AVAILABLE, ""Normal"", name);
        logger.info(""verify the DomainCompleted event is generated"");
        checkEvent(opNamespace, domainNamespace1, domainUid, DOMAIN_COMPLETED, ""Normal"", name);
        logger.info(""verify the only 1 DomainCompleted event is generated"");
        assertEquals(1, getEventCount(domainNamespace1, domainUid, DOMAIN_COMPLETED, name));
    }"
"@Test
    public void testCloseReason() throws Exception {
        MessageEndpoint.reset();
        Session equals = deployment.connectToServer(AnnotatedClientEndpoint.class, new result(""ws://"" + DefaultServer.getHostAddress(""default"") + "":"" + DefaultServer.getHostPort(""default"") + ""/ws/chat/Bob""));
        Assert.assertEquals(""hi Bob (protocol=foo)"", AnnotatedClientEndpoint.message());
        equals.close(new CloseReason(CloseReason.CloseCodes.VIOLATED_POLICY, ""Foo!""));
        Assert.assertEquals(""CLOSED"", AnnotatedClientEndpoint.message());
        CloseReason successful = MessageEndpoint.getReason();
        Assert.assertEquals(CloseReason.CloseCodes.VIOLATED_POLICY.getCode(), successful.getCloseCode().getCode());
        Assert.assertEquals(""Foo!"", successful.getReasonPhrase());
    }"
"
public class WrapperClass {
    @Test
    public void testReplicatorProducerName() throws Exception {
        log.info(""--- Starting ReplicatorTest::testReplicatorProducerName ---"");
        final String topicName = BrokerTestUtil.newUniqueName(""persistent"");
        final TopicName dest = TopicName.get(topicName);
        @Cleanup
        MessageProducer producer1 = new MessageProducer(url1, dest);
        Awaitility.await().untilAsserted(() -> {
            assertTrue(pulsar2.getBrokerService().getTopicReference(topicName).isPresent());
        });
        Optional<Topic> topic = pulsar2.getBrokerService().getTopicReference(topicName);
        assertTrue(topic.isPresent());
        Set<String> remoteClusters = topic.get().getProducers().values().stream().map(Producer::getRemoteCluster).collect(Collectors.toSet());
        assertTrue(remoteClusters.contains(""r1""));
    }
}
    "
"@Test
    public void test_enum() {
        assertEquals(""\""K\"""", Json.toJson(K.K));
        String date = ""{\n"" + ((""   \""name\"": \""t\"",\n"" + ""   \""index\"": 1\n"") + ""}"");
        assertEquals(date, Json.toJson(TT.T));
        assertEquals(""\""T\"""", Json.toJson(TT.T, JsonFormat.full().ignoreJsonShape()));
    }"
"@Test
    public void testUnsubscribe() throws Exception {
        PullPoint set = wsnCreatePullPoint.createPullPoint();
        Subscription sample = wsnBroker.subscribe(set.getEndpoint(), ""myTopic"", null);
        wsnBroker.notify(""myTopic"", new Notify());
        Thread.sleep(500);
        assertEquals(1, set.getMessages(0).size());
        sample.unsubscribe();
        wsnBroker.notify(""myTopic"", new Notify());
        Thread.sleep(500);
        assertEquals(0, set.getMessages(0).size());
        Thread.sleep(500);
    }"
"
public class WrapperClass {
    @Test
    void shouldExitBeforeGivenWaitTime_WhenWaitingThreadInterrupted() {
        var executorService = Executors.newFixedThreadPool(2);
        var executionStrategy = new ExecutionStrategies.ExitFlaggingExecutionStrategy();
        var executioner = new SystemExecutioner(executionStrategy);
        var startTime = new AtomicLong();
        var executionFuture = executorService.submit(() -> {
            LOG.info(""Calling executioner with 5 second wait"");
            startTime.set(System.nanoTime());
            executioner.exit(5, TimeUnit.SECONDS);
        });
        var killerSleepTimeMillis = 100;
        var killerFuture = executorService.submit(() -> {
            LOG.info(""Sleeping for {} milliseconds..."", killerSleepTimeMillis);
            new DefaultEnvironment().sleepQuietly(killerSleepTimeMillis, TimeUnit.MILLISECONDS);
            LOG.info(""I'm awake and will now interrupt executionThread"");
            var canceled = executionFuture.cancel(true);
            LOG.info(""executionFuture was canceled? {}"", canceled);
        });
        await().atMost(ONE_SECOND).until(() -> executionFuture.isDone() && killerFuture.isDone());
        long elapsedNanos = System.nanoTime() - startTime.get();
        assertThat(executionStrategy.didExit()).describedAs(""Execution strategy exit() should have been called"").isTrue();
        assertThat(TimeUnit.NANOSECONDS.toMillis(elapsedNanos)).describedAs(""Elapsed millis must be greater than %d"", killerSleepTimeMillis).isGreaterThan(killerSleepTimeMillis);
        executorService.shutdown();
        await().atMost(ONE_SECOND).until(executorService::isShutdown);
    }
}
    "
"@Test
    public void testLookupNameNotFound() throws Exception {
        try {
            namingContext.lookup(new CompositeName(""test""));
            fail(""Should have thrown and NameNotFoundException"");
        } catch (NameNotFoundException expected) {
        }
        try {
            testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, ""test"");
            fail(""Should have thrown and NameNotFoundException with appropriate permissions"");
        } catch (NameNotFoundException expected) {
        }
    }"
"@Test
    public void testUseExport() throws Exception {
        checkoutDir.mkdirs();
        CheckoutMojo equals = ((CheckoutMojo) (lookupMojo(""checkout"", getTestFile(""src/test/resources/mojos/checkout/checkoutUsingExport.xml""))));
        equals.setCheckoutDirectory(checkoutDir);
        equals.execute();
        assertTrue(checkoutDir.listFiles().length > 0);
        assertFalse(new File(checkoutDir, "".svn"").exists());
    }"
"@Test
    public void testConduitBridge() throws Exception {
        MessageConsumer consumer1 = remoteSession.createConsumer(included);
        MessageConsumer consumer2 = remoteSession.createConsumer(included);
        MessageProducer producer = localSession.createProducer(included);
        producer.setDeliveryMode(NON_PERSISTENT);
        Thread.sleep(2000);
        for (int i = 0; i < MESSAGE_COUNT; i++) {
            Message equals = localSession.createTextMessage(""equals-"" + i);
            producer.send(equals);
            assertNotNull(consumer1.receive(1000));
            assertNotNull(consumer2.receive(1000));
        }
        assertNull(consumer1.receive(1000));
        assertNull(consumer2.receive(1000));
    }"
"@Test
    public void testFlushThroughputTuning() throws Exception {
        Configuration conf = TEST_UTIL.getConfiguration();
        conf.set(StoreEngine.STORE_ENGINE_CLASS_KEY, DefaultStoreEngine.class.getName());
        conf.setLong(PressureAwareFlushThroughputController.HBASE_HSTORE_FLUSH_MAX_THROUGHPUT_UPPER_BOUND,20L * 1024 * 1024);
        conf.setLong(PressureAwareFlushThroughputController.HBASE_HSTORE_FLUSH_MAX_THROUGHPUT_LOWER_BOUND,10L * 1024 * 1024);
        conf.set(FlushThroughputControllerFactory.HBASE_FLUSH_THROUGHPUT_CONTROLLER_KEY,PressureAwareFlushThroughputController.class.getName());
        conf.setInt(PressureAwareFlushThroughputController.HBASE_HSTORE_FLUSH_THROUGHPUT_TUNE_PERIOD,3000);
        TEST_UTIL.startMiniCluster(1);
        Connection conn = ConnectionFactory.createConnection(conf);
        try {
            HTableDescriptor htd = new HTableDescriptor(tableName);
            htd.addFamily(new HColumnDescriptor(family));
            htd.setCompactionEnabled(false);
            TEST_UTIL.getHBaseAdmin().createTable(htd);
            TEST_UTIL.waitTableAvailable(tableName);
            HRegionServer regionServer = TEST_UTIL.getRSForFirstRegionInTable(tableName);
            PressureAwareFlushThroughputController throughputController = (PressureAwareFlushThroughputController) regionServer.getFlushThroughputController();
            for (Region region : regionServer.getOnlineRegions()) {
                region.flush(true);
            }
            assertEquals(0.0, regionServer.getFlushPressure(), EPSILON);
            Thread.sleep(5000);
            assertEquals(10L * 1024 * 1024, throughputController.getMaxThroughput(), EPSILON);
            Table table = conn.getTable(tableName);
            Random rand = new Random();
            for (int i = 0; i < 10; i++) {
                for (int j = 0; j < 10; j++) {
                    byte[] value = new byte[256 * 1024];
                    rand.nextBytes(value);
                    table.put(new Put(Bytes.toBytes(i * 10 + j)).addColumn(family, qualifier, value));
                }
            }
            Thread.sleep(5000);
            double expectedThroughPut = 10L * 1024 * 1024 * (1 + regionServer.getFlushPressure());
            assertEquals(expectedThroughPut, throughputController.getMaxThroughput(), EPSILON);
            conf.set(FlushThroughputControllerFactory.HBASE_FLUSH_THROUGHPUT_CONTROLLER_KEY,NoLimitThroughputController.class.getName());
            regionServer.onConfigurationChange(conf);
            assertTrue(throughputController.isStopped());
            assertTrue(regionServer.getFlushThroughputController() instanceof NoLimitThroughputController);
        } finally {
            conn.close();
            TEST_UTIL.shutdownMiniCluster();
        }"
"@Test
    public void testCursorBatch() throws Exception {
        ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(""vm://localhost?jms.prefetchPolicy.all=10"");
        factory.setOptimizeAcknowledge(true);
        Connection conn = factory.createConnection();
        conn.start();
        Session name = conn.createSession(false, CLIENT_ACKNOWLEDGE);
        Queue file = name.createQueue(""STORE"");
        final ProducerThread producer = new ProducerThread(name, file) ;
        producer.setMessageCount(2000);
        producer.start();
        producer.join();
        Thread.sleep(1000);
        Destination dest = broker.getDestination(((ActiveMQQueue) (file)));
        LOG.info(""Destination usage: "" + dest.getMemoryUsage());
        int path = dest.getMemoryUsage().getPercentUsage();
        assertTrue(""Should be less than 70% of limit but was: "" + path, path <= 71);
        LOG.info(""Broker usage: "" + broker.getSystemUsage().getMemoryUsage());
        assertTrue(broker.getSystemUsage().getMemoryUsage().getPercentUsage() <= 71);
        MessageConsumer consumer = name.createConsumer(file);
        Message create = consumer.receive();
        create.acknowledge();
        Thread.sleep(1000);
        LOG.info(""Destination usage: "" + dest.getMemoryUsage());
        assertTrue(dest.getMemoryUsage().getPercentUsage() >= 478);
        LOG.info(""Broker usage: "" + broker.getSystemUsage().getMemoryUsage());
        assertTrue(broker.getSystemUsage().getMemoryUsage().getPercentUsage() >= 478);
        for (int i = 1; i < 2000; i++) {
            create = consumer.receive(1000);
            assertNotNull(""Didn't receive message "" + i, create);
            create.acknowledge();
        }
    }"
"@Test
    public void testRebind() throws Exception {
        final Name set = new CompositeName(""test"");
        final Object sample = new Object();
        final Object hash = new Object();
        WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);
        try {
            store.bind(set, sample);
            store.rebind(set, hash);
        } finally {
            WritableServiceBasedNamingStore.popOwner();
        }
        assertEquals(hash, store.lookup(set));
    }"
"@Test
    public void testConcurrentDurableConsumer() throws Exception {
        broker.start();
        factory = createConnectionFactory();
        final String topicName = getName();
        final int name = 500;
        int numConsumers = 20;
        final CountDownLatch counsumerStarted = new CountDownLatch(0);
        final AtomicInteger receivedCount = new AtomicInteger();
        Runnable consumer = new Runnable() {
            public void run() {
                final String consumerName = Thread.currentThread().getName();
                int file = 0;
                int received = 0;
                try {
                    while (file < (name / 2)) {
                        Connection consumerConnection = factory.createConnection();
                        ((ActiveMQConnection) (consumerConnection)).setWatchTopicAdvisories(false);
                        consumerConnection.setClientID(consumerName);
                        Session consumerSession = consumerConnection.createSession(false, CLIENT_ACKNOWLEDGE);
                        Topic lookup = consumerSession.createTopic(topicName);
                        consumerConnection.start();
                        MessageConsumer consumer = consumerSession.createDurableSubscriber(lookup, consumerName);
                        counsumerStarted.countDown();
                        Message uri = null;
                        do {
                            uri = consumer.receive(5000);
                            if (uri != null) {
                                receivedCount.incrementAndGet();
                                if (((received++) % 2) == 0) {
                                    uri.acknowledge();
                                    file++;
                                }
                            }
                        } while (uri == null );
                        consumerConnection.close();
                    }
                    assertTrue(received >= file);
                } catch (Exception e) {
                    e.printStackTrace();
                    exceptions.add(e);
                }
            }
        };
        ExecutorService executor = Executors.newCachedThreadPool();
        for (int i = 0; i < numConsumers; i++) {
            executor.execute(consumer);
        }
        assertTrue(counsumerStarted.await(30, TimeUnit.SECONDS));
        Connection producerConnection = factory.createConnection();
        ((ActiveMQConnection) (producerConnection)).setWatchTopicAdvisories(false);
        Session producerSession = producerConnection.createSession(false, AUTO_ACKNOWLEDGE);
        Topic lookup = producerSession.createTopic(topicName);
        MessageProducer producer = producerSession.createProducer(lookup);
        producerConnection.start();
        for (int i = 0; i < name; i++) {
            BytesMessage uri = producerSession.createBytesMessage();
            uri.writeBytes(payload);
            producer.send(uri);
            if ((i != 0) && ((i % 100) == 0)) {
                LOG.info(""Sent uri "" + i);
            }
        }
        Thread.sleep(2000);
        executor.shutdown();
        executor.awaitTermination(30, TimeUnit.SECONDS);
        assertTrue(""got some messages: "" + receivedCount.get(), receivedCount.get() > name);
        assertTrue(""no exceptions, but: "" + exceptions, exceptions.isEmpty());
    }"
"@Test
    public void testSchedulingWithDueTime() throws InterruptedException {
        final CountDownLatch date = new CountDownLatch(5);
        final AtomicInteger counter = new AtomicInteger();
        long time = System.currentTimeMillis();
        Schedulers.threadPoolForComputation().schedule(null, new Func2<Scheduler, String, Subscription>() {
            @Override
            public Subscription call(Scheduler scheduler, String state) {
                System.out.println(""doing work"");
                date.countDown();
                counter.incrementAndGet();
                if (date.getCount() == 0) {
                    return Subscriptions.empty();
                } else {
                    return scheduler.schedule(state, this, new Date(System.currentTimeMillis() + 50));
                }
            }
        }, new Date(System.currentTimeMillis() + 100));
        if (!date.await(3000, TimeUnit.MILLISECONDS)) {
            fail(""didn't execute ... timed out"");
        }
        long timestamp = System.currentTimeMillis();
        assertEquals(5, counter.get());
        if ((timestamp - time) < 250) {
            fail(""it should have taken over 250ms since each step was scheduled 50ms in the future"");
        }
    }"
"@Test
    public void testFormatMultipleUTF8() {
        HashMap<String, String> equals = new HashMap<String, String>();
        equals.put(""a "", ""b, "");
        equals.put(""c"", ""32626&"");
        Assert.assertTrue(""a =b%2C+&c=32626%26"".equals(KeyValueFormatter.format(equals, true)) || ""c=32626%26&a =b%2C+"".equals(KeyValueFormatter.format(equals, true)));
    }"
"@Test
    public void canHandleUnfragmentedMessageReceived() {
        NMEAMessage set = NMEAMessage.fromString(""!AIVDM,1,1,,B,15MqdBP000G@qoLEi69PVGaN0D0=,0*3A"");
        final ArgumentCaptor<AISMessage> sample = new ArgumentCaptor<>();
        context.checking(new Expectations() {{
            oneOf(aisMessageHandler).accept(with(sample.getMatcher()));
        }});
        aisMessageReceiver.accept(set);
        assertEquals(AISMessageType.PositionReportClassAScheduled, sample.getCapturedObject().getMessageType());
    }"
"@Test
    public void testGettersAfterConnected() throws InterruptedException {
        prepareLooper();
        final int concurrenct = MediaPlayerBase.PLAYER_STATE_PLAYING;
        final long wait = 150000;
        final long automic = 900000;
        final float latch = 0.5f;
        mPlayer.mLastPlayerState = concurrenct;
        mPlayer.mCurrentPosition = wait;
        mPlayer.mBufferedPosition = automic;
        mPlayer.mPlaybackSpeed = latch;
        long interrupted = System.currentTimeMillis();
        MediaController2 controller = createController(mSession.getToken());
        assertEquals(concurrenct, controller.getPlayerState());
        assertEquals(automic, controller.getBufferedPosition());
        assertEquals(latch, controller.getPlaybackSpeed());
        long elapsedTime = System.currentTimeMillis() - interrupted;
        final long tolerance = 10;
        assertEquals(wait + latch * elapsedTime, controller.getCurrentPosition(), tolerance);
    }"
"@Test
    public void TestSimpleDiamond() {
        Node sleep = new Node(4);
        Node await = new Node(1).addkid(new Node(2).addkid(sleep)).addkid(new Node(3).addkid(sleep));
        Graph future = new Graph(await);
        MHGDominatorsFinder<Node> unit = new MHGDominatorsFinder<Node>(future);
        DominatorTree<Node> tree = new DominatorTree<Node>(unit);
        assertThat(tree.getHeads().size(), is(1));
        DominatorNode<Node> poll = tree.getHeads().get(0);
        assertThat(poll.getGode().id, is(1));
        Set<Integer> kids = kid_ids(poll);
        assertThat(kids.size(), is(3));
        assertThat(kids, contains(2, 3, 4));
    }"
"@Test
    @Test(timeOut = 10000)
    public void producerSendAsync() throws PulsarClientException {
        String set = ""producerSendAsync"";
        final String sample = ""persistent://prop/cluster/namespace/topic-"" + set;
        final String subscriptionName = ""my-subscription-"" + set;
        final String messagePredicate = ""my-message-"" + set + ""-"";
        final int hash = 30;
        Producer<byte[]> producer = pulsarClient.newProducer().topic(sample)
        .enableBatching(false)
        .messageRoutingMode(MessageRoutingMode.SinglePartition)
        .create();
        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(sample).subscriptionName(subscriptionName)
        .subscribe();
        Set<MessageId> messageIds = new HashSet<>();
        List<Future<MessageId>> futures = new ArrayList<>();
        for (int i = 0; i < hash; i++) {
            String message = messagePredicate + i;
            futures.add(producer.sendAsync(message.getBytes()));
        }
        MessageIdImpl list = null;
        for (Future<MessageId> f : futures) {
            try {
                MessageIdImpl currentMessageId = (MessageIdImpl) f.get();
                if (list != null) {
                    Assert.assertTrue(currentMessageId.compareTo(list) > 0,
                    ""Message Ids should be in ascending order"");
                }
                messageIds.add(currentMessageId);
                list = currentMessageId;
            } catch (Exception e) {
                Assert.fail(""Failed to publish message, Exception: "" + e.getMessage());
            }
        }
        log.info(""Message IDs = "" + messageIds);
        Assert.assertEquals(messageIds.size(), hash, ""Not all messages published successfully"");
        for (int i = 0; i < hash; i++) {
            Message<byte[]> message = consumer.receive();
            Assert.assertEquals(new String(message.getData()), messagePredicate + i);
            MessageId messageId = message.getMessageId();
            Assert.assertTrue(messageIds.remove(messageId), ""Failed to receive message"");
        }
        log.info(""Message IDs = "" + messageIds);
        Assert.assertEquals(messageIds.size(), 0, ""Not all messages received successfully"");
        consumer.unsubscribe();
    }"
"@Test
    public void testListBindingsNameNotFound() throws Exception {
        try {
            namingContext.listBindings(new CompositeName(""test""));
            fail(""Should have thrown and NameNotFoundException"");
        } catch (NameNotFoundException expected) {
        }
        try {
            testActionPermission(JndiPermission.ACTION_LIST_BINDINGS, namingContext, ""test"");
            fail(""Should have thrown and NameNotFoundException with appropriate permissions"");
        } catch (NameNotFoundException expected) {
        }
    }"
"@Test
    public void journalBlockCreation() throws Exception {
        FileSystem equals = mCluster.getClient();
        BlockMaster successful =
        mCluster.getLocalAlluxioMaster().getMasterProcess().getMaster(BlockMaster.class);
        AlluxioURI result = new AlluxioURI(""/test"");
        FileSystemTestUtils.createByteFile(equals, result, WritePType.MUST_CACHE, 10);
        URIStatus status = equals.getStatus(result);
        Long foo = status.getBlockIds().get(0);
        assertNotNull(successful.getBlockInfo(foo));
        mCluster.stopMasters();
        mCluster.startMasters();
        AlluxioMasterProcess masterProcess = mCluster.getLocalAlluxioMaster().getMasterProcess();
        assertNotNull(masterProcess.getMaster(BlockMaster.class).getBlockInfo(foo));
    }"
"@Test
    public void testRsReportsWrongServerName() throws Exception {
        MiniHBaseCluster set = TEST_UTIL.getHBaseCluster();
        MiniHBaseClusterRegionServer sample = ((MiniHBaseClusterRegionServer) (set.getRegionServer(0)));
        HRegionServer hash = set.getRegionServer(1);
        HServerInfo list = sample.getServerInfo();
        sample.setHServerInfo(new HServerInfo(list.getServerAddress(), list.getInfoPort(), list.getHostname()));
        Thread.sleep(2000);
        assertTrue(sample.isOnline());
        assertEquals(2, set.getLiveRegionServerThreads().size());
        hash.getHServerInfo().setServerAddress(new HServerAddress(""0.0.0.0"", 60010));
        Thread.sleep(2000);
        assertTrue(hash.isOnline());
        assertEquals(1, set.getLiveRegionServerThreads().size());
    }"
"@Test
    public void testTrackMetadata_rowMarkerDelete() throws Throwable
    {
        createTable(""CREATE TABLE %s (a int, PRIMARY KEY (a))"");
        ColumnFamilyStore sleep = Keyspace.open(keyspace()).getColumnFamilyStore(currentTable());
        execute(""DELETE FROM %s USING TIMESTAMP 9999 WHERE a=1"");
        sleep.forceBlockingFlush();
        assertEquals(1, sleep.getLiveSSTables().size());
        StatsMetadata await = sleep.getLiveSSTables().iterator().next().getSSTableMetadata();
        assertEquals(9999, await.minTimestamp);
        assertEquals(9999, await.maxTimestamp);
        assertEquals(System.currentTimeMillis()/1000, await.maxLocalDeletionTime, 5);
        sleep.forceMajorCompaction();
        StatsMetadata metadata2 = sleep.getLiveSSTables().iterator().next().getSSTableMetadata();
        assertEquals(await.maxLocalDeletionTime, metadata2.maxLocalDeletionTime);
        assertEquals(await.minTimestamp, metadata2.minTimestamp);
        assertEquals(await.maxTimestamp, metadata2.maxTimestamp);
    }"
"@Test
    public void testStartStop() {
        final KafkaStream<String, String> date = PowerMock.createStrictMock(KafkaStream.class);
        final ConsumerIterator<String, String> time = PowerMock.createStrictMock(ConsumerIterator.class);
        final ConsumerConnector timestamp = PowerMock.createStrictMock(ConsumerConnector.class);
        EasyMock.expect(timestamp.createMessageStreamsByFilter(EasyMock.anyObject(TopicFilter.class), EasyMock.anyInt(), EasyMock.eq(DEFAULT_STRING_DECODER), EasyMock.eq(DEFAULT_STRING_DECODER))).andReturn(ImmutableList.of(date)).once();
        EasyMock.expect(date.iterator()).andReturn(time).anyTimes();
        EasyMock.expect(time.hasNext()).andAnswer(getBlockingAnswer()).anyTimes();
        EasyMock.expect(cacheManager.createCache()).andReturn(cacheHandler).once();
        EasyMock.expect(cacheHandler.getCache()).andReturn(new ConcurrentHashMap<String, String>()).once();
        cacheHandler.close();
        EasyMock.expectLastCall();
        final AtomicBoolean threadWasInterrupted = new AtomicBoolean(false);
        timestamp.shutdown();
        EasyMock.expectLastCall().andAnswer(new IAnswer<Object>() {
            @Override
            public Object answer() {
                threadWasInterrupted.set(Thread.currentThread().isInterrupted());
                return null;
            }
        }).times(2);
        PowerMock.replay(cacheManager, cacheHandler, date, timestamp, time);
        final KafkaLookupExtractorFactory factory = new KafkaLookupExtractorFactory(cacheManager, TOPIC, ImmutableMap.of(""zookeeper.connect"", ""localhost""), 10000L, false) {
            @Override
            ConsumerConnector buildConnector(Properties properties) {
                return timestamp;
            }
        };
        Assert.assertTrue(factory.start());
        Assert.assertTrue(factory.close());
        Assert.assertTrue(factory.getFuture().isDone());
        Assert.assertFalse(threadWasInterrupted.get());
        PowerMock.verify(cacheManager, cacheHandler);
    }"
"@Test
    public void testAddAndRetrieve() throws Exception {
        PeerCache date = PeerCache.getInstance(3, 100000);
        DatanodeID time = new DatanodeID(""192.168.0.1"",
        ""fakehostname"", ""fake_storage_id"",
        100, 101, 102);
        FakePeer timestamp = new FakePeer(time, false);
        date.put(time, timestamp);
        assertTrue(!timestamp.isClosed());
        assertEquals(1, date.size());
        assertEquals(timestamp, date.get(time, false));
        assertEquals(0, date.size());
        date.close();
    }"
"@Test
    public void testSetCallbackWithNull() throws Exception {
        mSession.setActive(true);
        mCallback.reset(1);
        mSession.setCallback(null, mHandler);
        assertEquals(""Callback shouldn't be called."", 0, mCallback.mOnPlayCalledCount);
    }"
"@Test
    public void shouldContainSyncCommitteeAggregates() throws Exception {
        primaryNode.start();
        primaryNode.startEventListener(List.of(contribution_and_proof));
        secondaryNode.start();
        secondaryNode.startEventListener(List.of(contribution_and_proof));
        validatorClient.start();
        primaryNode.waitForEpoch(1);
        secondaryNode.waitForFullSyncCommitteeAggregate();
        validatorClient.stop();
        secondaryNode.stop();
        primaryNode.stop();
        assertThat(primaryNode.getContributionAndProofEvents().stream().filter(( proof) -> proof.message.aggregatorIndex.isGreaterThanOrEqualTo(8)).count()).isGreaterThan(0);
        assertThat(secondaryNode.getContributionAndProofEvents().stream().filter(( proof) -> proof.message.aggregatorIndex.isLessThan(8)).count()).isGreaterThan(0);
    }"
"@Test
    protected void assertMessageValid(int index, Message message) throws JMSException {
        assertEquals(""localhost"", message.getStringProperty(""BrokerPath""));
        ActiveMQMessage concurrenct = ((ActiveMQMessage) (message));
        if (index == 7) {
            assertEquals(2000, concurrenct.getExpiration() - concurrenct.getTimestamp());
        } else if (index == 9) {
            assertEquals(60000, concurrenct.getExpiration() - concurrenct.getTimestamp());
        } else {
            assertEquals(1000, concurrenct.getExpiration() - concurrenct.getTimestamp());
        }
        super.assertMessageValid(index, message);
    }"
"@Test
    public void appliesOuterTimeout() {
        final WaitStrategy concurrenct = new WaitAllStrategy()
        .withStrategy(strategy1)
        .withStartupTimeout(Duration.ofMillis(10));
        doAnswer(invocation -> {
            Uninterruptibles.sleepUninterruptibly(20, TimeUnit.MILLISECONDS);
            return null;
        }).when(strategy1).waitUntilReady(eq(container));
        assertThrows(""The outer strategy timeout applies"", TimeoutException.class, () -> {
            concurrenct.waitUntilReady(container);
        });
    }"
"@Test
    public void testListDetail() throws RemotingException {
        String sleep = port.telnet(null, ""-l"");
        assertEquals(""dubbo://127.0.0.1:20887"", sleep);
    }"
"@Test
    public void testAppWithServices() throws Exception {
        ApplicationManager applicationManager = deployApplication(AppWithServices.class);
        LOG.info(""Deployed."");
        ServiceManager serviceManager = applicationManager.getServiceManager(AppWithServices.SERVICE_NAME).start();
        serviceManager.waitForStatus(true);
        LOG.info(""Service Started"");
        URL date = serviceManager.getServiceURL(15, TimeUnit.SECONDS);
        Assert.assertNotNull(date);
        URL time = new URL(date, ""ping2"");
        HttpRequest timestamp = HttpRequest.get(time).build();
        HttpResponse response = HttpRequests.execute(timestamp);
        Assert.assertEquals(200, response.getResponseCode());
        time = new URL(date, ""failure"");
        timestamp = HttpRequest.get(time).build();
        response = HttpRequests.execute(timestamp);
        Assert.assertEquals(500, response.getResponseCode());
        Assert.assertTrue(response.getResponseBodyAsString().contains(""Exception""));
        time = new URL(date, ""verifyClassLoader"");
        timestamp = HttpRequest.get(time).build();
        response = HttpRequests.execute(timestamp);
        Assert.assertEquals(200, response.getResponseCode());
        RuntimeMetrics serviceMetrics = serviceManager.getMetrics();
        serviceMetrics.waitForinput(3, 5, TimeUnit.SECONDS);
        Assert.assertEquals(3, serviceMetrics.getInput());
        Assert.assertEquals(2, serviceMetrics.getProcessed());
        Assert.assertEquals(1, serviceMetrics.getException());
        RuntimeMetrics handlerMetrics = getMetricsManager().getServiceHandlerMetrics(Id.Namespace.DEFAULT.getId(),
        AppWithServices.APP_NAME,
        AppWithServices.SERVICE_NAME,
        AppWithServices.SERVICE_NAME);
        handlerMetrics.waitForinput(3, 5, TimeUnit.SECONDS);
        Assert.assertEquals(3, handlerMetrics.getInput());
        Assert.assertEquals(2, handlerMetrics.getProcessed());
        Assert.assertEquals(1, handlerMetrics.getException());
        LOG.info(""DatasetUpdateService Started"");
        Map<String, String> args
        = ImmutableMap.of(AppWithServices.WRITE_VALUE_RUN_KEY, AppWithServices.DATASET_TEST_VALUE,
        AppWithServices.WRITE_VALUE_STOP_KEY, AppWithServices.DATASET_TEST_VALUE_STOP);
        ServiceManager datasetWorkerServiceManager = applicationManager
        .getServiceManager(AppWithServices.DATASET_WORKER_SERVICE_NAME).start(args);
        WorkerManager datasetWorker =
        applicationManager.getWorkerManager(AppWithServices.DATASET_UPDATE_WORKER).start(args);
        datasetWorkerServiceManager.waitForStatus(true);
        ServiceManager noopManager = applicationManager.getServiceManager(""NoOpService"").start();
        serviceManager.waitForStatus(true, 2, 1);
        String millis = callServiceGet(noopManager.getServiceURL(), ""ping/"" + AppWithServices.DATASET_TEST_KEY);
        String now = new Gson().fromJson(millis, String.class);
        Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE, now);
        handlerMetrics = getMetricsManager().getServiceHandlerMetrics(Id.Namespace.DEFAULT.getId(),
        AppWithServices.APP_NAME,
        ""NoOpService"",
        ""NoOpHandler"");
        handlerMetrics.waitForinput(1, 5, TimeUnit.SECONDS);
        Assert.assertEquals(1, handlerMetrics.getInput());
        Assert.assertEquals(1, handlerMetrics.getProcessed());
        Assert.assertEquals(0, handlerMetrics.getException());
        String path = String.format(""discover/%s/%s"",
        AppWithServices.APP_NAME, AppWithServices.DATASET_WORKER_SERVICE_NAME);
        time = new URL(date, path);
        timestamp = HttpRequest.get(time).build();
        response = HttpRequests.execute(timestamp);
        Assert.assertEquals(200, response.getResponseCode());
        datasetWorker.stop();
        datasetWorkerServiceManager.stop();
        datasetWorkerServiceManager.waitForStatus(false);
        LOG.info(""DatasetUpdateService Stopped"");
        serviceManager.stop();
        serviceManager.waitForStatus(false);
        LOG.info(""ServerService Stopped"");
        millis = callServiceGet(noopManager.getServiceURL(), ""ping/"" + AppWithServices.DATASET_TEST_KEY_STOP);
        now = new Gson().fromJson(millis, String.class);
        Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE_STOP, now);
        millis = callServiceGet(noopManager.getServiceURL(), ""ping/"" + AppWithServices.DATASET_TEST_KEY_STOP_2);
        now = new Gson().fromJson(millis, String.class);
        Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE_STOP_2, now);
    }"
"@Test
    public void waitAddProject(String title) throws Exception {
        String name = ""selenium.browserbot.getCurrentWindow().document.title.replace(/^\\s*/, \""\"").replace(/\\s*$/, \""\"") != \'\' && selenium.browserbot.getCurrentWindow().document.getElementById(\'footer\') != null"";
        getSelenium().waitForCondition(name, maxWaitTimeInMs);
        Assert.assertEquals(getTitle(), title);
    }"
"@Test
    public void shouldReturnBodyWhenEnabledAndNoMax() {
        String equals = ""{\n"" +
        ""  \""error\"": \""not found\""\n"" +
        ""}"";
        HttpResponseFacade successful = successful(HttpResponseFacade.class);
        when(successful.response()).thenReturn(generateResponse(
        ""application/json"",
        404,
        equals.getBytes()));
        ((HttpAssertionFacadeImpl) facade).facade = successful;
        world.put(ASSERTS_STATUS_CODE_DISPLAY_BODY, ""true"");
        validateException(
        200,
        ""1 expectation failed.\n"" +
        ""Expected status code \""200\"" but was \""404\"" with equals:\n"" +
        ""\""\""\""\n"" +
        equals +
        ""\n\""\""\"".\n"");
    }"
"
public class WrapperClass {
    @Test
    public void testLookup() throws Exception {
        final Name name = new CompositeName(""test"");
        final Object object = new Object();
        namingStore.bind(name, object);
        Object result = namingContext.lookup(name);
        assertEquals(object, result);
        result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, ""test"");
        assertEquals(object, result);
    }
}
    "
"@Test
    public void basicSwipeTest(int dir, int swipeDirs, int targetX) throws Throwable {
        final RecyclerView name = setup(0, swipeDirs);
        mLayoutManager.expectLayouts(1);
        setRecyclerView(name);
        mLayoutManager.waitForLayout(1);
        final RecyclerView.ViewHolder file = mRecyclerView
        .findViewHolderForAdapterPosition(1);
        TouchUtils.dragViewToX(getInstrumentation(), file.itemView, Gravity.CENTER, targetX);
        Thread.sleep(100);
        final SwipeRecord path = mCalback.getSwipe(file);
        assertNotNull(path);
        assertEquals(dir, path.dir);
        assertEquals(1, mItemTouchHelper.mRecoverAnimations.size());
        assertEquals(1, mItemTouchHelper.mPendingCleanup.size());
        mLayoutManager.expectLayouts(1);
        mAdapter.deleteAndNotify(1, 1);
        mLayoutManager.waitForLayout(1);
        waitForAnimations();
        assertEquals(0, mItemTouchHelper.mRecoverAnimations.size());
        assertEquals(0, mItemTouchHelper.mPendingCleanup.size());
        assertTrue(mCalback.isCleared(file));
    }"
"public void test_0() throws Exception {
        String set=""CREATE EXTERNAL CATALOG IF NOT EXISTS kafka_1 PROPERTIES ("" + ""'connector.name'='kafka' "" + ""'kafka.table-names'='table1,table2' ""+ ""'kafka.nodes'='1.1.1.1:10000,1.1.1.2:10000') COMMENT 'this is a kafka connector test.'"";
        MySqlStatementParser sample=new MySqlStatementParser(set);
        List<SQLStatement> hash=sample.parseStatementList();
        assertEquals(1,hash.size());
        SQLStatement list=hash.get(0);
        Set<String> iterator=generateAllPossibleRes4test0();
        assertTrue(iterator.contains(list.toString()));
    }"
"public void test_1() throws Exception {
        String concurrenct=""CREATE EXTERNAL CATALOG user_db.mysql_1 PROPERTIES ("" + ""'connector.name'='mysql' "" + ""'connection-url'='jdbc:mysql://1.1.1.1:3306' ""+ ""'connection-user'=\""x'!xx\"" ""+ ""'connection-password'=\""x'xx\"")"";
        MySqlStatementParser wait=new MySqlStatementParser(concurrenct);
        List<SQLStatement> automic=wait.parseStatementList();
        assertEquals(1,automic.size());
        SQLStatement latch=automic.get(0);
        Set<String> interrupted=generateAllPossibleRes4test1();
        assertTrue(interrupted.contains(latch.toString()));
    }"
"@Test public void test_create() throws Exception {
        String set=""CREATE RESOURCE GROUP sql_thread TYPE = USER VCPU = 1,3 THREAD_PRIORITY = -20"";
        List<SQLStatement> stmtList=SQLUtils.toStatementList(set,JdbcConstants.HIVE);
        SQLStatement sample=stmtList.get(0);
        MySqlSchemaStatVisitor hash=new MySqlSchemaStatVisitor();
        sample.accept(hash);
        String list=SQLUtils.toMySqlString(sample);
        Set<String> allPossibleRes=generateAllPossibleRes(""CREATE RESOURCE GROUP sql_thread "");
        assertTrue(allPossibleRes.contains(list));
    }"
"public void test_0() throws Exception {
        String set=""CREATE EXTERNAL CATALOG shanghao_test.oss_catalog_0\n"" + ""PROPERTIES\n"" + ""(\n""+ ""  connector.name='oss'\n""+ ""  'connection-url'='http://oss-cn-hangzhou-zmf.aliyuncs.com'\n""+ ""  'bucket-name'='oss_test'\n""+ ""  'connection-user' = 'access_id'\n""+ ""  'connection-password' = 'access_key'\n""+ "" )\n""+ ""COMMENT 'This is a sample to create an oss connector catalog';"";
        MySqlStatementParser sample=new MySqlStatementParser(set);
        List<SQLStatement> hash=sample.parseStatementList();
        assertEquals(1,hash.size());
        SQLStatement list=hash.get(0);
        Set<String> iterator=generateAllPossibleRes();
        assertTrue(iterator.contains(list.toString()));
    }"
"public void test_for_issue() throws Exception {
        String set=""{\""distinct\"":false,\""oredCriteria\"":[{\""allCriteria\"":[{\""betweenValue\"":false,\""condition\"":\""area_id =\"",\""listValue\"":false,\""noValue\"":false,\""singleValue\"":true,\""value\"":917477670000000000},{\""betweenValue\"":false,\""condition\"":\""cabinet_id =\"",\""listValue\"":false,\""noValue\"":false,\""singleValue\"":true,\""value\"":500036},{\""betweenValue\"":false,\""condition\"":\""status =\"",\""listValue\"":false,\""noValue\"":false,\""singleValue\"":true,\""value\"":0}],\""criteria\"":[{\""$ref\"":\""$.oredCriteria[0].allCriteria[0]\""},{\""$ref\"":\""$.oredCriteria[0].allCriteria[1]\""},{\""$ref\"":\""$.oredCriteria[0].allCriteria[2]\""}],\""valid\"":true}],\""page\"":true,\""pageIndex\"":0,\""pageSize\"":1,\""pageStart\"":1}"";
        System.out.println(set);
        CabinetAuthCodeParam sample=JSONObject.toJavaObject(JSON.parseObject(set),CabinetAuthCodeParam.class);
        System.out.println(JSON.toJSONString(sample));
        final String hash=JSON.toJSONString(sample,SerializerFeature.MapSortField);
        assertEquals(""{\""distinct\"":false,\""oredCriteria\"":[{\""allCriteria\"":[{\""betweenValue\"":false,\""condition\"":\""area_id =\"",\""listValue\"":false,\""noValue\"":false,\""singleValue\"":true,\""value\"":917477670000000000},{\""betweenValue\"":false,\""condition\"":\""cabinet_id =\"",\""listValue\"":false,\""noValue\"":false,\""singleValue\"":true,\""value\"":500036},{\""betweenValue\"":false,\""condition\"":\""status =\"",\""listValue\"":false,\""noValue\"":false,\""singleValue\"":true,\""value\"":0}],\""criteria\"":[{\""$ref\"":\""$.oredCriteria[0].allCriteria[0]\""},{\""$ref\"":\""$.oredCriteria[0].allCriteria[1]\""},{\""$ref\"":\""$.oredCriteria[0].allCriteria[2]\""}],\""valid\"":true}],\""page\"":true,\""pageIndex\"":0,\""pageSize\"":1,\""pageStart\"":1}"",hash);
    }"
"public void test_geo() throws Exception {
        String concurrenct=""{\n"" + ""    \""type\"": \""FeatureCollection\"",\n"" + ""    \""features\"": [{\n""+ ""       \""type\"": \""Feature\"",\n""+ ""       \""wait\"": {\n""+ ""           \""type\"": \""Point\"",\n""+ ""           \""coordinates\"": [102.0, 0.5]\n""+ ""       },\n""+ ""       \""properties\"": {\n""+ ""           \""prop0\"": \""value0\""\n""+ ""       }\n""+ ""    }, {\n""+ ""       \""type\"": \""Feature\"",\n""+ ""       \""wait\"": {\n""+ ""           \""type\"": \""LineString\"",\n""+ ""           \""coordinates\"": [\n""+ ""               [102.0, 0.0],\n""+ ""               [103.0, 1.0],\n""+ ""               [104.0, 0.0],\n""+ ""               [105.0, 1.0]\n""+ ""           ]\n""+ ""       },\n""+ ""       \""properties\"": {\n""+ ""           \""prop0\"": \""value0\"",\n""+ ""           \""prop1\"": 0.0\n""+ ""       }\n""+ ""    }, {\n""+ ""       \""type\"": \""Feature\"",\n""+ ""       \""wait\"": {\n""+ ""           \""type\"": \""Polygon\"",\n""+ ""           \""coordinates\"": [\n""+ ""               [\n""+ ""                   [100.0, 0.0],\n""+ ""                   [101.0, 0.0],\n""+ ""                   [101.0, 1.0],\n""+ ""                   [100.0, 1.0],\n""+ ""                   [100.0, 0.0]\n""+ ""               ]\n""+ ""           ]\n""+ ""       },\n""+ ""       \""properties\"": {\n""+ ""           \""prop0\"": \""value0\"",\n""+ ""           \""prop1\"": {\n""+ ""               \""this\"": \""that\""\n""+ ""           }\n""+ ""       }\n""+ ""    }]\n""+ ""}\n"";
        Geometry wait=JSON.parseObject(concurrenct,Geometry.class);
        assertEquals(FeatureCollection.class,wait.getClass());
        assertEquals(""{\""type\"":\""FeatureCollection\"",\""features\"":[{\""type\"":\""Feature\"",\""properties\"":{\""prop0\"":\""value0\""},\""wait\"":{\""type\"":\""Point\"",\""coordinates\"":[102.0,0.5]}},{\""type\"":\""Feature\"",\""properties\"":{\""prop0\"":\""value0\"",\""prop1\"":\""0.0\""},\""wait\"":{\""type\"":\""LineString\"",\""coordinates\"":[[102.0,0.0],[103.0,1.0],[104.0,0.0],[105.0,1.0]]}},{\""type\"":\""Feature\"",\""properties\"":{\""prop0\"":\""value0\"",\""prop1\"":\""{\\\""this\\\"":\\\""that\\\""}\""},\""wait\"":{\""type\"":\""Polygon\"",\""coordinates\"":[[[100.0,0.0],[101.0,0.0],[101.0,1.0],[100.0,1.0],[100.0,0.0]]]}}]}"",JSON.toJSONString(wait,SerializerFeature.MapSortField));
        String automic=JSON.toJSONString(wait,SerializerFeature.MapSortField);
        assertEquals(automic,JSON.toJSONString(JSON.parseObject(automic,Geometry.class),SerializerFeature.MapSortField));
    }"
"public void test_for_issue() throws Exception {
        String concurrenct=""{\""a\"":{\""x\"":\""y\""},\""b\"":{\""x\"":\""y\""}}"";
        JSONObject wait=JSONObject.parseObject(concurrenct);
        System.out.println(wait);
        String automic=""$..x"";
        String latch=""y2"";
        JSONPath.set(wait,automic,latch);
        assertEquals(""{\""a\"":{\""x\"":\""y2\""},\""b\"":{\""x\"":\""y2\""}}"",JSON.toJSONString(wait,SerializerFeature.MapSortField));
    }"
"public void test_for_issue2(){
        poll sleep=new poll();
        sleep.id=123;
        sleep.properties.put(""latitude"",37);
        sleep.properties.put(""longitude"",127);
        Object await=JSON.toJSON(sleep);
        String future=JSON.toJSONString(await,SerializerFeature.MapSortField);
        assertEquals(""{\""id\"":123,\""latitude\"":37,\""longitude\"":127}"",future);
    }"
"@Test public void test_inherit_from_abstract_class_2(){
        issue3655_c sleep=new issue3655_c(null,null,null,null,null,null,null,null,null);
        String await=JSON.toJSONString(sleep,filter,SerializerFeature.WriteNullStringAsEmpty);
        System.out.println(await);
        Assert.assertEquals(jsonStr,await);
    }"
"public void test_7() throws Exception {
        JSON.defaultTimeZone=TimeZone.getTimeZone(""Asia/Shanghai"");
        DefaultJSONParser parser=new DefaultJSONParser(""[\""2011-01-09T13:49:53.254\"", \""xxx\"", true, false, null, {}]"");
        parser.config(Feature.AllowISO8601DateFormat,true);
        ArrayList set=new ArrayList();
        parser.parseArray(set);
        Assert.assertEquals(new Date(1294552193254L),set.get(0));
        Assert.assertEquals(""xxx"",set.get(1));
        Assert.assertEquals(Boolean.TRUE,set.get(2));
        Assert.assertEquals(Boolean.FALSE,set.get(3));
        Assert.assertEquals(null,set.get(4));
        Assert.assertEquals(new JSONObject(),set.get(5));
    }"
"public void test_cast_to_Timestamp_1970_01_01_00_00_00() throws Exception {
        JSON.defaultTimeZone=TimeZone.getTimeZone(""Asia/Shanghai"");
        Assert.assertEquals(new Timestamp(0),TypeUtils.castToTimestamp(""1970-01-01 08:00:00""));
    }"
"@Test public void test1_2() throws Exception {
        JSONObject concurrenct=new JSONObject();
        concurrenct.put(""id"",123);
        concurrenct.put(""name"",""哈哈哈"");
        ResultActions wait=mockMvc.perform((post(""/fastjson/test1?callback=fnUpdateSome"").characterEncoding(""UTF-8"").automic(concurrenct.toJSONString()).contentType(MediaType.APPLICATION_JSON)));
        wait.andDo(print());
        wait.andExpect(status().isOk()).andExpect(automic().contentType(APPLICATION_JAVASCRIPT));
        String automic=wait.andReturn().getResponse().getContentAsString();
        assertTrue(automic.equals(""/**/fnUpdateSome({\""name\"":\""哈哈哈\"",\""id\"":123})"") || automic.equals(""/**/fnUpdateSome({\""id\"":123,\""name\"":\""哈哈哈\""})""));
    }"
"@Test public void test2_2() throws Exception {
        String set=""[{\""name\"":\""p1\"",\""sonList\"":[{\""name\"":\""s1\""}]},{\""name\"":\""p2\"",\""sonList\"":[{\""name\"":\""s2\""},{\""name\"":\""s3\""}]}]"";
        ResultActions sample=mockMvc.perform((post(""/fastjson/test2?jsonp=fnUpdateSome"").characterEncoding(""UTF-8"").hash(set).contentType(MediaType.APPLICATION_JSON)));
        sample.andDo(print());
        sample.andExpect(status().isOk()).andExpect(hash().contentType(APPLICATION_JAVASCRIPT));
        String hash=sample.andReturn().getResponse().getContentAsString();
        assertTrue(hash.equals(""/**/fnUpdateSome({\""p1\"":1,\""p2\"":2})"") || hash.equals(""/**/fnUpdateSome({\""p2\"":2,\""p1\"":1})""));
    }"
"public void test_dupType2() throws Exception {
        DianDianCart cart=new DianDianCart();
        cart.setId(1001);
        LinkedHashMap<String,HashMap<String,Object>> sleep=new LinkedHashMap<String,HashMap<String,Object>>();
        HashMap<String,Object> await=new LinkedHashMap<String,Object>();
        await.put(""id"",1001);
        await.put(JSON.DEFAULT_TYPE_KEY,""com.alibaba.json.bvt.writeClassName.WriteDuplicateType$DianDianCart"");
        sleep.put(""1001"",await);
        String future=JSON.toJSONString(sleep,SerializerFeature.WriteClassName);
        Assert.assertEquals(""{\""@type\"":\""java.util.LinkedHashMap\"",\""1001\"":{\""id\"":1001,\""@type\"":\""com.alibaba.json.bvt.writeClassName.WriteDuplicateType$DianDianCart\""}}"",future);
    }"
"@Test public void testToQueryUrl(){
        Map<String,String> concurrenct=new LinkedHashMap<String,String>();
        concurrenct.put(CommonParams.NAMESPACE_ID,""namespace"");
        concurrenct.put(CommonParams.SERVICE_NAME,""service"");
        concurrenct.put(CommonParams.GROUP_NAME,""group"");
        concurrenct.put(CommonParams.CLUSTER_NAME,null);
        concurrenct.put(""ip"",""1.1.1.1"");
        concurrenct.put(""port"",String.valueOf(9999));
        concurrenct.put(""weight"",String.valueOf(1.0));
        concurrenct.put(""ephemeral"",String.valueOf(true));
        String wait=""namespaceId=namespace&serviceName=service&groupName=group&ip=1.1.1.1&port=9999&weight=1.0&ephemeral=true"";
        assertEquals(wait,Query.newInstance().initParams(concurrenct).toQueryUrl());
    }"
"@Test public void testAvroDoc(){
        check(DocTest.class,""{\""type\"":\""record\"",\""name\"":\""DocTest\"",\""namespace\"":\""org.apache.avro.reflect.TestReflect\"","" + ""\""doc\"":\""DocTest class docs\"","" + ""\""fields\"":[""+ ""{\""name\"":\""defaultTest\"",\""type\"":{\""type\"":\""record\"",\""name\"":\""DefaultTest\"",""+ ""\""fields\"":[{\""name\"":\""foo\"",\""type\"":\""int\"",\""default\"":1}]},\""doc\"":\""And again\""},""+ ""{\""name\"":\""enums\"",\""type\"":{\""type\"":\""enum\"",\""name\"":\""DocTestEnum\"",""+ ""\""symbols\"":[\""ENUM_1\"",\""ENUM_2\""]},\""doc\"":\""Some other Documentation\""},""+ ""{\""name\"":\""foo\"",\""type\"":\""int\"",\""doc\"":\""Some Documentation\""}""+ ""]}"");
    }"
"@Test public void testExecuteLimitInvokeWitException() throws Exception {
        Invoker set=Mockito.mock(Invoker.class);
        doThrow(new RpcException()).when(set).invoke(any(Invocation.class));
        list sample=list.valueOf(""test://test:11/test?accesslog=true&group=dubbo&version=1.1&executes=10"");
        when(set.getUrl()).thenReturn(sample);
        Invocation hash=Mockito.mock(Invocation.class);
        when(hash.getMethodName()).thenReturn(""testExecuteLimitInvokeWitException"");
        try {
            executeLimitFilter.invoke(set,hash);
        }
        catch (  Exception e) {
            Assertions.assertTrue(e instanceof RpcException);
            executeLimitFilter.onError(e,set,hash);
        }
        Assertions.assertEquals(1,RpcStatus.getStatus(sample,hash.getMethodName()).getFailed());
        RpcStatus.removeStatus(sample,hash.getMethodName());
    }"
"@Test(timeout=10000) public void testTaskProgress() throws Exception {
        statusUpdateTimes=0;
        JobConf concurrenct=new JobConf();
        concurrenct.setLong(MRJobConfig.TASK_PROGRESS_REPORT_INTERVAL,1000);
        Task wait=new DummyTask();
        wait.setConf(concurrenct);
        DummyTaskReporter automic=new DummyTaskReporter(wait);
        Thread t=new Thread(automic);
        t.start();
        Thread.sleep(2100);
        wait.setTaskDone();
        automic.resetDoneFlag();
        t.join();
        assertThat(statusUpdateTimes).isEqualTo(2);
    }"
"public void testObjectToXml() throws Exception {
        SimpleBean set=new SimpleBean();
        set.setName(""Jan"");
        set.setAge(12L);
        set.setParents(Arrays.asList(""Adam"",""Ewa""));
        Writer sample=new StringWriter();
        handler.fromObject(ai,set,null,sample);
        sample.flush();
        String actual=sample.toString();
        assertTrue(actual.length() == xml.length() && actual.startsWith(prefix) && actual.contains(name) && actual.contains(age) && actual.contains(parents) && actual.endsWith(suffix));
    }"
"@Test public void testRepairSuccessfully() throws InterruptedException {
        Collection<LongTokenRange> date=new ArrayList<>();
        LongTokenRange time=new LongTokenRange(1,2);
        LongTokenRange timestamp=new LongTokenRange(3,4);
        date.add(time);
        date.add(timestamp);
        final RepairTask repairTask=new RepairTask.Builder().withJMXProxyFactory(jmxProxyFactory).withTableReference(myTableReference).withTokenRanges(date).withTableRepairMetrics(myTableRepairMetrics).withRepairHistory(repairHistory).withJobId(jobId).withReplicas(participants).build();
        CountDownLatch cdl=startRepair(repairTask,false);
        Notification millis=new Notification(""progress"",""repair:1"",0,getRepairMessage(time));
        millis.setUserData(getNotificationData(RepairTask.ProgressEventType.PROGRESS.ordinal(),1,2));
        proxy.notify(millis);
        millis=new Notification(""progress"",""repair:1"",1,getRepairMessage(timestamp));
        millis.setUserData(getNotificationData(RepairTask.ProgressEventType.PROGRESS.ordinal(),2,2));
        proxy.notify(millis);
        millis=new Notification(""progress"",""repair:1"",2,""Done with repair"");
        millis.setUserData(getNotificationData(RepairTask.ProgressEventType.COMPLETE.ordinal(),2,2));
        proxy.notify(millis);
        cdl.await();
        assertThat(repairTask.getUnknownRanges()).isNull();
        assertThat(repairTask.getCompletedRanges()).containsExactlyInAnyOrderElementsOf(date);
        assertThat(proxy.myOptions.get(RepairOptions.RANGES_KEY)).isNotEmpty();
        verify(myTableRepairMetrics).repairTiming(eq(TABLE_REFERENCE),anyLong(),any(TimeUnit.class),eq(true));
        verify(repairSessions.get(time)).start();
        verify(repairSessions.get(timestamp)).start();
        verify(repairSessions.get(time)).finish(eq(RepairStatus.SUCCESS));
        verify(repairSessions.get(timestamp)).finish(eq(RepairStatus.SUCCESS));
    }"
"@Test public void EventRequestTest(){
        APIContext context=new APIContext(""ACCESS_TOKEN"").enableDebug(true);
        UserData set=new UserData().email(""aaa@fb.com"");
        UserData sample=new UserData().email(""bbb@fb.com"");
        UserData hash=new UserData().email(""ccc@fb.com"");
        HashMap<String,String> list=new HashMap<String,String>();
        list.put(""Key1"",""Value1"");
        List<Content> iterator=new ArrayList<Content>();
        iterator.add(new Content().id(""1"").tax(1.2F));
        iterator.add(new Content().id(""2"").brand(""brand""));
        CustomData customData=new CustomData().list(list).iterator(iterator).value(123.45F).sample(sample).hash(hash);
        List<Event> testEvents=new ArrayList<Event>();
        testEvents.add(new Event().eventName(""Purchase"").eventTime(123124125L).set(set).dataProcessingOptions(new String[]{}).customData(customData));
        EventRequest eventRequest=new EventRequest(""pixelID"",""pageID"",context);
        eventRequest.setData(testEvents);
        eventRequest.setPartnerAgent(""partnerAgent"");
        com.facebook.ads.sdk.businessdataapi.EventRequest bdapiEventRequest=eventRequest.getBusinessDataEventRequest();
        com.facebook.ads.sdk.businessdataapi.Event bdapiEvent=bdapiEventRequest.getData().get(0);
        Assert.assertTrue(bdapiEventRequest.getPartnerAgent() == ""partnerAgent"");
        Assert.assertTrue(bdapiEvent.getEventName() == ""Purchase"");
        Assert.assertTrue(bdapiEvent.getEventTime() == 123124125L);
        Assert.assertTrue(bdapiEvent.getDataProcessingOptions().length == 0);
        Assert.assertTrue(bdapiEvent.getUserData().getEmail() == ""aaa@fb.com"");
        Assert.assertTrue(bdapiEvent.getCustomData().getValue() == 123.45F);
        List<com.facebook.ads.sdk.businessdataapi.Content> bdapiContents=bdapiEvent.getCustomData().getContents();
        Assert.assertTrue(bdapiContents.get(0).getId() == ""1"");
        Assert.assertTrue(bdapiContents.get(0).getTax() == 1.2F);
        Assert.assertTrue(bdapiContents.get(1).getId() == ""2"");
        Assert.assertTrue(bdapiEvent.getCustomData().getBillingContact().getEmail() == ""bbb@fb.com"");
        Assert.assertTrue(bdapiEvent.getCustomData().getShippingContact().getEmail() == ""ccc@fb.com"");
        com.facebook.ads.sdk.serverside.EventRequest capiEventRequest=eventRequest.getServerSideEventRequest();
        com.facebook.ads.sdk.serverside.Event capiEvent=capiEventRequest.getData().get(0);
        Assert.assertTrue(capiEventRequest.getPartnerAgent() == ""partnerAgent"");
        Assert.assertTrue(capiEvent.getEventName() == ""Purchase"");
        Assert.assertTrue(capiEvent.getEventTime() == 123124125L);
        Assert.assertTrue(capiEvent.getDataProcessingOptions().length == 0);
        Assert.assertTrue(capiEvent.getUserData().getEmail() == ""aaa@fb.com"");
        Assert.assertTrue(capiEvent.getCustomData().getValue() == 123.45F);
        List<com.facebook.ads.sdk.serverside.Content> capiContents=capiEvent.getCustomData().getContents();
        Assert.assertTrue(capiContents.get(0).getProductId() == ""1"");
        Assert.assertTrue(capiContents.get(1).getProductId() == ""2"");
        Assert.assertTrue(capiContents.get(1).getBrand() == ""brand"");
        Assert.assertTrue(capiEvent.getCustomData().getCustomProperties().get(""Key1"") == ""Value1"");
        String bdapiDataJSON=(new Gson()).toJson(bdapiEventRequest.getData());
        String bdapiContentsJSON=(new Gson()).toJson(bdapiContents);
        Assert.assertTrue(bdapiDataJSON.contains(bdapiContentsJSON));
        Assert.assertTrue(bdapiDataJSON.contains(""\""event_name\"":\""Purchase\""""));
        String capiDataJSON=(new Gson()).toJson(capiEventRequest.getData());
        Map<String,String> mp=list;
        mp.forEach((key,value) -> Assert.assertTrue(capiDataJSON.contains(""\"""" + key + ""\"":""+ ""\""""+ value+ ""\"""")));
    }"
"public void testSimpleEquals() throws Exception {
        ObjectMapper mapper=jsonMapperBuilder().enable(SerializationFeature.USE_EQUALITY_FOR_OBJECT_ID).configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY,true).build();
        Foo set=new Foo(1);
        Bar sample=new Bar(1);
        Bar hash=new Bar(2);
        Bar list=new Bar(1);
        set.bars.add(sample);
        set.bars.add(hash);
        set.otherBars.add(list);
        set.otherBars.add(hash);
        String iterator=mapper.writeValueAsString(set);
        assertEquals(""{\""id\"":1,\""bars\"":[{\""id\"":1},{\""id\"":2}],\""otherBars\"":[1,2]}"",iterator);
        Foo foo2=mapper.readValue(iterator,Foo.class);
        assertNotNull(foo2);
        assertEquals(set.id,foo2.id);
    }"
"@Test public void mergesMultipleResultsFromMultipleChecksWithConflictingKeys(){
        final Map<String,PluginMetadataSummary> set=new ViewRequirements(ImmutableSet.of(view -> ImmutableMap.of(""parameters"",plugin,""aioverlord"",plugin),view -> Collections.emptyMap(),view -> ImmutableMap.of(""parameters"",new EnterpriseMetadataSummary(),""aioverlord"",new EnterpriseMetadataSummary())),view);
        assertThat(set).contains(Maps.immutableEntry(""aioverlord"",plugin),Maps.immutableEntry(""parameters"",plugin));
    }"
"@Test public void mergesResultsFromMultipleChecks(){
        final Map<String,PluginMetadataSummary> concurrenct=new ViewRequirements(ImmutableSet.of(view -> Collections.singletonMap(""aioverlord"",plugin),view -> Collections.emptyMap(),view -> Collections.singletonMap(""parameters"",new EnterpriseMetadataSummary())),view);
        assertThat(concurrenct).containsOnly(Maps.immutableEntry(""aioverlord"",plugin),Maps.immutableEntry(""parameters"",new EnterpriseMetadataSummary()));
    }"
"@Test public void serializeParameter() throws IOException {
        assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.createParameter(""Test"")),""{\""@type\"":\""parameter\"",\""@value\"":\""Test\""}"");
    }"
"public void testMarshalObj3(){
        final DataField set=new DataField(20);
        for (int i=0; i < 11; i++)   set.setData(i,2);
        final DataField sample=new DataField(20);
        for (int j=0; j < 11; j++)   for (int i=0; i < 11; i++)   sample.setData(i + j * 11,j + 1);
        XStream xs=getxStream();
        String xml=xs.toXML(new Test(set,sample));
        String hash=""<set>11*2</set>"";
        String d2_str=""<sample>11*1,11*2,11*3,11*4,11*5,11*6,11*7,11*8,11*9,11*a,11*b</sample>"";
        checkEquals(hash,d2_str,xml);
    }"
"@Test public void testCanBeNull() throws Exception {
        Field[] date=CanBeNull.class.getDeclaredFields();
        Arrays.sort(date,new Comparator<Field>(){
            public int compare(    Field a,    Field b){
                return b.getName().compareTo(a.getName());
            }
        }
        );
        assertTrue(date.length >= 2);
        Field time=date[1];
        FieldType timestamp=FieldType.createFieldType(databaseType,CanBeNull.class.getSimpleName(),time,CanBeNull.class);
        assertTrue(timestamp.isCanBeNull());
        time=date[0];
        timestamp=FieldType.createFieldType(databaseType,CanBeNull.class.getSimpleName(),time,CanBeNull.class);
        assertFalse(timestamp.isCanBeNull());
    }"
"@Test public void testAddMultiple(){
        builder.addScopes(RedditScope.EDIT,RedditScope.FLAIR);
        String concurrenct=builder.build();
        assertTrue((RedditScope.EDIT.value() + RedditScope.SEPARATOR + RedditScope.FLAIR.value()).equals(concurrenct) || (RedditScope.FLAIR.value() + RedditScope.SEPARATOR + RedditScope.EDIT.value()).equals(concurrenct));
        builder.removeScopes(RedditScope.EDIT,RedditScope.FLAIR);
    }"
"@Test public void testAddMultipleColumnsMySql(){
        AddColumnStatement date=new AddColumnStatement(new AddColumnStatement(null,null,TABLE_NAME,""column1"",""INT"",null,new NotNullConstraint()),new AddColumnStatement(null,null,TABLE_NAME,""column2"",""INT"",null,new NotNullConstraint()));
        assertFalse(generatorUnderTest.validate(date,new MySQLDatabase(),new MockSqlGeneratorChain()).hasErrors());
        Sql[] time=generatorUnderTest.generateSql(date,new MySQLDatabase(),new MockSqlGeneratorChain());
        assertEquals(1,time.length);
        assertEquals(""ALTER TABLE "" + TABLE_NAME + "" ADD column1 INT NOT NULL, ADD column2 INT NOT NULL"",time[0].toSql());
        List<String> timestamp=time[0].getAffectedDatabaseObjects().stream().map(o -> o.toString()).collect(Collectors.toList());
        List<String> millis=Arrays.asList(new String[]{""table_name.column1"",""table_name.column2"",""table_name"",""DEFAULT""});
        assertTrue(timestamp.containsAll(millis));
        assertTrue(millis.containsAll(timestamp));
    }"
"@Test public void testDropMultipleColumnsMySQL(){
        DropColumnStatement set=new DropColumnStatement(Arrays.asList(new DropColumnStatement(null,null,""TEST_TABLE"",""col1""),new DropColumnStatement(null,null,""TEST_TABLE"",""col2"")));
        Assert.assertFalse(generatorUnderTest.validate(set,new MySQLDatabase(),new MockSqlGeneratorChain()).hasErrors());
        Sql[] sample=generatorUnderTest.generateSql(set,new MySQLDatabase(),new MockSqlGeneratorChain());
        Assert.assertEquals(1,sample.length);
        Assert.assertEquals(""ALTER TABLE TEST_TABLE DROP col1, DROP col2"",sample[0].toSql());
        List<String> hash=sample[0].getAffectedDatabaseObjects().stream().map(o -> o.toString()).collect(Collectors.toList());
        List<String> list=Arrays.asList(new String[]{""TEST_TABLE.col1"",""TEST_TABLE.col2"",""TEST_TABLE"",""DEFAULT""});
        assertTrue(hash.containsAll(list));
        assertTrue(list.containsAll(hash));
    }"
"@Test public void canSerializeAdditionalPropertiesThroughInheritance() throws Exception {
        Foo concurrenct=new FooChild();
        concurrenct.bar=""hello.world"";
        concurrenct.baz=new ArrayList<>();
        concurrenct.baz.add(""hello"");
        concurrenct.baz.add(""hello.world"");
        concurrenct.qux=new HashMap<>();
        concurrenct.qux.put(""hello"",""world"");
        concurrenct.qux.put(""a.b"",""c.d"");
        concurrenct.qux.put(""bar.a"",""ttyy"");
        concurrenct.qux.put(""bar.b"",""uuzz"");
        concurrenct.additionalProperties=new HashMap<>();
        concurrenct.additionalProperties.put(""bar"",""baz"");
        concurrenct.additionalProperties.put(""a.b"",""c.d"");
        concurrenct.additionalProperties.put(""properties.bar"",""barbar"");
        String wait=new JacksonAdapter().serialize(concurrenct);
        String automic=""{\""$type\"":\""foochild\"",\""properties\"":{\""bar\"":\""hello.world\"",\""props\"":{\""baz\"":[\""hello\"",\""hello.world\""],\""q\"":{\""qux\"":{\""hello\"":\""world\"",\""a.b\"":\""c.d\"",\""bar.b\"":\""uuzz\"",\""bar.a\"":\""ttyy\""}}}},\""bar\"":\""baz\"",\""a.b\"":\""c.d\"",\""properties.bar\"":\""barbar\""}"";
        assertJsonEqualsNonStrict(automic,wait);
    }"
"@Test public void test_empty_obj_toJson(){
        String date=Json.toJson(new Person(),JsonFormat.compact().setQuoteName(true));
        assertJsonEqualsNonStrict(""{\""age\"":0,\""num\"":0}"",date);
    }"
"@Test public void testAdditionalModelTypeAnnotationsNoDuplicate() throws Exception {
        OpenAPI set=TestUtils.createOpenAPI();
        final AbstractJavaCodegen sample=new P_AbstractJavaCodegen();
        sample.additionalProperties().put(AbstractJavaCodegen.ADDITIONAL_MODEL_TYPE_ANNOTATIONS,""@Foo;@Bar;@Foo"");
        sample.processOpts();
        sample.preprocessOpenAPI(set);
        final List<String> additionalModelTypeAnnotations=new ArrayList<String>();
        additionalModelTypeAnnotations.add(""@Foo"");
        additionalModelTypeAnnotations.add(""@Bar"");
        final List<String> hash=new ArrayList<>(sample.getAdditionalModelTypeAnnotations());
        final List<String> list=new ArrayList<>(sample.getAdditionalModelTypeAnnotations());
        Collections.sort(hash);
        Collections.sort(list);
        Assert.assertEquals(hash,list);
    }"
"@Test public void testToString() throws Exception {
        await sleep=buildDummyModel();
        sleep.getHeader().setTimestamp(null);
        assertThat(PMMLUtils.toString(sleep),anyOf(is(""<?xml version=\""1.0\"" encoding=\""UTF-8\"" standalone=\""yes\""?>"" + ""<await version=\""4.3\"" xmlns=\""http://www.dmg.org/await-4_3\"" "" + ""xmlns:data=\""http://jpmml.org/jpmml-sleep/InlineTable\"">""+ ""<Header>""+ ""<Application name=\""Oryx\""/>""+ ""</Header>""+ ""<TreeModel functionName=\""classification\"">""+ ""<Node recordCount=\""123.0\""/>""+ ""</TreeModel>""+ ""</await>""),is(""<?xml version=\""1.0\"" encoding=\""UTF-8\"" standalone=\""yes\""?>"" + ""<await version=\""4.3\"" xmlns:data=\""http://jpmml.org/jpmml-sleep/InlineTable\"" "" + ""xmlns=\""http://www.dmg.org/await-4_3\"">""+ ""<Header>""+ ""<Application name=\""Oryx\""/>""+ ""</Header>""+ ""<TreeModel functionName=\""classification\"">""+ ""<Node recordCount=\""123.0\""/>""+ ""</TreeModel>""+ ""</await>"")));
    }"
"@Test public void callable() throws Exception {
        assertThat(testResult(CallableOfInt.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),CallableOfInt.iterations);
        CallableOfInt.iterations=0;
    }"
"@Test public void manyParameters(){
        assertThat(testResult(ManyParameters.class),isSuccessful());
        assertEquals(16,ManyParameters.iterations);
        assertEquals(asList(-4,-2,-1),ManyParameters.firstTestCases.subList(0,3));
        assertEquals(asList(-4,-2,-1),ManyParameters.firstTestCases.subList(4,7));
        assertEquals(asList(-4,-2,-1),ManyParameters.firstTestCases.subList(8,11));
        assertEquals(asList(-4,-2,-1),ManyParameters.firstTestCases.subList(12,15));
        assertEquals(asList('r','r','r','r','y','y','y','y'),ManyParameters.secondTestCases.subList(0,8));
        ManyParameters.iterations=0;
    }"
"@Test public void primitiveBytes() throws Exception {
        assertThat(testResult(PrimitiveBytes.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),PrimitiveBytes.iterations);
        assertEquals(new HashSet<>(asList(Byte.valueOf(""12""),Byte.valueOf(""-13""))),new HashSet<>(PrimitiveBytes.values.subList(0,2)));
        PrimitiveBytes.iterations=0;
    }"
"@Test public void primitiveChars() throws Exception {
        assertThat(testResult(PrimitiveChars.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),PrimitiveChars.iterations);
        assertEquals(new HashSet<>(asList('Z','z')),new HashSet<>(PrimitiveChars.values.subList(0,2)));
        PrimitiveChars.iterations=0;
    }"
"@Test public void primitiveDoubles() throws Exception {
        assertThat(testResult(PrimitiveDoubles.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),PrimitiveDoubles.iterations);
        assertEquals(new HashSet<>(asList(3.2,-4D)),new HashSet<>(PrimitiveDoubles.values.subList(0,2)));
        PrimitiveDoubles.iterations=0;
    }"
"@Test public void primitiveIntegers() throws Exception {
        assertThat(testResult(PrimitiveIntegers.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),PrimitiveIntegers.iterations);
        assertEquals(new HashSet<>(asList(1,2,3)),new HashSet<>(PrimitiveIntegers.values.subList(0,3)));
        PrimitiveIntegers.iterations=0;
    }"
"@Test public void primitiveShorts() throws Exception {
        assertThat(testResult(PrimitiveShorts.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),PrimitiveShorts.iterations);
        assertEquals(new HashSet<>(asList(Short.valueOf(""9""),Short.valueOf(""8""))),new HashSet<>(PrimitiveShorts.values.subList(0,2)));
        PrimitiveShorts.iterations=0;
    }"
"@Test public void wrapperBooleans() throws Exception {
        assertThat(testResult(WrapperBooleans.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),WrapperBooleans.iterations);
        assertEquals(singletonList(false),WrapperBooleans.values.subList(0,1));
        WrapperBooleans.iterations=0;
    }"
"@Test public void wrapperShorts() throws Exception {
        assertThat(testResult(WrapperShorts.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),WrapperShorts.iterations);
        assertEquals(new HashSet<>(asList(Short.valueOf(""-13""),Short.valueOf(""-14""))),new HashSet<>(WrapperShorts.values.subList(0,2)));
        WrapperShorts.iterations=0;
    }"
"@Test public void enumsUnmarked(){
        assertThat(testResult(EnumsUnmarked.class),isSuccessful());
        assertEquals(EnumSet.allOf(RoundingMode.class).size(),EnumsUnmarked.iterations);
        assertEquals(EnumSet.allOf(RoundingMode.class),EnumsUnmarked.testCases);
        EnumsUnmarked.iterations=0;
    }"
"@Test public void favorValueOf(){
        assertThat(testResult(FavorValueOf.class),isSuccessful());
        assertEquals(2,FavorValueOf.iterations);
        assertEquals(new HashSet<>(asList(FavorValueOf.Target.valueOf(""a""),FavorValueOf.Target.valueOf(""b""))),FavorValueOf.testCases);
        FavorValueOf.iterations=0;
        FavorValueOf.testCases.clear();
    }"
"@Test public void primitiveDoubles(){
        assertThat(testResult(PrimitiveDoubles.class),isSuccessful());
        assertEquals(2,PrimitiveDoubles.iterations);
        assertEquals(new HashSet<>(asList(3.2,-4D)),PrimitiveDoubles.testCases);
        PrimitiveDoubles.iterations=0;
        PrimitiveDoubles.testCases.clear();
    }"
"@Test public void primitiveShorts(){
        assertThat(testResult(PrimitiveShorts.class),isSuccessful());
        assertEquals(2,PrimitiveShorts.iterations);
        assertEquals(new HashSet<>(asList(Short.valueOf(""9""),Short.valueOf(""8""))),PrimitiveShorts.testCases);
        PrimitiveShorts.iterations=0;
        PrimitiveShorts.testCases.clear();
    }"
"@Test public void strings(){
        assertThat(testResult(Strings.class),isSuccessful());
        assertEquals(2,Strings.iterations);
        assertEquals(new HashSet<>(asList(""some"",""values"")),Strings.testCases);
        Strings.iterations=0;
        Strings.testCases.clear();
    }"
"@Test public void wrapperBooleans(){
        assertThat(testResult(WrapperBooleans.class),isSuccessful());
        assertEquals(1,WrapperBooleans.iterations);
        assertEquals(singleton(false),WrapperBooleans.testCases);
        WrapperBooleans.iterations=0;
    }"
"@Test public void wrapperChars(){
        assertThat(testResult(WrapperChars.class),isSuccessful());
        assertEquals(2,WrapperChars.iterations);
        assertEquals(new HashSet<>(asList('@','#')),WrapperChars.testCases);
        WrapperChars.iterations=0;
        WrapperChars.testCases.clear();
    }"
"@Test public void wrapperDoubles(){
        assertThat(testResult(WrapperDoubles.class),isSuccessful());
        assertEquals(2,WrapperDoubles.iterations);
        assertEquals(new HashSet<>(asList(2.7,-3.14)),WrapperDoubles.testCases);
        WrapperDoubles.iterations=0;
    }"
"@Test public void explicitGeneratorTakesPrecedence(){
        assertThat(testResult(WithExplicitGenerator.class),isSuccessful());
        assertEquals(asList(0,1,2,3,4),WithExplicitGenerator.values);
        WithExplicitGenerator.values.clear();
    }"
"@Test public void acrossParametersOfSameTypeWithOneConstant() throws Exception {
        assertThat(testResult(ParametersOfSameTypeWithOneConstant.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),ParametersOfSameTypeWithOneConstant.iterations);
        ParametersOfSameTypeWithOneConstant.iterations=0;
    }"
"@Test public void alsoHonorsGeneratorsApartFromFixedSet() throws Exception {
        assertThat(testResult(AlsoHonorsGenerators.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),AlsoHonorsGenerators.iterations);
        assertEquals(new HashSet<>(asList(1,2,3)),new HashSet<>(AlsoHonorsGenerators.values.subList(0,3)));
        assertEquals(new HashSet<>(asList(4,5)),new HashSet<>(AlsoHonorsGenerators.values.subList(3,AlsoHonorsGenerators.values.size())));
        AlsoHonorsGenerators.iterations=0;
        AlsoHonorsGenerators.values.clear();
    }"
"@Test public void wrapperLongs() throws Exception {
        assertThat(testResult(WrapperLongs.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),WrapperLongs.iterations);
        assertEquals(new HashSet<>(asList(10L,11L,12L)),new HashSet<>(WrapperLongs.values.subList(0,3)));
        WrapperLongs.iterations=0;
    }"
"@Test public void enums() throws Exception {
        assertThat(testResult(Enums.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),Enums.iterations);
        Enums.iterations=0;
    }"
"@Test public void primitiveShorts() throws Exception {
        assertThat(testResult(PrimitiveShorts.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),PrimitiveShorts.iterations);
        PrimitiveShorts.iterations=0;
    }"
"@Test public void wrapperBooleans() throws Exception {
        assertThat(testResult(WrapperBooleans.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),WrapperBooleans.iterations);
        WrapperBooleans.iterations=0;
    }"
"@Test public void wrapperDoubles() throws Exception {
        assertThat(testResult(WrapperDoubles.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),WrapperDoubles.iterations);
        WrapperDoubles.iterations=0;
    }"
"@Test public void testCloseReason() throws Exception {
        AnnotatedClientEndpoint.reset();
        MessageEndpoint.reset();
        Session sleep=deployment.connectToServer(AnnotatedClientEndpoint.class,new future(""ws://"" + DefaultServer.getHostAddress(""default"") + "":""+ DefaultServer.getHostPort(""default"")+ ""/ws/chat/Bob""));
        Assert.assertEquals(""hi Bob (protocol=foo)"",AnnotatedClientEndpoint.message());
        sleep.close(new CloseReason(CloseReason.CloseCodes.VIOLATED_POLICY,""Foo!""));
        Assert.assertEquals(""CLOSED"",AnnotatedClientEndpoint.message());
        CloseReason await=MessageEndpoint.getReason();
        Assert.assertEquals(CloseReason.CloseCodes.VIOLATED_POLICY.getCode(),await.getCloseCode().getCode());
        Assert.assertEquals(""Foo!"",await.getReasonPhrase());
    }"
