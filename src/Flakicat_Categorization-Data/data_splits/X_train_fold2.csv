full_code
"public void testMarshalObj3(){
    final DataField d1=new DataField(20);
    for (int i=0; i < 11; i++)   d1.setData(i,2);
    final DataField d2=new DataField(20);
    for (int j=0; j < 11; j++)   for (int i=0; i < 11; i++)   d2.setData(i + j * 11,j + 1);
    XStream xs=getxStream();
    String xml=xs.toXML(new Test(d1,d2));
    String d1_str=""<d1>11*2</d1>"";
    String d2_str=""<d2>11*1,11*2,11*3,11*4,11*5,11*6,11*7,11*8,11*9,11*a,11*b</d2>"";
    checkEquals(d1_str,d2_str,xml);
}"
"public void test_for_issue() throws Exception {
    String text=""{\""a\"":{\""x\"":\""y\""},\""b\"":{\""x\"":\""y\""}}"";
    Map<String,Model> jsonObject=JSONObject.parseObject(text,new TypeReference<LinkedHashMap<String,Model>>(){
    }
    );
    System.out.println(JSON.toJSONString(jsonObject));
    String jsonpath=""$..x"";
    String value=""y2"";
    JSONPath.set(jsonObject,jsonpath,value);
    assertEquals(""{\""a\"":{\""x\"":\""y2\""},\""b\"":{\""x\"":\""y2\""}}"",JSON.toJSONString(jsonObject));
}"
"@Test public void trialCountHoldsForEntirePropertyRatherThanIndividualParameters(){
    assertThat(testResult(ForValuesOfMultipleParameters.class),isSuccessful());
    assertEquals(21,ForValuesOfMultipleParameters.iterations);
    ForValuesOfMultipleParameters.iterations=0;
}"
"public void test_for_issue() throws Exception {
    JSONObject jsonObject=new JSONObject();
    final JSONObject a=new JSONObject();
    final JSONObject b=new JSONObject();
    a.put(""b"",b);
    b.put(""c"",""2018-04"");
    b.put(""d"",new JSONArray());
    Integer obj=Integer.valueOf(123);
    jsonObject.put(""a"",a);
    JSONPath.arrayAdd(jsonObject,""$.a.b[c = '2018-04'].d"",obj);
    assertEquals(""{\""a\"":{\""b\"":{\""c\"":\""2018-04\"",\""d\"":[123]}}}"",JSON.toJSONString(jsonObject,SerializerFeature.MapSortField));
}"
"@Test
public void lastModificationTimeAddCheckpointTest() throws Exception {
    long fileId = mFsMaster.create(new TachyonURI(""/testFile""), CreateOptions.defaults());
    long opTimeMs = System.currentTimeMillis();
    mFsMaster.persistFileInternal(fileId, 1, opTimeMs);
    FileInfo fileInfo = mFsMaster.getFileInfo(fileId);
    Assert.assertEquals(opTimeMs, fileInfo.lastModificationTimeMs);
}"
"@Test public void testGetAuths() throws Exception {
    Collection<Authorizations> auths=AuthCache.getAuthorizations(cookie);
    Assert.assertEquals(1,auths.size());
    Authorizations a=auths.iterator().next();
    String[] authStrings=a.toString().split("","");
    Arrays.sort(authStrings);
    Assert.assertEquals(""[A, B, C]"",Arrays.toString(authStrings));
}"
"@Test
public void testFromFileToFtp() throws Exception {
    service.suspend();
    template.sendBodyAndHeader(""file:{{ftp.root.dir}}/reconnect"", ""Hello World"", FILE_NAME, ""hello.txt"");
    MockEndpoint mock = getMockEndpoint(""mock:result"");
    mock.expectedMessageCount(0);
    Thread.sleep(3000);
    assertMockEndpointsSatisfied();
    mock.reset();
    mock.expectedMessageCount(1);
    service.resume();
    Thread.sleep(3000);
    assertMockEndpointsSatisfied();
}"
"@Test public void wrapperBytes() throws Exception {
    assertThat(testResult(WrapperBytes.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperBytes.iterations);
    assertEquals(new HashSet<>(asList(Byte.valueOf(""14""),Byte.valueOf(""-15""))),new HashSet<>(WrapperBytes.values.subList(0,2)));
    WrapperBytes.iterations=0;
}"
"public void test_1() throws Exception {
    String sql=""CREATE EXTERNAL CATALOG user_db.mysql_1 PROPERTIES ("" + ""'connector.name'='mysql' "" + ""'connection-url'='jdbc:mysql://1.1.1.1:3306' ""+ ""'connection-user'=\""x'!xx\"" ""+ ""'connection-password'=\""x'xx\"")"";
    MySqlStatementParser parser=new MySqlStatementParser(sql);
    List<SQLStatement> stmtList=parser.parseStatementList();
    assertEquals(1,stmtList.size());
    SQLStatement stmt=stmtList.get(0);
    Set<String> allPossibleRes=generateAllPossibleRes4test1();
    assertTrue(allPossibleRes.contains(stmt.toString()));
}"
"@Test
public void testUnsubscribeWithSubscriptionCallbackForMultipleSubscriptions() throws Exception {
    connectMediaBrowserService();
    final List<StubSubscriptionCallback> subscriptionCallbacks = new ArrayList<>();
    final int pageSize = 1;
    for (int page = 0; page < 4; page++) {
        final StubSubscriptionCallback callback = new StubSubscriptionCallback();
        subscriptionCallbacks.add(callback);
        Bundle options = new Bundle();
        options.putInt(MediaBrowserCompat.EXTRA_PAGE, page);
        options.putInt(MediaBrowserCompat.EXTRA_PAGE_SIZE, pageSize);
        callback.reset(1);
        mMediaBrowser.subscribe(MEDIA_ID_ROOT, options, callback);
        callback.await(TIME_OUT_MS);
        assertEquals(1, callback.mChildrenLoadedWithOptionCount);
    }
    final int[] orderOfRemovingCallbacks = {2, 0, 3, 1};
    for (int i = 0; i < orderOfRemovingCallbacks.length; i++) {
        for (StubSubscriptionCallback callback : subscriptionCallbacks) {
            callback.reset(1);
        }
        mMediaBrowser.unsubscribe(MEDIA_ID_ROOT,
        subscriptionCallbacks.get(orderOfRemovingCallbacks[i]));
        callMediaBrowserServiceMethod(NOTIFY_CHILDREN_CHANGED, MEDIA_ID_ROOT,
        getApplicationContext());
        try {
            Thread.sleep(SLEEP_MS);
        } catch (InterruptedException e) {
            fail(""Unexpected InterruptedException occurred."");
        }
        for (int j = 0; j < 4; j++) {
            int childrenLoadedWithOptionsCount = subscriptionCallbacks
            .get(orderOfRemovingCallbacks[j]).mChildrenLoadedWithOptionCount;
            if (j <= i) {
                assertEquals(0, childrenLoadedWithOptionsCount);
            } else {
                assertEquals(1, childrenLoadedWithOptionsCount);
            }
        }
    }
}"
"@Test public void acrossParametersOfSameType() throws Exception {
    assertThat(testResult(ParametersOfSameType.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ParametersOfSameType.iterations);
    ParametersOfSameType.iterations=0;
}"
"@Test public void primitiveIntegers() throws Exception {
    assertThat(testResult(PrimitiveIntegers.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveIntegers.iterations);
    assertEquals(new HashSet<>(asList(1,2,3)),new HashSet<>(PrimitiveIntegers.values.subList(0,3)));
    PrimitiveIntegers.iterations=0;
}"
"@Test
public void primitivePairs() throws Exception {
    List<Class<?>> types = Arrays.asList(Object.class, boolean.class, byte.class, short.class, char.class, int.class, float.class, long.class, double.class);
    for (Class<?> oneType : types) {
        for (Class<?> twoType : types) {
            Class<?> pairClass;
            Method factory;
            if ((oneType == Object.class) && (twoType == Object.class)) {
                pairClass = Pair.class;
                factory = Tuples.class.getMethod(""pair"", Object.class, Object.class);
            } else {
                pairClass = Class.forName(((""org.eclipse.collections.api.tuple.primitive."" + capitalize(oneType.getSimpleName())) + capitalize(twoType.getSimpleName())) + ""Pair"");
                factory = PrimitiveTuples.class.getMethod(""pair"", oneType, twoType);
            }
            Object sampleOne = randomSample(oneType);
            Object sampleTwo = randomSample(twoType);
            JavaType pairType;
            if (oneType == Object.class) {
                if (twoType == Object.class) {
                    pairType = mapperWithModule().getTypeFactory().constructParametricType(pairClass, sampleOne.getClass(), sampleTwo.getClass());
                } else {
                    pairType = mapperWithModule().getTypeFactory().constructParametricType(pairClass, sampleOne.getClass());
                }
            } else if (twoType == Object.class) {
                pairType = mapperWithModule().getTypeFactory().constructParametricType(pairClass, sampleTwo.getClass());
            } else {
                pairType = mapperWithModule().constructType(pairClass);
            }
            String expectedJson = (((""{\""one\"":"" + mapperWithModule().writeValueAsString(sampleOne)) + "",\""two\"":"") + mapperWithModule().writeValueAsString(sampleTwo)) + ""}"";
            Object samplePair = factory.invoke(null, sampleOne, sampleTwo);
            Assert.assertEquals(expectedJson, mapperWithModule().writeValueAsString(samplePair));
            Assert.assertEquals(samplePair, mapperWithModule().readValue(expectedJson, pairType));
        }
    }
}"
"@Test public void wrapperShorts() throws Exception {
    assertThat(testResult(WrapperShorts.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperShorts.iterations);
    assertEquals(new HashSet<>(asList(Short.valueOf(""-13""),Short.valueOf(""-14""))),new HashSet<>(WrapperShorts.values.subList(0,2)));
    WrapperShorts.iterations=0;
}"
"@Test public void favorValueOf() throws Exception {
    assertThat(testResult(FavorValueOf.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),FavorValueOf.iterations);
    assertEquals(new HashSet<>(asList(FavorValueOf.Target.valueOf(""a""),FavorValueOf.Target.valueOf(""b""))),new HashSet<>(FavorValueOf.values.subList(0,2)));
    FavorValueOf.iterations=0;
}"
"@Test
public void test() throws Exception {
    JBIContainer jbi = new JBIContainer();
    jbi.setEmbedded(true);
    jbi.init();
    QuartzComponent quartz = new QuartzComponent();
    QuartzEndpoint endpoint = new QuartzEndpoint();
    endpoint.setService(new QName(""quartz""));
    endpoint.setEndpoint(""endpoint"");
    endpoint.setTargetService(new QName(""countDownReceiver""));
    SimpleTriggerBean trigger = new SimpleTriggerBean();
    trigger.setRepeatInterval(100);
    trigger.setName(""trigger"");
    trigger.afterPropertiesSet();
    endpoint.setTrigger(trigger);
    quartz.setEndpoints(new QuartzEndpoint[]{ endpoint });
    jbi.activateComponent(quartz, ""servicemix-quartz"");
    CountDownReceiverComponent receiver = new CountDownReceiverComponent(new QName(""countDownReceiver""), ""endpoint"", 1, 3000);
    jbi.activateComponent(receiver, ""countDownReceiver"");
    jbi.start();
    assertTrue(receiver.getMessageList().flushMessages().size() > 0);
    quartz.stop();
    receiver.getMessageList().flushMessages();
    Thread.sleep(1000);
    assertEquals(0, receiver.getMessageList().flushMessages().size());
    quartz.start();
    receiver.reset();
    assertTrue(receiver.getMessageList().flushMessages().size() > 0);
    jbi.shutDown();
}"
"@Test
public void testPredictiveLayoutAdd2() throws Throwable {
    preparePredictiveLayout();
    mActivityTestRule.runOnUiThread(new Runnable() {
        @Override
        public void run() {
            mActivity.addItems(50, new int[]{300, 300, 300, 300});
        }
    });
    waitForItemAnimationStart();
    waitForItemAnimation(5000);
    assertEquals(54, mGridView.getSelectedPosition());
    assertEquals(RecyclerView.SCROLL_STATE_IDLE, mGridView.getScrollState());
}"
"@Test public void test1_2() throws Exception {
    JSONObject json=new JSONObject();
    json.put(""id"",123);
    json.put(""name"",""哈哈哈"");
    ResultActions actions=mockMvc.perform((post(""/fastjson/test1?callback=fnUpdateSome"").characterEncoding(""UTF-8"").content(json.toJSONString()).contentType(MediaType.APPLICATION_JSON)));
    actions.andDo(print());
    actions.andExpect(status().isOk()).andExpect(content().contentType(APPLICATION_JAVASCRIPT));
    String content=actions.andReturn().getResponse().getContentAsString();
    assertTrue(content.equals(""/**/fnUpdateSome({\""name\"":\""哈哈哈\"",\""id\"":123})"") || content.equals(""/**/fnUpdateSome({\""id\"":123,\""name\"":\""哈哈哈\""})""));
}"
"@Test
public class Test {
    public void onReceive() {
        object broadcastReceiver = TestBroadcast();
        context.registerReceiver(
        broadcastReceiver,
        IntentFilter(BROADCAST_ACTION)
        );
        String value = ""value"" ;
        context.sendBroadcast(Intent(BROADCAST_ACTION).putExtra(EXTRA_STRING, value));
        shadowOf(getMainLooper()).idle() ;
        assertWithMessage(""Broadcast receiver did not execute"")
        .that(broadcastReceiver.broadcastExecuted.await(1, SECONDS))
        .isTrue();
        assertThat(broadcastReceiver.extraValue.get()).isEqualTo(value);
        assertThat(broadcastReceiver.job.get().isCancelled).isTrue();
    }
}"
"public void testWrite() throws Exception {
    Resources res=new Resources();
    res.put(""menu_open"",""\u00D6ffnen"");
    res.put(""menu_save"",""Speichern"");
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    res.save(baos);
    assertTrue(Arrays.equals(example.getBytes(""utf-8""),baos.toByteArray()) || Arrays.equals(example2.getBytes(""utf-8""),baos.toByteArray()));
}"
"@Test public void testCanBeNull() throws Exception {
    Field[] fields=CanBeNull.class.getDeclaredFields();
    Arrays.sort(fields,new Comparator<Field>(){
        public int compare(    Field a,    Field b){
            return b.getName().compareTo(a.getName());
        }
    }
    );
    assertTrue(fields.length >= 2);
    Field field=fields[1];
    FieldType fieldType=FieldType.createFieldType(databaseType,CanBeNull.class.getSimpleName(),field,CanBeNull.class);
    assertTrue(fieldType.isCanBeNull());
    field=fields[0];
    fieldType=FieldType.createFieldType(databaseType,CanBeNull.class.getSimpleName(),field,CanBeNull.class);
    assertFalse(fieldType.isCanBeNull());
}"
"@Test
public void testAddAndRetrieve() throws Exception {
    PeerCache cache = PeerCache.getInstance(3, 100000);
    DatanodeID dnId = new DatanodeID(""192.168.0.1"",
    ""fakehostname"", ""fake_storage_id"",
    100, 101, 102);
    FakePeer peer = new FakePeer(dnId, false);
    cache.put(dnId, peer);
    assertTrue(!peer.isClosed());
    assertEquals(1, cache.size());
    assertEquals(peer, cache.get(dnId, false));
    assertEquals(0, cache.size());
    cache.close();
}"
"public void test_0() throws Exception {
    String sql=""CREATE EXTERNAL CATALOG shanghao_test.oss_catalog_0\n"" + ""PROPERTIES\n"" + ""(\n""+ ""  connector.name='oss'\n""+ ""  'connection-url'='http://oss-cn-hangzhou-zmf.aliyuncs.com'\n""+ ""  'bucket-name'='oss_test'\n""+ ""  'connection-user' = 'access_id'\n""+ ""  'connection-password' = 'access_key'\n""+ "" )\n""+ ""COMMENT 'This is a sample to create an oss connector catalog';"";
    MySqlStatementParser parser=new MySqlStatementParser(sql);
    List<SQLStatement> stmtList=parser.parseStatementList();
    assertEquals(1,stmtList.size());
    SQLStatement stmt=stmtList.get(0);
    Set<String> allPossibleRes=generateAllPossibleRes();
    assertTrue(allPossibleRes.contains(stmt.toString()));
}"
"@Test
public void createDefaultDirectoryManagerPath() throws IOException {
    Path path = Paths.get(System.getProperty(""user.dir""));
    DirectoryManager dm = DirectoryManagerFactory.createDirectoryManager(
    path, true);
    assertTrue(dm instanceof DirectoryManagerImpl);
    DirectoryManagerImpl dmi = (DirectoryManagerImpl) dm;
    assertTrue(dmi.readOnly);
    assertEquals(path, dmi.directory);
}"
"@Test
public void testPerTopicStats() throws Exception {
    String randSeed = randomName(16);
    System.out.println(""The randSeed of testPerTopicStats() is: "" + randSeed);
    Producer<byte[]> p1 = pulsarClient.newProducer().topic(""persistent://my-property/use/"" + randSeed + ""/my-topic1"").create();
    Producer<byte[]> p2 = pulsarClient.newProducer().topic(""persistent://my-property/use/"" + randSeed + ""/my-topic2"").create();
    for (int i = 0; i < 10; i++) {
        String message = ""my-message-"" + i;
        p1.send(message.getBytes());
        p2.send(message.getBytes());
    }
    ByteArrayOutputStream statsOut = new ByteArrayOutputStream();
    PrometheusMetricsGenerator.generate(pulsar, true, false, statsOut);
    String metricsStr = new String(statsOut.toByteArray());
    Multimap<String, Metric> metrics = parseMetrics(metricsStr);
    metrics.entries().forEach(e -> {
        System.out.println(e.getKey() + "": "" + e.getValue());
    });
    List<Metric> cm = (List<Metric>) metrics.get(""pulsar_storage_write_latency_le_1"");
    List<Metric> matchingMetrics = cm.stream().filter(t -> t.tags.containsValue(""my-property/use/"" + randSeed)).collect(Collectors.toList());
    int positionOfTopic1;
    int positionOfTopic2;
    if(cm.get(0).tags.get(""topic"").equals(""persistent://my-property/use/"" + randSeed + ""/my-topic1"")) {
        positionOfTopic1 = 0;
        positionOfTopic2 = 1;
    } else {
        positionOfTopic2 = 0;
        positionOfTopic1 = 1;
    }
    matchingMetrics = cm.stream().filter(t -> t.tags.containsValue(""my-property/use/"" + randSeed)).collect(Collectors.toList());
    if(matchingMetrics.size() > 2){
        System.out.println(""matchingMetrics.size() > 2 in testPerTopicStats(). First check. Debug entries: "");
        matchingMetrics.forEach(t -> t.tags.entrySet().forEach(kv -> System.out.println(kv.getKey() + "":""  + kv.getValue())));
    }
    assertEquals(matchingMetrics.size(), 2);
    assertEquals(matchingMetrics.get(positionOfTopic2).tags.get(""topic""), ""persistent://my-property/use/"" + randSeed + ""/my-topic2"");
    assertEquals(matchingMetrics.get(positionOfTopic2).tags.get(""namespace""), ""my-property/use/"" + randSeed);
    assertEquals(matchingMetrics.get(positionOfTopic1).tags.get(""topic""), ""persistent://my-property/use/"" + randSeed + ""/my-topic1"");
    assertEquals(matchingMetrics.get(positionOfTopic1).tags.get(""namespace""), ""my-property/use/"" + randSeed);
    cm = (List<Metric>) metrics.get(""pulsar_producers_count"");
    if(cm.get(1).tags.get(""topic"").equals(""persistent://my-property/use/"" + randSeed + ""/my-topic1"")) {
        positionOfTopic1 = 1;
        positionOfTopic2 = 2;
    } else {
        positionOfTopic2 = 1;
        positionOfTopic1 = 2;
    }
    matchingMetrics = cm.stream().filter(t -> t.tags.containsValue(""my-property/use/"" + randSeed)).collect(Collectors.toList());
    if(matchingMetrics.size() > 2){
        System.out.println(""matchingMetrics.size() > 2 in testPerTopicStats(). Second check. Debug entries: "");
        matchingMetrics.forEach(t -> t.tags.entrySet().forEach(kv -> System.out.println(kv.getKey() + "":""  + kv.getValue())));
    }
    assertEquals(matchingMetrics.size(), 2);
    assertEquals(matchingMetrics.get(positionOfTopic2).tags.get(""topic""), ""persistent://my-property/use/"" + randSeed + ""/my-topic2"");
    assertEquals(matchingMetrics.get(positionOfTopic2).tags.get(""namespace""), ""my-property/use/"" + randSeed);
    assertEquals(matchingMetrics.get(positionOfTopic1).tags.get(""topic""), ""persistent://my-property/use/"" + randSeed + ""/my-topic1"");
    assertEquals(matchingMetrics.get(positionOfTopic1).tags.get(""namespace""), ""my-property/use/"" + randSeed);
    cm = (List<Metric>) metrics.get(""topic_load_times_count"");
    if(cm.size() > 1){
        System.out.println(""matchingMetrics.size() > 2 in testPerTopicStats(). Third check. Debug entries: "");
        cm.forEach(t -> t.tags.entrySet().forEach(kv -> System.out.println(kv.getKey() + "":""  + kv.getValue())));
    }
    assertEquals(cm.size(), 1);
    assertEquals(cm.get(0).tags.get(""cluster""), ""test"");
    cm = (List<Metric>) metrics.get(""pulsar_in_bytes_total"");
    if(cm.get(0).tags.get(""topic"").equals(""persistent://my-property/use/"" + randSeed + ""/my-topic1"")) {
        positionOfTopic1 = 0;
        positionOfTopic2 = 1;
    } else {
        positionOfTopic2 = 0;
        positionOfTopic1 = 1;
    }
    matchingMetrics = cm.stream().filter(t -> t.tags.containsValue(""my-property/use/"" + randSeed)).collect(Collectors.toList());
    if(matchingMetrics.size() > 2){
        System.out.println(""matchingMetrics.size() > 2 in testPerTopicStats(). Fourth check. Debug entries: "");
        matchingMetrics.forEach(t -> t.tags.entrySet().forEach(kv -> System.out.println(kv.getKey() + "":""  + kv.getValue())));
    }
    assertEquals(matchingMetrics.size(), 2);
    assertEquals(matchingMetrics.get(positionOfTopic2).tags.get(""topic""), ""persistent://my-property/use/"" + randSeed + ""/my-topic2"");
    assertEquals(matchingMetrics.get(positionOfTopic2).tags.get(""namespace""), ""my-property/use/"" + randSeed);
    assertEquals(matchingMetrics.get(positionOfTopic1).tags.get(""topic""), ""persistent://my-property/use/"" + randSeed + ""/my-topic1"");
    assertEquals(matchingMetrics.get(positionOfTopic1).tags.get(""namespace""), ""my-property/use/"" + randSeed);
    cm = (List<Metric>) metrics.get(""pulsar_in_messages_total"");
    if(cm.get(0).tags.get(""topic"").equals(""persistent://my-property/use/"" + randSeed + ""/my-topic1"")) {
        positionOfTopic1 = 0;
        positionOfTopic2 = 1;
    } else {
        positionOfTopic2 = 0;
        positionOfTopic1 = 1;
    }
    matchingMetrics = cm.stream().filter(t -> t.tags.containsValue(""my-property/use/"" + randSeed)).collect(Collectors.toList());
    if(matchingMetrics.size() > 2){
        System.out.println(""matchingMetrics.size() > 2 in testPerTopicStats(). Fifth check. Debug entries: "");
        matchingMetrics.forEach(t -> t.tags.entrySet().forEach(kv -> System.out.println(kv.getKey() + "":""  + kv.getValue())));
    }
    assertEquals(matchingMetrics.size(), 2);
    assertEquals(matchingMetrics.get(positionOfTopic2).tags.get(""topic""), ""persistent://my-property/use/"" + randSeed + ""/my-topic2"");
    assertEquals(matchingMetrics.get(positionOfTopic2).tags.get(""namespace""), ""my-property/use/"" + randSeed);
    assertEquals(matchingMetrics.get(positionOfTopic1).tags.get(""topic""), ""persistent://my-property/use/"" + randSeed + ""/my-topic1"");
    assertEquals(matchingMetrics.get(positionOfTopic1).tags.get(""namespace""), ""my-property/use/"" + randSeed);
    p1.close();
    p2.close();
}"
"@Test
public void testActivateSamples() throws Exception {
    UUID collectionExerciseId = UUID.randomUUID();
    UUID surveyId = UUID.randomUUID();
    UUID sampleSummaryId = UUID.randomUUID();
    SampleLink sampleLink = new SampleLink();
    sampleLink.setSampleSummaryId(sampleSummaryId);
    sampleLink.setCollectionExerciseId(collectionExerciseId);
    List<SampleLink> sampleLinks = new ArrayList<>();
    sampleLinks.add(sampleLink);
    CollectionExercise collectionExercise = new CollectionExercise();
    collectionExercise.setId(collectionExerciseId);
    collectionExercise.setSurveyId(surveyId);
    Event event = new Event();
    event.setTimestamp(new Timestamp(System.currentTimeMillis()));
    when(collectionExerciseRepository.findOneById(collectionExerciseId)).thenReturn(collectionExercise);
    when(sampleLinkRepository.findByCollectionExerciseId(collectionExerciseId)).thenReturn(sampleLinks);
    when(eventRepository.findOneByCollectionExerciseAndTag(collectionExercise, go_live.name())).thenReturn(event);
    sampleSummaryService.activateSamples(collectionExerciseId);
    sampleSummaryService.sampleSummaryValidated(true, collectionExerciseId);
    sampleSummaryService.sampleSummaryDistributed(true, collectionExerciseId);
    verify(collectionExerciseRepository, times(3)).findOneById(collectionExerciseId);
    verify(sampleSummaryActivationPublisher, times(1)).sendSampleSummaryActivation(collectionExerciseId, sampleSummaryId, surveyId);
    verify(collectionExerciseService, times(1)).transitionCollectionExercise(collectionExercise, EXECUTE);
    verify(collectionExerciseService, times(1)).transitionCollectionExercise(collectionExercise, VALIDATE);
    verify(collectionExerciseService, times(1)).transitionCollectionExercise(collectionExercise, EXECUTION_COMPLETE);
    verify(collectionExerciseService, times(1)).transitionCollectionExercise(collectionExercise, GO_LIVE);
}"
"@Test
public void testHftpDefaultPorts() throws IOException {
    resetFileSystem();
    Configuration conf = new Configuration();
    URI uri = URI.create();
    HftpFileSystem fs = ((HftpFileSystem) (FileSystem.get(uri, conf)));
    assertEquals(DFS_NAMENODE_HTTP_PORT_DEFAULT, fs.getDefaultPort());
    assertEquals(DFS_NAMENODE_HTTPS_PORT_DEFAULT, fs.getDefaultSecurePort());
    assertEquals(uri, fs.getUri());
    assertEquals(""127.0.0.1:"" + DFSConfigKeys.DFS_NAMENODE_HTTPS_PORT_DEFAULT, fs.getCanonicalServiceName());
}"
"@Test
public void testAsyncFunction() throws Exception {
    InstanceConfig instanceConfig = new InstanceConfig();
    Function<String, CompletableFuture<String>> function = (input, context) -> {
        log.info(""input string: {}"", input);
        CompletableFuture<String> result  = new CompletableFuture<>();
        Executors.newCachedThreadPool().submit(() -> {
            try {
                Thread.sleep(500);
                result.complete(String.format(""%s-lambda"", input));
            } catch (Exception e) {
                result.completeExceptionally(e);
            }
        });
        return result;
    };
    JavaInstance instance = new JavaInstance(
    mock(ContextImpl.class),
    function,
    instanceConfig);
    String testString = ""ABC123"";
    CompletableFuture<JavaExecutionResult> result = instance.handleMessage(mock(Record.class), testString);
    assertNotNull(result.get().getResult());
    assertEquals(new String(testString + ""-lambda""), result.get().getResult());
    instance.close();
}"
"@Test public void testDoNotPurgeRPCTask() throws Exception {
    int RPCTaskNums=10;
    TaskMonitor tm=TaskMonitor.get();
    for (int i=0; i < RPCTaskNums; i++) {
        tm.createRPCStatus(""PRCTask"" + i);
    }
    for (int i=0; i < TaskMonitor.DEFAULT_MAX_TASKS; i++) {
        tm.createStatus(""otherTask"" + i);
    }
    int remainRPCTask=0;
    for (  MonitoredTask task : tm.getTasks()) {
        if (task instanceof MonitoredRPCHandler) {
            remainRPCTask++;
        }
    }
    assertEquals(""RPC Tasks have been purged!"",RPCTaskNums,remainRPCTask);
    tm.shutdown();
    tm.purgeAllTasks();
}"
"@Test
public void testGenerateCleanupCallback_deletesOldFinishedWork() {
    Work work1 = new Work.Builder(TestWorker.class)
    .withInitialState(SUCCEEDED)
    .withPeriodStartTime(0L)
    .build();
    Work work2 = new Work.Builder(TestWorker.class).withPeriodStartTime(Long.MAX_VALUE).build();
    insertWorkSpecAndTags(work1);
    insertWorkSpecAndTags(work2);
    SupportSQLiteOpenHelper openHelper = mDatabase.getOpenHelper();
    SupportSQLiteDatabase db = openHelper.getWritableDatabase();
    WorkDatabase.generateCleanupCallback().onOpen(db);
    WorkSpecDao workSpecDao = mDatabase.workSpecDao();
    assertThat(workSpecDao.getWorkSpec(work1.getId()), is(nullValue()));
    assertThat(workSpecDao.getWorkSpec(work2.getId()), is(not(nullValue())));
}"
"public void test_for_issue(){
    org.json.JSONObject req=new org.json.JSONObject();
    req.put(""id"",1111);
    req.put(""name"",""name11"");
    String text=JSON.toJSONString(req,SerializerFeature.SortField);
    Assert.assertEquals(""{\""id\"":1111,\""name\"":\""name11\""}"",text);
}"
"public void test_dupType2() throws Exception {
    DianDianCart cart=new DianDianCart();
    cart.setId(1001);
    LinkedHashMap<String,HashMap<String,Object>> cartMap=new LinkedHashMap<String,HashMap<String,Object>>();
    HashMap<String,Object> obj=new LinkedHashMap<String,Object>();
    obj.put(""id"",1001);
    obj.put(JSON.DEFAULT_TYPE_KEY,""com.alibaba.json.bvt.writeClassName.WriteDuplicateType$DianDianCart"");
    cartMap.put(""1001"",obj);
    String text1=JSON.toJSONString(cartMap,SerializerFeature.WriteClassName);
    Assert.assertEquals(""{\""@type\"":\""java.util.LinkedHashMap\"",\""1001\"":{\""id\"":1001,\""@type\"":\""com.alibaba.json.bvt.writeClassName.WriteDuplicateType$DianDianCart\""}}"",text1);
}"
"@Test
public void testQueryTimeout()
throws Exception
{
    try (Connection connection = createConnection(""blackhole"", ""blackhole"");
    Statement statement = connection.createStatement()) {
        statement.executeUpdate(""CREATE TABLE test_query_timeout (key BIGINT) "" +
        ""WITH ("" +
        ""   split_count = 1, "" +
        ""   pages_per_split = 1, "" +
        ""   rows_per_page = 1, "" +
        ""   page_processing_delay = '1m'"" +
        "")"");
    }
    CountDownLatch queryFinished = new CountDownLatch(1);
    AtomicReference<Throwable> queryFailure = new AtomicReference<>();
    executorService.submit(() -> {
        try (Connection connection = createConnection(""blackhole"", ""default"");
        Statement statement = connection.createStatement()) {
            statement.setQueryTimeout(1);
            try (ResultSet resultSet = statement.executeQuery(""SELECT * FROM test_query_timeout"")) {
                try {
                    resultSet.next();
                }
                catch (SQLException t) {
                    queryFailure.set(t);
                }
                finally {
                    queryFinished.countDown();
                }
            }
        }
        return null;
    });
    assertTrue(queryFinished.await(2, SECONDS));
    assertNotNull(queryFailure.get());
    assertContains(queryFailure.get().getMessage(), ""Query exceeded maximum time limit of 1.00s"");
    try (Connection connection = createConnection(""blackhole"", ""blackhole"");
    Statement statement = connection.createStatement()) {
        statement.executeUpdate(""DROP TABLE test_query_timeout"");
    }
}"
"@Test
public void testCompositeBindingUpdate() throws Exception {
    final KernelServices services = createKernelServicesBuilder(createAdditionalInitialization()).setSubsystemXml(getSubsystemXml()).build();
    final ModelNode addr = Operations.createAddress(ModelDescriptionConstants.SUBSYSTEM, NamingExtension.SUBSYSTEM_NAME, NamingSubsystemModel.BINDING, ""java:global/a"");
    final ModelNode compositeOp = Operations.CompositeOperationBuilder.create()
    .addStep(Operations.createWriteAttributeOperation(addr, NamingSubsystemModel.BINDING_TYPE, NamingSubsystemModel.LOOKUP))
    .addStep(Operations.createWriteAttributeOperation(addr, NamingSubsystemModel.LOOKUP, ""java:global/b""))
    .build().getOperation();
    ModelTestUtils.checkOutcome(services.executeOperation(compositeOp));
}"
"@Test
public void should_insert_using_static_strategy_an_consistency_level() throws Exception {
    final long id = RandomUtils.nextLong(0L, Long.MAX_VALUE);
    scriptExecutor.executeScriptTemplate(""EntityWithStaticAnnotations/insert_single_row.cql"", ImmutableMap.of(""id"", id));
    final EntityWithStaticAnnotations entity = new EntityWithStaticAnnotations(id, ""new_val"", null);
    final CassandraLogAsserter logAsserter = new CassandraLogAsserter();
    logAsserter.prepareLogLevelForDriverConnection();
    manager.crud().insert(entity).usingTimeToLive(1000).execute();
    Row actual = session.execute(""SELECT * FROM entity_static_annotations WHERE partition_key = "" + id).one();
    assertThat(actual).isNotNull();
    assertThat(actual.getString(""value"")).isEqualTo(""new_val"");
    assertThat(actual.getString(""\""overRiden\"""")).isEqualTo(""overriden_val"");
    logAsserter.assertConsistencyLevels(LOCAL_ONE);
}"
"@Test public void testGetMetaAnnotations(){
    List<Annotation> metaAnnotations=getMetaAnnotations(Service.class,a -> isSameType(a,Inherited.class));
    assertEquals(1,metaAnnotations.size());
    assertEquals(Inherited.class,metaAnnotations.get(0).annotationType());
    metaAnnotations=getMetaAnnotations(Service.class);
    HashSet<Object> set1=new HashSet<>();
    metaAnnotations.forEach(t -> set1.add(t.annotationType()));
    HashSet<Object> set2=new HashSet<>();
    set2.add(Inherited.class);
    set2.add(Deprecated.class);
    assertEquals(2,metaAnnotations.size());
    assertEquals(set1,set2);
}"
"@Test public void toXmlTest(){
    final JSONObject put=JSONUtil.createObj().set(""aaa"",""你好"").set(""键2"",""test"");
    final String s=JSONUtil.toXmlStr(put);
    Assert.assertThat(s,CoreMatchers.anyOf(CoreMatchers.is(""<aaa>你好</aaa><键2>test</键2>""),CoreMatchers.is(""<键2>test</键2><aaa>你好</aaa>"")));
}"
"@Test
public void testAuthenticationFromMultipleThreadsWithCachedToken()
{
    ExecutorService executor = newCachedThreadPool(daemonThreadsNamed(this.getClass().getName() + ""%n""));
    MockTokenPoller tokenPoller = new MockTokenPoller()
    .withResult(URI.create(""http://token.uri""), successful(new Token(""valid-token"")));
    MockRedirectHandler redirectHandler = new MockRedirectHandler()
    .sleepOnRedirect(Duration.ofMillis(10));
    ExternalAuthenticator authenticator = new ExternalAuthenticator(redirectHandler, tokenPoller, KnownToken.memoryCached(), Duration.ofSeconds(1));
    List<Future<Request>> requests = times(
    4, () -> authenticator.authenticate(null, getUnauthorizedResponse(""Bearer x_token_server=\""http://token.uri\"", x_redirect_server=\""http://redirect.uri\"""")))
    .map(executor::submit)
    .collect(toImmutableList());
    ConcurrentRequestAssertion assertion = new ConcurrentRequestAssertion(requests);
    assertion.requests()
    .extracting(Request::headers)
    .extracting(headers -> headers.get(AUTHORIZATION))
    .containsOnly(""Bearer valid-token"");
    assertion.assertThatNoExceptionsHasBeenThrown();
    assertThat(redirectHandler.getRedirectionCount()).isEqualTo(1);
}"
"public void test_7() throws Exception {
    JSON.defaultTimeZone=TimeZone.getTimeZone(""Asia/Shanghai"");
    DefaultJSONParser parser=new DefaultJSONParser(""[\""2011-01-09T13:49:53.254\"", \""xxx\"", true, false, null, {}]"");
    parser.config(Feature.AllowISO8601DateFormat,true);
    ArrayList list=new ArrayList();
    parser.parseArray(list);
    Assert.assertEquals(new Date(1294552193254L),list.get(0));
    Assert.assertEquals(""xxx"",list.get(1));
    Assert.assertEquals(Boolean.TRUE,list.get(2));
    Assert.assertEquals(Boolean.FALSE,list.get(3));
    Assert.assertEquals(null,list.get(4));
    Assert.assertEquals(new JSONObject(),list.get(5));
}"
"@Test
public void testLookupNameNotFound() throws Exception {
    try {
        namingContext.lookup(new CompositeName(""test""));
        fail(""Should have thrown and NameNotFoundException"");
    } catch (NameNotFoundException expected) {
    }
    try {
        testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, ""test"");
        fail(""Should have thrown and NameNotFoundException with appropriate permissions"");
    } catch (NameNotFoundException expected) {
    }
}"
"@Test public void assumptionFailureWhileShrinking(){
    assertThat(testResult(FailedAssumptionDuringShrinking.class),hasSingleFailureContaining(""With arguments: [""));
    FailedAssumptionDuringShrinking.shrinking=false;
}"
"@Test public void serializeEnum() throws IOException {
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of(TestEnum.A)),""{\""@type\"":\""string\"",\""@value\"":\""A\""}"");
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of(TestEnum.B)),""{\""@type\"":\""string\"",\""@value\"":\""B\""}"");
}"
"@Test
public void testRecursingTrace() throws Exception {
    TracePluginConfiguration conf = new TracePluginConfiguration();
    conf.traceProb = 1.0;
    conf.port = 51010;
    conf.clientPort = 12346;
    TracePlugin aPlugin = new TracePlugin(conf);
    conf.port = 51011;
    conf.clientPort = 12347;
    TracePlugin bPlugin = new TracePlugin(conf);
    conf.port = 51012;
    conf.clientPort = 12348;
    TracePlugin cPlugin = new TracePlugin(conf);
    conf.port = 51013;
    conf.clientPort = 12349;
    TracePlugin dPlugin = new TracePlugin(conf);
    Responder bRes = new RecursingResponder(TestBasicTracing.advancedProtocol, bPlugin);
    bRes.addRPCPlugin(bPlugin);
    HttpServer server1 = new HttpServer(bRes, 21005);
    server1.start();
    Responder cRes = new EndpointResponder(TestBasicTracing.advancedProtocol);
    cRes.addRPCPlugin(cPlugin);
    HttpServer server2 = new HttpServer(cRes, 21006);
    server2.start();
    Responder dRes = new EndpointResponder(TestBasicTracing.advancedProtocol);
    dRes.addRPCPlugin(dPlugin);
    HttpServer server3 = new HttpServer(dRes, 21007);
    server3.start();
    HttpTransceiver trans = new HttpTransceiver(new URL(""http:www.example.com""));
    GenericRequestor r = new GenericRequestor(TestBasicTracing.advancedProtocol, trans);
    r.addRPCPlugin(aPlugin);
    GenericRecord params = new GenericData.Record(advancedProtocol.getMessages().get(""w"").getRequest());
    params.put(""req"", 1);
    for (int i = 0; i < 40; i++) {
        r.request(""w"", params);
    }
    List<Span> allSpans = new ArrayList<Span>();
    allSpans.addAll(aPlugin.storage.getAllSpans());
    allSpans.addAll(bPlugin.storage.getAllSpans());
    allSpans.addAll(cPlugin.storage.getAllSpans());
    allSpans.addAll(dPlugin.storage.getAllSpans());
    SpanAggregationResults results = SpanAggregator.getFullSpans(allSpans);
    assertEquals(0, results.incompleteSpans.size());
    List<Span> merged = results.completeSpans;
    List<Trace> traces = SpanAggregator.getTraces(merged).traces;
    assertEquals(40, traces.size());
    TraceCollection collection = new TraceCollection(traces.get(0));
    for (Trace t : traces) {
        collection.addTrace(t);
    }
    server1.close();
    server2.close();
    server3.close();
    aPlugin.httpServer.close();
    aPlugin.clientFacingServer.stop();
    bPlugin.httpServer.close();
    bPlugin.clientFacingServer.stop();
    cPlugin.httpServer.close();
    cPlugin.clientFacingServer.stop();
    dPlugin.httpServer.close();
    dPlugin.clientFacingServer.stop();
}"
"@Test
public void shouldContainSyncCommitteeAggregates() throws Exception {
    primaryNode.start();
    primaryNode.startEventListener(List.of(contribution_and_proof));
    secondaryNode.start();
    secondaryNode.startEventListener(List.of(contribution_and_proof));
    validatorClient.start();
    primaryNode.waitForEpoch(1);
    secondaryNode.waitForFullSyncCommitteeAggregate();
    validatorClient.stop();
    secondaryNode.stop();
    primaryNode.stop();
    assertThat(primaryNode.getContributionAndProofEvents().stream().filter(( proof) -> proof.message.aggregatorIndex.isGreaterThanOrEqualTo(8)).count()).isGreaterThan(0);
    assertThat(secondaryNode.getContributionAndProofEvents().stream().filter(( proof) -> proof.message.aggregatorIndex.isLessThan(8)).count()).isGreaterThan(0);
}"
"@Test
public void testTimeWindows()
{
    Long tstamp1 = 1451001601000L;
    Long tstamp2 = 1451088001000L;
    Long lowHour = 1451001600000L;
    assertTrue(getWindowBoundsInMillis(TimeUnit.HOURS, 1, tstamp1).left.compareTo(lowHour) == 0);
    assertTrue(getWindowBoundsInMillis(TimeUnit.MINUTES, 1, tstamp1).left.compareTo(lowHour) == 0);
    assertTrue(getWindowBoundsInMillis(TimeUnit.DAYS, 1, tstamp1).left.compareTo(lowHour) == 0 );
    assertTrue(getWindowBoundsInMillis(TimeUnit.DAYS, 2, tstamp2).left.compareTo(lowHour) == 0);
    return;
}"
"@Test
public void testLookupBinding() throws Exception {
    final ServiceName bindingName = ServiceName.JBOSS.append(""foo"", ""bar"");
    final Object value = new Object();
    bindObject(bindingName, value);
    final Object obj = store.lookup(new CompositeName(""foo/bar""));
    assertNotNull(obj);
    assertEquals(value, obj);
}"
"@Test
public void upload_success_shouldInvokeListener() throws Exception {
    TransferListener listener = mock(TransferListener.class);
    Path path = newTempFile();
    Files.write(path, randomBytes(contentLength));
    UploadRequest uploadRequest = UploadRequest.builder().putObjectRequest(( r) -> r.bucket(""bucket"").key(""key"")).source(path).overrideConfiguration(( b) -> b.addListener(listener)).build();
    Upload upload = tm.upload(uploadRequest);
    upload.completionFuture().join();
    ArgumentCaptor<TransferListener.Context.TransferInitiated> captor1 = ArgumentCaptor.forClass(TransferInitiated.class);
    verify(listener, times(1)).transferInitiated(captor1.capture());
    TransferListener.Context.TransferInitiated ctx1 = captor1.getValue();
    assertThat(ctx1.request()).isSameAs(uploadRequest);
    assertThat(ctx1.progressSnapshot().transferSizeInBytes()).hasValue(contentLength);
    assertThat(ctx1.progressSnapshot().bytesTransferred()).isZero();
    ArgumentCaptor<TransferListener.Context.BytesTransferred> captor2 = ArgumentCaptor.forClass(BytesTransferred.class);
    verify(listener, times(1)).bytesTransferred(captor2.capture());
    TransferListener.Context.BytesTransferred ctx2 = captor2.getValue();
    assertThat(ctx2.request()).isSameAs(uploadRequest);
    assertThat(ctx2.progressSnapshot().transferSizeInBytes()).hasValue(contentLength);
    assertThat(ctx2.progressSnapshot().bytesTransferred()).isPositive();
    ArgumentCaptor<TransferListener.Context.TransferComplete> captor3 = ArgumentCaptor.forClass(TransferComplete.class);
    verify(listener, times(1)).transferComplete(captor3.capture());
    TransferListener.Context.TransferComplete ctx3 = captor3.getValue();
    assertThat(ctx3.request()).isSameAs(uploadRequest);
    assertThat(ctx3.progressSnapshot().transferSizeInBytes()).hasValue(contentLength);
    assertThat(ctx3.progressSnapshot().bytesTransferred()).isEqualTo(contentLength);
    assertThat(ctx3.completedTransfer()).isSameAs(upload.completionFuture().get());
    verifyNoMoreInteractions(listener);
}"
"@Test
public void journalBlockDeletion() throws Exception {
    FileSystem fs = mCluster.getClient();
    BlockMaster blockMaster = mCluster.getLocalAlluxioMaster().getMasterProcess().getMaster(BlockMaster.class);
    AlluxioURI file = new AlluxioURI(""/test"");
    FileSystemTestUtils.createByteFile(fs, file, MUST_CACHE, 10);
    URIStatus status = fs.getStatus(file);
    Long blockId = status.getBlockIds().get(0);
    assertNotNull(blockMaster.getBlockInfo(blockId));
    fs.delete(file);
    WorkerNetAddress workerAddress = mCluster.getWorkerAddress();
    try {
        blockMaster.getBlockInfo(blockId);
        fail(""Expected the block to be deleted"");
    } catch (BlockInfoException e) {
    }
    mCluster.stopMasters();
    mCluster.startMasters();
    AlluxioMasterProcess masterProcess = mCluster.getLocalAlluxioMaster().getMasterProcess();
    try {
        masterProcess.getMaster(BlockMaster.class).getBlockInfo(blockId);
        fail(""Expected the block to be deleted after restart"");
    } catch (BlockInfoException e) {
    }
}"
"@Test
public void testExpiry() throws Exception {
    final int CAPACITY = 3;
    final int EXPIRY_PERIOD = 10;
    PeerCache cache = PeerCache.getInstance(CAPACITY, EXPIRY_PERIOD);
    DatanodeID dnIds[] = new DatanodeID[CAPACITY];
    FakePeer peers[] = new FakePeer[CAPACITY];
    for (int i = 0; i < CAPACITY; ++i) {
        dnIds[i] = new DatanodeID(""192.168.0.1"",
        ""fakehostname_"" + i, ""fake_storage_id"",
        100, 101, 102);
        peers[i] = new FakePeer(dnIds[i], false);
    }
    for (int i = 0; i < CAPACITY; ++i) {
        cache.put(dnIds[i], peers[i]);
    }
    Thread.sleep(EXPIRY_PERIOD * 50);
    assertEquals(0, cache.size());
    for (int i = 0; i < CAPACITY; ++i) {
        assertTrue(peers[i].isClosed());
    }
    Thread.sleep(EXPIRY_PERIOD * 50);
    cache.close();
}"
"@Test public void stringArray(){
    final WithArrays wa=new WithArrays();
    wa.stringArray=new String[]{""a"",""A""};
    final String exp=getClassPrefix(wa) + ""["" + BR+ ""  boolArray=<null>,""+ BR+ ""  charArray=<null>,""+ BR+ ""  doubleArray=<null>,""+ BR+ ""  intArray=<null>,""+ BR+ ""  longArray=<null>,""+ BR+ ""  stringArray={""+ BR+ ""    a,""+ BR+ ""    A""+ BR+ ""  }""+ BR+ ""]"";
    assertEquals(exp,toString(wa));
}"
"@Test
public void testWithRevisions() {
    Country de = new Country();
    de.code = ""de"";
    de.name = ""Deutschland"";
    countryRepository.save(de);
    de.name = ""Germany"";
    countryRepository.save(de);
    Revisions<Integer, Country> revisions = countryRepository.findRevisions(de.id);
    assertThat(revisions).hasSize(2);
    Iterator<Revision<Integer, Country>> iterator = revisions.iterator();
    Integer firstRevisionNumber = iterator.next().getRevisionNumber().get();
    Integer secondRevisionNumber = iterator.next().getRevisionNumber().get();
    assertThat(countryRepository.findRevision(de.id, firstRevisionNumber).get().getEntity().name)
    .isEqualTo(""Deutschland"");
    assertThat(countryRepository.findRevision(de.id, secondRevisionNumber).get().getEntity().name).isEqualTo(""Germany"");
}"
"@Test
public void testToMetricResponse() throws Exception {
    String subscriptionId = ""12345"";
    long ts = 1000L;
    List<Tag> tags = new ArrayList<>();
    tags.add(new Tag(""tag1"", ""value1""));
    Metric m = Metric.newBuilder().name(""sys.cpu.user"").value(ts, 2.0).tags(tags).tag(VISIBILITY_TAG, ""(a&b)|(c&d)"").build();
    String json = JsonUtil.getObjectMapper().writeValueAsString(MetricResponse.fromMetric(m, subscriptionId));
    String expected = ""{\""metric\"":\""sys.cpu.user\"",\""timestamp\"":1000,\""value\"":2.0,\""tags\"":[{\""tag1\"":\""value1\""},{\""viz\"":\""(a&b)|(c&d)\""}],\""subscriptionId\"":\""12345\"",\""complete\"":false}"";
    Assert.assertEquals(expected, json);
}"
"@Test
public void testWebHdfsDoAs() throws Exception {
    LOG.info(""START: testWebHdfsDoAs()"");
    ((Log4JLogger) (LOG)).getLogger().setLevel(ALL);
    ((Log4JLogger) (LOG)).getLogger().setLevel(ALL);
    final UserGroupInformation ugi = UserGroupInformation.createRemoteUser(REAL_USER);
    LOG.info(""ugi.getShortUserName()="" + ugi.getShortUserName());
    final WebHdfsFileSystem webhdfs = WebHdfsTestUtil.getWebHdfsFileSystemAs(ugi, config);
    final Path root = new Path(""/"");
    cluster.getFileSystem().setPermission(root, new FsPermission(((short) (0777))));
    {
        final URL url = WebHdfsTestUtil.toUrl(webhdfs, GETHOMEDIRECTORY, root, new DoAsParam(PROXY_USER));
        final HttpURLConnection conn = ((HttpURLConnection) (url.openConnection()));
        final Map<?, ?> m = WebHdfsTestUtil.connectAndGetJson(conn, SC_OK);
        conn.disconnect();
        final Object responsePath = m.get(Path.class.getSimpleName());
        LOG.info(""responsePath="" + responsePath);
        Assert.assertEquals(""/user/"" + PROXY_USER, responsePath);
    }
    {
        final URL url = WebHdfsTestUtil.toUrl(webhdfs, GETHOMEDIRECTORY, root, new DoAsParam(PROXY_USER) {
            @Override
            public String getName() {
                return ""DOas"";
            }
        });
        final HttpURLConnection conn = ((HttpURLConnection) (url.openConnection()));
        final Map<?, ?> m = WebHdfsTestUtil.connectAndGetJson(conn, SC_OK);
        conn.disconnect();
        final Object responsePath = m.get(Path.class.getSimpleName());
        LOG.info(""responsePath="" + responsePath);
        Assert.assertEquals(""/user/"" + PROXY_USER, responsePath);
    }
    final Path f = new Path(""/testWebHdfsDoAs/a.txt"");
    {
        final PutOpParam.Op op = Op.CREATE;
        final URL url = WebHdfsTestUtil.toUrl(webhdfs, op, f, new DoAsParam(PROXY_USER));
        HttpURLConnection conn = ((HttpURLConnection) (url.openConnection()));
        conn = WebHdfsTestUtil.twoStepWrite(webhdfs, op, conn);
        final FSDataOutputStream out = WebHdfsTestUtil.write(webhdfs, op, conn, 4096);
        out.write(""Hello, webhdfs user!"".getBytes());
        out.close();
        final FileStatus status = webhdfs.getFileStatus(f);
        LOG.info(""status.getOwner()="" + status.getOwner());
        Assert.assertEquals(PROXY_USER, status.getOwner());
    }
    {
        final PostOpParam.Op op = Op.APPEND;
        final URL url = WebHdfsTestUtil.toUrl(webhdfs, op, f, new DoAsParam(PROXY_USER));
        HttpURLConnection conn = ((HttpURLConnection) (url.openConnection()));
        conn = WebHdfsTestUtil.twoStepWrite(webhdfs, op, conn);
        final FSDataOutputStream out = WebHdfsTestUtil.write(webhdfs, op, conn, 4096);
        out.write(""\nHello again!"".getBytes());
        out.close();
        final FileStatus status = webhdfs.getFileStatus(f);
        LOG.info(""status.getOwner()="" + status.getOwner());
        LOG.info(""status.getLen()  ="" + status.getLen());
        Assert.assertEquals(PROXY_USER, status.getOwner());
    }
}"
"@Test public void acrossParametersOfSameParameterizedTypeWithOneConstant() throws Exception {
    assertThat(testResult(ParametersOfSameParameterizedTypeWithOneConstant.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ParametersOfSameParameterizedTypeWithOneConstant.iterations);
    ParametersOfSameParameterizedTypeWithOneConstant.iterations=0;
}"
"@Test
public void testTakeSnapshot() throws Exception {
    String snapshotName1 = ""snapshotName1"";
    String snapshotName2 = ""snapshotName2"";
    TableName tableName = TableName.valueOf(""testTakeSnapshot"");
    Admin syncAdmin = TEST_UTIL.getAdmin();
    try {
        Table table = TEST_UTIL.createTable(tableName, Bytes.toBytes(""f1""));
        for (int i = 0; i < 3000; i++) {
            table.put(new Put(Bytes.toBytes(i)).addColumn(Bytes.toBytes(""f1""), Bytes.toBytes(""cq""),
            Bytes.toBytes(i)));
        }
        admin.snapshot(snapshotName1, tableName).get();
        admin.snapshot(snapshotName2, tableName).get();
        List<SnapshotDescription> snapshots = syncAdmin.listSnapshots();
        Collections.sort(snapshots, (snap1, snap2) -> {
            Assert.assertNotNull(snap1);
            Assert.assertNotNull(snap1.getName());
            Assert.assertNotNull(snap2);
            Assert.assertNotNull(snap2.getName());
            return snap1.getName().compareTo(snap2.getName());
        });
        Assert.assertEquals(snapshotName1, snapshots.get(0).getName());
        Assert.assertEquals(tableName, snapshots.get(0).getTableName());
        Assert.assertEquals(SnapshotType.FLUSH, snapshots.get(0).getType());
        Assert.assertEquals(snapshotName2, snapshots.get(1).getName());
        Assert.assertEquals(tableName, snapshots.get(1).getTableName());
        Assert.assertEquals(SnapshotType.FLUSH, snapshots.get(1).getType());
    } finally {
        syncAdmin.deleteSnapshot(snapshotName1);
        syncAdmin.deleteSnapshot(snapshotName2);
        TEST_UTIL.deleteTable(tableName);
    }"
"@Test
public void testLookupLink() throws Exception {
    final Name name = new CompositeName(""test"");
    namingStore.bind(name, ""testValue"", String.class);
    final Name linkName = new CompositeName(""link"");
    namingStore.bind(linkName, new LinkRef(""./test""));
    Object result = namingContext.lookup(linkName);
    assertEquals(""testValue"", result);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, Arrays.asList(new JndiPermission(""test"", ""lookup"")), namingContext, ""link"");
    assertEquals(""testValue"", result);
    System.setProperty(Context.INITIAL_CONTEXT_FACTORY, InitialContextFactory.class.getName());
    namingStore.rebind(linkName, new LinkRef(name));
    result = namingContext.lookup(linkName);
    assertEquals(""testValue"", result);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, Arrays.asList(new JndiPermission(""test"", ""lookup"")), namingContext, ""link"");
    assertEquals(""testValue"", result);
}"
"@Test public void primitiveLongs() throws Exception {
    assertThat(testResult(PrimitiveLongs.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveLongs.iterations);
    assertEquals(new HashSet<>(asList(-6L,-7L,-8L)),new HashSet<>(PrimitiveLongs.values.subList(0,3)));
    PrimitiveLongs.iterations=0;
}"
"@Test
public void testRetryWithBackpressure() throws InterruptedException {
    final int NUM_RETRIES = RxRingBuffer.SIZE * 2;
    for (int i = 0; i < 400; i++) {
        @SuppressWarnings(""unchecked"")
        Observer<String> observer = mock(Observer.class);
        Observable<String> origin = Observable.create(new FuncWithErrors(NUM_RETRIES));
        TestSubscriber<String> ts = new TestSubscriber<String>(observer);
        origin.retry().observeOn(Schedulers.computation()).unsafeSubscribe(ts);
        ts.awaitTerminalEvent(5, TimeUnit.SECONDS);
        InOrder inOrder = inOrder(observer);
        verify(observer, never()).onError(any(Throwable.class));
        inOrder.verify(observer, times(NUM_RETRIES + 1)).onNext(""beginningEveryTime"");
        inOrder.verify(observer, times(1)).onNext(""onSuccessOnly"");
        inOrder.verify(observer, times(1)).onCompleted();
        inOrder.verifyNoMoreInteractions();
    }
}"
"@Test public void primitiveBooleans() throws Exception {
    assertThat(testResult(PrimitiveBooleans.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveBooleans.iterations);
    PrimitiveBooleans.iterations=0;
}"
"@Test public void primitiveFloats(){
    assertThat(testResult(PrimitiveFloats.class),isSuccessful());
    assertEquals(2,PrimitiveFloats.iterations);
    assertEquals(new HashSet<>(asList(3.3F,-5F)),PrimitiveFloats.testCases);
    PrimitiveFloats.iterations=0;
    PrimitiveFloats.testCases.clear();
}"
"@Test
public void testListDetail() throws RemotingException {
    String result = port.telnet(null, ""-l"");
    assertEquals(""dubbo://127.0.0.1:20887"", result);
}"
"@Test
public void testStartDoesNotFailWithNonExistentVersion() {
    BundleContext bundleContext = EasyMock.createMock(BundleContext.class);
    final Map<String, Map<String, Feature>> features = new HashMap<String, Map<String, Feature>>();
    Map<String, Feature> versions = new HashMap<String, Feature>();
    versions.put(""1.0.0"", new FeatureImpl(""transaction"", ""1.0.0""));
    versions.put(""2.0.0"", new FeatureImpl(""transaction"", ""2.0.0""));
    features.put(""transaction"", versions);
    Map<String, Feature> versions2 = new HashMap<String, Feature>();
    versions2.put(""1.0.0"", new FeatureImpl(""ssh"", ""1.0.0""));
    features.put(""ssh"", versions2);
    final FeaturesServiceImpl impl = new FeaturesServiceImpl() ;
    impl.setBundleContext(bundleContext);
    try {
        Thread.currentThread().setContextClassLoader(new URLClassLoader(new URL[0]));
        impl.setBoot(""transaction;version=1.2,ssh;version=1.0.0"");
        impl.start();
        assertFalse(""Feature transaction 1.0.0 should not be installed"", impl.isInstalled(impl.getFeature(""transaction"", ""1.0.0"")));
        assertFalse(""Feature transaction 2.0.0 should not be installed"", impl.isInstalled(impl.getFeature(""transaction"", ""2.0.0"")));
        assertFalse(""Feature ssh should be installed"", impl.isInstalled(impl.getFeature(""ssh"", ""1.0.0"")));
    } catch (Exception e) {
        fail(String.format(""Service should not throw start-up exception but log the error instead: %s"", e));
    }
}"
"@Test public void testDubboProtocolWithMina() throws Exception {
    DemoService service=new DemoServiceImpl();
    protocol.export(proxy.getInvoker(service,DemoService.class,URL.valueOf(""dubbo://127.0.0.1:9011/"" + DemoService.class.getName()).addParameter(Constants.SERVER_KEY,""mina"")));
    service=proxy.getProxy(protocol.refer(DemoService.class,URL.valueOf(""dubbo://127.0.0.1:9011/"" + DemoService.class.getName()).addParameter(Constants.CLIENT_KEY,""mina"").addParameter(""timeout"",3000l)));
    for (int i=0; i < 10; i++) {
        assertEquals(service.enumlength(new Type[]{}),Type.Lower);
        assertEquals(service.getSize(null),-1);
        assertEquals(service.getSize(new String[]{"""","""",""""}),3);
    }
    Map<String,String> map=new HashMap<String,String>();
    map.put(""aa"",""bb"");
    for (int i=0; i < 10; i++) {
        Set<String> set=service.keys(map);
        assertEquals(set.size(),1);
        assertEquals(set.iterator().next(),""aa"");
        service.invoke(""dubbo://127.0.0.1:9010/"" + DemoService.class.getName() + """",""invoke"");
    }
    service=proxy.getProxy(protocol.refer(DemoService.class,URL.valueOf(""dubbo://127.0.0.1:9011/"" + DemoService.class.getName() + ""?client=mina"").addParameter(""timeout"",3000l)));
    StringBuffer buf=new StringBuffer();
    for (int i=0; i < 1024 * 32 + 32; i++)   buf.append('A');
    System.out.println(service.stringLength(buf.toString()));
    EchoService echo=proxy.getProxy(protocol.refer(EchoService.class,URL.valueOf(""dubbo://127.0.0.1:9011/"" + DemoService.class.getName() + ""?client=mina"").addParameter(""timeout"",3000l)));
    for (int i=0; i < 10; i++) {
        assertEquals(echo.$echo(buf.toString()),buf.toString());
        assertEquals(echo.$echo(""test""),""test"");
        assertEquals(echo.$echo(""abcdefg""),""abcdefg"");
        assertEquals(echo.$echo(1234),1234);
    }
}"
"@Test
public void testBindNested() throws Exception {
    final Name name = new CompositeName(""nested/test"");
    final Object value = new Object();
    WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);
    try {
        store.bind(name, value);
    } finally {
        WritableServiceBasedNamingStore.popOwner();
    }
    assertEquals(value, store.lookup(name));
}"
"@Test public void wrapperIntegers(){
    assertThat(testResult(WrapperIntegers.class),isSuccessful());
    assertEquals(2,WrapperIntegers.iterations);
    assertEquals(new HashSet<>(asList(4,5)),WrapperIntegers.testCases);
    WrapperIntegers.iterations=0;
    WrapperIntegers.testCases.clear();
}"
"@Test
public void kafkaTopicIsPattern() throws Exception {
    to.expectedMessageCount(5);
    to.expectedBodiesReceivedInAnyOrder(""message-0"", ""message-1"", ""message-2"", ""message-3"", ""message-4"");
    to.allMessages().header(TOPIC).isEqualTo(""test"");
    to.expectedHeaderValuesReceivedInAnyOrder(LAST_RECORD_BEFORE_COMMIT, null, null, null, null, null);
    for (int k = 0; k < 5; k++) {
        String msg = ""message-"" + k;
        ProducerRecord<String, String> data = new ProducerRecord<>(TOPIC, ""1"", msg);
        producer.send(data);
    }
    to.assertIsSatisfied(3000);
    assertEquals(5, StreamSupport.stream(recordsCaptured.get(0).records(TOPIC).spliterator(), false).count());
}"
"@Test
void scanShouldIterateOverAvailableEntries() {
    adapter.put(""1"", object1, COLLECTION_1);
    adapter.put(""2"", object2, COLLECTION_1);
    CloseableIterator<Map.Entry<Object, Object>> iterator = adapter.entries(COLLECTION_1);
    assertThat(iterator.next()).isEqualTo(new AbstractMap.SimpleEntry<>(""1"", object1));
    assertThat(iterator.next()).isEqualTo(new AbstractMap.SimpleEntry<>(""2"", object2));
    Map.Entry<Object, Object> entry1 = iterator.next();
    Map.Entry<Object, Object> entry2 = iterator.next();
    assertThat(iterator.hasNext()).isFalse();
}"
"@Test
public void findingAnnotationsRecursively() {
    Method method = findMethod(this.getClass(), ""withMarker"", String.class);
    List<Annotation> annotations = allAnnotations(method.getParameters()[0]);
    assertEquals(4, annotations.size());
    assertEquals(X.class, annotations.get(0).annotationType());
    assertEquals(Y.class, annotations.get(1).annotationType());
    assertEquals(Z.class, annotations.get(2).annotationType());
    assertEquals(W.class, annotations.get(3).annotationType());
}"
"@Test
public void testTrackMetadata_rowTombstone() throws Throwable
{
    createTable(""CREATE TABLE %s (a int, b int, c text, PRIMARY KEY (a, b))"");
    ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(currentTable());
    execute(""DELETE FROM %s USING TIMESTAMP 9999 WHERE a = 1"");
    cfs.forceBlockingFlush();
    assertEquals(1, cfs.getLiveSSTables().size());
    StatsMetadata metadata = cfs.getLiveSSTables().iterator().next().getSSTableMetadata();
    assertEquals(9999, metadata.minTimestamp);
    assertEquals(9999, metadata.maxTimestamp);
    assertEquals(System.currentTimeMillis()/1000, metadata.maxLocalDeletionTime, 5);
    assertEquals(nowInSec(), metadata.maxLocalDeletionTime, DELTA);
    cfs.forceMajorCompaction();
    StatsMetadata metadata2 = cfs.getLiveSSTables().iterator().next().getSSTableMetadata();
    assertEquals(metadata.maxLocalDeletionTime, metadata2.maxLocalDeletionTime);
    assertEquals(metadata.minTimestamp, metadata2.minTimestamp);
    assertEquals(metadata.maxTimestamp, metadata2.maxTimestamp);
}"
"@Test
public class Test {
    @Test(timeout = 300000)
    public void testRSSplitEphemeralsDisappearButDaughtersAreOnlinedAfterShutdownHandling() throws IOException, InterruptedException, NodeExistsException, KeeperException {
        final byte[] tableName = Bytes.toBytes(""ephemeral"");
        HTable t = TESTING_UTIL.createTable(tableName, CATALOG_FAMILY);
        List<HRegion> regions = cluster.getRegions(tableName);
        HRegionInfo hri = getAndCheckSingleTableRegion(regions);
        int tableRegionIndex = ensureTableRegionNotOnSameServerAsMeta(admin, hri);
        this.admin.setBalancerRunning(false, true);
        cluster.getMaster().setCatalogJanitorEnabled(false);
        try {
            TESTING_UTIL.loadTable(t, CATALOG_FAMILY);
            HRegionServer server = cluster.getRegionServer(tableRegionIndex);
            printOutRegions(server, ""Initial regions: "");
            int regionCount = server.getOnlineRegions().size();
            SplitRegionHandler.TEST_SKIP = true;
            split(hri, server, regionCount);
            List<HRegion> daughters = cluster.getRegions(tableName);
            assertTrue(daughters.size() >= 2);
            String path = ZKAssign.getNodeName(t.getConnection().getZooKeeperWatcher(), hri.getEncodedName());
            Stat stats = t.getConnection().getZooKeeperWatcher().getRecoverableZooKeeper().exists(path, false);
            LOG.info(((""EPHEMERAL NODE BEFORE SERVER ABORT, path="" + path) + "", stats="") + stats);
            RegionTransitionData rtd = ZKAssign.getData(t.getConnection().getZooKeeperWatcher(), hri.getEncodedName());
            assertTrue(rtd.getEventType().equals(RS_ZK_REGION_SPLIT) || rtd.getEventType().equals(RS_ZK_REGION_SPLITTING));
            cluster.abortRegionServer(tableRegionIndex);
            waitUntilRegionServerDead();
            while (cluster.getRegions(tableName).size() < daughters.size()) {
                LOG.info(""Waiting for repair to happen"");
                Thread.sleep(1000);
            }
            regions = cluster.getRegions(tableName);
            for (HRegion r : regions) {
                assertTrue(daughters.contains(r));
            }
            stats = t.getConnection().getZooKeeperWatcher().getRecoverableZooKeeper().exists(path, false);
            LOG.info(((""EPHEMERAL NODE AFTER SERVER ABORT, path="" + path) + "", stats="") + stats);
            assertTrue(stats == null);
        } finally {
            SplitRegionHandler.TEST_SKIP = false;
            admin.setBalancerRunning(true, false);
            cluster.getMaster().setCatalogJanitorEnabled(true);
        }
    }
}"
"@Test public void acrossParametersOfSameTypeWithOneConstant() throws Exception {
    assertThat(testResult(ParametersOfSameTypeWithOneConstant.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ParametersOfSameTypeWithOneConstant.iterations);
    ParametersOfSameTypeWithOneConstant.iterations=0;
}"
"@Test
public class Test {
    public void testPendingAndInvalidate() throws Exception {
        final Configuration CONF = new HdfsConfiguration();
        MiniDFSCluster cluster = new MiniDFSCluster.Builder(CONF).numDataNodes(DATANODE_COUNT).build();
        cluster.waitActive();
        FSNamesystem namesystem = cluster.getNamesystem();
        BlockManager bm = namesystem.getBlockManager();
        DistributedFileSystem fs = cluster.getFileSystem();
        try {
            Path filePath = new Path(""/tmp.txt"");
            DFSTestUtil.createFile(fs, filePath, 1024, (short) 3, 0L);
            for (DataNode dn : cluster.getDataNodes()) {
                DataNodeTestUtils.setHeartbeatsDisabledForTests(dn, true);
            }
            LocatedBlock block = NameNodeAdapter.getBlockLocations(
            cluster.getNameNode(), filePath.toString(), 0, 1).get(0);
            cluster.getNamesystem().writeLock();
            try {
                bm.findAndMarkBlockAsCorrupt(block.getBlock(), block.getLocations()[0],
                ""STORAGE_ID"", ""TEST"");
            } finally {
                cluster.getNamesystem().writeUnlock();
            }
            BlockManagerTestUtil.computeAllPendingWork(bm);
            BlockManagerTestUtil.updateState(bm);
            assertEquals(bm.getPendingReconstructionBlocksCount(), 1L);
            BlockInfo storedBlock = bm.getStoredBlock(block.getBlock().getLocalBlock());
            assertEquals(bm.pendingReconstruction.getNumReplicas(storedBlock), 2);
            fs.delete(filePath, true);
            int retries = 10;
            long pendingNum = bm.getPendingReconstructionBlocksCount();
            while (pendingNum != 0 && retries-- > 0) {
                Thread.sleep(1000);
                BlockManagerTestUtil.updateState(bm);
                pendingNum = bm.getPendingReconstructionBlocksCount();
            }
            assertEquals(pendingNum, 0L);
        } finally {
            cluster.shutdown();
        }
    }
}"
"@Test public void wrapperBooleans() throws Exception {
    assertThat(testResult(WrapperBooleans.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperBooleans.iterations);
    WrapperBooleans.iterations=0;
}"
"@Test
public void testWritesWhileScanning() throws IOException, InterruptedException {
    byte[] tableName = Bytes.toBytes(""testWritesWhileScanning"");
    int testCount = 100;
    int numRows = 1;
    int numFamilies = 10;
    int numQualifiers = 100;
    int flushInterval = 7;
    int compactInterval = 5 * flushInterval;
    byte[][] families = new byte[numFamilies][];
    for (int i = 0; i < numFamilies; i++) {
        families[i] = Bytes.toBytes(""family"" + i);
    }
    byte[][] qualifiers = new byte[numQualifiers][];
    for (int i = 0; i < numQualifiers; i++) {
        qualifiers[i] = Bytes.toBytes(""qual"" + i);
    }
    String method = ""testWritesWhileScanning"";
    initHRegion(tableName, method, families);
    PutThread putThread = new PutThread(numRows, families, qualifiers);
    putThread.start();
    FlushThread flushThread = new FlushThread();
    flushThread.start();
    Scan scan = new Scan(Bytes.toBytes(""row0""), Bytes.toBytes(""row1""));
    int expectedCount = numFamilies * numQualifiers;
    List<KeyValue> res = new ArrayList<KeyValue>();
    long prevTimestamp = 0L;
    for (int i = 0; i < testCount; i++) {
        if ((i != 0) && ((i % compactInterval) == 0)) {
            region.compactStores(true);
        }
        if ((i != 0) && ((i % flushInterval) == 0)) {
            flushThread.flush();
        }
        boolean previousEmpty = res.isEmpty();
        res.clear();
        InternalScanner scanner = region.getScanner(scan);
        while (scanner.next(res));
        if (((!res.isEmpty()) || (!previousEmpty)) || (i > compactInterval)) {
            assertEquals(""i="" + i, expectedCount, res.size());
            long timestamp = res.get(0).getTimestamp();
            assertTrue(((""Timestamps were broke: "" + timestamp) + "" prev: "") + prevTimestamp, timestamp >= prevTimestamp);
            prevTimestamp = timestamp;
        }
    }
    putThread.done();
    region.flushcache();
    putThread.join();
    putThread.checkNoError();
    flushThread.done();
    flushThread.join();
    flushThread.checkNoError();
}"
"@Test public void primitiveChars(){
    assertThat(testResult(PrimitiveChars.class),isSuccessful());
    assertEquals(2,PrimitiveChars.iterations);
    assertEquals(new HashSet<>(asList('Z','z')),PrimitiveChars.testCases);
    PrimitiveChars.iterations=0;
}"
"public void testObjectToXml() throws Exception {
    SimpleBean obj=new SimpleBean();
    obj.setName(""Jan"");
    obj.setAge(12L);
    obj.setParents(Arrays.asList(""Adam"",""Ewa""));
    Writer stream=new StringWriter();
    handler.fromObject(ai,obj,null,stream);
    stream.flush();
    String actual=stream.toString();
    assertTrue(actual.length() == xml.length() && actual.startsWith(prefix) && actual.contains(name) && actual.contains(age) && actual.contains(parents) && actual.endsWith(suffix));
}"
"@Test
public void testLeaseRelease() throws Exception {
    HttpConnection conn1 = Mockito.mock(HttpConnection.class);
    HttpConnection conn2 = Mockito.mock(HttpConnection.class);
    LocalConnFactory connFactory = Mockito.mock(LocalConnFactory.class);
    Mockito.when(connFactory.create(Mockito.eq(""somehost""))).thenReturn(conn1);
    Mockito.when(connFactory.create(Mockito.eq(""otherhost""))).thenReturn(conn2);
    LocalConnPool pool = new LocalConnPool(connFactory, 2, 10);
    Future<LocalPoolEntry> future1 = pool.lease(""somehost"", null);
    LocalPoolEntry entry1 = future1.get(1, TimeUnit.SECONDS);
    Assert.assertNotNull(entry1);
    Future<LocalPoolEntry> future2 = pool.lease(""somehost"", null);
    LocalPoolEntry entry2 = future2.get(1, TimeUnit.SECONDS);
    Assert.assertNotNull(entry2);
    Future<LocalPoolEntry> future3 = pool.lease(""otherhost"", null);
    LocalPoolEntry entry3 = future3.get(1, TimeUnit.SECONDS);
    Assert.assertNotNull(entry3);
    PoolStats totals = pool.getTotalStats();
    Assert.assertEquals(0, totals.getAvailable());
    Assert.assertEquals(3, totals.getLeased());
    LocalPoolEntry entry = future1.get();
    Assert.assertSame(entry1, entry);
    pool.release(entry1, true);
    pool.release(entry2, true);
    pool.release(entry3, false);
    Mockito.verify(conn1, Mockito.never()).close();
    Mockito.verify(conn2, Mockito.times(1)).close();
    totals = pool.getTotalStats();
    Assert.assertEquals(2, totals.getAvailable());
    Assert.assertEquals(0, totals.getLeased());
}"
"@Test public void canFlatten() throws Exception {
    Foo foo=new Foo();
    foo.bar=""hello.world"";
    foo.baz=new ArrayList<>();
    foo.baz.add(""hello"");
    foo.baz.add(""hello.world"");
    foo.qux=new HashMap<>();
    foo.qux.put(""hello"",""world"");
    foo.qux.put(""a.b"",""c.d"");
    foo.qux.put(""bar.a"",""ttyy"");
    foo.qux.put(""bar.b"",""uuzz"");
    JacksonAdapter adapter=new JacksonAdapter();
    String serialized=adapter.serialize(foo);
    String expected=""{\""$type\"":\""foo\"",\""properties\"":{\""bar\"":\""hello.world\"",\""props\"":{\""baz\"":[\""hello\"",\""hello.world\""],\""q\"":{\""qux\"":{\""hello\"":\""world\"",\""a.b\"":\""c.d\"",\""bar.b\"":\""uuzz\"",\""bar.a\"":\""ttyy\""}}}}}"";
    assertJsonEqualsNonStrict(expected,serialized);
    Foo deserialized=adapter.deserialize(serialized,Foo.class);
    Assert.assertEquals(""hello.world"",deserialized.bar);
    Assert.assertArrayEquals(new String[]{""hello"",""hello.world""},deserialized.baz.toArray());
    Assert.assertNotNull(deserialized.qux);
    Assert.assertEquals(""world"",deserialized.qux.get(""hello""));
    Assert.assertEquals(""c.d"",deserialized.qux.get(""a.b""));
    Assert.assertEquals(""ttyy"",deserialized.qux.get(""bar.a""));
    Assert.assertEquals(""uuzz"",deserialized.qux.get(""bar.b""));
}"
"@Test public void testAdditionalModelTypeAnnotationsSemiColon() throws Exception {
    OpenAPI openAPI=TestUtils.createOpenAPI();
    final AbstractJavaCodegen codegen=new P_AbstractJavaCodegen();
    codegen.additionalProperties().put(AbstractJavaCodegen.ADDITIONAL_MODEL_TYPE_ANNOTATIONS,""@Foo;@Bar"");
    codegen.processOpts();
    codegen.preprocessOpenAPI(openAPI);
    final List<String> additionalModelTypeAnnotations=new ArrayList<String>();
    additionalModelTypeAnnotations.add(""@Foo"");
    additionalModelTypeAnnotations.add(""@Bar"");
    final List<String> sortedCodegenAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    final List<String> sortedAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    Collections.sort(sortedCodegenAdditionalModelTypeAnnotations);
    Collections.sort(sortedAdditionalModelTypeAnnotations);
    Assert.assertEquals(sortedCodegenAdditionalModelTypeAnnotations,sortedAdditionalModelTypeAnnotations);
}"
"@Test
void writesAndReadsCustomFieldsConvertedClass() {
    List<Object> converters = new ArrayList<>();
    converters.add(BigDecimalToStringConverter.INSTANCE);
    converters.add(StringToBigDecimalConverter.INSTANCE);
    CustomConversions customConversions = new CouchbaseCustomConversions(converters);
    converter.setCustomConversions(customConversions);
    converter.afterPropertiesSet();
    ((CouchbaseMappingContext) (converter.getMappingContext())).setSimpleTypeHolder(customConversions.getSimpleTypeHolder());
    CouchbaseDocument converted = new CouchbaseDocument();
    final String valueStr = ""12.345"";
    final BigDecimal value = new BigDecimal(valueStr);
    final String value2Str = ""0.6789"";
    final BigDecimal value2 = new BigDecimal(value2Str);
    List<BigDecimal> listOfValues = new ArrayList<>();
    listOfValues.add(value);
    listOfValues.add(value2);
    Map<String, BigDecimal> mapOfValues = new HashMap<>();
    mapOfValues.put(""val1"", value);
    mapOfValues.put(""val2"", value2);
    CustomFieldsEntity entity = new CustomFieldsEntity(value, listOfValues, mapOfValues);
    converter.write(entity, converted);
    CouchbaseDocument source = new CouchbaseDocument();
    source.put(""_class"", CustomFieldsEntity.class.getName());
    source.put(""decimalValue"", valueStr);
    CouchbaseList listOfValuesDoc = new CouchbaseList();
    listOfValuesDoc.put(valueStr);
    listOfValuesDoc.put(value2Str);
    source.put(""listOfDecimalValues"", listOfValuesDoc);
    CouchbaseDocument mapOfValuesDoc = new CouchbaseDocument();
    mapOfValuesDoc.put(""val1"", valueStr);
    mapOfValuesDoc.put(""val2"", value2Str);
    source.put(""mapOfDecimalValues"", mapOfValuesDoc);
    assertThat(valueStr).isEqualTo(((CouchbaseList) (converted.getContent().get(""listOfDecimalValues""))).get(0));
    assertThat(value2Str).isEqualTo(((CouchbaseList) (converted.getContent().get(""listOfDecimalValues""))).get(1));
    assertThat(converted.export().toString()).isEqualTo(source.export().toString());
    CustomFieldsEntity readConverted = converter.read(CustomFieldsEntity.class, source);
    assertThat(readConverted.value).isEqualTo(value);
    assertThat(readConverted.listOfValues.get(0)).isEqualTo(listOfValues.get(0));
    assertThat(readConverted.listOfValues.get(1)).isEqualTo(listOfValues.get(1));
    assertThat(readConverted.mapOfValues.get(""val1"")).isEqualTo(mapOfValues.get(""val1""));
    assertThat(readConverted.mapOfValues.get(""val2"")).isEqualTo(mapOfValues.get(""val2""));
}"
"@Test
public void shouldBeAbleToCancelJob() throws Exception {
    RobustJobSchedulerWrapper robustWrapper = new RobustJobSchedulerWrapper(actualScheduler, log);
    AtomicInteger count = new AtomicInteger();
    JobHandle jobHandle = robustWrapper.scheduleRecurring(""JobName"", 1, count::incrementAndGet);
    assertEventually(""run count"", count::get, Matchers.greaterThanOrEqualTo(100), DEFAULT_TIMEOUT_MS, MILLISECONDS);
    robustWrapper.cancelAndWaitTermination(jobHandle);
    int finalCount = count.get();
    Thread.sleep(50);
    assertEquals(finalCount, count.get());
}"
"@Test
public void testTransactionMetaStoreAssignAndFailover() throws IOException, InterruptedException {
    int transactionMetaStoreCount = 0;
    for (PulsarService pulsarService : pulsarServices) {
        transactionMetaStoreCount += pulsarService.getTransactionMetadataStoreService().getStores().size();
    }
    Assert.assertEquals(transactionMetaStoreCount, 16);
    PulsarService crashedMetaStore = null;
    for (int i = pulsarServices.length - 1; i >= 0; i--) {
        if (pulsarServices[i].getTransactionMetadataStoreService().getStores().size() > 0) {
            crashedMetaStore = pulsarServices[i];
            break;
        }
    }
    Assert.assertNotNull(crashedMetaStore);
    List<PulsarService> services = new ArrayList<>(pulsarServices.length - 1);
    for (PulsarService pulsarService : pulsarServices) {
        if (pulsarService != crashedMetaStore) {
            services.add(pulsarService);
        }
    }
    pulsarServices = new PulsarService[pulsarServices.length - 1];
    for (int i = 0; i < services.size(); i++) {
        pulsarServices[i] = services.get(i);
    }
    crashedMetaStore.close();
    Thread.sleep(3000);
    transactionMetaStoreCount = 0;
    for (PulsarService pulsarService : pulsarServices) {
        transactionMetaStoreCount += pulsarService.getTransactionMetadataStoreService().getStores().size();
    }
    Assert.assertEquals(transactionMetaStoreCount, 16);
    transactionCoordinatorClient.close();
}"
"@Test public void testAdditionalModelTypeAnnotationsNewLineWindows() throws Exception {
    OpenAPI openAPI=TestUtils.createOpenAPI();
    final AbstractJavaCodegen codegen=new P_AbstractJavaCodegen();
    codegen.additionalProperties().put(AbstractJavaCodegen.ADDITIONAL_MODEL_TYPE_ANNOTATIONS,""@Foo\r\n@Bar"");
    codegen.processOpts();
    codegen.preprocessOpenAPI(openAPI);
    final List<String> additionalModelTypeAnnotations=new ArrayList<String>();
    additionalModelTypeAnnotations.add(""@Foo"");
    additionalModelTypeAnnotations.add(""@Bar"");
    final List<String> sortedCodegenAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    final List<String> sortedAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    Collections.sort(sortedCodegenAdditionalModelTypeAnnotations);
    Collections.sort(sortedAdditionalModelTypeAnnotations);
    Assert.assertEquals(sortedCodegenAdditionalModelTypeAnnotations,sortedAdditionalModelTypeAnnotations);
}"
"@Test
public void testOneTimeRequest_noInitialDelay_withConstraintNetworkConnected() {
    val now = System.currentTimeMillis() ;
    when(mTaskConverter.now()).thenReturn(now) ;
    val constraints = Constraints.Builder().setRequiredNetworkType(NetworkType.METERED).setRequiresCharging(true).build() ;
    val request = OneTimeWorkRequestBuilder<TestWorker>()
    .setConstraints(constraints)
    .build() ;
    val task = mTaskConverter.convert(request.workSpec) ;
    val expected = request.workSpec.calculateNextRunTime() ;
    val offset = offset(expected, now) ;
    assertEquals(task.serviceName, WorkManagerGcmService::class.java.name) ;
    assertEquals(task.isPersisted, false) ;
    assertEquals(task.isUpdateCurrent, true) ;
    assertEquals(task.requiredNetwork, Task.NETWORK_STATE_CONNECTED) ;
    assertEquals(task.requiresCharging, true) ;
    assertEquals(task.windowStart, offset) ;
    assertEquals(task.windowEnd, offset + EXECUTION_WINDOW_SIZE_IN_SECONDS) ;
}"
"@Test
public void testBuildTokenServiceSockAddr() {
    assertEquals(""127.0.0.1:123"", SecurityUtil.buildTokenService(new InetSocketAddress(""LocalHost"", 123)).toString());
    assertEquals(""127.0.0.1:123"", SecurityUtil.buildTokenService(new InetSocketAddress(""127.0.0.1"", 123)).toString());
    assertEquals(""127.0.0.1:123"", SecurityUtil.buildTokenService(NetUtils.createSocketAddr(""127.0.0.1"", 123)).toString());
}"
"@Test public void serializeFloat() throws IOException {
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of(1.0f)),""{\""@type\"":\""float\"",\""@value\"":1.0}"");
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of(42.4f)),""{\""@type\"":\""float\"",\""@value\"":42.4}"");
}"
"@Test
public void shouldBuildUpGracefullyUntilReachedMinPoolSize() throws InterruptedException
{
    StatefulMonitor stateMonitor = new StatefulMonitor();
    FakeClock clock = new FakeClock();
    final LinkedQueuePool<Object> pool = getLinkedQueuePool( stateMonitor, clock, 5 );
    ExecutorService executor = Executors.newCachedThreadPool();
    List<FlyweightHolder<Object>> flyweightHolders = acquireFromPool( pool, 5, executor );
    executor.shutdown();
    for ( FlyweightHolder<Object> flyweightHolder : flyweightHolders )
    {
        flyweightHolder.release();
    }
    executor.awaitTermination( 10, TimeUnit.SECONDS );
    assertEquals( -1, stateMonitor.currentPeakSize.get() );
    assertEquals( -1, stateMonitor.targetSize.get() );
    assertEquals( 0, stateMonitor.disposed.get() );
}"
"@Test
public void testRead() throws Exception {
    FileSystem fs = cluster.getFileSystem();
    long tStart = System.currentTimeMillis();
    bench.readTest(fs);
    long execTime = System.currentTimeMillis() - tStart;
    bench.analyzeResult(fs, TestType.TEST_TYPE_READ, execTime);
}"
"@Test
public void atScope1() throws Exception {
    System.out.println(""atScope1"");
    BThread b1 = new BThread(""ThreadB1"");
    BThread b2 = new BThread(""ThreadB2"");
    CThread c1 = new CThread(""ThreadC1"");
    CThread c2 = new CThread(""ThreadC2"");
    b1.start();
    b2.start();
    c1.start();
    c2.start();
    b1.join();
    b2.join();
    c1.join();
    c2.join();
    Assert.assertEquals(""None"", b1.failedReason);
    Assert.assertEquals(""None"", b2.failedReason);
    Assert.assertEquals(""None"", c1.failedReason);
    Assert.assertEquals(""None"", c2.failedReason);
}"
"@Test
public void serverStatusThrottledIfJournalUtilizationIsHigherThanThreshold() throws Exception {
    serverStatus.running();
    final Size segmentSize = Size.kilobytes(1L);
    final KafkaJournal journal = new KafkaJournal(journalDirectory, scheduler, segmentSize, Duration.standardSeconds(1L), Size.kilobytes(4L), Duration.standardSeconds(1L), 1000000, Duration.standardSeconds(1L), 90, new MetricRegistry(), serverStatus);
    createBulkChunks(journal, segmentSize, 4);
    journal.flushDirtyLogs();
    journal.cleanupLogs();
    assertThat(serverStatus.getLifecycle()).isEqualTo(THROTTLED);
}"
"public void test_cast_to_Timestamp_1970_01_01_00_00_00() throws Exception {
    JSON.defaultTimeZone=TimeZone.getTimeZone(""Asia/Shanghai"");
    Assert.assertEquals(new Timestamp(0),TypeUtils.castToTimestamp(""1970-01-01 08:00:00""));
}"
"@Test
public void testSuccess_multipartTldsWithSharedSuffixes() throws Exception {
    createTlds(""bar.foo.tld"", ""foo.tld"", ""tld"");
    assertCommandAndResponse(""login_valid.xml"", ""login_response.xml"");
    assertCommandAndResponse(
    ""contact_create_sh8013.xml"",
    ImmutableMap.of(),
    ""contact_create_response_sh8013.xml"",
    ImmutableMap.of(""CRDATE"", ""2000-06-01T00:00:00Z""),
    DateTime.parse(""2000-06-01T00:00:00Z""));
    assertCommandAndResponse(
    ""contact_create_jd1234.xml"",
    ""contact_create_response_jd1234.xml"",
    DateTime.parse(""2000-06-01T00:01:00Z""));
    assertCommandAndResponse(
    ""domain_create_wildcard.xml"",
    ImmutableMap.of(""HOSTNAME"", ""example.bar.foo.tld""),
    ""domain_create_response.xml"",
    ImmutableMap.of(
    ""NAME"", ""example.bar.foo.tld"",
    ""CRDATE"", ""2000-06-01T00:02:00.0Z"",
    ""EXDATE"", ""2002-06-01T00:02:00.0Z""),
    DateTime.parse(""2000-06-01T00:02:00Z""));
}"
"@Test
public void serializeWithTruncateArrayTest() throws IOException {
    final ResponseContext ctx = ResponseContext.createEmpty();
    ctx.put(UNCOVERED_INTERVALS, Arrays.asList(interval(1), interval(2), interval(3), interval(4), interval(5), interval(6)));
    ctx.put(EXTN_STRING_KEY, Strings.repeat(""x"", INTERVAL_LEN * 7));
    final DefaultObjectMapper objectMapper = new DefaultObjectMapper();
    final String fullString = objectMapper.writeValueAsString(ctx.getDelegate());
    final ResponseContext.SerializationResult res1 = ctx.serializeWith(objectMapper, Integer.MAX_VALUE);
    Assert.assertEquals(fullString, res1.getResult());
    final int maxLen = ((((INTERVAL_LEN * 4) + UNCOVERED_INTERVALS.getName().length()) + 4) + TRUNCATED.getName().length()) + 6;
    final ResponseContext.SerializationResult res2 = ctx.serializeWith(objectMapper, maxLen);
    final ResponseContext ctxCopy = ResponseContext.createEmpty();
    ctxCopy.put(UNCOVERED_INTERVALS, Arrays.asList(interval(1), interval(2), interval(3)));
    ctxCopy.put(TRUNCATED, true);
    Assert.assertEquals(ctxCopy.getDelegate(), deserializeContext(res2.getResult(), objectMapper));
}"
"@Test
public void testNoTestClassesInDeploymentAssembly()
throws InvocationTargetException, CoreException {
    CreateAppEngineWtpProject creator = new CreateAppEngineStandardWtpProject(config, adaptable);
    creator.execute(monitor);
    ProjectUtils.waitForProjects(project);
    assertNoTestClassesInDeploymentAssembly();
}
private void assertNoTestClassesInDeploymentAssembly() throws CoreException {
    StructureEdit core = StructureEdit.getStructureEditForRead(project);
    WorkbenchComponent component = core.getComponent();
    assertNotNull(component);
    boolean seenMainSourcePath = false;
    List<ComponentResource> resources = component.getResources();
    for (ComponentResource resource : resources) {
        assertFalse(containsSegment(resource.getSourcePath(), ""test""));
        if (resource.getSourcePath().equals(new Path(""/src/main/java""))
        && resource.getRuntimePath().equals(new Path(""/WEB-INF/classes""))) {
            seenMainSourcePath = true;
        }
    }
    assertTrue(seenMainSourcePath);
}"
"@Test
public void testListBindingsNameNotFound() throws Exception {
    try {
        namingContext.listBindings(new CompositeName(""test""));
        fail(""Should have thrown and NameNotFoundException"");
    } catch (NameNotFoundException expected) {
    }
    try {
        testActionPermission(JndiPermission.ACTION_LIST_BINDINGS, namingContext, ""test"");
        fail(""Should have thrown and NameNotFoundException with appropriate permissions"");
    } catch (NameNotFoundException expected) {
    }
}"
"@Test
public void testFireMultiLevelEvent() throws Exception {
    final NamingEventCoordinator coordinator = new NamingEventCoordinator();
    final CollectingListener subtreeListener = new CollectingListener(1);
    coordinator.addListener(""foo"", EventContext.SUBTREE_SCOPE, subtreeListener);
    final CollectingListener subtreeListenerTwo = new CollectingListener(1);
    coordinator.addListener(""foo/bar"", EventContext.SUBTREE_SCOPE, subtreeListenerTwo);
    final CollectingListener subtreeListenerThree = new CollectingListener(1);
    coordinator.addListener(""foo/bar/baz"", EventContext.SUBTREE_SCOPE, subtreeListenerThree);
    coordinator.fireEvent(context, new CompositeName(""foo/bar/baz/boo""), null, null, NamingEvent.OBJECT_ADDED, ""bind"", EventContext.OBJECT_SCOPE, EventContext.ONELEVEL_SCOPE, EventContext.SUBTREE_SCOPE);
    subtreeListener.latch.await(1, TimeUnit.SECONDS);
    subtreeListenerTwo.latch.await(1, TimeUnit.SECONDS);
    subtreeListenerThree.latch.await(1, TimeUnit.SECONDS);
    assertEquals(1, subtreeListener.capturedEvents.size());
    assertEquals(1, subtreeListenerTwo.capturedEvents.size());
    assertEquals(1, subtreeListenerThree.capturedEvents.size());
}"
"@Test
public void shouldHighPriorityNodeStartElectionFirst() {
    final AtomicBoolean highPrioElectionTriggered = spy(new AtomicBoolean());
    final AtomicBoolean lowPrioElectionTriggered = spy(new AtomicBoolean());
    final int targetPriority = 4;
    final PriorityElectionTimer timerHighPrio = new PriorityElectionTimer(Duration.ofMillis(100), threadContext, () -> highPrioElectionTriggered.set(true), log, targetPriority, targetPriority);
    final PriorityElectionTimer timerLowPrio = new PriorityElectionTimer(Duration.ofMillis(100), threadContext, () -> lowPrioElectionTriggered.set(true), log, targetPriority, 1);
    timerLowPrio.reset();
    timerHighPrio.reset();
    Awaitility.await().until(highPrioElectionTriggered::get);
    Awaitility.await().until(lowPrioElectionTriggered::get);
    final var inorder = Mockito.inOrder(highPrioElectionTriggered, lowPrioElectionTriggered);
    inorder.verify(highPrioElectionTriggered).set(true);
    inorder.verify(lowPrioElectionTriggered).set(true);
}"
"@Test
public void testReadRandom() throws Exception {
    FileSystem fs = cluster.getFileSystem();
    long tStart = System.currentTimeMillis();
    bench.getConf().setLong(""test.io.skip.size"", 0);
    bench.randomReadTest(fs);
    long execTime = System.currentTimeMillis() - tStart;
    bench.analyzeResult(fs, TestType.TEST_TYPE_READ_RANDOM, execTime);
}"
"@Test
public void serverStatusUnthrottledIfJournalUtilizationIsLowerThanThreshold() throws Exception {
    serverStatus.throttle();
    final Size segmentSize = Size.kilobytes(1L);
    final KafkaJournal journal = new KafkaJournal(journalDirectory, scheduler, segmentSize, Duration.standardSeconds(1L), Size.kilobytes(4L), Duration.standardSeconds(1L), 1000000, Duration.standardSeconds(1L), 90, new MetricRegistry(), serverStatus);
    journal.flushDirtyLogs();
    journal.cleanupLogs();
    assertThat(serverStatus.getLifecycle()).isEqualTo(RUNNING);
}"
"public void test_for_issue() throws Exception {
    Multimap<String,String> multimap=ArrayListMultimap.create();
    multimap.put(""admin"",""admin.create"");
    multimap.put(""admin"",""admin.update"");
    multimap.put(""admin"",""admin.delete"");
    multimap.put(""user"",""user.create"");
    multimap.put(""user"",""user.delete"");
    String json=JSON.toJSONString(multimap,SerializerFeature.MapSortField);
    assertEquals(""{\""admin\"":[\""admin.create\"",\""admin.update\"",\""admin.delete\""],\""user\"":[\""user.create\"",\""user.delete\""]}"",json);
    ArrayListMultimap multimap1=JSON.parseObject(json,ArrayListMultimap.class);
    assertEquals(multimap.size(),multimap1.size());
    assertEquals(json,JSON.toJSONString(multimap1,SerializerFeature.MapSortField));
}"
"public void test_for_issue(){
    org.json.JSONObject req=new org.json.JSONObject();
    SerializeConfig config=new SerializeConfig();
    config.register(new myModule());
    req.put(""id"",1111);
    req.put(""name"",""name11"");
    String text=JSON.toJSONString(req,SerializerFeature.SortField);
    Assert.assertEquals(""{\""id\"":1111,\""name\"":\""name11\""}"",text);
}"
"@Test public void acrossParametersOfSameArrayType() throws Exception {
    assertThat(testResult(ParametersOfSameArrayType.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ParametersOfSameArrayType.iterations);
    ParametersOfSameArrayType.iterations=0;
}"
"/**
* Binds an entry and then do lookups with several permissions
* @throws Exception
*/
@Test public void testPermissions() throws Exception {
    final NamingContext namingContext=new NamingContext(store,null);
    final String name=""a/b"";
    final Object value=new Object();
    ArrayList<JndiPermission> permissions=new ArrayList<JndiPermission>();
    WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);
    try {
        permissions.add(new JndiPermission(store.getBaseName() + ""/"" + name,""bind,list,listBindings""));
        Name nameObj=new CompositeName(name);
        store.bind(nameObj,value);
        store.lookup(nameObj);
    }
    finally {
        WritableServiceBasedNamingStore.popOwner();
    }
    permissions.set(0,new JndiPermission(store.getBaseName() + ""/"" + name,JndiPermission.ACTION_LOOKUP));
    assertEquals(value,testActionWithPermission(JndiPermission.ACTION_LOOKUP,permissions,namingContext,name));
    permissions.set(0,new JndiPermission(store.getBaseName() + ""/-"",JndiPermission.ACTION_LOOKUP));
    assertEquals(value,testActionWithPermission(JndiPermission.ACTION_LOOKUP,permissions,namingContext,name));
    permissions.set(0,new JndiPermission(store.getBaseName() + ""/a/*"",JndiPermission.ACTION_LOOKUP));
    assertEquals(value,testActionWithPermission(JndiPermission.ACTION_LOOKUP,permissions,namingContext,name));
    permissions.set(0,new JndiPermission(store.getBaseName() + ""/a/-"",JndiPermission.ACTION_LOOKUP));
    assertEquals(value,testActionWithPermission(JndiPermission.ACTION_LOOKUP,permissions,namingContext,name));
    permissions.set(0,new JndiPermission(""<<ALL BINDINGS>>"",JndiPermission.ACTION_LOOKUP));
    assertEquals(value,testActionWithPermission(JndiPermission.ACTION_LOOKUP,permissions,namingContext,name));
    permissions.set(0,new JndiPermission(store.getBaseName() + ""/"" + name,JndiPermission.ACTION_LOOKUP));
    assertEquals(value,testActionWithPermission(JndiPermission.ACTION_LOOKUP,permissions,namingContext,store.getBaseName() + ""/"" + name));
    NamingContext aNamingContext=(NamingContext)namingContext.lookup(""a"");
    permissions.set(0,new JndiPermission(store.getBaseName() + ""/"" + name,JndiPermission.ACTION_LOOKUP));
    assertEquals(value,testActionWithPermission(JndiPermission.ACTION_LOOKUP,permissions,aNamingContext,""b""));
    try {
        testActionWithPermission(JndiPermission.ACTION_LOOKUP,Collections.<JndiPermission>emptyList(),namingContext,name);
        fail(""Should have failed due to missing permission"");
    }
    catch (  AccessControlException e) {
    }
    try {
        permissions.set(0,new JndiPermission(store.getBaseName() + ""/*"",JndiPermission.ACTION_LOOKUP));
        testActionWithPermission(JndiPermission.ACTION_LOOKUP,permissions,namingContext,name);
        fail(""Should have failed due to missing permission"");
    }
    catch (  AccessControlException e) {
    }
    try {
        permissions.set(0,new JndiPermission(name,JndiPermission.ACTION_LOOKUP));
        testActionWithPermission(JndiPermission.ACTION_LOOKUP,permissions,namingContext,name);
        fail(""Should have failed due to missing permission"");
    }
    catch (  AccessControlException e) {
    }
    if (!""java:"".equals(store.getBaseName().toString())) {
        try {
            permissions.set(0,new JndiPermission(""/"" + name,JndiPermission.ACTION_LOOKUP));
            testActionWithPermission(JndiPermission.ACTION_LOOKUP,permissions,namingContext,name);
            fail(""Should have failed due to missing permission"");
        }
        catch (    AccessControlException e) {
        }
        try {
            permissions.set(0,new JndiPermission(""/-"",JndiPermission.ACTION_LOOKUP));
            testActionWithPermission(JndiPermission.ACTION_LOOKUP,permissions,namingContext,name);
            fail(""Should have failed due to missing permission"");
        }
        catch (    AccessControlException e) {
        }
    }
}"
"@Test public void explicitConversion(){
    assertThat(testResult(ExplicitConversion.class),isSuccessful());
    assertEquals(2,ExplicitConversion.iterations);
    assertEquals(new HashSet<>(asList(LocalDate.of(2017,1,1),LocalDate.of(2001,12,25))),ExplicitConversion.testCases);
    ExplicitConversion.iterations=0;
    ExplicitConversion.testCases.clear();
}"
"@Test
public void testHftpCustomDefaultPorts() throws IOException {
    resetFileSystem();
    Configuration conf = new Configuration();
    conf.setInt(""dfs.http.port"", 123);
    conf.setInt(""dfs.https.port"", 456);
    URI uri = URI.create();
    HftpFileSystem fs = ((HftpFileSystem) (FileSystem.get(uri, conf)));
    assertEquals(123, fs.getDefaultPort());
    assertEquals(456, fs.getDefaultSecurePort());
    assertEquals(uri, fs.getUri());
    assertEquals(""127.0.0.1:456"", fs.getCanonicalServiceName());
}"
"public void test_6() throws Exception {
    JSONObject jsonObject=new JSONObject();
    jsonObject.put(""val"",new Character[]{});
    jsonObject.put(""cls"",java.lang.Number.class);
    jsonObject.put(""nums"",new java.lang.Number[]{});
    ByteArrayOutputStream bytesOut=new ByteArrayOutputStream();
    ObjectOutputStream objOut=new ObjectOutputStream(bytesOut);
    objOut.writeObject(jsonObject);
    objOut.flush();
    byte[] bytes=bytesOut.toByteArray();
    ByteArrayInputStream bytesIn=new ByteArrayInputStream(bytes);
    ObjectInputStream objIn=new ObjectInputStream(bytesIn);
    Object obj=objIn.readObject();
    assertEquals(JSONObject.class,obj.getClass());
    assertEquals(JSON.toJSONString(jsonObject,SerializerFeature.MapSortField),JSON.toJSONString(obj,SerializerFeature.MapSortField));
}"
"@Test
public void testUnbind() throws Exception {
    final Name name = new CompositeName(""test"");
    final Object value = new Object();
    namingStore.bind(name, value);
    namingContext.unbind(name);
    try {
        namingStore.lookup(name);
        fail(""Should have thrown name not found"");
    } catch (NameNotFoundException expect) {}
    testActionPermission(JndiPermission.ACTION_BIND, namingContext, ""test"", value);
    testActionPermission(JndiPermission.ACTION_UNBIND, namingContext, ""test"");
    try {
        namingStore.lookup(name);
        fail(""Should have thrown name not found"");
    } catch (NameNotFoundException expect) {}
}"
"public void test_reserve() throws Exception {
    JSONObject object=JSON.parseObject(""{\""id\"":1001,\""name\"":\""ljw\"",\""age\"":50}"");
    assertEquals(""[1001,\""ljw\""]"",JSONPath.reserveToArray(object,""id"",""name"").toString());
    assertEquals(""[\""ljw\"",1001]"",JSONPath.reserveToArray(object,""name"",""id"").toString());
    String text=JSON.toJSONString(JSONPath.reserveToArray(object,""name"",""*""),SerializerFeature.MapSortField);
    assertTrue(text.equals(""[\""ljw\"",[\""ljw\"",1001,50]]"") || text.equals(""[\""ljw\"",[\""ljw\"",50,1001]]"") || text.equals(""[\""ljw\"",[50,1001,\""ljw\""]]"")|| text.equals(""[\""ljw\"",[1001,50,\""ljw\""]]"")|| text.equals(""[\""ljw\"",[1001,\""ljw\"",50]]"")|| text.equals(""[\""ljw\"",[50,\""ljw\"",1001]]""));
}"
"@Test
@Test(dependsOnMethods = ""testCreateJob"")
public void testGetJobListFromRoot() {
    JobList output = api().jobList("""");
    assertNotNull(output);
    assertFalse(output.jobs().isEmpty());
    assertEquals(output.jobs().size(), 2);
}"
"@Test public void acrossParametersOfSameParameterizedType() throws Exception {
    assertThat(testResult(ParametersOfSameParameterizedType.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ParametersOfSameParameterizedType.iterations);
    ParametersOfSameParameterizedType.iterations=0;
}"
"@Test
public void testSubscribeRate() throws Exception {
    SubscribeRate subscribeRate = new SubscribeRate(1, 5);
    String namespace = ""my-tenants/my-namespace"";
    admin.tenants().createTenant(""my-tenants"", new TenantInfoImpl(Sets.newHashSet(), Sets.newHashSet(testLocalCluster)));
    admin.namespaces().createNamespace(namespace, Sets.newHashSet(testLocalCluster));
    admin.namespaces().setSubscribeRate(namespace, subscribeRate);
    assertEquals(subscribeRate, admin.namespaces().getSubscribeRate(namespace));
    String topicName = ((""persistent""));
    admin.topics().createPartitionedTopic(topicName, 2);
    pulsar.getConfiguration().setAuthorizationEnabled(false);
    Consumer<?> consumer = pulsarClient.newConsumer().topic(topicName).subscriptionType(Shared).subscriptionName(""subscribe-rate"").subscribe();
    assertTrue(consumer.isConnected());
    pulsarClient.updateServiceUrl(lookupUrl.toString());
    Awaitility.await().untilAsserted(() -> assertFalse(consumer.isConnected()));
    Thread.sleep(6000L);
    pulsarClient.updateServiceUrl(lookupUrl.toString());
    assertTrue(consumer.isConnected());
    subscribeRate = new SubscribeRate(0, 10);
    admin.namespaces().setSubscribeRate(namespace, subscribeRate);
    pulsarClient.updateServiceUrl(lookupUrl.toString());
    Awaitility.await().untilAsserted(() -> assertTrue(consumer.isConnected()));
    pulsar.getConfiguration().setAuthorizationEnabled(true);
    admin.topics().deletePartitionedTopic(topicName, true);
    admin.namespaces().deleteNamespace(namespace);
    admin.tenants().deleteTenant(""my-tenants"");
}"
"@Test
public void testReadWithTimeoutInterleaved() {
    int space = 0xfd;
    long address = 0x12345678;
    int length = 4;
    MemoryConfigurationService.McsReadHandler hnd = mock(McsReadHandler.class);
    MemoryConfigurationService.McsReadHandler hnd2 = mock(McsReadHandler.class);
    iface.getDatagramMeteringBuffer().setTimeout(30);
    iface.getMemoryConfigurationService().setTimeoutMillis(30);
    {
        iface.getMemoryConfigurationService().requestRead(farID, space, address, length, hnd);
        expectMessageAndNoMore(new DatagramMessage(hereID, farID, new int[]{ 0x20, 0x41, 0x12, 0x34, 0x56, 0x78, 4 }));
        System.err.println(""Expect 'Never received reply' here -->"");
        delay(50);
        System.err.println(""<--"");
        verify(hnd).handleFailure(0x100);
        verifyNoMoreInteractions(hnd);
        iface.getMemoryConfigurationService().requestRead(farID, space, address + 1, length, hnd2);
        expectMessageAndNoMore(new DatagramMessage(hereID, farID, new int[]{ 0x20, 0x41, 0x12, 0x34, 0x56, 0x79, 4 }));
        sendMessage(new DatagramAcknowledgedMessage(farID, hereID, 0x80));
        consumeMessages();
        sendMessage(new DatagramRejectedMessage(farID, hereID, 0x2020));
        consumeMessages();
        System.err.println(""Expect 'unexpected response datagram' here -->"");
        sendMessageAndExpectResult(new DatagramMessage(farID, hereID, new int[]{ 0x20, 0x51, 0x12, 0x34, 0x56, 0x78, 0xaa }), new DatagramAcknowledgedMessage(hereID, farID));
        System.err.println(""<--"");
        expectNoMessages();
        delay(50);
        expectMessageAndNoMore(new DatagramMessage(hereID, farID, new int[]{ 0x20, 0x41, 0x12, 0x34, 0x56, 0x79, 4 }));
        sendMessage(new DatagramAcknowledgedMessage(farID, hereID, 0x80));
        consumeMessages();
        sendMessage(new DatagramAcknowledgedMessage(farID, hereID, 0x80));
        consumeMessages();
        sendMessageAndExpectResult(new DatagramMessage(farID, hereID, new int[]{ 0x20, 0x51, 0x12, 0x34, 0x56, 0x79, 0xaa }), new DatagramAcknowledgedMessage(hereID, farID));
        verify(hnd2).handleReadData(farID, space, address + 1, new byte[]{ ((byte) (0xaa)) });
        verifyNoMoreInteractions(hnd2);
    }
    System.err.println(""Sending another request..."");
    sendAnother(space, address + 5);
}"
"@Test
public void testGetPartialRepairTasks() {
    Node node = mockNode(""DC1"");
    Node node2 = mockNode(""DC1"");
    ImmutableList<LongTokenRange> vnodes = ImmutableList.of(new LongTokenRange(1, 2), new LongTokenRange(2, 3), new LongTokenRange(4, 5));
    ReplicaRepairGroup replicaRepairGroup = new ReplicaRepairGroup(ImmutableSet.of(node, node2), vnodes);
    RepairGroup repairGroup = builderFor(replicaRepairGroup).build(priority);
    Collection<RepairTask> tasks = repairGroup.getRepairTasks();
    assertThat(tasks.size()).isEqualTo(3);
    Set<LongTokenRange> repairTaskRanges = new HashSet<>();
    for (RepairTask repairTask : tasks) {
        assertThat(repairTask.getTokenRanges().size()).isEqualTo(1);
        LongTokenRange range = repairTask.getTokenRanges().iterator().next();
        repairTaskRanges.add(range);
        assertThat(repairTask.getReplicas()).containsExactlyInAnyOrder(node, node2);
        assertThat(repairTask.getTableReference()).isEqualTo(tableReference);
        assertThat(repairTask.getRepairConfiguration().getRepairParallelism()).isEqualTo(PARALLEL);
    }
    assertThat(repairTaskRanges).containsExactlyElementsOf(vnodes);
}"
"@Test
public void testErrorNotGzipped() throws Exception {
    Header[] headers = new Header[2];
    headers[0] = new Header(""Accept"", Constants.MIMETYPE_BINARY);
    headers[1] = new Header(""Accept-Encoding"", ""gzip"");
    Response response = client.get(((((""/"" + TABLE) + ""/"") + ROW_1) + ""/"") + COLUMN_2, headers);
    assertEquals(response.getCode(), 404);
    String contentEncoding = response.getHeader(""Content-Encoding"");
    assertTrue((contentEncoding == null) || (!contentEncoding.contains(""gzip"")));
    response = client.get(""/"" + TABLE, headers);
    assertEquals(response.getCode(), 405);
    contentEncoding = response.getHeader(""Content-Encoding"");
    assertTrue((contentEncoding == null) || (!contentEncoding.contains(""gzip"")));
}"
"@Test public void primitiveChars() throws Exception {
    assertThat(testResult(PrimitiveChars.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveChars.iterations);
    PrimitiveChars.iterations=0;
}"
"/**
* Test a class that defines an ivar pointing to itself.  This test was created to show that handling cyclical object resulted in a missing endFieldSeparator call.
*/
@Test public void testSelfInstanceTwoVarsReflectionObjectCycle(){
    final SelfInstanceTwoVarsReflectionTestFixture test=new SelfInstanceTwoVarsReflectionTestFixture();
    assertEquals(this.toBaseString(test) + ""[otherType="" + test.getOtherType().toString()+ "",typeIsSelf=""+ this.toBaseString(test)+ ""]"",test.toString());
}"
"@Test public void wrapperBytes() throws Exception {
    assertThat(testResult(WrapperBytes.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperBytes.iterations);
    assertEquals(new HashSet<>(asList((byte)14,(byte)-15)),new HashSet<>(WrapperBytes.values.subList(0,2)));
    WrapperBytes.iterations=0;
}"
"@Test
public void testPrematureTimeout() throws Exception {
    final AtomicBoolean failed = new AtomicBoolean(false);
    MockVolt volt = new MockVolt(20000);
    volt.start();
    Distributer dist = new Distributer(false,
    ClientConfig.DEFAULT_PROCEDURE_TIMOUT_NANOS,
    2000,
    false, null);
    dist.addClientStatusListener(new TimeoutMonitorCSL());
    dist.createConnection(""localhost"", """", """", 20000);
    assertTrue(volt.handler != null);
    long start = System.currentTimeMillis();
    while ((System.currentTimeMillis() - start) < 3000) {
        Thread.yield();
    }
    volt.handler.sendResponses.set(false);
    start = System.currentTimeMillis();
    while (!failed.get()) {
        if ((System.currentTimeMillis() - start) > 2000) {
            break;
        } else {
            Thread.yield();
        }
    }
    if ((System.currentTimeMillis() - start) < 2000) {
    fail(""Premature timeout occurred""); }
    dist.shutdown();
    volt.shutdown();
}"
"@Test public void expectedOrderingOfMethods() throws Exception {
    assertThat(testResult(Leaf.class),isSuccessful());
    assertEquals(resourceAsString(""subclass-property-test-expected.txt""),bytesOut.toString().replaceAll(System.lineSeparator(),""\r\n""));
}"
"@Test void scanShouldIterateOverAvailableEntries(){
    adapter.put(""1"",object1,COLLECTION_1);
    adapter.put(""2"",object2,COLLECTION_1);
    CloseableIterator<Map.Entry<Object,Object>> iterator=adapter.entries(COLLECTION_1);
    Map.Entry<Object,Object> entry1=iterator.next();
    Map.Entry<Object,Object> entry2=iterator.next();
    if (entry1.getKey().equals(""1"")) {
        assertThat(entry1).isEqualTo(new AbstractMap.SimpleEntry<>(""1"",object1));
        assertThat(entry2).isEqualTo(new AbstractMap.SimpleEntry<>(""2"",object2));
    }
    else {
        assertThat(entry2).isEqualTo(new AbstractMap.SimpleEntry<>(""2"",object2));
        assertThat(entry1).isEqualTo(new AbstractMap.SimpleEntry<>(""1"",object1));
    }
    assertThat(iterator.hasNext()).isFalse();
}"
"@Test
public void testFromDbField() throws Exception {
    Field[] fields = Foo.class.getDeclaredFields();
    assertTrue(fields.length >= 1);
    DatabaseFieldConfig config = DatabaseFieldConfig.fromField(databaseType, ""foo"", fields[0]);
    assertNotNull(config);
    assertTrue(config.isCanBeNull());
    assertEquals(fields[0].getName(), config.getFieldName());
}"
"@Test public void wrapperFloats(){
    assertThat(testResult(WrapperFloats.class),isSuccessful());
    assertEquals(2,WrapperFloats.iterations);
    assertEquals(new HashSet<>(asList(1.7F,-4.14F)),WrapperFloats.testCases);
    WrapperFloats.iterations=0;
}"
"@Test
public void testLookupEmptyName() throws Exception {
    Object result = namingContext.lookup(new CompositeName());
    assertTrue(result instanceof NamingContext);
    result = namingContext.lookup(new CompositeName(""""));
    assertTrue(result instanceof NamingContext);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, null);
    assertTrue(result instanceof NamingContext);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, """");
    assertTrue(result instanceof NamingContext);
}"
"@Test public void testPartialRepair() throws InterruptedException {
    Collection<LongTokenRange> ranges=new ArrayList<>();
    LongTokenRange range1=new LongTokenRange(1,2);
    LongTokenRange range2=new LongTokenRange(3,4);
    ranges.add(range1);
    ranges.add(range2);
    final RepairTask repairTask=new RepairTask.Builder().withJMXProxyFactory(jmxProxyFactory).withTableReference(myTableReference).withTokenRanges(ranges).withTableRepairMetrics(myTableRepairMetrics).withRepairHistory(repairHistory).withJobId(jobId).withReplicas(participants).build();
    CountDownLatch cdl=startRepair(repairTask,false);
    Notification notification=new Notification(""progress"",""repair:1"",0,getRepairMessage(range1));
    notification.setUserData(getNotificationData(RepairTask.ProgressEventType.PROGRESS.ordinal(),1,2));
    proxy.notify(notification);
    notification=new Notification(""progress"",""repair:1"",1,getRepairMessage(range2));
    notification.setUserData(getNotificationData(RepairTask.ProgressEventType.PROGRESS.ordinal(),2,2));
    proxy.notify(notification);
    notification=new Notification(""progress"",""repair:1"",2,""Done with repair"");
    notification.setUserData(getNotificationData(RepairTask.ProgressEventType.COMPLETE.ordinal(),2,2));
    proxy.notify(notification);
    cdl.await();
    assertThat(repairTask.getUnknownRanges()).isNull();
    assertThat(repairTask.getCompletedRanges()).containsExactlyInAnyOrderElementsOf(ranges);
    assertThat(proxy.myOptions.get(RepairOptions.RANGES_KEY)).isNotEmpty();
    verify(myTableRepairMetrics).repairTiming(eq(TABLE_REFERENCE),anyLong(),any(TimeUnit.class),eq(true));
    verify(repairSessions.get(range1)).start();
    verify(repairSessions.get(range2)).start();
    verify(repairSessions.get(range1)).finish(eq(RepairStatus.SUCCESS));
    verify(repairSessions.get(range2)).finish(eq(RepairStatus.SUCCESS));
}"
"public void test_set() throws Exception {
    Set<Object> set=new LinkedHashSet<Object>();
    set.add(3L);
    set.add(4L);
    Entity entity=new Entity();
    entity.setValue(set);
    String text=JSON.toJSONString(entity,SerializerFeature.WriteClassName);
    System.out.println(text);
    Assert.assertEquals(""{\""@type\"":\""com.alibaba.json.bvt.bug.Bug_for_smoothrat6$Entity\"",\""value\"":Set[3L,4L]}"",text);
    Entity entity2=JSON.parseObject(text,Entity.class);
    Assert.assertEquals(set,entity2.getValue());
}"
"@Test public void doubleArray(){
    final WithArrays wa=new WithArrays();
    wa.doubleArray=new double[]{1,2};
    final String exp=getClassPrefix(wa) + ""["" + BR+ ""  boolArray=<null>,""+ BR+ ""  charArray=<null>,""+ BR+ ""  doubleArray={""+ BR+ ""    1.0,""+ BR+ ""    2.0""+ BR+ ""  },""+ BR+ ""  intArray=<null>,""+ BR+ ""  longArray=<null>,""+ BR+ ""  stringArray=<null>""+ BR+ ""]"";
    assertEquals(exp,toString(wa));
}"
"@Test
public void testBrokerSelectionForAntiAffinityGroup() throws Exception {
    final String broker1 = primaryHost;
    final String broker2 = secondaryHost;
    final String cluster = pulsar1.getConfiguration().getClusterName();
    final String tenant = ""tenant-"" + UUID.randomUUID().toString();
    final String namespace1 = ((tenant + ""/"") + cluster) + ""/ns1"";
    final String namespace2 = ((tenant + ""/"") + cluster) + ""/ns2"";
    final String namespaceAntiAffinityGroup = ""group"";
    FailureDomain domain1 = new FailureDomain();
    domain1.brokers = Sets.newHashSet(broker1);
    admin1.clusters().createFailureDomain(cluster, ""domain1"", domain1);
    FailureDomain domain2 = new FailureDomain();
    domain2.brokers = Sets.newHashSet(broker2);
    admin1.clusters().createFailureDomain(cluster, ""domain2"", domain2);
    admin1.tenants().createTenant(tenant, new TenantInfo(null, Sets.newHashSet(cluster)));
    admin1.namespaces().createNamespace(namespace1);
    admin1.namespaces().createNamespace(namespace2);
    admin1.namespaces().setNamespaceAntiAffinityGroup(namespace1, namespaceAntiAffinityGroup);
    admin1.namespaces().setNamespaceAntiAffinityGroup(namespace2, namespaceAntiAffinityGroup);
    for (int i = 0; i < 5; i++) {
        if ((!isLoadManagerUpdatedDomainCache(primaryLoadManager)) || (!isLoadManagerUpdatedDomainCache(secondaryLoadManager))) {
            Thread.sleep(200);
        } else {
            break;
        }
    }
    assertTrue(isLoadManagerUpdatedDomainCache(primaryLoadManager));
    assertTrue(isLoadManagerUpdatedDomainCache(secondaryLoadManager));
    ServiceUnitId serviceUnit1 = makeBundle(tenant, cluster, ""ns1"");
    String selectedBroker1 = primaryLoadManager.selectBrokerForAssignment(serviceUnit1).get();
    ServiceUnitId serviceUnit2 = makeBundle(tenant, cluster, ""ns2"");
    String selectedBroker2 = primaryLoadManager.selectBrokerForAssignment(serviceUnit2).get();
    assertNotEquals(selectedBroker1, selectedBroker2);
}"
"@Test
public void testReadBackward() throws Exception {
    FileSystem fs = cluster.getFileSystem();
    long tStart = System.currentTimeMillis();
    bench.getConf().setLong(""test.io.skip.size"", -DEFAULT_BUFFER_SIZE);
    bench.randomReadTest(fs);
    long execTime = System.currentTimeMillis() - tStart;
    bench.analyzeResult(fs, TestType.TEST_TYPE_READ_BACKWARD, execTime);
}"
"@Test
public void testLookupWithContinuation() throws Exception {
    namingStore.bind(new CompositeName(""comp/nested""), ""test"");
    final Reference reference = new Reference(String.class.getName(), new StringRefAddr(""nns"", ""comp""), TestObjectFactoryWithNameResolution.class.getName(), null);
    namingStore.bind(new CompositeName(""test""), reference);
    Object result = namingContext.lookup(new CompositeName(""test/nested""));
    assertEquals(""test"", result);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, Arrays.asList(new JndiPermission(""comp/nested"", ""lookup"")), namingContext, ""test/nested"");
    assertEquals(""test"", result);
}"
"@Test public void longArray(){
    final WithArrays wa=new WithArrays();
    wa.longArray=new long[]{1L,2L};
    final String exp=getClassPrefix(wa) + ""["" + BR+ ""  boolArray=<null>,""+ BR+ ""  charArray=<null>,""+ BR+ ""  doubleArray=<null>,""+ BR+ ""  intArray=<null>,""+ BR+ ""  longArray={""+ BR+ ""    1,""+ BR+ ""    2""+ BR+ ""  },""+ BR+ ""  stringArray=<null>""+ BR+ ""]"";
    assertEquals(exp,toString(wa));
}"
"@Test
void scanShouldIterateOverAvailableEntries() {
    adapter.put(""1"", object1, COLLECTION_1);
    adapter.put(""2"", object2, COLLECTION_1);
    CloseableIterator<Map.Entry<Object, Object>> iterator = adapter.entries(COLLECTION_1);
    assertThat(iterator.next()).isEqualTo(new AbstractMap.SimpleEntry<>(""1"", object1));
    assertThat(iterator.next()).isEqualTo(new AbstractMap.SimpleEntry<>(""2"", object2));
    assertThat(iterator.hasNext()).isFalse();
}"
"@Test
public void testStartStop() {
    final KafkaStream<String, String> kafkaStream = PowerMock.createStrictMock(KafkaStream.class);
    final ConsumerIterator<String, String> consumerIterator = PowerMock.createStrictMock(ConsumerIterator.class);
    final ConsumerConnector consumerConnector = PowerMock.createStrictMock(ConsumerConnector.class);
    EasyMock.expect(consumerConnector.createMessageStreamsByFilter(EasyMock.anyObject(TopicFilter.class), EasyMock.anyInt(), EasyMock.eq(DEFAULT_STRING_DECODER), EasyMock.eq(DEFAULT_STRING_DECODER))).andReturn(ImmutableList.of(kafkaStream)).once();
    EasyMock.expect(kafkaStream.iterator()).andReturn(consumerIterator).anyTimes();
    EasyMock.expect(consumerIterator.hasNext()).andAnswer(getBlockingAnswer()).anyTimes();
    EasyMock.expect(cacheManager.createCache()).andReturn(cacheHandler).once();
    EasyMock.expect(cacheHandler.getCache()).andReturn(new ConcurrentHashMap<String, String>()).once();
    cacheHandler.close();
    EasyMock.expectLastCall();
    final AtomicBoolean threadWasInterrupted = new AtomicBoolean(false);
    consumerConnector.shutdown();
    EasyMock.expectLastCall().andAnswer(new IAnswer<Object>() {
        @Override
        public Object answer() {
            threadWasInterrupted.set(Thread.currentThread().isInterrupted());
            return null;
        }
    }).times(2);
    PowerMock.replay(cacheManager, cacheHandler, kafkaStream, consumerConnector, consumerIterator);
    final KafkaLookupExtractorFactory factory = new KafkaLookupExtractorFactory(cacheManager, TOPIC, ImmutableMap.of(""zookeeper.connect"", ""localhost""), 10000L, false) {
        @Override
        ConsumerConnector buildConnector(Properties properties) {
            return consumerConnector;
        }
    };
    Assert.assertTrue(factory.start());
    Assert.assertTrue(factory.close());
    Assert.assertTrue(factory.getFuture().isDone());
    Assert.assertFalse(threadWasInterrupted.get());
    PowerMock.verify(cacheManager, cacheHandler);
}"
"@Test
public void executeTransactionAsync_callbacksShouldBeClearedBeforeCalling() {
    final AtomicInteger callbackCounter = new AtomicInteger(0);
    final Realm foregroundRealm = looperThread.getRealm();
    foregroundRealm.setAutoRefresh(false);
    foregroundRealm.executeTransactionAsync(new Realm.Transaction() {
        @Override
        public void execute(Realm realm) {
            realm.createObject(AllTypes.class);
        }
    }, new Realm.Transaction.OnSuccess() {
        @Override
        public void onSuccess() {
            assertEquals(0, callbackCounter.getAndIncrement());
            foregroundRealm.beginTransaction();
            foregroundRealm.createObject(AllTypes.class);
            foregroundRealm.commitTransaction();
        }
    });
    foregroundRealm.executeTransactionAsync(new Realm.Transaction() {
        @Override
        public void execute(Realm realm) {
            realm.createObject(AllTypes.class);
            looperThread.postRunnableDelayed(new Runnable() {
                @Override
                public void run() {
                    foregroundRealm.sharedRealm.refresh();
                    foregroundRealm.setAutoRefresh(true);
                }
            }, 50);
        }
    }, new Realm.Transaction.OnSuccess() {
        @Override
        public void onSuccess() {
            assertEquals(1, callbackCounter.getAndIncrement());
            looperThread.testComplete();
        }
    });
}"
"@Test
public void testRecordWithJsr310LogicalTypes() throws IOException {
    TestRecordWithJsr310LogicalTypes record = new TestRecordWithJsr310LogicalTypes(
    true,
    34,
    35L,
    3.14F,
    3019.34,
    null,
    java.time.LocalDate.now(),
    java.time.LocalTime.now().truncatedTo(ChronoUnit.MILLIS),
    java.time.Instant.now().truncatedTo(ChronoUnit.MILLIS),
    new BigDecimal(123.45f).setScale(2, BigDecimal.ROUND_HALF_DOWN)
    );
    File data = write(TestRecordWithJsr310LogicalTypes.getClassSchema(), record);
    List<TestRecordWithJsr310LogicalTypes> actual = read(
    TestRecordWithJsr310LogicalTypes.getClassSchema(), data);
    Assert.assertEquals(""Should match written record"", record, actual.get(0));
}"
"@Test public void wrapperLongs() throws Exception {
    assertThat(testResult(WrapperLongs.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperLongs.iterations);
    assertEquals(new HashSet<>(asList(10L,11L,12L)),new HashSet<>(WrapperLongs.values.subList(0,3)));
    WrapperLongs.iterations=0;
}"
"@Test
public void test_date() throws Exception {
    Date date1 = JSON.parseObject(""{\""gmtCreate\"":\""2018-09-12\""}"", VO.class).getGmtCreate();
    assertNotNull(date1);
    Date date2 = JSON.parseObject(""{\""gmtCreate\"":\""2018-09-12T15:10:19+00:00\""}"", VO.class).getGmtCreate();
    Date date3 = JSON.parseObject(""{\""gmtCreate\"":\""2018-09-12T15:10:19Z\""}"", VO.class).getGmtCreate();
    Date date4 = JSON.parseObject(""{\""gmtCreate\"":\""20180912T151019Z\""}"", VO.class).getGmtCreate();
    Date date5 = JSON.parseObject(""{\""gmtCreate\"":\""2018-09-12T15:10:19Z\""}"", VO.class).getGmtCreate();
    Date date6 = JSON.parseObject(""{\""gmtCreate\"":\""20180912\""}"", VO.class).getGmtCreate();
    long delta_2_1 = date2.getTime() - date1.getTime();
    assertEquals(83419000, delta_2_1);
    long delta_3_1 = date3.getTime() - date1.getTime();
    assertEquals(83419000, delta_3_1);
    long delta_4_3 = date4.getTime() - date3.getTime();
    assertEquals(0, delta_4_3);
    long delta_5_4 = date5.getTime() - date4.getTime();
    assertEquals(0, delta_5_4);
    long delta_6_1 = date6.getTime() - date1.getTime();
    assertEquals(0, delta_6_1);
}"
"@Test
public void testUnsubscribe() throws Exception {
    PullPoint pullPoint = wsnCreatePullPoint.createPullPoint();
    Subscription subscription = wsnBroker.subscribe(pullPoint.getEndpoint(), ""myTopic"", null);
    wsnBroker.notify(""myTopic"", new Notify());
    Thread.sleep(500);
    assertEquals(1, pullPoint.getMessages(0).size());
    subscription.unsubscribe();
    wsnBroker.notify(""myTopic"", new Notify());
    Thread.sleep(500);
    assertEquals(0, pullPoint.getMessages(0).size());
    Thread.sleep(500);
}"
"public void test_for_issue() throws Exception {
    DataSimpleVO a=new DataSimpleVO(""a"",1);
    DataSimpleVO b=new DataSimpleVO(""b"",2);
    b.value=a;
    Map<String,Object> map=new HashMap<String,Object>();
    map.put(a.name,a);
    b.value1=map;
    String jsonStr=JSON.toJSONString(b,SerializerFeature.MapSortField);
    System.out.println(jsonStr);
    DataSimpleVO obj=JSON.parseObject(jsonStr,DataSimpleVO.class);
    assertEquals(jsonStr,JSON.toJSONString(obj,SerializerFeature.MapSortField));
}"
"@Test
public void manyParameters() throws Exception {
    assertThat(testResult(ManyParameters.class), isSuccessful());
    assertEquals(6, ManyParameters.iterations);
    assertEquals(asList(-1, -2, -4, -1, -2, -4), ManyParameters.firstTestCases);
    assertEquals(asList('r', 'r', 'r', 'y', 'y', 'y'), ManyParameters.secondTestCases);
}"
"@Test public void strings(){
    assertThat(testResult(Strings.class),isSuccessful());
    assertEquals(2,Strings.iterations);
    assertEquals(new HashSet<>(asList(""some"",""values"")),Strings.testCases);
    Strings.iterations=0;
    Strings.testCases.clear();
}"
"@Test public void orderingOfStatements(){
    assertThat(testResult(PropertyBasedTests.class),isSuccessful());
    assertEquals(expectedStatements,PropertyBasedTests.LOGS);
    PropertyBasedTests.clearLogs();
}"
"@Test public void explicitGeneratorTakesPrecedence(){
    assertThat(testResult(WithExplicitGenerator.class),isSuccessful());
    assertEquals(asList(0,1,2,3,4),WithExplicitGenerator.values);
    WithExplicitGenerator.values.clear();
}"
"@Test
public void testTopicLevelInactivePolicyUpdateAndClean() throws Exception {
    super.resetConfig();
    conf.setSystemTopicEnabled(true);
    conf.setTopicLevelPoliciesEnabled(true);
    conf.setBrokerDeleteInactiveTopicsEnabled(true);
    conf.setBrokerDeleteInactiveTopicsMaxInactiveDurationSeconds(1000);
    conf.setBrokerDeleteInactiveTopicsMode(delete_when_no_subscriptions);
    InactiveTopicPolicies defaultPolicy = new InactiveTopicPolicies(InactiveTopicDeleteMode.delete_when_no_subscriptions, 1000, true);
    super.baseSetup();
    Thread.sleep(2000);
    final String namespace = ""prop/ns-abc"";
    final String topic = ""persistent"";
    final String topic2 = ""persistent"";
    final String topic3 = ""persistent"";
    List<String> topics = Arrays.asList(topic, topic2, topic3);
    for (String tp : topics) {
        admin.topics().createNonPartitionedTopic(tp);
    }
    InactiveTopicPolicies inactiveTopicPolicies = new InactiveTopicPolicies(InactiveTopicDeleteMode.delete_when_no_subscriptions, 1, true);
    admin.topics().setInactiveTopicPolicies(topic, inactiveTopicPolicies);
    inactiveTopicPolicies.setInactiveTopicDeleteMode(delete_when_subscriptions_caught_up);
    admin.topics().setInactiveTopicPolicies(topic2, inactiveTopicPolicies);
    inactiveTopicPolicies.setInactiveTopicDeleteMode(delete_when_no_subscriptions);
    admin.topics().setInactiveTopicPolicies(topic3, inactiveTopicPolicies);
    for (int i = 0; i < 50; i++) {
        if (admin.topics().getInactiveTopicPolicies(topic) != null) {
            break;
        }
        Thread.sleep(100);
    }
    InactiveTopicPolicies policies = ((PersistentTopic) (pulsar.getBrokerService().getTopic(topic, false).get().get())).inactiveTopicPolicies;
    Assert.assertTrue(policies.isDeleteWhileInactive());
    assertEquals(policies.getInactiveTopicDeleteMode(), delete_when_no_subscriptions);
    assertEquals(policies.getMaxInactiveDurationSeconds(), 1);
    assertEquals(policies, admin.topics().getInactiveTopicPolicies(topic));
    admin.topics().removeInactiveTopicPolicies(topic);
    for (int i = 0; i < 50; i++) {
        if (admin.topics().getInactiveTopicPolicies(topic) == null) {
            break;
        }
        Thread.sleep(100);
    }
    assertEquals(((PersistentTopic) (pulsar.getBrokerService().getTopic(topic, false).get().get())).inactiveTopicPolicies, defaultPolicy);
    policies = ((PersistentTopic) (pulsar.getBrokerService().getTopic(topic2, false).get().get())).inactiveTopicPolicies;
    Assert.assertTrue(policies.isDeleteWhileInactive());
    assertEquals(policies.getInactiveTopicDeleteMode(), delete_when_subscriptions_caught_up);
    assertEquals(policies.getMaxInactiveDurationSeconds(), 1);
    assertEquals(policies, admin.topics().getInactiveTopicPolicies(topic2));
    inactiveTopicPolicies.setMaxInactiveDurationSeconds(999);
    admin.namespaces().setInactiveTopicPolicies(namespace, inactiveTopicPolicies);
    Thread.sleep(1000);
    admin.topics().removeInactiveTopicPolicies(topic2);
    for (int i = 0; i < 50; i++) {
        if (admin.topics().getInactiveTopicPolicies(topic2) == null) {
            break;
        }
        Thread.sleep(100);
    }
    InactiveTopicPolicies nsPolicies = ((PersistentTopic) (pulsar.getBrokerService().getTopic(topic2, false).get().get())).inactiveTopicPolicies;
    assertEquals(nsPolicies.getMaxInactiveDurationSeconds(), 999);
    super.internalCleanup();
}"
"@Test public void testRepairSuccessfully() throws InterruptedException {
    Collection<LongTokenRange> ranges=new ArrayList<>();
    LongTokenRange range1=new LongTokenRange(1,2);
    LongTokenRange range2=new LongTokenRange(3,4);
    ranges.add(range1);
    ranges.add(range2);
    final RepairTask repairTask=new RepairTask.Builder().withJMXProxyFactory(jmxProxyFactory).withTableReference(myTableReference).withTokenRanges(ranges).withTableRepairMetrics(myTableRepairMetrics).withRepairHistory(repairHistory).withJobId(jobId).withReplicas(participants).build();
    CountDownLatch cdl=startRepair(repairTask,false);
    Notification notification=new Notification(""progress"",""repair:1"",0,getRepairMessage(range1));
    notification.setUserData(getNotificationData(RepairTask.ProgressEventType.PROGRESS.ordinal(),1,2));
    proxy.notify(notification);
    notification=new Notification(""progress"",""repair:1"",1,getRepairMessage(range2));
    notification.setUserData(getNotificationData(RepairTask.ProgressEventType.PROGRESS.ordinal(),2,2));
    proxy.notify(notification);
    notification=new Notification(""progress"",""repair:1"",2,""Done with repair"");
    notification.setUserData(getNotificationData(RepairTask.ProgressEventType.COMPLETE.ordinal(),2,2));
    proxy.notify(notification);
    cdl.await();
    assertThat(repairTask.getUnknownRanges()).isNull();
    assertThat(repairTask.getCompletedRanges()).containsExactlyInAnyOrderElementsOf(ranges);
    assertThat(proxy.myOptions.get(RepairOptions.RANGES_KEY)).isNotEmpty();
    verify(myTableRepairMetrics).repairTiming(eq(TABLE_REFERENCE),anyLong(),any(TimeUnit.class),eq(true));
    verify(repairSessions.get(range1)).start();
    verify(repairSessions.get(range2)).start();
    verify(repairSessions.get(range1)).finish(eq(RepairStatus.SUCCESS));
    verify(repairSessions.get(range2)).finish(eq(RepairStatus.SUCCESS));
}"
"@Test
public void testRsReportsWrongServerName() throws Exception {
    MiniHBaseCluster cluster = TEST_UTIL.getHBaseCluster();
    MiniHBaseClusterRegionServer firstServer = ((MiniHBaseClusterRegionServer) (cluster.getRegionServer(0)));
    HRegionServer secondServer = cluster.getRegionServer(1);
    HServerInfo hsi = firstServer.getServerInfo();
    firstServer.setHServerInfo(new HServerInfo(hsi.getServerAddress(), hsi.getInfoPort(), hsi.getHostname()));
    Thread.sleep(2000);
    assertTrue(firstServer.isOnline());
    assertEquals(2, cluster.getLiveRegionServerThreads().size());
    secondServer.getHServerInfo().setServerAddress(new HServerAddress(""0.0.0.0"", 60010));
    Thread.sleep(2000);
    assertTrue(secondServer.isOnline());
    assertEquals(1, cluster.getLiveRegionServerThreads().size());
}"
"@Test public void primitiveBytes() throws Exception {
    assertThat(testResult(PrimitiveBytes.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveBytes.iterations);
    assertEquals(new HashSet<>(asList(Byte.valueOf(""12""),Byte.valueOf(""-13""))),new HashSet<>(PrimitiveBytes.values.subList(0,2)));
    PrimitiveBytes.iterations=0;
}"
"public void test_geo() throws Exception {
    String str=""{\n"" + ""    \""type\"": \""FeatureCollection\"",\n"" + ""    \""features\"": [{\n""+ ""       \""type\"": \""Feature\"",\n""+ ""       \""geometry\"": {\n""+ ""           \""type\"": \""Point\"",\n""+ ""           \""coordinates\"": [102.0, 0.5]\n""+ ""       },\n""+ ""       \""properties\"": {\n""+ ""           \""prop0\"": \""value0\""\n""+ ""       }\n""+ ""    }, {\n""+ ""       \""type\"": \""Feature\"",\n""+ ""       \""geometry\"": {\n""+ ""           \""type\"": \""LineString\"",\n""+ ""           \""coordinates\"": [\n""+ ""               [102.0, 0.0],\n""+ ""               [103.0, 1.0],\n""+ ""               [104.0, 0.0],\n""+ ""               [105.0, 1.0]\n""+ ""           ]\n""+ ""       },\n""+ ""       \""properties\"": {\n""+ ""           \""prop0\"": \""value0\"",\n""+ ""           \""prop1\"": 0.0\n""+ ""       }\n""+ ""    }, {\n""+ ""       \""type\"": \""Feature\"",\n""+ ""       \""geometry\"": {\n""+ ""           \""type\"": \""Polygon\"",\n""+ ""           \""coordinates\"": [\n""+ ""               [\n""+ ""                   [100.0, 0.0],\n""+ ""                   [101.0, 0.0],\n""+ ""                   [101.0, 1.0],\n""+ ""                   [100.0, 1.0],\n""+ ""                   [100.0, 0.0]\n""+ ""               ]\n""+ ""           ]\n""+ ""       },\n""+ ""       \""properties\"": {\n""+ ""           \""prop0\"": \""value0\"",\n""+ ""           \""prop1\"": {\n""+ ""               \""this\"": \""that\""\n""+ ""           }\n""+ ""       }\n""+ ""    }]\n""+ ""}\n"";
    Geometry geometry=JSON.parseObject(str,Geometry.class);
    assertEquals(FeatureCollection.class,geometry.getClass());
    assertEquals(""{\""type\"":\""FeatureCollection\"",\""features\"":[{\""type\"":\""Feature\"",\""properties\"":{\""prop0\"":\""value0\""},\""geometry\"":{\""type\"":\""Point\"",\""coordinates\"":[102.0,0.5]}},{\""type\"":\""Feature\"",\""properties\"":{\""prop0\"":\""value0\"",\""prop1\"":\""0.0\""},\""geometry\"":{\""type\"":\""LineString\"",\""coordinates\"":[[102.0,0.0],[103.0,1.0],[104.0,0.0],[105.0,1.0]]}},{\""type\"":\""Feature\"",\""properties\"":{\""prop0\"":\""value0\"",\""prop1\"":\""{\\\""this\\\"":\\\""that\\\""}\""},\""geometry\"":{\""type\"":\""Polygon\"",\""coordinates\"":[[[100.0,0.0],[101.0,0.0],[101.0,1.0],[100.0,1.0],[100.0,0.0]]]}}]}"",JSON.toJSONString(geometry,SerializerFeature.MapSortField));
    String str2=JSON.toJSONString(geometry,SerializerFeature.MapSortField);
    assertEquals(str2,JSON.toJSONString(JSON.parseObject(str2,Geometry.class),SerializerFeature.MapSortField));
}"
"@Test
public void testNodeMetricsDb() {
    ManualClock clock = new ManualClock();
    NodeMetricsDb db = new NodeMetricsDb();
    List<NodeMetrics.MetricValue> values = new ArrayList<>();
    for (int i = 0; i < 40; i++) {
        values.add(new NodeMetrics.MetricValue(""host0"", ""cpu.util"", clock.instant().getEpochSecond(), 0.9f));
        clock.advance(Duration.ofHours(1));
    }
    db.add(values);
    assertEquals(29, db.getWindow(clock.instant().minus(Duration.ofHours(30)), Resource.cpu,    List.of(""host0"")).measurementCount());
    assertEquals( 0, db.getWindow(clock.instant().minus(Duration.ofHours(30)), Resource.memory, List.of(""host0"")).measurementCount());
    db.gc(clock);
    assertEquals(23, db.getWindow(clock.instant().minus(Duration.ofHours(30)), Resource.cpu,    List.of(""host0"")).measurementCount());
    assertEquals( 0, db.getWindow(clock.instant().minus(Duration.ofHours(30)), Resource.memory, List.of(""host0"")).measurementCount());
}"
"@Test
public void testCollectorContextWithKeyword() throws Exception {
    ValidationResult validationResult = validate(""{\""test-property1\"":\""sample1\"",\""test-property2\"":\""sample2\""}"");
    Assertions.assertEquals(0, validationResult.getValidationMessages().size());
    List<String> contextValues = ((List<String>) (validationResult.getCollectorContext().get(SAMPLE_COLLECTOR)));
    Assertions.assertEquals(0, validationResult.getValidationMessages().size());
    Assertions.assertEquals(2, contextValues.size());
    Assertions.assertEquals(contextValues.get(0), ""actual_value_added_to_context1"");
    Assertions.assertEquals(contextValues.get(1), ""actual_value_added_to_context2"");
}"
"@Test
public void testZkNodeChangesUpdateFeatureState() throws Exception {
    setupTestWithEmptyDatastore();
    FeatureState savedFeatureState = new FeatureState(TestFeature.FEATURE);
    savedFeatureState.setStrategyId(ID);
    savedFeatureState.setParameter(PARAM_USERS, ""user1, user2, user3"");
    stateRepository.setFeatureState(savedFeatureState);
    FeatureState loadedFeatureState = stateRepository.getFeatureState(TestFeature.FEATURE);
    assertThat(reflectionEquals(savedFeatureState, loadedFeatureState), is(true));
    FeatureStateStorageWrapper externallySetStateWrapper = new FeatureStateStorageWrapper();
    FeatureState externallySetState = new FeatureState(TestFeature.FEATURE);
    ObjectMapper objectMapper = new ObjectMapper();
    final String json = objectMapper.writeValueAsString(externallySetStateWrapper);
    final CountDownLatch latch = new CountDownLatch(1);
    new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                serverClientPair.client.setData().forPath(TEST_ZNODE + ""/FEATURE"", json.getBytes(""UTF-8""));
                latch.countDown();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }).start();
    latch.await(2, TimeUnit.SECONDS);
    Thread.sleep(25);
    loadedFeatureState = stateRepository.getFeatureState(TestFeature.FEATURE);
    assertThat(reflectionEquals(externallySetState, loadedFeatureState), is(true));
}"
"@Test public void testExecuteLimitInvokeWitException() throws Exception {
    Invoker invoker=Mockito.mock(Invoker.class);
    doThrow(new RpcException()).when(invoker).invoke(any(Invocation.class));
    URL url=URL.valueOf(""test://test:11/test?accesslog=true&group=dubbo&version=1.1&executes=10"");
    when(invoker.getUrl()).thenReturn(url);
    Invocation invocation=Mockito.mock(Invocation.class);
    when(invocation.getMethodName()).thenReturn(""testExecuteLimitInvokeWitException"");
    try {
        executeLimitFilter.invoke(invoker,invocation);
    }
    catch (  Exception e) {
        Assertions.assertTrue(e instanceof RpcException);
        executeLimitFilter.onError(e,invoker,invocation);
    }
    Assertions.assertEquals(1,RpcStatus.getStatus(url,invocation.getMethodName()).getFailed());
    RpcStatus.removeStatus(url,invocation.getMethodName());
}"
"@Test
public void testCorrectRebalancingCurrentlyRentingPartitions() throws Exception {
    IgniteEx ignite = ((IgniteEx) (startGrids(3)));
    ignite.cluster().active(true);
    final int keysCnt = SF.applyLB(300000, 10000);
    try (final IgniteDataStreamer<Integer, Integer> ds = ignite.dataStreamer(CACHE_NAME)) {
        log.info(""Writing initial data..."");
        ds.allowOverwrite(true);
        for (int k = 1; k <= keysCnt; k++) {
            ds.addData(k, k);
            if ((k % 10000) == 0) {
                log.info((""Written "" + k) + "" entities."");
            }
        }
        log.info(""Writing initial data finished."");
    }
    startGrid(3);
    resetBaselineTopology();
    stopGrid(3);
    resetBaselineTopology();
    stopGrid(1);
    startGrid(1);
    awaitPartitionMapExchange();
    for (int k = 1; k <= keysCnt; k++) {
        Integer val = ((Integer) (ignite.cache(CACHE_NAME).get(k)));
        Assert.assertNotNull((""Value for "" + k) + "" is null"", val);
        Assert.assertEquals(((""Check failed for "" + k) + "" = "") + val, k, ((int) (val)));
    }
}"
"@Test
public void testPerson() {
    final Person p = new Person();
    p.name = ""John Doe"";
    p.age = 33;
    p.smoker = false;
    p.job = new Job();
    p.job.title = ""Manager"";
    final String pBaseStr = (p.getClass().getName() + ""@"") + Integer.toHexString(System.identityHashCode(p));
    final String pJobStr = (p.job.getClass().getName() + ""@"") + Integer.toHexString(System.identityHashCode(p.job));
    assertEquals(((pBaseStr + ""[name=John Doe,age=33,smoker=false,job="") + pJobStr) + ""[title=Manager]]"", new ReflectionToStringBuilder(p, new RecursiveToStringStyle()).toString());
}"
"@Test
public void testMinAllowedValue() {
    long millis = _validMinTime;
    DateTime dateTime = new DateTime(millis, DateTimeZone.UTC);
    LocalDateTime localDateTime = dateTime.toLocalDateTime();
    int year = localDateTime.getYear();
    int month = localDateTime.getMonthOfYear();
    int day = localDateTime.getDayOfMonth();
    Assert.assertEquals(year, 1971);
    Assert.assertEquals(month, 1);
    Assert.assertEquals(day, 1);
}"
"@Test public void wrapperBooleans(){
    assertThat(testResult(WrapperBooleans.class),isSuccessful());
    assertEquals(1,WrapperBooleans.iterations);
    assertEquals(singleton(false),WrapperBooleans.testCases);
    WrapperBooleans.iterations=0;
}"
"@Test
public void manyParametersWithBooleanAndEnum() throws Exception {
    assertThat(testResult(ManyParametersWithBooleanAndEnum.class), isSuccessful());
    int expectedCount = ((4 * 4) * 2) * RoundingMode.values().length;
    assertEquals(expectedCount, ManyParametersWithBooleanAndEnum.iterations);
    for (int i = 0; i < (expectedCount / 4); ++i) {
        assertEquals(String.valueOf(i), asList(3, 7), ManyParametersWithBooleanAndEnum.firstTestCases.subList(i * 4, (i * 4) + 2));
    }
    for (int i = 0; i < (expectedCount / 16); ++i) {
        assertEquals(String.valueOf(i), asList('a', 'a', 'a', 'a', 'b', 'b', 'b', 'b', 'c', 'c', 'c', 'c'), ManyParametersWithBooleanAndEnum.secondTestCases.subList(i * 16, (i * 16) + 12));
    }
    for (int i = 0; i < (expectedCount / 32); ++i) {
        assertEquals(asList(false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false), ManyParametersWithBooleanAndEnum.thirdTestCases.subList(i * 32, (i * 32) + 16));
        assertEquals(asList(true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true), ManyParametersWithBooleanAndEnum.thirdTestCases.subList((i * 32) + 16, (i * 32) + 32));
    }
}"
"@Test public void enumsUnmarked(){
    assertThat(testResult(EnumsUnmarked.class),isSuccessful());
    assertEquals(EnumSet.allOf(RoundingMode.class).size(),EnumsUnmarked.iterations);
    assertEquals(EnumSet.allOf(RoundingMode.class),EnumsUnmarked.testCases);
    EnumsUnmarked.iterations=0;
}"
"@Test public void alsoHonorsGeneratorsApartFromFixedSet() throws Exception {
    assertThat(testResult(AlsoHonorsGenerators.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),AlsoHonorsGenerators.iterations);
    assertEquals(new HashSet<>(asList(1,2,3)),new HashSet<>(AlsoHonorsGenerators.values.subList(0,3)));
    assertEquals(new HashSet<>(asList(4,5)),new HashSet<>(AlsoHonorsGenerators.values.subList(3,AlsoHonorsGenerators.values.size())));
    AlsoHonorsGenerators.iterations=0;
    AlsoHonorsGenerators.values.clear();
}"
"@Test public void wrapperDoubles() throws Exception {
    assertThat(testResult(WrapperDoubles.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperDoubles.iterations);
    assertEquals(new HashSet<>(asList(2.7,-3.14)),new HashSet<>(WrapperDoubles.values.subList(0,2)));
    WrapperDoubles.iterations=0;
}"
"@Test
public void testBlueprintCompNamespaceWorks() throws Exception {
    Bundle bBiz = getInstalledBundle(""org.apache.aries.jndi.url.itest.biz"");
    assertNotNull(bBiz);
    Bundle bweb = getInstalledBundle(""org.apache.aries.jndi.url.itest.web"");
    assertNotNull(bweb);
    printBundleStatus(""Before first request"");
    try {
        getTestServletResponse();
    } catch (IOException iox) {
    }
    try {
        Thread.sleep(5000);
    } catch (InterruptedException iox) {
    }
    printBundleStatus(""After workaround, before test proper"");
    System.out.println(""In test and trying to get connection...."");
    String response = getTestServletResponse();
    assertEquals(""ITest servlet response wrong"", ""Mark.2.0.three"", response);
}"
"@Test public void wrapperIntegers() throws Exception {
    assertThat(testResult(WrapperIntegers.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperIntegers.iterations);
    assertEquals(new HashSet<>(asList(4,5)),new HashSet<>(WrapperIntegers.values.subList(0,2)));
    WrapperIntegers.iterations=0;
}"
"@Test
public void testMaximumRolloverTime() throws Exception {
    ManagedLedgerConfig conf = new ManagedLedgerConfig();
    conf.setMaxEntriesPerLedger(5);
    conf.setMinimumRolloverTime(1, SECONDS);
    conf.setMaximumRolloverTime(1, SECONDS);
    ManagedLedgerImpl ledger = ((ManagedLedgerImpl) (factory.open(""my_test_maxtime_ledger"", conf)));
    ledger.openCursor(""c1"");
    ledger.addEntry(""data"".getBytes());
    ledger.addEntry(""data"".getBytes());
    assertEquals(ledger.getLedgersInfoAsList().size(), 1);
    Thread.sleep(2000);
    ledger.addEntry(""data"".getBytes());
    ledger.addEntry(""data"".getBytes());
    assertEquals(ledger.getLedgersInfoAsList().size(), 2);
}"
"@Test
public void testSetCallbackWithNull() throws Exception {
    mSession.setActive(true);
    mCallback.reset(1);
    mSession.setCallback(null, mHandler);
    assertEquals(""Callback shouldn't be called."", 0, mCallback.mOnPlayCalledCount);
}"
"@Test public void testAllowNullSchema() throws JSONException {
    AvroSchema<Foo> avroSchema=AvroSchema.of(SchemaDefinition.<Foo>builder().withPojo(Foo.class).build());
    assertEquals(avroSchema.getSchemaInfo().getType(),SchemaType.AVRO);
    Schema.Parser parser=new Schema.Parser();
    parser.setValidateDefaults(false);
    String schemaJson=new String(avroSchema.getSchemaInfo().getSchema());
    assertJSONEquals(schemaJson,SCHEMA_AVRO_ALLOW_NULL);
    Schema schema=parser.parse(schemaJson);
    for (  String fieldName : FOO_FIELDS) {
        Schema.Field field=schema.getField(fieldName);
        Assert.assertNotNull(field);
        if (field.name().equals(""field4"")) {
            Assert.assertNotNull(field.schema().getTypes().get(1).getField(""field1""));
        }
        if (field.name().equals(""fieldUnableNull"")) {
            Assert.assertNotNull(field.schema().getType());
        }
    }
}"
"@Test
public void testDelegationTokenWithRealUser() throws IOException {
    UserGroupInformation ugi = UserGroupInformation.createRemoteUser(REAL_USER);
    final UserGroupInformation proxyUgi = UserGroupInformation.createProxyUserForTesting(PROXY_USER, ugi, GROUP_NAMES);
    try {
        Token<?>[] tokens = proxyUgi.doAs(new PrivilegedExceptionAction<Token<?>[]>() {
            @Override
            public Token<?>[] run() throws IOException {
                return cluster.getFileSystem().addDelegationTokens(""RenewerUser"", null);
            }
        });
        DelegationTokenIdentifier identifier = new DelegationTokenIdentifier();
        byte[] tokenId = tokens[0].getIdentifier();
        identifier.readFields(new DataInputStream(new ByteArrayInputStream(tokenId)));
        Assert.assertEquals(identifier.getUser().getUserName(), PROXY_USER);
        Assert.assertEquals(identifier.getUser().getRealUser().getUserName(), REAL_USER);
    } catch (InterruptedException e) {
    }
}"
"@Test
void writesAndReadsClassContainingCustomConvertedObjects() {
    List<Object> converters = new ArrayList<>();
    converters.add(BigDecimalToStringConverter.INSTANCE);
    converters.add(StringToBigDecimalConverter.INSTANCE);
    CustomConversions customConversions = new CouchbaseCustomConversions(converters);
    converter.setCustomConversions(customConversions);
    converter.afterPropertiesSet();
    ((CouchbaseMappingContext) (converter.getMappingContext())).setSimpleTypeHolder(customConversions.getSimpleTypeHolder());
    CouchbaseDocument converted = new CouchbaseDocument();
    final String weightStr = ""12.34"";
    final BigDecimal weight = new BigDecimal(weightStr);
    final CustomObject addy = new CustomObject(weight);
    List<CustomObject> listOfObjects = new ArrayList<>();
    listOfObjects.add(addy);
    Map<String, CustomObject> mapOfObjects = new HashMap<>();
    mapOfObjects.put(""obj0"", addy);
    mapOfObjects.put(""obj1"", addy);
    CustomObjectEntity entity = new CustomObjectEntity(addy, listOfObjects, mapOfObjects);
    converter.write(entity, converted);
    CouchbaseDocument source = new CouchbaseDocument();
    source.put(""_class"", CustomObjectEntity.class.getName());
    CouchbaseDocument objectDoc = new CouchbaseDocument();
    objectDoc.put(""weight"", weightStr);
    source.put(""object"", objectDoc);
    CouchbaseList listOfObjectsDoc = new CouchbaseList();
    listOfObjectsDoc.put(objectDoc);
    source.put(""listOfObjects"", listOfObjectsDoc);
    CouchbaseDocument mapOfObjectsDoc = new CouchbaseDocument();
    mapOfObjectsDoc.put(""obj0"", objectDoc);
    mapOfObjectsDoc.put(""obj1"", objectDoc);
    source.put(""mapOfObjects"", mapOfObjectsDoc);
    assertThat(converted.export().toString()).isEqualTo(source.export().toString());
    CustomObjectEntity readConverted = converter.read(CustomObjectEntity.class, source);
    assertThat(readConverted.object.weight).isEqualTo(addy.weight);
    assertThat(readConverted.listOfObjects.get(0).weight).isEqualTo(listOfObjects.get(0).weight);
    assertThat(readConverted.mapOfObjects.get(""obj0"").weight).isEqualTo(mapOfObjects.get(""obj0"").weight);
    assertThat(readConverted.mapOfObjects.get(""obj1"").weight).isEqualTo(mapOfObjects.get(""obj1"").weight);
}"
"@Test public void testAdditionalModelTypeAnnotationsNewLineLinux() throws Exception {
    OpenAPI openAPI=TestUtils.createOpenAPI();
    final AbstractJavaCodegen codegen=new P_AbstractJavaCodegen();
    codegen.additionalProperties().put(AbstractJavaCodegen.ADDITIONAL_MODEL_TYPE_ANNOTATIONS,""@Foo\n@Bar"");
    codegen.processOpts();
    codegen.preprocessOpenAPI(openAPI);
    final List<String> additionalModelTypeAnnotations=new ArrayList<String>();
    additionalModelTypeAnnotations.add(""@Foo"");
    additionalModelTypeAnnotations.add(""@Bar"");
    final List<String> sortedCodegenAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    final List<String> sortedAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    Collections.sort(sortedCodegenAdditionalModelTypeAnnotations);
    Collections.sort(sortedAdditionalModelTypeAnnotations);
    Assert.assertEquals(sortedCodegenAdditionalModelTypeAnnotations,sortedAdditionalModelTypeAnnotations);
}"
"@Test
public void shouldPickANewServerToWriteToOnLeaderSwitch() throws Throwable
{
    cluster = clusterRule.withNumberOfEdgeMembers( 0 ).startCluster();
    CoreClusterMember leader = cluster.awaitLeader();
    CountDownLatch startTheLeaderSwitching = new CountDownLatch( 1 );
    Thread thread = new Thread( () ->
    {
        try
        {
            startTheLeaderSwitching.await();
            CoreClusterMember theLeader = cluster.awaitLeader();
            switchLeader( theLeader );
        }
        catch ( TimeoutException | InterruptedException e )
        {
        }
    } );
    thread.start();
    Config config = Config.build().withLogging( new JULogging( Level.OFF ) ).toConfig();
    try ( Driver driver = GraphDatabase
    .driver( leader.routingURI(), AuthTokens.basic( ""neo4j"", ""neo4j"" ), config ) )
    {
        boolean success = false;
        Set<BoltServerAddress> seenAddresses = new HashSet<>();
        long deadline = System.currentTimeMillis() + (30 * 1000);
        while ( !success )
        {
            if ( System.currentTimeMillis() > deadline )
            {
                fail( ""Failed to write to the new leader in time"" );
            }
            try ( Session session = driver.session( AccessMode.WRITE ) )
            {
                startTheLeaderSwitching.countDown();
                BoltServerAddress boltServerAddress = ((RoutingNetworkSession) session).address();
                seenAddresses.add( boltServerAddress );
                session.run( ""CREATE (p:Person)"" );
                success = seenAddresses.size() >= 2;
            }
            catch ( Exception e )
            {
                Thread.sleep( 100 );
            }
        }
    }
    finally
    {
        thread.join();
    }
}"
"@Test
public void test_for_issue() throws Exception {
    ParserConfig config = new ParserConfig();
    String json = ""{\""k\"":1,\""v\"":\""A\""}"";
    {
        Map.Entry entry = JSON.parseObject(json, Map.Entry.class, config);
        assertEquals(""v"", entry.getKey());
        assertEquals(""A"", entry.getValue());
    }
    config.putDeserializer(Map.Entry.class, new ObjectDeserializer() {
        public <T> T deserialze(DefaultJSONParser parser, Type type, Object fieldName) {
            JSONObject object = parser.parseObject();
            Object k = object.get(""k"");
            Object v = object.get(""v"");
            return ((T) (Collections.singletonMap(k, v).entrySet().iterator().next()));
        }
        public int getFastMatchToken() {
            return 0;
        }
    });
    Map.Entry entry = JSON.parseObject(json, Map.Entry.class, config);
    assertEquals(1, entry.getKey());
    assertEquals(""A"", entry.getValue());
}"
"@Test
public void appliesOuterTimeout() {
    final WaitStrategy underTest = new WaitAllStrategy()
    .withStrategy(strategy1)
    .withStartupTimeout(Duration.ofMillis(10));
    doAnswer(invocation -> {
        Uninterruptibles.sleepUninterruptibly(20, TimeUnit.MILLISECONDS);
        return null;
    }).when(strategy1).waitUntilReady(eq(container));
    assertThrows(""The outer strategy timeout applies"", TimeoutException.class, () -> {
        underTest.waitUntilReady(container);
    });
}"
"@Test public void wrapperBytes(){
    assertThat(testResult(WrapperBytes.class),isSuccessful());
    assertEquals(2,WrapperBytes.iterations);
    assertEquals(new HashSet<>(asList(Byte.valueOf(""14""),Byte.valueOf(""-15""))),WrapperBytes.testCases);
    WrapperBytes.iterations=0;
}"
"@Test
public void testRedeliverNewSession() throws Exception {
    String text = ""TEST"";
    Message sendMessage = session.createTextMessage(text);
    if (verbose) {
        log.info(((""About to send a message: "" + sendMessage) + "" with text: "") + text);
    }
    producer.send(producerDestination, sendMessage);
    Message unackMessage = consumer.receive(1000);
    assertNotNull(unackMessage);
    String unackId = unackMessage.getJMSMessageID();
    assertEquals(((TextMessage) (unackMessage)).getText(), text);
    assertFalse(unackMessage.getJMSRedelivered());
    assertEquals(unackMessage.getIntProperty(""JMSXDeliveryCount""), 1);
    consumeSession.close();
    consumer.close();
    consumeSession = connection.createSession(false, CLIENT_ACKNOWLEDGE);
    consumer = createConsumer();
    Message ackMessage = consumer.receive(1000);
    assertNotNull(ackMessage);
    ackMessage.acknowledge();
    String ackId = ackMessage.getJMSMessageID();
    assertEquals(((TextMessage) (ackMessage)).getText(), text);
    assertTrue(ackMessage.getJMSRedelivered());
    assertEquals(ackMessage.getIntProperty(""JMSXDeliveryCount""), 2);
    assertEquals(unackId, ackId);
    consumeSession.close();
    consumer.close();
    consumeSession = connection.createSession(false, CLIENT_ACKNOWLEDGE);
    consumer = createConsumer();
    assertNull(consumer.receiveNoWait());
}"
"@Test
public void testBindReferenceable() throws Exception {
    Name name = new CompositeName(""test"");
    final TestObjectReferenceable referenceable = new TestObjectReferenceable(""addr"");
    namingContext.bind(name, referenceable);
    Object result = namingContext.lookup(name);
    assertEquals(referenceable.addr, result);
    name = new CompositeName(""securitytest"");
    testActionPermission(JndiPermission.ACTION_BIND, namingContext, ""securitytest"", referenceable);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, ""securitytest"");
    assertEquals(referenceable.addr, result);
}"
"@Test public void wrapperFloats() throws Exception {
    assertThat(testResult(WrapperFloats.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperFloats.iterations);
    assertEquals(new HashSet<>(asList(1.7F,-4.14F)),new HashSet<>(WrapperFloats.values.subList(0,2)));
    WrapperFloats.iterations=0;
}"
"@Test public void testSize() throws InterruptedException {
    final InternalThreadLocal<Integer> internalThreadLocal=new InternalThreadLocal<Integer>();
    internalThreadLocal.set(1);
    Assertions.assertEquals(1,InternalThreadLocal.size(),""size method is wrong!"");
    final InternalThreadLocal<String> internalThreadLocalString=new InternalThreadLocal<String>();
    internalThreadLocalString.set(""value"");
    Assertions.assertEquals(2,InternalThreadLocal.size(),""size method is wrong!"");
    InternalThreadLocal.removeAll();
}"
"@Test public void testAddMultipleColumnsMySql(){
    AddColumnStatement columns=new AddColumnStatement(new AddColumnStatement(null,null,TABLE_NAME,""column1"",""INT"",null,new NotNullConstraint()),new AddColumnStatement(null,null,TABLE_NAME,""column2"",""INT"",null,new NotNullConstraint()));
    assertFalse(generatorUnderTest.validate(columns,new MySQLDatabase(),new MockSqlGeneratorChain()).hasErrors());
    Sql[] sql=generatorUnderTest.generateSql(columns,new MySQLDatabase(),new MockSqlGeneratorChain());
    assertEquals(1,sql.length);
    assertEquals(""ALTER TABLE "" + TABLE_NAME + "" ADD column1 INT NOT NULL, ADD column2 INT NOT NULL"",sql[0].toSql());
    List<String> actualNames=sql[0].getAffectedDatabaseObjects().stream().map(o -> o.toString()).collect(Collectors.toList());
    List<String> expectedNames=Arrays.asList(new String[]{""table_name.column1"",""table_name.column2"",""table_name"",""DEFAULT""});
    assertTrue(actualNames.containsAll(expectedNames));
    assertTrue(expectedNames.containsAll(actualNames));
}"
"@Test public void testMRAppMasterShutDownJob() throws Exception, InterruptedException {
    ExitUtil.resetFirstExitException();
    String applicationAttemptIdStr=""appattempt_1317529182569_0004_000002"";
    String containerIdStr=""container_1317529182569_0004_000002_1"";
    String userName=""TestAppMasterUser"";
    ApplicationAttemptId applicationAttemptId=ApplicationAttemptId.fromString(applicationAttemptIdStr);
    ContainerId containerId=ContainerId.fromString(containerIdStr);
    JobConf conf=new JobConf();
    conf.set(MRJobConfig.MR_AM_STAGING_DIR,stagingDir);
    File stagingDir=new File(MRApps.getStagingAreaDir(conf,userName).toString());
    stagingDir.mkdirs();
    MRAppMasterTest appMaster=spy(new MRAppMasterTest(applicationAttemptId,containerId,""host"",-1,-1,System.currentTimeMillis(),false,true));
    MRAppMaster.initAndStartAppMaster(appMaster,conf,userName);
    doReturn(conf).when(appMaster).getConfig();
    appMaster.isLastAMRetry=true;
    doNothing().when(appMaster).serviceStop();
    appMaster.shutDownJob();
    Assert.assertTrue(""Expected shutDownJob to terminate."",ExitUtil.terminateCalled());
    Assert.assertEquals(""Expected shutDownJob to exit with status code of 0."",0,ExitUtil.getFirstExitException().status);
    ExitUtil.resetFirstExitException();
    String msg=""Injected Exception"";
    doThrow(new RuntimeException(msg)).when(appMaster).notifyIsLastAMRetry(anyBoolean());
    appMaster.shutDownJob();
    assertTrue(""Expected message from ExitUtil.ExitException to be "" + msg,ExitUtil.getFirstExitException().getMessage().contains(msg));
    Assert.assertEquals(""Expected shutDownJob to exit with status code of 1."",1,ExitUtil.getFirstExitException().status);
}"
"@Test public void manyParameters() throws Exception {
    assertThat(testResult(ManyParameters.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ManyParameters.iterations);
    ManyParameters.iterations=0;
}"
"@Test
public void testConnectedComponents() {
    System.out.println(""graph is "" + graph.toString());
    List<Set<Integer>> ccs = graph.getConnectedComponents();
    for (Set<Integer> cc : ccs) {
        System.out.println(""Connected component: "" + cc);
    }
    assertEquals(ccs.size(), 4);
    assertEquals(CollectionUtils.sorted(ccs.get(0)), Arrays.asList(1, 2, 3, 4));
}"
"@Test
public void testCwdContents() throws Exception {
    dirString = Path.CUR_DIR;
    item = new PathData(dirString, conf);
    PathData[] items = item.getDirectoryContents();
    assertEquals(sortedString(""d1"", ""d2""), sortedString(items));
}"
"@Test public void wrapperDoubles(){
    assertThat(testResult(WrapperDoubles.class),isSuccessful());
    assertEquals(2,WrapperDoubles.iterations);
    assertEquals(new HashSet<>(asList(2.7,-3.14)),WrapperDoubles.testCases);
    WrapperDoubles.iterations=0;
}"
"@Test
public void testSequenceListenerWithIncorrectOrder() {
    SequenceListener sl = new SequenceListener();
    sl.sentenceRead(AIS_05_2);
    assertNull(sl.received);
    sl.sentenceRead(AIS_05_1);
    assertNull(sl.received);
    sl.sentenceRead(AIS_05_2);
    assertEquals(sl.received.toString(), MSG_05.toString());
}"
"@Test
protected void assertMessageValid(int index, Message message) throws JMSException {
    assertEquals(""localhost"", message.getStringProperty(""BrokerPath""));
    ActiveMQMessage amqMsg = ((ActiveMQMessage) (message));
    if (index == 7) {
        assertEquals(2000, amqMsg.getExpiration() - amqMsg.getTimestamp());
    } else if (index == 9) {
        assertEquals(60000, amqMsg.getExpiration() - amqMsg.getTimestamp());
    } else {
        assertEquals(1000, amqMsg.getExpiration() - amqMsg.getTimestamp());
    }
    super.assertMessageValid(index, message);
}"
"@Test
public void testCreateSubcontext() throws Exception {
    assertTrue(namingContext.createSubcontext(new CompositeName(""test"")) instanceof NamingContext);
    assertTrue(testActionPermission(JndiPermission.ACTION_CREATE_SUBCONTEXT, namingContext, ""securitytest"") instanceof NamingContext);
}"
"@Test @MongoDBFixtures(""V20161215163900_MoveIndexSetDefaultConfigTest.json"") public void upgrade() throws Exception {
    final long count=collection.count();
    migration.upgrade();
    final MigrationCompleted migrationCompleted=clusterConfigService.get(MigrationCompleted.class);
    assertThat(collection.count()).withFailMessage(""No document should be deleted by the migration!"").isEqualTo(count);
    assertThat(collection.count(Filters.exists(""default""))).withFailMessage(""The migration should have deleted the \""default\"" field from the documents!"").isEqualTo(0L);
    assertThat(clusterConfigService.get(DefaultIndexSetConfig.class)).withFailMessage(""The DefaultIndexSetConfig should have been written to cluster config!"").isNotNull();
    assertThat(clusterConfigService.get(DefaultIndexSetConfig.class).defaultIndexSetId()).isEqualTo(""57f3d721a43c2d59cb750001"");
    assertThat(migrationCompleted).isNotNull();
    assertThat(migrationCompleted.indexSetIds()).containsExactlyInAnyOrder(""57f3d721a43c2d59cb750001"",""57f3d721a43c2d59cb750003"");
}"
"@Test public void ctorOnly() throws Exception {
    assertThat(testResult(CtorOnly.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),CtorOnly.iterations);
    CtorOnly.iterations=0;
}"
"@Test
public void testPullWithFilter() throws Exception {
    PullPoint pullPoint1 = wsnCreatePullPoint.createPullPoint();
    PullPoint pullPoint2 = wsnCreatePullPoint.createPullPoint();
    wsnBroker.subscribe(pullPoint1.getEndpoint(), ""myTopic"", ""@type = 'a'"");
    wsnBroker.subscribe(pullPoint2.getEndpoint(), ""myTopic"", ""@type = 'b'"");
    wsnBroker.notify(""myTopic"", parse(""<msg type='a'/>""));
    Thread.sleep(500);
    assertEquals(1, pullPoint1.getMessages(0).size());
    assertEquals(0, pullPoint2.getMessages(0).size());
    wsnBroker.notify(""myTopic"", parse(""<msg type='b'/>""));
    Thread.sleep(500);
    assertEquals(0, pullPoint1.getMessages(0).size());
    assertEquals(1, pullPoint2.getMessages(0).size());
    wsnBroker.notify(""myTopic"", parse(""<msg type='c'/>""));
    Thread.sleep(500);
    assertEquals(0, pullPoint1.getMessages(0).size());
    assertEquals(0, pullPoint2.getMessages(0).size());
}"
"@Test
public void shouldReturnBodyWhenEnabledAndNoMax() {
    String body = ""{\n"" +
    ""  \""error\"": \""not found\""\n"" +
    ""}"";
    HttpResponseFacade mock = mock(HttpResponseFacade.class);
    when(mock.response()).thenReturn(generateResponse(
    ""application/json"",
    404,
    body.getBytes()));
    ((HttpAssertionFacadeImpl) facade).facade = mock;
    world.put(ASSERTS_STATUS_CODE_DISPLAY_BODY, ""true"");
    validateException(
    200,
    ""1 expectation failed.\n"" +
    ""Expected status code \""200\"" but was \""404\"" with body:\n"" +
    ""\""\""\""\n"" +
    body +
    ""\n\""\""\"".\n"");
}"
"@Test
public void incrementUpperLimitIfOneMinuteElapsedSinceLastUpdate() throws InterruptedException {
    Clock clock = mock(Clock.class);
    when(clock.getTimeMillis()).thenReturn(0L, TWO_MINUTES_IN_MILLIS, 2 * TWO_MINUTES_IN_MILLIS, 3 * TWO_MINUTES_IN_MILLIS);
    TimestampBoundStore timestampBoundStore = initialTimestampBoundStore();
    PersistentTimestampService persistentTimestampService = PersistentTimestampService.create(timestampBoundStore, clock);
    persistentTimestampService.getFreshTimestamp();
    Thread.sleep(10);
    persistentTimestampService.getFreshTimestamp();
    Thread.sleep(10);
    verify(timestampBoundStore, atLeast(2)).storeUpperLimit(anyLong());
}"
"@Test public void testResponse1() throws Exception {
    SearchLookupResponse response=new SearchLookupResponse();
    response.setType(""LOOKUP"");
    response.setMetric(""sys.cpu.user"");
    response.putTag(""host"",""localhost"");
    response.putTag(""rack"",""r1"");
    response.setTime(1500);
    List<Result> results=new ArrayList<>();
    Result r1=new Result();
    r1.setMetric(""sys.cpu.idle"");
    r1.setTsuid(""000011000008203D00"");
    r1.putTag(""host"",""localhost"");
    r1.putTag(""rack"",""r1"");
    Result r2=new Result();
    r2.setMetric(""sys.cpu.user"");
    r2.setTsuid(""000011000008203D01"");
    r2.putTag(""host"",""localhost"");
    r2.putTag(""rack"",""r1"");
    results.add(r1);
    results.add(r2);
    response.setResults(results);
    response.setTotalResults(results.size());
    String r=JsonUtil.getObjectMapper().writeValueAsString(response);
    String expected=""{\""type\"":\""LOOKUP\"",\""metric\"":\""sys.cpu.user\"",\""tags\"":{\""host\"":\""localhost\"",\""rack\"":\""r1\""},\""limit\"":0,\""time\"":1500,\""totalResults\"":2,\""results\"":[{\""tags\"":{\""host\"":\""localhost\"",\""rack\"":\""r1\""},\""metric\"":\""sys.cpu.idle\"",\""tsuid\"":\""000011000008203D00\""},{\""tags\"":{\""host\"":\""localhost\"",\""rack\"":\""r1\""},\""metric\"":\""sys.cpu.user\"",\""tsuid\"":\""000011000008203D01\""}]}"";
    Assert.assertEquals(expected,r);
    SearchLookupResponse slr=JsonUtil.getObjectMapper().readValue(r,SearchLookupResponse.class);
    Assert.assertEquals(response,slr);
}"
"@Test public void primitiveDoubles() throws Exception {
    assertThat(testResult(PrimitiveDoubles.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveDoubles.iterations);
    assertEquals(new HashSet<>(asList(3.2,-4D)),new HashSet<>(PrimitiveDoubles.values.subList(0,2)));
    PrimitiveDoubles.iterations=0;
}"
"@Test
public void testListNameNotFound() throws Exception {
    try {
        namingContext.list(new CompositeName(""test""));
        fail(""Should have thrown and NameNotFoundException"");
    } catch (NameNotFoundException expected) {
    }
    try {
        testActionPermission(JndiPermission.ACTION_LIST, namingContext, ""test"");
        fail(""Should have thrown and NameNotFoundException with appropriate permissions"");
    } catch (NameNotFoundException expected) {
    }
}"
"@Test public void test1_2() throws Exception {
    JSONObject json=new JSONObject();
    json.put(""id"",123);
    json.put(""name"",""哈哈哈"");
    ResultActions actions=mockMvc.perform((post(""/fastjson/test1?callback=fnUpdateSome"").characterEncoding(""UTF-8"").content(json.toJSONString()).contentType(MediaType.APPLICATION_JSON)));
    actions.andDo(print());
    actions.andExpect(status().isOk()).andExpect(content().contentType(APPLICATION_JAVASCRIPT));
    String content=actions.andReturn().getResponse().getContentAsString();
    assertTrue(content.equals(""/**/fnUpdateSome({\""name\"":\""哈哈哈\"",\""id\"":123})"") || content.equals(""/**/fnUpdateSome({\""id\"":123,\""name\"":\""哈哈哈\""})""));
}"
"@Test
public void duplexWithRedirect() throws Exception {
    enableProtocol(HTTP_2);
    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(new MockResponse().clearHeaders().setResponseCode(HttpURLConnection.HTTP_MOVED_PERM).addHeader(""Location: /b""), new MockDuplexResponseBody().sendResponse(""/a has moved!\n"").requestIOException().exhaustResponse());
    server.enqueue(new MockResponse().setBody(""this is /b""));
    Call call = client.newCall(new Request.Builder().url(server.url(""/"")).post(new AsyncRequestBody()).build());
    try (final Response response = call.execute()) {
        BufferedSource responseBody = response.body().source();
        assertThat(responseBody.readUtf8Line()).isEqualTo(""this is /b"");
    }
    BufferedSink requestBody = ((AsyncRequestBody) (call.request().body())).takeSink();
    try {
        requestBody.writeUtf8(""request body\n"");
        requestBody.flush();
        fail();
    } catch (IOException expected) {
        assertThat(expected.getMessage()).isEqualTo(""stream was reset: CANCEL"");
    }
    mockDuplexResponseBody.awaitSuccess();
    assertThat(listener.recordedEventTypes()).containsExactly(""CallStart"", ""DnsStart"", ""DnsEnd"", ""ConnectStart"", ""SecureConnectStart"", ""SecureConnectEnd"", ""ConnectEnd"", ""ConnectionAcquired"", ""RequestHeadersStart"", ""RequestHeadersEnd"", ""RequestBodyStart"", ""ResponseHeadersStart"", ""ResponseHeadersEnd"", ""ResponseBodyStart"", ""ResponseBodyEnd"", ""RequestHeadersStart"", ""RequestHeadersEnd"", ""ResponseHeadersStart"", ""ResponseHeadersEnd"", ""ResponseBodyStart"", ""ResponseBodyEnd"", ""ConnectionReleased"", ""CallEnd"", ""RequestFailed"");
}"
"@Test public void shouldDeserializeSerializedContentPack() throws Exception {
    final ContentPack contentPack=createTestContentPack();
    final URL contentPackURL=ContentPackTest.class.getResource(""expected_content_pack.json"");
    Path path=Paths.get(contentPackURL.toURI());
    String expectedJSON=String.join("""",Files.readAllLines(path)).replace(""\n"","""").replace(""\r"","""");
    final String jsonTxt=objectMapper.writeValueAsString(contentPack);
    assertJSONEqual(jsonTxt,expectedJSON);
    final ContentPack readContentPack=objectMapper.readValue(jsonTxt,ContentPack.class);
    assertThat(readContentPack.id()).isEqualTo(contentPack.id());
    assertThat(readContentPack.version()).isEqualTo(contentPack.version());
    assertThat(readContentPack.revision()).isEqualTo(contentPack.revision());
}"
"@Test
public void testQueryRaw() throws Exception {
    Dao<Foo, Integer> dao = createDao(Foo.class, true);
    Foo foo = new Foo();
    foo.stringField = ""zipper"";
    dao.create(foo);
    QueryBuilder<Foo, Integer> qb = dao.queryBuilder();
    assertEquals(1, qb.countOf());
    GenericRawResults<String[]> results = qb.queryRaw();
    List<String[]> stringResults = results.getResults();
    assertEquals(1, stringResults.size());
    assertEquals(Integer.toString(foo.id), stringResults.get(0)[0]);
    assertEquals(foo.stringField, stringResults.get(0)[3]);
}"
"@Test public void strings() throws Exception {
    assertThat(testResult(Strings.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),Strings.iterations);
    assertEquals(new HashSet<>(asList(""some"",""values"")),new HashSet<>(Strings.values.subList(0,2)));
    Strings.iterations=0;
}"
"@Test
public void testReacquireLocksAfterSessionLost() throws Exception {
    @Cleanup
    MetadataStoreExtended store = MetadataStoreExtended.create(zks.getConnectionString(), MetadataStoreConfig.builder().sessionTimeoutMillis(2000).build());
    BlockingQueue<SessionEvent> sessionEvents = new LinkedBlockingQueue<>();
    store.registerSessionListener(sessionEvents::add);
    @Cleanup
    CoordinationService coordinationService = new CoordinationServiceImpl(store);
    @Cleanup
    LockManager<String> lm1 = coordinationService.getLockManager(String.class);
    String path = newKey();
    ResourceLock<String> lock = lm1.acquireLock(path, ""value-1"").join();
    zks.expireSession(((ZKMetadataStore) (store)).getZkSessionId());
    SessionEvent e = sessionEvents.poll(5, TimeUnit.SECONDS);
    assertEquals(e, ConnectionLost);
    e = sessionEvents.poll(10, TimeUnit.SECONDS);
    assertEquals(e, SessionLost);
    e = sessionEvents.poll(10, TimeUnit.SECONDS);
    assertEquals(e, Reconnected);
    e = sessionEvents.poll(10, TimeUnit.SECONDS);
    assertEquals(e, SessionReestablished);
    Awaitility.await().untilAsserted(() -> {
        assertFalse(lock.getLockExpiredFuture().isDone());
    });
    assertTrue(store.get(path).join().isPresent());
}"
"@Test
public void testRunWriteAfterRead() {
    final Function1<CancelIndicator, Integer> _function = (CancelIndicator it) -> {
        return Integer.valueOf(this.sharedState.incrementAndGet());
    };
    this.requestManager.<Integer>runRead(_function);
    final Function0<Object> _function_1 = () -> {
        return null;
    };
    final Function2<CancelIndicator, Object, Integer> _function_2 = (CancelIndicator $0,Object $1) -> {
        int _xblockexpression = ((int) (0));
        {
            Assert.assertEquals(1, this.sharedState.get());
            _xblockexpression = this.sharedState.incrementAndGet();
        }
        return Integer.valueOf(_xblockexpression);
    };
    this.requestManager.<Object, Integer>runWrite(_function_1, _function_2).join();
    Assert.assertEquals(2, this.sharedState.get());
}"
"public void test_for_issue(){
    VO vo=new VO();
    vo.id=123;
    vo.location=new Location(127,37);
    Object obj=JSON.toJSON(vo);
    String text=JSON.toJSONString(obj,SerializerFeature.MapSortField);
    assertEquals(""{\""id\"":123,\""latitude\"":37,\""longitude\"":127}"",text);
}"
"@Test
public void servicesCanCallOtherServices() throws InterruptedException {
    ReactorGreeterGrpc.ReactorGreeterStub stub = ReactorGreeterGrpc.newReactorStub(channel);
    Mono<String> chain =
    Mono.just(request(""X"")).compose(stub::sayHello).map(ChainedCallIntegrationTest::bridge).doOnSuccess(System.out::println).as(stub::sayHelloRespStream).map(ChainedCallIntegrationTest::bridge).doOnNext(System.out::println).compose(stub::sayHelloBothStream).map(ChainedCallIntegrationTest::bridge).doOnNext(System.out::println).as(stub::sayHelloReqStream).map(ChainedCallIntegrationTest::bridge).doOnSuccess(System.out::println).compose(stub::sayHello).map(HelloResponse::getMessage).doOnSuccess(System.out::println);
    StepVerifier.create(chain).expectNext(""[<{[X]}> :: </[X]/> :: <\\[X]\\> :: <([X])>]"").expectComplete().verify(Duration.ofSeconds(2));
}"
"@Test public void serializeInteger() throws IOException {
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of(1)),""{\""@type\"":\""integer\"",\""@value\"":1}"");
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of(42)),""{\""@type\"":\""integer\"",\""@value\"":42}"");
}"
"@Test public void favorValueOf(){
    assertThat(testResult(FavorValueOf.class),isSuccessful());
    assertEquals(2,FavorValueOf.iterations);
    assertEquals(new HashSet<>(asList(FavorValueOf.Target.valueOf(""a""),FavorValueOf.Target.valueOf(""b""))),FavorValueOf.testCases);
    FavorValueOf.iterations=0;
    FavorValueOf.testCases.clear();
}"
"@Test
public void testDoNotPurgeRPCTask() throws Exception {
    int RPCTaskNums = 10;
    TaskMonitor tm = TaskMonitor.get();
    for(int i = 0; i < RPCTaskNums; i++) {
        tm.createRPCStatus(""PRCTask"" + i);
    }
    for(int i = 0; i < TaskMonitor.DEFAULT_MAX_TASKS; i++) {
        tm.createStatus(""otherTask"" + i);
    }
    int remainRPCTask = 0;
    for(MonitoredTask task: tm.getTasks()) {
        if(task instanceof MonitoredRPCHandler) {
            remainRPCTask++;
        }
    }
    assertEquals(""RPC Tasks have been purged!"", RPCTaskNums, remainRPCTask);
    tm.shutdown();
}"
"@Test
public void shouldTogglePrepareForBulkLoadDuringRestoreCalls() throws Exception {
    final List<KeyValue<byte[], byte[]>> entries = new ArrayList<>();
    entries.add(new KeyValue<>(""1"".getBytes(""UTF-8""), ""a"".getBytes(""UTF-8"")));
    entries.add(new KeyValue<>(""2"".getBytes(""UTF-8""), ""b"".getBytes(""UTF-8"")));
    entries.add(new KeyValue<>(""3"".getBytes(""UTF-8""), ""c"".getBytes(""UTF-8"")));
    final AtomicReference<Exception> conditionNotMet = new AtomicReference<>();
    final AtomicInteger conditionCheckCount = new AtomicInteger();
    Thread conditionCheckThread = new Thread(new Runnable() {
        @Override
        public void run() {
            assertRocksDBTurnsOnBulkLoading(conditionCheckCount, conditionNotMet);
            assertRockDBTurnsOffBulkLoad(conditionCheckCount, conditionNotMet);
        }
    });
    subject.init(context, subject);
    conditionCheckThread.start();
    context.restore(subject.name(), entries);
    conditionCheckThread.join(2000);
    assertTrue(conditionNotMet.get() == null);
    assertTrue(conditionCheckCount.get() == 2);
}"
"@Test void nullAndObjectValuesInMap(){
    Map<String,Object> queryParams=new LinkedHashMap<>();
    queryParams.put(""foo"",null);
    queryParams.put(""baz"",""qux"");
    Unirest.get(MockServer.GET).queryString(queryParams).asObject(RequestCapture.class).getBody().assertParam(""foo"","""").assertParam(""baz"",""qux"").assertQueryString(""foo&baz=qux"");
}"
"@Test public void testAdditionalModelTypeAnnotationsNoDuplicate() throws Exception {
    OpenAPI openAPI=TestUtils.createOpenAPI();
    final AbstractJavaCodegen codegen=new P_AbstractJavaCodegen();
    codegen.additionalProperties().put(AbstractJavaCodegen.ADDITIONAL_MODEL_TYPE_ANNOTATIONS,""@Foo;@Bar;@Foo"");
    codegen.processOpts();
    codegen.preprocessOpenAPI(openAPI);
    final List<String> additionalModelTypeAnnotations=new ArrayList<String>();
    additionalModelTypeAnnotations.add(""@Foo"");
    additionalModelTypeAnnotations.add(""@Bar"");
    final List<String> sortedCodegenAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    final List<String> sortedAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    Collections.sort(sortedCodegenAdditionalModelTypeAnnotations);
    Collections.sort(sortedAdditionalModelTypeAnnotations);
    Assert.assertEquals(sortedCodegenAdditionalModelTypeAnnotations,sortedAdditionalModelTypeAnnotations);
}"
"@Test
public void testRender_ok() {
    final Mock mockResponse = mock(RenderResponse.class);
    mockResponse.stubs().method(ANYTHING);
    PortletMode mode = PortletMode.VIEW;
    Map<String, String[]> requestParams = new HashMap<String, String[]>();
    requestParams.put(ACTION_PARAM, new String[]{""/view/testAction""});
    requestParams.put(EVENT_ACTION, new String[]{""true""});
    requestParams.put(MODE_PARAM, new String[]{mode.toString()});
    Map<String, Object> sessionMap = new HashMap<String, Object>();
    Map<String, String> initParams = new HashMap<String, String>();
    initParams.put(""viewNamespace"", ""/view"");
    initParams.put(StrutsConstants.STRUTS_ALWAYS_SELECT_FULL_NAMESPACE, ""true"");
    initPortletConfig(initParams, new HashMap<String, Object>());
    initRequest(requestParams, new HashMap<String, Object>(), sessionMap, PortletMode.VIEW, WindowState.NORMAL, false, null);
    setupActionFactory(""/view"", ""testAction"", ""success"", EasyMock.createNiceMock(ValueStack.class));
    mockInvocation.expects(once()).method(""getStack"").will(
    returnValue(null));
    try {
        dispatcher
        .setActionProxyFactory((ActionProxyFactory) mockActionFactory
        .proxy());
        dispatcher.init((PortletConfig) mockConfig.proxy());
        dispatcher.render((RenderRequest) mockRequest.proxy(),
        (RenderResponse) mockResponse.proxy());
    } catch (Exception e) {
        e.printStackTrace();
        fail(""Error occured"");
    }
}"
"@Test public void test2_2() throws Exception {
    String jsonStr=""[{\""name\"":\""p1\"",\""sonList\"":[{\""name\"":\""s1\""}]},{\""name\"":\""p2\"",\""sonList\"":[{\""name\"":\""s2\""},{\""name\"":\""s3\""}]}]"";
    ResultActions actions=mockMvc.perform((post(""/fastjson/test2?jsonp=fnUpdateSome"").characterEncoding(""UTF-8"").content(jsonStr).contentType(MediaType.APPLICATION_JSON)));
    actions.andDo(print());
    actions.andExpect(status().isOk()).andExpect(content().contentType(APPLICATION_JAVASCRIPT));
    String content=actions.andReturn().getResponse().getContentAsString();
    assertTrue(content.equals(""/**/fnUpdateSome({\""p1\"":1,\""p2\"":2})"") || content.equals(""/**/fnUpdateSome({\""p2\"":2,\""p1\"":1})""));
}"
"public void testSimpleEquals() throws Exception {
    ObjectMapper mapper=jsonMapperBuilder().enable(SerializationFeature.USE_EQUALITY_FOR_OBJECT_ID).configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY,true).build();
    Foo foo=new Foo(1);
    Bar bar1=new Bar(1);
    Bar bar2=new Bar(2);
    Bar anotherBar1=new Bar(1);
    foo.bars.add(bar1);
    foo.bars.add(bar2);
    foo.otherBars.add(anotherBar1);
    foo.otherBars.add(bar2);
    String json=mapper.writeValueAsString(foo);
    assertEquals(""{\""id\"":1,\""bars\"":[{\""id\"":1},{\""id\"":2}],\""otherBars\"":[1,2]}"",json);
    Foo foo2=mapper.readValue(json,Foo.class);
    assertNotNull(foo2);
    assertEquals(foo.id,foo2.id);
}"
"@Test
public void create_repo_and_uploads_commits() throws Exception {
    String challengeId = ""TCH"";
    String participantId = generateId();
    String s3destination = String.format(""%s/%s/file.srcs"", challengeId, participantId);
    TestSrcsFile srcsForTestChallenge = new TestSrcsFile(""HmmmLang_R1Cov33_R2Cov44.srcs"");
    S3Event s3Event = localS3Bucket.putObject(srcsForTestChallenge.asFile(), s3destination);
    coverageUploadHandler.handleRequest(convertToMap(wrapAsSNSEvent(s3Event)),NO_CONTEXT);
    waitForQueueToReceiveEvents();
    assertThat(languageDetectedEvents.size(), equalTo(1));
    System.out.println(""Received language detected events: ""+languageDetectedEvents);
    ProgrammingLanguageDetectedEvent languageEvent = languageDetectedEvents.get(0);
    assertThat(languageEvent.getParticipant(), equalTo(participantId));
    assertThat(languageEvent.getChallengeId(), equalTo(challengeId));
    assertThat(languageEvent.getProgrammingLanguage(), equalTo(""HmmmLang""));
    assertThat(coverageComputedEvents.size(), equalTo(2));
    System.out.println(""Received coverage events: ""+coverageComputedEvents);
    coverageComputedEvents.sort(Comparator.comparing(CoverageComputedEvent::getRoundId));
    CoverageComputedEvent coverageRound1 = coverageComputedEvents.get(0);
    assertThat(coverageRound1.getParticipant(), equalTo(participantId));
    assertThat(coverageRound1.getRoundId(), equalTo(challengeId+""_R1""));
    assertThat(coverageRound1.getCoverage(), equalTo(33));
    CoverageComputedEvent coverageRound2 = coverageComputedEvents.get(1);
    assertThat(coverageRound2.getParticipant(), equalTo(participantId));
    assertThat(coverageRound2.getRoundId(), equalTo(challengeId+""_R2""));
    assertThat(coverageRound2.getCoverage(), equalTo(44));
}"
"@Test public void canSerializeMapKeysWithDotAndSlash() throws Exception {
    String serialized=new JacksonAdapter().serialize(prepareSchoolModel());
    String expected=""{\""teacher\"":{\""students\"":{\""af.B/D\"":{},\""af.B/C\"":{}}},\""tags\"":{\""foo.aa\"":\""bar\"",\""x.y\"":\""zz\""},\""properties\"":{\""name\"":\""school1\""}}"";
    assertJsonEqualsNonStrict(expected,serialized);
}"
"@Test public void joinMultiArrayTest(){
    final StrJoiner append=StrJoiner.of("","");
    append.append(new Object[]{ListUtil.of(""1"",""2""),CollUtil.newHashSet(""3"",""4"")});
    Assert.assertThat(append.toString(),CoreMatchers.anyOf(CoreMatchers.is(""1,2,3,4""),CoreMatchers.is(""1,2,4,3"")));
}"
"@Test
public void testListAllPort() throws RemotingException {
    String result = port.telnet(null, """");
    assertEquals(""20887"", result);
}"
"@Test
public void testNotifyWithJbiWrapper() throws Exception {
    wsnBroker.setJbiWrapped(true);
    ReceiverComponent receiver = new ReceiverComponent();
    jbi.activateComponent(receiver, ""receiver"");
    W3CEndpointReference consumer = createEPR(SERVICE, ENDPOINT);
    wsnBroker.subscribe(consumer, ""myTopic"", null);
    wsnBroker.notify(""myTopic"", parse(""<hello>world</hello>""));
    Thread.sleep(500);
    receiver.getMessageList().assertMessagesReceived(1);
    NormalizedMessage msg = ((NormalizedMessage) (receiver.getMessageList().getMessages().get(0)));
    Node node = new SourceTransformer().toDOMNode(msg);
    assertEquals(""Notify"", node.getLocalName());
    Thread.sleep(500);
}"
"@Test public void testNotAllowNullSchema() throws JSONException {
    AvroSchema<Foo> avroSchema=AvroSchema.of(SchemaDefinition.<Foo>builder().withPojo(Foo.class).withAlwaysAllowNull(false).build());
    assertEquals(avroSchema.getSchemaInfo().getType(),SchemaType.AVRO);
    Schema.Parser parser=new Schema.Parser();
    String schemaJson=new String(avroSchema.getSchemaInfo().getSchema());
    assertJSONEquals(schemaJson,SCHEMA_AVRO_NOT_ALLOW_NULL);
    Schema schema=parser.parse(schemaJson);
    for (  String fieldName : FOO_FIELDS) {
        Schema.Field field=schema.getField(fieldName);
        Assert.assertNotNull(field);
        if (field.name().equals(""field4"")) {
            Assert.assertNotNull(field.schema().getTypes().get(1).getField(""field1""));
        }
        if (field.name().equals(""fieldUnableNull"")) {
            Assert.assertNotNull(field.schema().getType());
        }
    }
}"
"@Test public void testMwDailyDumpFileProcessing() throws IOException {
    Path dmPath=Paths.get(System.getProperty(""user.dir""));
    MockDirectoryManager dm=new MockDirectoryManager(dmPath,true,true);
    setLocalDumpFile(""20140420"",DumpContentType.DAILY,dm);
    DumpProcessingController dpc=new DumpProcessingController(""wikidatawiki"");
    dpc.downloadDirectoryManager=dm;
    dpc.setOfflineMode(true);
    StatisticsMwRevisionProcessor mwrpAllStats=new StatisticsMwRevisionProcessor(""all"",2);
    dpc.registerMwRevisionProcessor(mwrpAllStats,null,false);
    TestMwRevisionProcessor tmrpAll=new TestMwRevisionProcessor();
    dpc.registerMwRevisionProcessor(tmrpAll,null,false);
    TestMwRevisionProcessor tmrpAllCurrent=new TestMwRevisionProcessor();
    dpc.registerMwRevisionProcessor(tmrpAllCurrent,null,true);
    TestMwRevisionProcessor tmrpAllItems=new TestMwRevisionProcessor();
    dpc.registerMwRevisionProcessor(tmrpAllItems,MwRevision.MODEL_WIKIBASE_ITEM,false);
    TestEntityDocumentProcessor edpCurrentCounter=new TestEntityDocumentProcessor();
    dpc.registerEntityDocumentProcessor(edpCurrentCounter,MwRevision.MODEL_WIKIBASE_ITEM,true);
    dpc.registerEntityDocumentProcessor(edpCurrentCounter,MwRevision.MODEL_WIKIBASE_PROPERTY,true);
    TestEntityDocumentProcessor edpAllCounter=new TestEntityDocumentProcessor();
    dpc.registerEntityDocumentProcessor(edpAllCounter,MwRevision.MODEL_WIKIBASE_ITEM,false);
    dpc.registerEntityDocumentProcessor(edpAllCounter,MwRevision.MODEL_WIKIBASE_PROPERTY,false);
    TestMwRevisionProcessor tmrpAllProperties=new TestMwRevisionProcessor();
    dpc.registerMwRevisionProcessor(tmrpAllProperties,MwRevision.MODEL_WIKIBASE_PROPERTY,false);
    TestMwRevisionProcessor tmrpAllLexemes=new TestMwRevisionProcessor();
    dpc.registerMwRevisionProcessor(tmrpAllLexemes,MwRevision.MODEL_WIKIBASE_LEXEME,false);
    dpc.processDump(dpc.getMostRecentDump(DumpContentType.DAILY));
    List<MwRevision> revisionsAllItems=new ArrayList<>();
    revisionsAllItems.add(getItemRevision(4));
    revisionsAllItems.add(getItemRevision(5));
    revisionsAllItems.add(getItemRevision(3));
    revisionsAllItems.add(getItemRevision(2));
    List<MwRevision> revisionsAllProperties=new ArrayList<>();
    revisionsAllProperties.add(getPropertyRevision(4));
    revisionsAllProperties.add(getPropertyRevision(5));
    List<MwRevision> revisionsAllLexemes=new ArrayList<>();
    revisionsAllLexemes.add(getLexemeRevision(9));
    revisionsAllLexemes.add(getLexemeRevision(10));
    List<MwRevision> revisionsAll=new ArrayList<>(revisionsAllItems);
    revisionsAll.add(getPageRevision(1));
    revisionsAll.add(getPageRevision(2));
    revisionsAll.addAll(revisionsAllProperties);
    revisionsAll.addAll(revisionsAllLexemes);
    List<MwRevision> revisionsAllCurrent=new ArrayList<>();
    revisionsAllCurrent.add(getItemRevision(5));
    revisionsAllCurrent.add(getPageRevision(2));
    revisionsAllCurrent.add(getPropertyRevision(5));
    revisionsAllCurrent.add(getLexemeRevision(10));
    assertEquals(""Wikidata Toolkit Test"",tmrpAll.siteName);
    assertEquals(revisionsAll.size(),mwrpAllStats.getTotalRevisionCount());
    assertEquals(revisionsAll.size(),mwrpAllStats.getCurrentRevisionCount());
    assertEqualRevisionLists(revisionsAll,tmrpAll.revisions,""all"");
    assertEqualRevisionLists(revisionsAllItems,tmrpAllItems.revisions,""allitems"");
    assertEqualRevisionLists(revisionsAllCurrent,tmrpAllCurrent.revisions,""allcurrent"");
    assertEqualRevisionLists(revisionsAllProperties,tmrpAllProperties.revisions,""allproperties"");
    assertEqualRevisionLists(revisionsAllLexemes,tmrpAllLexemes.revisions,""alllexemes"");
    assertEquals(revisionsAllItems.size(),edpAllCounter.itemCount);
    assertEquals(revisionsAllProperties.size(),edpAllCounter.propCount);
    assertEquals(1,edpCurrentCounter.itemCount);
    assertEquals(1,edpCurrentCounter.propCount);
}"
"@Test
public void testRecovery() throws Exception {
    SpringBusFactory bf = new SpringBusFactory();
    bus = bf.createBus();
    BusFactory.setDefaultBus(bus);
    LOG.fine((""Created bus "" + bus) + "" with default cfg"");
    ControlService cs = new ControlService();
    Control control = cs.getControlPort();
    updateAddressPort(control, PORT);
    assertTrue(""Failed to start greeter"", control.startGreeter(SERVER_LOSS_CFG));
    LOG.fine(""Started greeter server."");
    greeterBus = new SpringBusFactory().createBus(CFG);
    LOG.fine(((""Created bus "" + greeterBus) + "" with cfg : "") + CFG);
    BusFactory.setDefaultBus(greeterBus);
    greeterBus.getExtension(RMManager.class).getRMAssertion().getBaseRetransmissionInterval().setMilliseconds(new BigInteger(""60000""));
    GreeterService gs = new GreeterService();
    Greeter greeter = gs.getGreeterPort();
    updateAddressPort(greeter, PORT);
    LOG.fine(""Created greeter client."");
    ConnectionHelper.setKeepAliveConnection(greeter, true);
    Client c = ClientProxy.getClient(greeter);
    HTTPConduit hc = ((HTTPConduit) (c.getConduit()));
    HTTPClientPolicy cp = hc.getClient();
    cp.setDecoupledEndpoint((""http:example.com""));
    out = new OutMessageRecorder();
    in = new InMessageRecorder();
    greeterBus.getOutInterceptors().add(out);
    greeterBus.getInInterceptors().add(in);
    LOG.fine(""Configured greeter client."");
    Response<GreetMeResponse>[] responses = cast(new Response[4]);
    responses[0] = greeter.greetMeAsync(""one"");
    responses[1] = greeter.greetMeAsync(""two"");
    responses[2] = greeter.greetMeAsync(""three"");
    verifyMissingResponse(responses);
    control.stopGreeter(SERVER_LOSS_CFG);
    LOG.fine(""Stopped greeter server"");
    out.getOutboundMessages().clear();
    in.getInboundMessages().clear();
    control.startGreeter(CFG);
    String nl = System.getProperty(""line.separator"");
    LOG.fine((""Restarted greeter server"" + nl) + nl);
    verifyServerRecovery(responses);
    out.getOutboundMessages().clear();
    in.getInboundMessages().clear();
    responses[3] = greeter.greetMeAsync(""four"");
    verifyRetransmissionQueue();
    greeterBus.shutdown(true);
    control.stopGreeter(CFG);
    bus.shutdown(true);
}"
"@Test public void findingAnnotationsRecursively(){
    Method method=findMethod(this.getClass(),""withMarker"",String.class);
    List<Annotation> annotations=allAnnotations(method.getParameters()[0]);
    assertEquals(4,annotations.size());
    assertEquals(X.class,annotations.get(0).annotationType());
    assertEquals(Y.class,annotations.get(1).annotationType());
    assertTrue(Z.class.equals(annotations.get(2).annotationType()) || W.class.equals(annotations.get(2).annotationType()));
    if (Z.class.equals(annotations.get(2).annotationType())) {
        assertEquals(W.class,annotations.get(3).annotationType());
    }
    else {
        assertEquals(Z.class,annotations.get(3).annotationType());
    }
}"
"@Test
public void testProcessAction_ok() {
    final Mock mockResponse = mock(ActionResponse.class);
    PortletMode mode = PortletMode.VIEW;
    Map<String, String> initParams = new HashMap<String, String>();
    initParams.put(""viewNamespace"", ""/view"");
    Map<String, String[]> requestParams = new HashMap<String, String[]>();
    requestParams.put(ACTION_PARAM, new String[]{""/view/testAction""});
    requestParams.put(MODE_PARAM, new String[]{mode.toString()});
    initParams.put(StrutsConstants.STRUTS_ALWAYS_SELECT_FULL_NAMESPACE, ""true"");
    initPortletConfig(initParams, new HashMap<String, Object>());
    initRequest(requestParams, new HashMap<String, Object>(), new HashMap<String, Object>(), PortletMode.VIEW, WindowState.NORMAL, true, null);
    setupActionFactory(""/view"", ""testAction"", ""success"", EasyMock.createNiceMock(ValueStack.class));
    try {
        dispatcher
        .setActionProxyFactory((ActionProxyFactory) mockActionFactory
        .proxy());
        dispatcher.init((PortletConfig) mockConfig.proxy());
        dispatcher.processAction((ActionRequest) mockRequest.proxy(),
        (ActionResponse) mockResponse.proxy());
    } catch (Exception e) {
        e.printStackTrace();
        fail(""Error occured"");
    }
}"
"@Test public void onlyTrumpsAlso() throws Exception {
    assertThat(testResult(OnlyTrumpsAlso.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),OnlyTrumpsAlso.iterations);
    OnlyTrumpsAlso.iterations=0;
}"
"@Test
public void testFlowNoConflictsWithClients() throws Exception {
    startComputation(0, stopFlag0);
    if (!tcpDiscovery())
    return;
    startComputation(1, stopFlag1);
    startComputation(2, stopFlag2);
    startComputation(3, stopFlag3);
    startComputation(4, stopFlag4);
    final Set<Integer> deafClientObservedIds = new ConcurrentHashSet<>();
    startListening(5, true, deafClientObservedIds);
    final Set<Integer> regClientObservedIds = new ConcurrentHashSet<>();
    startListening(6, false, regClientObservedIds);
    START_LATCH.countDown();
    Thread killer = new Thread(new ServerNodeKiller());
    Thread resurrection = new Thread(new ServerNodeResurrection());
    killer.setName(""node-killer-thread"");
    killer.start();
    resurrection.setName(""node-resurrection-thread"");
    resurrection.start();
    while (!updatesQueue.isEmpty())
    Thread.sleep(1000);
    killer.interrupt();
    resurrection.interrupt();
}"
"public void testDynamicAttributesSupport() throws Exception {
    File file=new File(FreeMarkerResultTest.class.getResource(""dynaAttributes.ftl"").toURI());
    EasyMock.expect(servletContext.getRealPath(""/tutorial/org/apache/struts2/views/freemarker/dynaAttributes.ftl"")).andReturn(file.getAbsolutePath());
    file=new File(ClassLoaderUtil.getResource(""template/simple/text.ftl"",getClass()).toURI());
    EasyMock.expect(servletContext.getRealPath(""/template/simple/text.ftl"")).andReturn(file.getAbsolutePath());
    file=new File(ClassLoaderUtil.getResource(""template/simple/css.ftl"",getClass()).toURI());
    EasyMock.expect(servletContext.getRealPath(""/template/simple/css.ftl"")).andReturn(file.getAbsolutePath());
    EasyMock.expect(servletContext.getRealPath(""/template/~~~simple/css.ftl"")).andReturn(file.getAbsolutePath());
    file=new File(ClassLoaderUtil.getResource(""template/simple/scripting-events.ftl"",getClass()).toURI());
    EasyMock.expect(servletContext.getRealPath(""/template/simple/scripting-events.ftl"")).andReturn(file.getAbsolutePath());
    EasyMock.expect(servletContext.getRealPath(""/template/~~~simple/scripting-events.ftl"")).andReturn(file.getAbsolutePath());
    file=new File(ClassLoaderUtil.getResource(""template/simple/common-attributes.ftl"",getClass()).toURI());
    EasyMock.expect(servletContext.getRealPath(""/template/simple/common-attributes.ftl"")).andReturn(file.getAbsolutePath());
    EasyMock.expect(servletContext.getRealPath(""/template/~~~simple/common-attributes.ftl"")).andReturn(file.getAbsolutePath());
    file=new File(ClassLoaderUtil.getResource(""template/simple/dynamic-attributes.ftl"",getClass()).toURI());
    EasyMock.expect(servletContext.getRealPath(""/template/simple/dynamic-attributes.ftl"")).andReturn(file.getAbsolutePath());
    EasyMock.expect(servletContext.getRealPath(""/template/~~~simple/dynamic-attributes.ftl"")).andReturn(file.getAbsolutePath());
    EasyMock.replay(servletContext);
    init();
    request.setRequestURI(""/tutorial/test6.action"");
    ActionMapping mapping=container.getInstance(ActionMapper.class).getMapping(request,configurationManager);
    dispatcher.serviceAction(request,response,mapping);
    String result=stringWriter.toString();
    assertThat(result,allOf(startsWith(""<input type=\""text\"" name=\""test\"" value=\""\"" id=\""test\""""),containsString(""foo=\""bar\""""),containsString(""placeholder=\""input\""""),endsWith(""<input type=\""text\"" name=\""test\"" value=\""\"" id=\""test\"" break=\""true\""/>"" + ""<input type=\""text\"" name=\""required\"" value=\""\"" id=\""required\"" required=\""true\""/>"")));
}"
"@Test
public void testReplicatorProducerName() throws Exception {
    log.info(""--- Starting ReplicatorTest::testReplicatorProducerName ---"");
    final String topicName = BrokerTestUtil.newUniqueName(""persistent"");
    final TopicName dest = TopicName.get(topicName);
    @Cleanup
    MessageProducer producer1 = new MessageProducer(url1, dest);
    Awaitility.await().untilAsserted(() -> {
        assertTrue(pulsar2.getBrokerService().getTopicReference(topicName).isPresent());
    });
    Optional<Topic> topic = pulsar2.getBrokerService().getTopicReference(topicName);
    assertTrue(topic.isPresent());
    Set<String> remoteClusters = topic.get().getProducers().values().stream().map(Producer::getRemoteCluster).collect(Collectors.toSet());
    assertTrue(remoteClusters.contains(""r1""));
}"
"@Test public void serializeString() throws IOException {
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of("""")),""{\""@type\"":\""string\"",\""@value\"":\""\""}"");
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of(""Test"")),""{\""@type\"":\""string\"",\""@value\"":\""Test\""}"");
}"
"@Test
public void testQueuePageWithProjectCurrentlyBuilding() throws Exception {
    String M2_PROJ_GRP_NAME = getProperty(""M2_PROJ_GRP_NAME"");
    String M2_PROJ_GRP_ID = getProperty(""M2_PROJ_GRP_ID"");
    String M2_PROJ_GRP_DESCRIPTION = getProperty(""M2_PROJ_GRP_DESCRIPTION"");
    buildProjectForQueuePageTest(M2_PROJ_GRP_NAME, M2_PROJ_GRP_ID, M2_PROJ_GRP_DESCRIPTION, M2_PROJ_GRP_NAME);
    String location = getSelenium().getLocation();
    clickAndWait(""link=Queues"");
    assertPage(""Continuum - Build Queue"");
    assertTextPresent(""Current Build"");
    assertTextPresent(""Build Queue"");
    assertTextPresent(""Current Checkout"");
    assertTextPresent(""Checkout Queue "");
    assertTextPresent(""Current Prepare Build"");
    assertTextPresent(""Prepare Build Queue"");
    assertElementPresent();
    assertTextPresent(M2_PROJ_GRP_NAME);
    getSelenium().open(location);
    waitPage();
    waitForElementPresent();
}"
"@Test
public void testUpdatePerOperationSamplerUpdatesExistingPerOperationSampler() throws Exception {
    PerOperationSampler perOperationSampler = mock(PerOperationSampler.class);
    OperationSamplingParameters parameters = mock(OperationSamplingParameters.class);
    when(samplingManager.getSamplingStrategy(SERVICE_NAME)).thenReturn(
    new SamplingStrategyResponse(null, null, parameters));
    undertest = new RemoteControlledSampler(SERVICE_NAME, samplingManager, perOperationSampler, metrics);
    undertest.updateSampler();
    Thread.sleep(20);
    verify(perOperationSampler, times(2)).update(parameters);
}"
"@Test public void explicitConversion() throws Exception {
    assertThat(testResult(ExplicitConversion.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ExplicitConversion.iterations);
    assertEquals(new HashSet<>(asList(LocalDate.of(2017,1,1),LocalDate.of(2001,12,25))),new HashSet<>(ExplicitConversion.values.subList(0,2)));
    ExplicitConversion.iterations=0;
}"
"@Test public void testReflectionHashCodeExcludeFields(){
    final TestObjectWithMultipleFields x=new TestObjectWithMultipleFields(1,2,3);
    assertEquals(((17 * 37 + 1) * 37 + 3) * 37 + 2,HashCodeBuilder.reflectionHashCode(x));
    assertEquals(((17 * 37 + 1) * 37 + 3) * 37 + 2,HashCodeBuilder.reflectionHashCode(x,(String[])null));
    assertEquals(((17 * 37 + 1) * 37 + 3) * 37 + 2,HashCodeBuilder.reflectionHashCode(x));
    assertEquals(((17 * 37 + 1) * 37 + 3) * 37 + 2,HashCodeBuilder.reflectionHashCode(x,""xxx""));
    assertEquals((17 * 37 + 1) * 37 + 3,HashCodeBuilder.reflectionHashCode(x,""two""));
    assertEquals((17 * 37 + 1) * 37 + 2,HashCodeBuilder.reflectionHashCode(x,""three""));
    assertEquals(17 * 37 + 1,HashCodeBuilder.reflectionHashCode(x,""two"",""three""));
    assertEquals(17,HashCodeBuilder.reflectionHashCode(x,""one"",""two"",""three""));
    assertEquals(17,HashCodeBuilder.reflectionHashCode(x,""one"",""two"",""three"",""xxx""));
}"
"@Test
public void testKmeansSVD() throws Exception {
    DistanceMeasure measure = new EuclideanDistanceMeasure();
    Path output = getTestTempDirPath(""output"");
    Path tmp = getTestTempDirPath(""tmp"");
    DistributedLanczosSolver solver = new DistributedLanczosSolver();
    Configuration conf = new Configuration();
    solver.setConf(conf);
    Path testData = getTestTempDirPath(""testdata"");
    int sampleDimension = sampleData.get(0).get().size();
    int desiredRank = 15;
    solver.run(testData, output, tmp, null, sampleData.size(), sampleDimension, false, desiredRank, 0.5, 0.0, true);
    Path cleanEigenvectors = new Path(output, EigenVerificationJob.CLEAN_EIGENVECTORS);
    Matrix a = new DenseMatrix(sampleData.size(), sampleDimension);
    int i = 0;
    for (VectorWritable vw : sampleData) {
        a.assignRow(i++, vw.get());
    }
    Matrix p = new DenseMatrix(39, desiredRank - 1);
    FileSystem fs = FileSystem.get(cleanEigenvectors.toUri(), conf);
    i = 0;
    for (VectorWritable value : new SequenceFileValueIterable<VectorWritable>(cleanEigenvectors, conf)) {
        Vector v = value.get();
        p.assignColumn(i, v);
        i++;
    }
    Matrix sData = a.times(p);
    Path svdData = new Path(output, ""svddata"");
    SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, svdData, IntWritable.class, VectorWritable.class);
    try {
        IntWritable key = new IntWritable();
        VectorWritable value = new VectorWritable();
        for (int row = 0; row < sData.numRows(); row++) {
            key.set(row);
            value.set(sData.viewRow(row));
            writer.append(key, value);
        }
    } finally {
        Closeables.closeQuietly(writer);
    }
    CanopyDriver.run(conf, svdData, output, measure, 8, 4, false, 0.0, true);
    KMeansDriver.run(svdData, new Path(output, ""clusters-0""), output, measure, 0.001, 10, true, true);
    ClusterDumper clusterDumper = new ClusterDumper(finalClusterPath(conf, output, 10), new Path(output, ""clusteredPoints""));
    clusterDumper.printClusters(termDictionary);
}"
"@Test public void testRequestMetaForSuccessfulRequest() throws Exception {
    ListenerMeta listenerMeta=listenerMetaIndexProvider.get().getListenerMetas().get(0);
    OnlineServerMetaIndexProvider onlineServerMetaIndexProvider=listenerMeta.getOnlineServerMetaIndexProvider();
    await().until(() -> {
        assertThat(onlineServerMetaIndexProvider.get().getBalancer().size(),equalTo(3));
    }
    );
    String content=fetch(""http://example.com/request-meta"");
    RequestMeta requestMeta=RequestMeta.fromJSON(content);
    requestMeta.getHeaders().remove(""Via"");
    requestMeta.getHeaders().remove(""Cache-Control"");
    requestMeta.getHeaders().remove(""Accept"");
    requestMeta.getHeaders().remove(""Pragma"");
    assertEquals(""foo"",requestMeta.getHeaders().get(""X-foo""));
    content=requestMeta.toJSON();
    JSONAssert.assertEquals(content,corporaAsserter.getCorporaCache().read(""testRequestMetaForSuccessfulRequest""),false);
}"
"@Test
public void testWriteGaps() throws Exception {
    final Object notifyObject = new Object();
    byte[] passwd = new byte[20];
    Arrays.fill(passwd, ((byte) ('a')));
    InetSocketAddress addr = new InetSocketAddress(""127.0.0.1"", port);
    ResultStruct arc = new ResultStruct();
    BookieClient bc = new BookieClient(new ClientConfiguration(), channelFactory, executor);
    ChannelBuffer bb;
    bb = createByteBuffer(1, 1, 1);
    bc.addEntry(addr, 1, passwd, 1, bb, wrcb, null, FLAG_NONE);
    synchronized(arc) {
        bc.readEntry(addr, 1, 1, recb, arc, FLAG_NONE);
        arc.wait(1000);
        assertEquals(0, arc.rc);
        assertEquals(1, arc.entry.getInt());
    }
    bb = createByteBuffer(2, 1, 2);
    bc.addEntry(addr, 1, passwd, 2, bb, wrcb, null, FLAG_NONE);
    bb = createByteBuffer(3, 1, 3);
    bc.addEntry(addr, 1, passwd, 3, bb, wrcb, null, FLAG_NONE);
    bb = createByteBuffer(5, 1, 5);
    bc.addEntry(addr, 1, passwd, 5, bb, wrcb, null, FLAG_NONE);
    bb = createByteBuffer(7, 1, 7);
    bc.addEntry(addr, 1, passwd, 7, bb, wrcb, null, FLAG_NONE);
    synchronized(notifyObject) {
        bb = createByteBuffer(11, 1, 11);
        bc.addEntry(addr, 1, passwd, 11, bb, wrcb, notifyObject, FLAG_NONE);
        notifyObject.wait();
    }
    synchronized(arc) {
        bc.readEntry(addr, 1, 6, recb, arc, FLAG_NONE);
        arc.wait(1000);
        assertEquals(NoSuchEntryException, arc.rc);
    }
    synchronized(arc) {
        bc.readEntry(addr, 1, 7, recb, arc, FLAG_NONE);
        arc.wait(1000);
        assertEquals(0, arc.rc);
        assertEquals(7, arc.entry.getInt());
    }
    synchronized(arc) {
        bc.readEntry(addr, 1, 1, recb, arc, FLAG_NONE);
        arc.wait(1000);
        assertEquals(0, arc.rc);
        assertEquals(1, arc.entry.getInt());
    }
    synchronized(arc) {
        bc.readEntry(addr, 1, 2, recb, arc, FLAG_NONE);
        arc.wait(1000);
        assertEquals(0, arc.rc);
        assertEquals(2, arc.entry.getInt());
    }
    synchronized(arc) {
        bc.readEntry(addr, 1, 3, recb, arc, FLAG_NONE);
        arc.wait(1000);
        assertEquals(0, arc.rc);
        assertEquals(3, arc.entry.getInt());
    }
    synchronized(arc) {
        bc.readEntry(addr, 1, 4, recb, arc, FLAG_NONE);
        arc.wait(1000);
        assertEquals(NoSuchEntryException, arc.rc);
    }
    synchronized(arc) {
        bc.readEntry(addr, 1, 11, recb, arc, FLAG_NONE);
        arc.wait(1000);
        assertEquals(0, arc.rc);
        assertEquals(11, arc.entry.getInt());
    }
    synchronized(arc) {
        bc.readEntry(addr, 1, 5, recb, arc, FLAG_NONE);
        arc.wait(1000);
        assertEquals(0, arc.rc);
        assertEquals(5, arc.entry.getInt());
    }
    synchronized(arc) {
        bc.readEntry(addr, 1, 10, recb, arc, FLAG_NONE);
        arc.wait(1000);
        assertEquals(NoSuchEntryException, arc.rc);
    }
    synchronized(arc) {
        bc.readEntry(addr, 1, 12, recb, arc, FLAG_NONE);
        arc.wait(1000);
        assertEquals(NoSuchEntryException, arc.rc);
    }
    synchronized(arc) {
        bc.readEntry(addr, 1, 13, recb, arc, FLAG_NONE);
        arc.wait(1000);
        assertEquals(NoSuchEntryException, arc.rc);
    }
}"
"@Test public void testGetMap3(){
    Map<String,String> map1=new LinkedHashMap(1);
    Map<String,String> map2=new LinkedHashMap(2);
    map1.put(""key"",""value"");
    map2.put(""key1"",""value1"");
    map2.put(""key2"",""value2"");
    Iterator<Map.Entry<String,String>> iter=map1.entrySet().iterator();
    Assert.assertEquals(iter.next(),CollectionUtils.get(map1,0));
    Iterator<Map.Entry<String,String>> iter2=map2.entrySet().iterator();
    iter2.next();
    Map.Entry<String,String> second=iter2.next();
    Assert.assertEquals(second,CollectionUtils.get(map2,1));
}"
"@Test public void twin() throws Exception {
    final ObjectMapper mapper=mapperWithModule();
    Object sampleOne=randomSample(Object.class);
    Object sampleTwo=randomSample(Object.class);
    String expectedJson1=""{\""one\"":"" + mapper.writeValueAsString(sampleOne) + "",\""two\"":""+ mapper.writeValueAsString(sampleTwo)+ ""}"";
    String expectedJson2=""{\""two\"":"" + mapper.writeValueAsString(sampleTwo) + "",\""one\"":""+ mapper.writeValueAsString(sampleOne)+ ""}"";
    Twin<String> twin=Tuples.twin((String)sampleOne,(String)sampleTwo);
    String writeValue=mapper.writeValueAsString(twin);
    boolean assert1=writeValue.equals(expectedJson1);
    boolean assert2=writeValue.equals(expectedJson2);
    Assert.assertTrue(assert1 || assert2);
    Assert.assertEquals(twin,mapper.readValue(expectedJson1,new TypeReference<Twin<String>>(){
    }
    ));
}"
"@Test public void arrayOfFunction() throws Exception {
    assertThat(testResult(ArrayOfFunction.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ArrayOfFunction.iterations);
}"
"@Test
public void testSystemMetadataRetrieval() throws Exception {
    appClient.deploy(DEFAULT, createAppJarFile(AllProgramsApp.class));
    Id.Stream streamId = Stream.from(DEFAULT, STREAM_NAME);
    Set<String> streamSystemTags = getTags(streamId, SYSTEM);
    Assert.assertEquals(ImmutableSet.of(STREAM_NAME), streamSystemTags);
    Map<String, String> streamSystemProperties = getProperties(streamId, SYSTEM);
    final String creationTime = ""creation-time"";
    String description = ""description"";
    String schema = ""schema"";
    String ttl = ""ttl"";
    Assert.assertTrue(""Expected creation time to exist but it does not"", streamSystemProperties.containsKey(creationTime));
    long createTime = Long.parseLong(streamSystemProperties.get(creationTime));
    Assert.assertTrue(""Stream create time should be within the last hour - "" + createTime, createTime > (System.currentTimeMillis() - TimeUnit.HOURS.toMillis(1)));
    Assert.assertEquals(ImmutableMap.of(schema, Schema.recordOf(""stringBody"", Field.of(""body"", Schema.of(STRING))).toString(), ttl, String.valueOf(Long.MAX_VALUE), description, ""test stream"", creationTime, String.valueOf(createTime)), streamSystemProperties);
    long newTtl = 100000L;
    streamClient.setStreamProperties(streamId, new StreamProperties(newTtl, null, null));
    streamSystemProperties = getProperties(streamId, SYSTEM);
    Assert.assertEquals(ImmutableMap.of(schema, Schema.recordOf(""stringBody"", Field.of(""body"", Schema.of(STRING))).toString(), ttl, String.valueOf(newTtl * 1000), description, ""test stream"", creationTime, String.valueOf(createTime)), streamSystemProperties);
    Set<MetadataRecord> streamSystemMetadata = getMetadata(streamId, SYSTEM);
    Assert.assertEquals(ImmutableSet.of(new MetadataRecord(streamId, MetadataScope.SYSTEM, streamSystemProperties, streamSystemTags)), streamSystemMetadata);
    Id.Stream.View view = View.from(streamId, ""view"");
    Schema viewSchema = Schema.recordOf(""record"", Field.of(""viewBody"", Schema.nullableOf(Schema.of(BYTES))));
    streamViewClient.createOrUpdate(view, new ViewSpecification(new FormatSpecification(""format"", viewSchema)));
    Set<String> viewSystemTags = getTags(view, SYSTEM);
    Assert.assertEquals(ImmutableSet.of(""view"", STREAM_NAME), viewSystemTags);
    Map<String, String> viewSystemProperties = getProperties(view, SYSTEM);
    Assert.assertEquals(viewSchema.toString(), viewSystemProperties.get(schema));
    ImmutableSet<String> viewUserTags = ImmutableSet.of(""viewTag"");
    addTags(view, viewUserTags);
    Assert.assertEquals(ImmutableSet.of(new MetadataRecord(view, MetadataScope.USER, ImmutableMap.<String, String>of(), viewUserTags), new MetadataRecord(view, MetadataScope.SYSTEM, viewSystemProperties, viewSystemTags)), getMetadata(view));
    Id.DatasetInstance datasetInstance = DatasetInstance.from(DEFAULT, DATASET_NAME);
    Set<String> dsSystemTags = getTags(datasetInstance, SYSTEM);
    Assert.assertEquals(ImmutableSet.of(DATASET_NAME, BATCH_TAG, EXPLORE_TAG), dsSystemTags);
    Map<String, String> dsSystemProperties = getProperties(datasetInstance, SYSTEM);
    Assert.assertTrue(""Expected creation time to exist but it does not"", dsSystemProperties.containsKey(creationTime));
    createTime = Long.parseLong(dsSystemProperties.get(creationTime));
    Assert.assertTrue(""Dataset create time should be within the last hour - "" + createTime, createTime > (System.currentTimeMillis() - TimeUnit.HOURS.toMillis(1)));
    Assert.assertEquals(ImmutableMap.of(""type"", KeyValueTable.class.getName(), description, ""test dataset"", creationTime, String.valueOf(createTime)), dsSystemProperties);
    datasetClient.update(datasetInstance, ImmutableMap.of(PROPERTY_TTL, ""100000""));
    dsSystemProperties = getProperties(datasetInstance, SYSTEM);
    Assert.assertEquals(ImmutableMap.of(""type"", KeyValueTable.class.getName(), description, ""test dataset"", ttl, ""100000"", creationTime, String.valueOf(createTime)), dsSystemProperties);
    Id.Artifact artifactId = getArtifactId();
    Assert.assertEquals(ImmutableSet.of(new MetadataRecord(artifactId, MetadataScope.SYSTEM, ImmutableMap.<String, String>of(), ImmutableSet.of(AllProgramsApp.class.getSimpleName()))), getMetadata(artifactId, SYSTEM));
    Id.Application app = Application.from(DEFAULT, NAME);
    Assert.assertEquals(ImmutableMap.builder().put((FLOW.getPrettyName() + MetadataDataset.KEYVALUE_SEPARATOR) + NoOpFlow.NAME, NAME).put((MAPREDUCE.getPrettyName() + MetadataDataset.KEYVALUE_SEPARATOR) + NoOpMR.NAME, NAME).put((MAPREDUCE.getPrettyName() + MetadataDataset.KEYVALUE_SEPARATOR) + NoOpMR2.NAME, NAME).put((SERVICE.getPrettyName() + MetadataDataset.KEYVALUE_SEPARATOR) + NoOpService.NAME, NAME).put((SPARK.getPrettyName() + MetadataDataset.KEYVALUE_SEPARATOR) + NoOpSpark.NAME, NAME).put((WORKER.getPrettyName() + MetadataDataset.KEYVALUE_SEPARATOR) + NoOpWorker.NAME, NAME).put((WORKFLOW.getPrettyName() + MetadataDataset.KEYVALUE_SEPARATOR) + NoOpWorkflow.NAME, NAME).put((""schedule"" + MetadataDataset.KEYVALUE_SEPARATOR) + AllProgramsApp.SCHEDULE_NAME, (AllProgramsApp.SCHEDULE_NAME + MetadataDataset.KEYVALUE_SEPARATOR) + AllProgramsApp.SCHEDULE_DESCRIPTION).build(), getProperties(app, SYSTEM));
    Assert.assertEquals(ImmutableSet.of(AllProgramsApp.class.getSimpleName(), NAME), getTags(app, SYSTEM));
    assertProgramSystemMetadata(Program.from(app, FLOW, NAME), ""Realtime"");
    assertProgramSystemMetadata(Program.from(app, WORKER, NAME), ""Realtime"");
    assertProgramSystemMetadata(Program.from(app, SERVICE, NAME), ""Realtime"");
    assertProgramSystemMetadata(Program.from(app, MAPREDUCE, NAME), ""Batch"");
    assertProgramSystemMetadata(Program.from(app, SPARK, NAME), ""Batch"");
    assertProgramSystemMetadata(Program.from(app, WORKFLOW, NAME), ""Batch"");
}"
"@Test
@Test(timeOut = 10000)
public void producerSendAsync() throws PulsarClientException {
    String key = ""producerSendAsync"";
    final String topicName = ""persistent://prop/cluster/namespace/topic-"" + key;
    final String subscriptionName = ""my-subscription-"" + key;
    final String messagePredicate = ""my-message-"" + key + ""-"";
    final int numberOfMessages = 30;
    Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)
    .enableBatching(false)
    .messageRoutingMode(MessageRoutingMode.SinglePartition)
    .create();
    Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(topicName).subscriptionName(subscriptionName)
    .subscribe();
    Set<MessageId> messageIds = new HashSet<>();
    List<Future<MessageId>> futures = new ArrayList<>();
    for (int i = 0; i < numberOfMessages; i++) {
        String message = messagePredicate + i;
        futures.add(producer.sendAsync(message.getBytes()));
    }
    MessageIdImpl previousMessageId = null;
    for (Future<MessageId> f : futures) {
        try {
            MessageIdImpl currentMessageId = (MessageIdImpl) f.get();
            if (previousMessageId != null) {
                Assert.assertTrue(currentMessageId.compareTo(previousMessageId) > 0,
                ""Message Ids should be in ascending order"");
            }
            messageIds.add(currentMessageId);
            previousMessageId = currentMessageId;
        } catch (Exception e) {
            Assert.fail(""Failed to publish message, Exception: "" + e.getMessage());
        }
    }
    log.info(""Message IDs = "" + messageIds);
    Assert.assertEquals(messageIds.size(), numberOfMessages, ""Not all messages published successfully"");
    for (int i = 0; i < numberOfMessages; i++) {
        Message<byte[]> message = consumer.receive();
        Assert.assertEquals(new String(message.getData()), messagePredicate + i);
        MessageId messageId = message.getMessageId();
        Assert.assertTrue(messageIds.remove(messageId), ""Failed to receive message"");
    }
    log.info(""Message IDs = "" + messageIds);
    Assert.assertEquals(messageIds.size(), 0, ""Not all messages received successfully"");
    consumer.unsubscribe();
}"
"@Test
public void testWatch() throws Exception {
    final JsonArray operationTypes = new JsonArray(Arrays.asList(""insert"", ""update"", ""replace"", ""delete""));
    final JsonObject match = new JsonObject().put(""operationType"", new JsonObject().put(""$in"", operationTypes));
    final JsonArray pipeline = new JsonArray().add(new JsonObject().put(""$match"", match));
    final JsonObject fields = new JsonObject().put(""operationType"", true).put(""namespaceDocument"", true).put(""destinationNamespaceDocument"", true).put(""documentKey"", true).put(""updateDescription"", true).put(""fullDocument"", true);
    pipeline.add(new JsonObject().put(""$project"", fields));
    final String collection = randomCollection();
    final JsonObject doc = createDoc();
    final CountDownLatch latch = new CountDownLatch(4);
    final AtomicReference<ReadStream<ChangeStreamDocument<JsonObject>>> streamReference = new AtomicReference<>();
    mongoClient.createCollection(collection, onSuccess(( res) -> {
        ReadStream<ChangeStreamDocument<JsonObject>> stream = mongoClient.watch(collection, pipeline, true, 1).handler(( changeStreamDocument) -> {
            OperationType operationType = changeStreamDocument.getOperationType();
            assertNotNull(operationType);
            JsonObject fullDocument = changeStreamDocument.getFullDocument();
            switch (operationType.getValue()) {
                case ""insert"" :
                assertNotNull(fullDocument);
                assertNotNull(fullDocument.getString(MongoClientUpdateResult.ID_FIELD));
                assertEquals(""bar"", fullDocument.getString(""foo""));
                break;
                case ""update"" :
                assertNotNull(fullDocument);
                assertEquals(""updatedValue"", fullDocument.getString(""fieldToUpdate""));
                break;
                case ""replace"" :
                assertNotNull(fullDocument);
                assertEquals(""replacedValue"", fullDocument.getString(""fieldToReplace""));
                break;
                case ""delete"" :
                assertNull(fullDocument);
                break;
                default :
            }
            latch.countDown();
            if (latch.getCount() == 1) {
                mongoClient.removeDocuments(collection, new JsonObject());
            }
        }).endHandler(( v) -> assertEquals(0, latch.getCount())).exceptionHandler(this::fail).fetch(1);
        streamReference.set(stream);
        vertx.setTimer(50, ( v) -> {
            mongoClient.insert(collection, doc).compose(( idString) -> {
                doc.put(MongoClientUpdateResult.ID_FIELD, idString);
                doc.put(""fieldToUpdate"", ""updatedValue"");
                final JsonObject query = new JsonObject().put(MongoClientUpdateResult.ID_FIELD, idString);
                final JsonObject updateField = new JsonObject().put(""fieldToUpdate"", ""updatedValue"");
                return CompositeFuture.all(mongoClient.updateCollection(collection, query, new JsonObject().put(""$set"", updateField)), mongoClient.save(collection, doc.put(""fieldToReplace"", ""replacedValue"")));
            });
        });
    }));
    awaitLatch(latch);
    streamReference.get().handler(null);
}"
"@Test public void testClassFinderDefaultsToOwnPackage() throws Exception {
    ClassFinder allClassesFinder=new ClassFinder(classLoader);
    Set<Class<?>> pkgClasses=allClassesFinder.findClasses(ClassFinder.class.getPackage().getName(),false);
    Set<Class<?>> defaultClasses=allClassesFinder.findClasses(false);
    Object[] pkgClassesArray=pkgClasses.toArray();
    Object[] defaultClassesArray=defaultClasses.toArray();
    assertEquals(pkgClassesArray.length,defaultClassesArray.length);
    assertThat(pkgClassesArray,arrayContainingInAnyOrder(defaultClassesArray));
}"
"@Test public void primitiveShorts() throws Exception {
    assertThat(testResult(PrimitiveShorts.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveShorts.iterations);
    assertEquals(new HashSet<>(asList(Short.valueOf(""9""),Short.valueOf(""8""))),new HashSet<>(PrimitiveShorts.values.subList(0,2)));
    PrimitiveShorts.iterations=0;
}"
"@Test
public void doTestLogicalNodesConcurrentDFOMans(final int threads,
final int events, int timeout) throws IOException, InterruptedException,
FlumeSpecException {
    BenchmarkHarness.setupLocalWriteDir();
    FlumeMaster master = new FlumeMaster();
    FlumeNode node = new FlumeNode(new DirectMasterRPC(master), false, false);
    final Reportable[] dfos = new Reportable[threads];
    for (int i = 0; i < threads; i++) {
        String name = ""test."" + i;
        String report = ""report."" + i;
        int count = events + i;
        String src = ""asciisynth("" + count + "",100)"";
        String snk = ""{ diskFailover => counter(\"""" + report + ""\"") } "";
        node.getLogicalNodeManager().testingSpawn(name, src, snk);
        dfos[i] = node.getLogicalNodeManager().get(name);
    }
    waitForEmptyDFOs(node, timeout);
    boolean success = true;
    for (int i = 0; i < threads; i++) {
        LOG.info(dfos[i].getReport());
    }
    for (int i = 0; i < threads; i++) {
        CounterSink cnt = (CounterSink) ReportManager.get().getReportable(
        ""report."" + i);
        LOG.info(i + "" expected "" + (events + i) + "" and got "" + cnt.getCount());
        success &= ((events + i) == cnt.getCount());
        assertEquals(events + i, cnt.getCount());
    }
    assertTrue(""Counts did not line up"", success);
    BenchmarkHarness.cleanupLocalWriteDir();
}"
"@Test public void test_2() throws Exception {
    String sql=""create database test_cascade for 'ALIYUN$test@aliyun.com' options(resourceType=ecu ecu_type=c1 ecu_count=2)"";
    MySqlStatementParser parser=new MySqlStatementParser(sql);
    SQLStatement stmt=parser.parseStatement();
    String output=SQLUtils.toMySqlString(stmt);
    Set<String> allPossibleRes=generateAllPossibleRes();
    assertTrue(allPossibleRes.contains(output));
}"
"@Test
public void testGeneratedBlock() throws Exception {
    LOG.info(""Test testGeneratedBlock started."");
    long blockSize = 8192L;
    int stripeLength = 3;
    mySetup(stripeLength, -1);
    Path file1 = new Path(""/user/dhruba/raidtest/file1"");
    Path destPath = new Path(""/destraid/user/dhruba/raidtest"");
    long crc1 = TestRaidDfs.createTestFile(fileSys, file1, 1, 7, blockSize);
    long file1Len = fileSys.getFileStatus(file1).getLen();
    LOG.info(""Test testGeneratedBlock created test files"");
    Configuration localConf = new Configuration(conf);
    localConf.set(RAID_LOCATION_KEY, ""/destraid"");
    localConf.setInt(""raid.blockfix.interval"", 1000);
    localConf.setLong(""raid.blockfix.filespertask"", 2L);
    try {
        cnode = RaidNode.createRaidNode(null, localConf);
        TestRaidDfs.waitForFileRaided(LOG, fileSys, file1, destPath);
        cnode.stop();
        cnode.join();
        FileStatus srcStat = fileSys.getFileStatus(file1);
        DistributedFileSystem dfs = ((DistributedFileSystem) (fileSys));
        LocatedBlocks locs = RaidDFSUtil.getBlockLocations(dfs, file1.toUri().getPath(), 0, srcStat.getLen());
        String[] corruptFiles = RaidDFSUtil.getCorruptFiles(conf);
        assertEquals(corruptFiles.length, 0);
        assertEquals(0, cnode.blockFixer.filesFixed());
        corruptBlock(locs.get(0).getBlock().getBlockName());
        reportCorruptBlocks(dfs, file1, new int[]{ 0 }, blockSize);
        corruptFiles = RaidDFSUtil.getCorruptFiles(conf);
        assertEquals(corruptFiles.length, 1);
        assertEquals(corruptFiles[0], file1.toUri().getPath());
        cnode = RaidNode.createRaidNode(null, localConf);
        long start = System.currentTimeMillis();
        while ((cnode.blockFixer.filesFixed() < 1) && ((System.currentTimeMillis() - start) < 120000)) {
            LOG.info(""Test testGeneratedBlock waiting for files to be fixed."");
            Thread.sleep(1000);
        }
        assertEquals(1, cnode.blockFixer.filesFixed());
        cnode.stop();
        cnode.join();
        cnode = null;
        dfs = getDFS(conf, dfs);
        assertTrue(TestRaidDfs.validateFile(dfs, file1, file1Len, crc1));
        locs = RaidDFSUtil.getBlockLocations(dfs, file1.toUri().getPath(), 0, srcStat.getLen());
        corruptBlock(locs.get(0).getBlock().getBlockName());
        reportCorruptBlocks(dfs, file1, new int[]{ 0 }, blockSize);
        try {
            Thread.sleep(5 * 1000);
        } catch (InterruptedException ignore) {
        }
        try {
            TestRaidDfs.validateFile(dfs, file1, file1Len, crc1);
            fail(""Expected exception not thrown"");
        } catch (ChecksumException ce) {
        } catch (BlockMissingException bme) {
        }
    } catch (Exception e) {
        LOG.info((""Test testGeneratedBlock Exception "" + e) + StringUtils.stringifyException(e));
        throw e;
    } finally {
        myTearDown();
    }
    LOG.info(""Test testGeneratedBlock completed."");
}"
"@Test
public void TestSimpleDiamond() {
    Node x = new Node(4);
    Node n = new Node(1).addkid(new Node(2).addkid(x)).addkid(new Node(3).addkid(x));
    Graph g = new Graph(n);
    MHGDominatorsFinder<Node> finder = new MHGDominatorsFinder<Node>(g);
    DominatorTree<Node> tree = new DominatorTree<Node>(finder);
    assertThat(tree.getHeads().size(), is(1));
    DominatorNode<Node> head = tree.getHeads().get(0);
    assertThat(head.getGode().id, is(1));
    Set<Integer> kids = kid_ids(head);
    assertThat(kids.size(), is(3));
    assertThat(kids, contains(2, 3, 4));
}"
"@Test public void explicitConversion() throws Exception {
    assertThat(testResult(ExplicitConversion.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ExplicitConversion.iterations);
    assertEquals(new HashSet<>(asList(LocalDate.of(2017,1,1),LocalDate.of(2001,12,25))),new HashSet<>(ExplicitConversion.values.subList(0,2)));
    ExplicitConversion.iterations=0;
}"
"@Test public void wrapperDoubles() throws Exception {
    assertThat(testResult(WrapperDoubles.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperDoubles.iterations);
    assertEquals(new HashSet<>(asList(2.7,-3.14)),new HashSet<>(WrapperDoubles.values.subList(0,2)));
    WrapperDoubles.iterations=0;
}"
"@Test
public void socketTest() throws Exception {
    URI consumeUri = URI.create(CONSUME_URI);
    URI produceUri = URI.create(PRODUCE_URI);
    WebSocketClient consumeClient = new WebSocketClient();
    SimpleConsumerSocket consumeSocket = new SimpleConsumerSocket();
    WebSocketClient produceClient = new WebSocketClient();
    SimpleProducerSocket produceSocket = new SimpleProducerSocket();
    try {
        consumeClient.start();
        ClientUpgradeRequest consumeRequest = new ClientUpgradeRequest();
        Future<Session> consumerFuture = consumeClient.connect(consumeSocket, consumeUri, consumeRequest);
        log.info(""Connecting to : {}"", consumeUri);
        ClientUpgradeRequest produceRequest = new ClientUpgradeRequest();
        produceClient.start();
        Future<Session> producerFuture = produceClient.connect(produceSocket, produceUri, produceRequest);
        Thread.sleep(1000);
        Assert.assertTrue(consumerFuture.get().isOpen());
        Assert.assertTrue(producerFuture.get().isOpen());
        consumeSocket.awaitClose(1, TimeUnit.SECONDS);
        produceSocket.awaitClose(1, TimeUnit.SECONDS);
        Assert.assertTrue(produceSocket.getBuffer().size() > 0);
        Assert.assertEquals(produceSocket.getBuffer(), consumeSocket.getBuffer());
    } finally {
        try {
            consumeClient.stop();
            produceClient.stop();
        } catch (Exception e) {
            log.error(e.getMessage());
        }
    }
}"
"@Test
public void testCreateWithTwo() {
    AISMessage msg = amf.create(split1, split2);
    assertTrue(msg instanceof AISMessage05);
    assertEquals(5, msg.getMessageType());
}"
"@Test
public void testTimerThreadLeak() throws Exception {
    Tomcat tomcat = getTomcatInstance();
    Context ctx = tomcat.addContext("""", System.getProperty(""java.io.tmpdir""));
    if (ctx instanceof StandardContext) {
        ((StandardContext) (ctx)).setClearReferencesStopThreads(true);
    }
    ExecutorServlet executorServlet = new ExecutorServlet();
    Tomcat.addServlet(ctx, ""taskServlet"", executorServlet);
    ctx.addServletMapping(""/"", ""taskServlet"");
    tomcat.start();
    getUrl((""http://google.com""));
    ctx.stop();
    try {
        Thread.sleep(1000);
    } catch (InterruptedException ie) {
    }
    Assert.assertTrue(executorServlet.tpe.isShutdown());
    Assert.assertTrue(executorServlet.tpe.isTerminated());
}"
"@Test public void canSerializeAdditionalProperties() throws Exception {
    Foo foo=new Foo();
    foo.bar=""hello.world"";
    foo.baz=new ArrayList<>();
    foo.baz.add(""hello"");
    foo.baz.add(""hello.world"");
    foo.qux=new HashMap<>();
    foo.qux.put(""hello"",""world"");
    foo.qux.put(""a.b"",""c.d"");
    foo.qux.put(""bar.a"",""ttyy"");
    foo.qux.put(""bar.b"",""uuzz"");
    foo.additionalProperties=new HashMap<>();
    foo.additionalProperties.put(""bar"",""baz"");
    foo.additionalProperties.put(""a.b"",""c.d"");
    foo.additionalProperties.put(""properties.bar"",""barbar"");
    String serialized=new JacksonAdapter().serialize(foo);
    String expected=""{\""$type\"":\""foo\"",\""properties\"":{\""bar\"":\""hello.world\"",\""props\"":{\""baz\"":[\""hello\"",\""hello.world\""],\""q\"":{\""qux\"":{\""hello\"":\""world\"",\""a.b\"":\""c.d\"",\""bar.b\"":\""uuzz\"",\""bar.a\"":\""ttyy\""}}}},\""bar\"":\""baz\"",\""a.b\"":\""c.d\"",\""properties.bar\"":\""barbar\""}"";
    assertJsonEqualsNonStrict(expected,serialized);
}"
"@Test public void testMwMostRecentFullDumpFileProcessing() throws IOException {
    Path dmPath=Paths.get(System.getProperty(""user.dir""));
    MockDirectoryManager dm=new MockDirectoryManager(dmPath,true,true);
    mockLocalDumpFile(""20140418"",2,DumpContentType.FULL,dm);
    DumpProcessingController dpc=new DumpProcessingController(""wikidatawiki"");
    dpc.downloadDirectoryManager=dm;
    dpc.setOfflineMode(true);
    StatisticsMwRevisionProcessor mwrpStats=new StatisticsMwRevisionProcessor(""stats"",2);
    dpc.registerMwRevisionProcessor(mwrpStats,null,false);
    dpc.processMostRecentMainDump();
    assertEquals(9,mwrpStats.getTotalRevisionCount());
    assertEquals(9,mwrpStats.getCurrentRevisionCount());
}"
"@Test
public void shutdownDatabaseDuringIndexPopulations() {
    AssertableLogProvider assertableLogProvider = new AssertableLogProvider(true);
    File storeDir = directory.directory(""shutdownDbTest"");
    Label testLabel = Label.label(""testLabel"");
    String propertyName = ""testProperty"";
    GraphDatabaseService shutDownDb = new TestGraphDatabaseFactory().setInternalLogProvider(assertableLogProvider).newEmbeddedDatabase(storeDir);
    prePopulateDatabase(shutDownDb, testLabel, propertyName);
    try (final Transaction transaction = shutDownDb.beginTx()) {
        shutDownDb.schema().indexFor(testLabel).on(propertyName).create();
        transaction.success();
    }
    shutDownDb.shutdown();
    assertableLogProvider.assertNone(AssertableLogProvider.inLog(IndexPopulationJob.class).anyError());
}"
"public void test_8() throws Exception {
    JSON.defaultTimeZone=TimeZone.getTimeZone(""Asia/Shanghai"");
    DefaultJSONParser parser=new DefaultJSONParser(""\""2011-01-09T13:49:53.254\"""");
    parser.config(Feature.AllowISO8601DateFormat,true);
    Object value=parser.parse();
    Assert.assertEquals(new Date(1294552193254L),value);
}"
"@Test
void shouldExitBeforeGivenWaitTime_WhenWaitingThreadInterrupted() {
    var executorService = Executors.newFixedThreadPool(2);
    var executionStrategy = new ExecutionStrategies.ExitFlaggingExecutionStrategy();
    var executioner = new SystemExecutioner(executionStrategy);
    var startTime = new AtomicLong();
    var executionFuture = executorService.submit(() -> {
        LOG.info(""Calling executioner with 5 second wait"");
        startTime.set(System.nanoTime());
        executioner.exit(5, TimeUnit.SECONDS);
    });
    var killerSleepTimeMillis = 100;
    var killerFuture = executorService.submit(() -> {
        LOG.info(""Sleeping for {} milliseconds..."", killerSleepTimeMillis);
        new DefaultEnvironment().sleepQuietly(killerSleepTimeMillis, TimeUnit.MILLISECONDS);
        LOG.info(""I'm awake and will now interrupt executionThread"");
        var canceled = executionFuture.cancel(true);
        LOG.info(""executionFuture was canceled? {}"", canceled);
    });
    await().atMost(ONE_SECOND).until(() -> executionFuture.isDone() && killerFuture.isDone());
    long elapsedNanos = System.nanoTime() - startTime.get();
    assertThat(executionStrategy.didExit()).describedAs(""Execution strategy exit() should have been called"").isTrue();
    assertThat(TimeUnit.NANOSECONDS.toMillis(elapsedNanos)).describedAs(""Elapsed millis must be greater than %d"", killerSleepTimeMillis).isGreaterThan(killerSleepTimeMillis);
    executorService.shutdown();
    await().atMost(ONE_SECOND).until(executorService::isShutdown);
}"
"@Test public void primitiveDoubles(){
    assertThat(testResult(PrimitiveDoubles.class),isSuccessful());
    assertEquals(2,PrimitiveDoubles.iterations);
    assertEquals(new HashSet<>(asList(3.2,-4D)),PrimitiveDoubles.testCases);
    PrimitiveDoubles.iterations=0;
    PrimitiveDoubles.testCases.clear();
}"
"@Test
public void testOnlyExternalContextAllowsCache() throws Exception {
    KernelServices services = createKernelServicesBuilder(AdditionalInitialization.MANAGEMENT)
    .build();
    Assert.assertTrue(services.isSuccessfulBoot());
    List<ModelNode> list = parse(ModelTestUtils.readResource(this.getClass(), ""subsystem.xml""));
    for (ModelNode addOp : list) {
        PathAddress addr = PathAddress.pathAddress(addOp.require(ModelDescriptionConstants.OP_ADDR));
        if (addr.size() == 2 && addr.getLastElement().getKey().equals(NamingSubsystemModel.BINDING) && BindingType.forName(addOp.get(NamingBindingResourceDefinition.BINDING_TYPE.getName()).asString()) != BindingType.EXTERNAL_CONTEXT) {
            addOp.get(NamingBindingResourceDefinition.CACHE.getName()).set(true);
            services.executeForFailure(addOp);
            addOp.remove(NamingBindingResourceDefinition.CACHE.getName());
            ModelTestUtils.checkOutcome(services.executeOperation(addOp));
            ModelTestUtils.checkFailed(services.executeOperation(Util.getWriteAttributeOperation(addr, NamingBindingResourceDefinition.CACHE.getName(), new ModelNode(true))));
        } else {
            ModelTestUtils.checkOutcome(services.executeOperation(addOp));
        }
    }"
"@Test
public void testAppWithServices() throws Exception {
    ApplicationManager applicationManager = deployApplication(AppWithServices.class);
    LOG.info(""Deployed."");
    ServiceManager serviceManager = applicationManager.getServiceManager(AppWithServices.SERVICE_NAME).start();
    serviceManager.waitForStatus(true);
    LOG.info(""Service Started"");
    URL serviceURL = serviceManager.getServiceURL(15, TimeUnit.SECONDS);
    Assert.assertNotNull(serviceURL);
    URL url = new URL(serviceURL, ""ping2"");
    HttpRequest request = HttpRequest.get(url).build();
    HttpResponse response = HttpRequests.execute(request);
    Assert.assertEquals(200, response.getResponseCode());
    url = new URL(serviceURL, ""failure"");
    request = HttpRequest.get(url).build();
    response = HttpRequests.execute(request);
    Assert.assertEquals(500, response.getResponseCode());
    Assert.assertTrue(response.getResponseBodyAsString().contains(""Exception""));
    url = new URL(serviceURL, ""verifyClassLoader"");
    request = HttpRequest.get(url).build();
    response = HttpRequests.execute(request);
    Assert.assertEquals(200, response.getResponseCode());
    RuntimeMetrics serviceMetrics = serviceManager.getMetrics();
    serviceMetrics.waitForinput(3, 5, TimeUnit.SECONDS);
    Assert.assertEquals(3, serviceMetrics.getInput());
    Assert.assertEquals(2, serviceMetrics.getProcessed());
    Assert.assertEquals(1, serviceMetrics.getException());
    RuntimeMetrics handlerMetrics = getMetricsManager().getServiceHandlerMetrics(Id.Namespace.DEFAULT.getId(),
    AppWithServices.APP_NAME,
    AppWithServices.SERVICE_NAME,
    AppWithServices.SERVICE_NAME);
    handlerMetrics.waitForinput(3, 5, TimeUnit.SECONDS);
    Assert.assertEquals(3, handlerMetrics.getInput());
    Assert.assertEquals(2, handlerMetrics.getProcessed());
    Assert.assertEquals(1, handlerMetrics.getException());
    LOG.info(""DatasetUpdateService Started"");
    Map<String, String> args
    = ImmutableMap.of(AppWithServices.WRITE_VALUE_RUN_KEY, AppWithServices.DATASET_TEST_VALUE,
    AppWithServices.WRITE_VALUE_STOP_KEY, AppWithServices.DATASET_TEST_VALUE_STOP);
    ServiceManager datasetWorkerServiceManager = applicationManager
    .getServiceManager(AppWithServices.DATASET_WORKER_SERVICE_NAME).start(args);
    WorkerManager datasetWorker =
    applicationManager.getWorkerManager(AppWithServices.DATASET_UPDATE_WORKER).start(args);
    datasetWorkerServiceManager.waitForStatus(true);
    ServiceManager noopManager = applicationManager.getServiceManager(""NoOpService"").start();
    serviceManager.waitForStatus(true, 2, 1);
    String result = callServiceGet(noopManager.getServiceURL(), ""ping/"" + AppWithServices.DATASET_TEST_KEY);
    String decodedResult = new Gson().fromJson(result, String.class);
    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE, decodedResult);
    handlerMetrics = getMetricsManager().getServiceHandlerMetrics(Id.Namespace.DEFAULT.getId(),
    AppWithServices.APP_NAME,
    ""NoOpService"",
    ""NoOpHandler"");
    handlerMetrics.waitForinput(1, 5, TimeUnit.SECONDS);
    Assert.assertEquals(1, handlerMetrics.getInput());
    Assert.assertEquals(1, handlerMetrics.getProcessed());
    Assert.assertEquals(0, handlerMetrics.getException());
    String path = String.format(""discover/%s/%s"",
    AppWithServices.APP_NAME, AppWithServices.DATASET_WORKER_SERVICE_NAME);
    url = new URL(serviceURL, path);
    request = HttpRequest.get(url).build();
    response = HttpRequests.execute(request);
    Assert.assertEquals(200, response.getResponseCode());
    datasetWorker.stop();
    datasetWorkerServiceManager.stop();
    datasetWorkerServiceManager.waitForStatus(false);
    LOG.info(""DatasetUpdateService Stopped"");
    serviceManager.stop();
    serviceManager.waitForStatus(false);
    LOG.info(""ServerService Stopped"");
    result = callServiceGet(noopManager.getServiceURL(), ""ping/"" + AppWithServices.DATASET_TEST_KEY_STOP);
    decodedResult = new Gson().fromJson(result, String.class);
    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE_STOP, decodedResult);
    result = callServiceGet(noopManager.getServiceURL(), ""ping/"" + AppWithServices.DATASET_TEST_KEY_STOP_2);
    decodedResult = new Gson().fromJson(result, String.class);
    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE_STOP_2, decodedResult);
}"
"@Test public void testCloseReason() throws Exception {
    AnnotatedClientEndpoint.reset();
    MessageEndpoint.reset();
    Session session=deployment.connectToServer(AnnotatedClientEndpoint.class,new URI(""ws://"" + DefaultServer.getHostAddress(""default"") + "":""+ DefaultServer.getHostPort(""default"")+ ""/ws/chat/Bob""));
    Assert.assertEquals(""hi Bob (protocol=foo)"",AnnotatedClientEndpoint.message());
    session.close(new CloseReason(CloseReason.CloseCodes.VIOLATED_POLICY,""Foo!""));
    Assert.assertEquals(""CLOSED"",AnnotatedClientEndpoint.message());
    CloseReason cr=MessageEndpoint.getReason();
    Assert.assertEquals(CloseReason.CloseCodes.VIOLATED_POLICY.getCode(),cr.getCloseCode().getCode());
    Assert.assertEquals(""Foo!"",cr.getReasonPhrase());
}"
"@Test
public void testRepairSuccessfully() throws InterruptedException {
    Collection<LongTokenRange> ranges = new ArrayList<>();
    LongTokenRange range1 = new LongTokenRange(1, 2);
    LongTokenRange range2 = new LongTokenRange(3, 4);
    ranges.add(range1);
    ranges.add(range2);
    final RepairTask repairTask = new RepairTask.Builder().withJMXProxyFactory(jmxProxyFactory).withTableReference(myTableReference).withTokenRanges(ranges).withTableRepairMetrics(myTableRepairMetrics).withRepairHistory(repairHistory).withJobId(jobId).withReplicas(participants).build();
    CountDownLatch cdl = startRepair(repairTask, false);
    Notification notification = new Notification(""progress"", ""repair:1"", 0, getRepairMessage(range1));
    notification.setUserData(getNotificationData(PROGRESS.ordinal(), 1, 2));
    proxy.notify(notification);
    notification = new Notification(""progress"", ""repair:1"", 1, getRepairMessage(range2));
    notification.setUserData(getNotificationData(PROGRESS.ordinal(), 2, 2));
    proxy.notify(notification);
    notification = new Notification(""progress"", ""repair:1"", 2, ""Done with repair"");
    notification.setUserData(getNotificationData(COMPLETE.ordinal(), 2, 2));
    proxy.notify(notification);
    cdl.await();
    assertThat(repairTask.getUnknownRanges()).isNull();
    assertThat(repairTask.getCompletedRanges()).containsExactlyElementsOf(ranges);
    assertThat(proxy.myOptions.get(RANGES_KEY)).isNotEmpty();
    verify(myTableRepairMetrics).repairTiming(eq(TABLE_REFERENCE), anyLong(), any(TimeUnit.class), eq(true));
    verify(repairSessions.get(range1)).start();
    verify(repairSessions.get(range2)).start();
    verify(repairSessions.get(range1)).finish(eq(SUCCESS));
    verify(repairSessions.get(range2)).finish(eq(SUCCESS));
}"
"@Test
public void testRejectionsEAP7() throws Exception {
    testTransformer(""subsystem.xml"", ModelTestControllerVersion.EAP_7_0_0, ModelVersion.create(2, 0), ""wildfly-naming"");
}"
"@Test
public void testProcessAction_ok() {
    final Mock mockResponse = mock(ActionResponse.class);
    PortletMode mode = PortletMode.VIEW;
    Map<String, String> initParams = new HashMap<String, String>();
    initParams.put(""viewNamespace"", ""/view"");
    Map<String, String[]> requestParams = new HashMap<String, String[]>();
    requestParams.put(ACTION_PARAM, new String[] { ""/view/testAction"" });
    requestParams.put(MODE_PARAM, new String[] { mode.toString() });
    initParams.put(StrutsConstants.STRUTS_ALWAYS_SELECT_FULL_NAMESPACE,
    ""true"");
    initPortletConfig(initParams, new HashMap<String, Object>());
    initRequest(requestParams, new HashMap<String, Object>(),
    new HashMap<String, Object>(), PortletMode.VIEW,
    WindowState.NORMAL, true, null);
    setupActionFactory(""/view"", ""testAction"", ""success"",
    EasyMock.createNiceMock(ValueStack.class));
    try {
        dispatcher
        .setActionProxyFactory((ActionProxyFactory) mockActionFactory
        .proxy());
        dispatcher.init((PortletConfig) mockConfig.proxy());
        dispatcher.processAction((ActionRequest) mockRequest.proxy(),
        (ActionResponse) mockResponse.proxy());
    } catch (Exception e) {
        e.printStackTrace();
        fail(""Error occured"");
    }
}"
"@Test
public void testDeadlockTimeout() throws SQLException, InterruptedException {
    setAutoCommit(false);
    Statement s = createStatement();
    assertUpdateCount(s, 1, ""update t set text='xxx' where id=1"");
    Connection c2 = openDefaultConnection();
    c2.setAutoCommit(false);
    Statement s2 = c2.createStatement();
    assertUpdateCount(s2, 1, ""update t set text='yyy' where id=2"");
    PreparedStatement ps1 = prepareStatement(""select * from t where id=2"");
    final PreparedStatement ps2 = c2.prepareStatement(""select * from t where id=1"");
    final Barrier barrier = new Barrier(2);
    final SQLException[] holder = new SQLException[2];
    final Throwable[] unexpected = new Throwable[1];
    Thread t = new Thread(new Runnable() {
        public void run() {
            try {
                barrier.await();
                JDBC.assertDrainResults(ps2.executeQuery());
            } catch (SQLException e) {
                holder[0] = e;
            } catch (Throwable t) {
                unexpected[0] = t;
            }
        }
    });
    t.start();
    barrier.await();
    try {
        JDBC.assertDrainResults(ps1.executeQuery());
    } catch (SQLException e) {
        holder[1] = e;
    }
    t.join();
    if (unexpected[0] != null) {
        fail(""Helper thread failed unexpectedly"", unexpected[0]);
    }
    assertFalse(""No deadlock"", (holder[0] == null) && (holder[1] == null));
    if ((holder[0] != null) && (holder[1] != null)) {
        printStackTrace(holder[0]);
        printStackTrace(holder[1]);
        fail(""Only one of the waiters should be aborted"");
    }
    SQLException deadlock = (holder[0] == null) ? holder[1] : holder[0];
    assertSQLState(""Not a deadlock"", ""40001"", deadlock);
    String[] lines = deadlock.getMessage().split(""\n"");
    assertEquals(""Unexpected number of lines in message"", 8, lines.length);
    Pattern[] patterns = new Pattern[]{ Pattern.compile(""Lock : ROW, T, \\(\\d+,\\d+\\)""), Pattern.compile("" *Waiting XID : \\{\\d+, S\\} , APP, "" + ""select \\* from t where id=(1|2)""), Pattern.compile("" *Granted XID : \\{\\d+, X\\} *"") };
    for (int i = 0; i < (patterns.length * 2); i++) {
        String line = lines[i + 1];
        Matcher m = patterns[i % patterns.length].matcher(line);
        assertTrue(""mismatch: "" + line, m.matches());
    }
    s.close();
    s2.close();
    c2.rollback();
    c2.close();
}"
"@Test
public void testLookupBindingUsingNestedContext() throws Exception {
    final ServiceName bindingName = ServiceName.JBOSS.append(""foo"", ""bar"", ""baz"", ""TestBean"");
    final Object value = new Object();
    bindObject(bindingName, value);
    Object context = store.lookup(new CompositeName(""foo""));
    assertNotNull(context);
    assertTrue(context instanceof Context);
    Object obj = Context.class.cast(context).lookup(new CompositeName(""bar/baz/TestBean""));
    assertNotNull(obj);
    assertEquals(value, obj);
    context = Context.class.cast(context).lookup(new CompositeName(""bar""));
    obj = Context.class.cast(context).lookup(new CompositeName(""baz/TestBean""));
    assertNotNull(obj);
    assertEquals(value, obj);
    context = Context.class.cast(context).lookup(new CompositeName(""baz""));
    obj = Context.class.cast(context).lookup(new CompositeName(""TestBean""));
    assertNotNull(obj);
    assertEquals(value, obj);
}"
"@Test public void ctorOnly() throws Exception {
    assertThat(testResult(CtorOnly.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),CtorOnly.iterations);
    assertEquals(new HashSet<>(asList(new CtorOnly.Target(""a""),new CtorOnly.Target(""b""))),new HashSet<>(CtorOnly.values.subList(0,2)));
    CtorOnly.iterations=0;
}"
"@Test public void primitiveLongs(){
    assertThat(testResult(PrimitiveLongs.class),isSuccessful());
    assertEquals(3,PrimitiveLongs.iterations);
    assertEquals(new HashSet<>(asList(-6L,-7L,-8L)),PrimitiveLongs.testCases);
    PrimitiveLongs.iterations=0;
}"
"@Test public void test_inherit_from_abstract_class_1(){
    issue3655_b b=new issue3655_b(null,null,null,null,null,null,null,null,null);
    String result=JSON.toJSONString(b,filter,SerializerFeature.WriteNullStringAsEmpty);
    System.out.println(result);
    Assert.assertEquals(jsonStr,result);
}"
"@Test public void intArray(){
    final WithArrays wa=new WithArrays();
    wa.intArray=new int[]{1,2};
    final String exp=getClassPrefix(wa) + ""["" + BR+ ""  boolArray=<null>,""+ BR+ ""  charArray=<null>,""+ BR+ ""  doubleArray=<null>,""+ BR+ ""  intArray={""+ BR+ ""    1,""+ BR+ ""    2""+ BR+ ""  },""+ BR+ ""  longArray=<null>,""+ BR+ ""  stringArray=<null>""+ BR+ ""]"";
    assertEquals(exp,toString(wa));
}"
"@Test public void CustomDataParametersTest(){
    APIContext context=new APIContext(""ACCESS_TOKEN"").enableDebug(true);
    UserData userData=new UserData().email(""abc@eg.com"");
    HashMap<String,String> customProperties=new HashMap<String,String>();
    customProperties.put(""Key1"",""Value1"");
    customProperties.put(""Key2"",""Value2"");
    List<Content> contents=new ArrayList<Content>();
    contents.add(new Content().productId(""1"").brand(""brandA""));
    contents.add(new Content().productId(""2"").brand(""brandB""));
    List<String> contentIds=new ArrayList<String>();
    contentIds.add(""123"");
    contentIds.add(""456"");
    String contentCategory=""content_categoryA"";
    String contentName=""content_nameA"";
    String currency=""USD"";
    CustomData customData=new CustomData().contentIds(contentIds).customProperties(customProperties).contents(contents).contentCategory(contentCategory).contentName(contentName).currency(currency).deliveryCategory(DeliveryCategory.curbside).value(123.45F);
    Event testEvent=new Event();
    testEvent.eventName(""Purchase"").eventTime(System.currentTimeMillis() / 1000L).userData(userData).dataProcessingOptions(new String[]{}).customData(customData);
    EventRequest eventRequest=new EventRequest(""123"",context);
    eventRequest.addDataItem(testEvent);
    String serializedPayload=eventRequest.getSerializedPayload();
    String serializedContents=(new Gson()).toJson(contents);
    String serializedContentIds=(new Gson()).toJson(contentIds);
    Map<String,String> mp=customProperties;
    mp.forEach((key,value) -> Assert.assertTrue(serializedPayload.contains(""\"""" + key + ""\"":""+ ""\""""+ value+ ""\"""")));
    Assert.assertTrue(serializedPayload.contains(serializedContents));
    Assert.assertTrue(serializedPayload.contains(serializedContentIds));
    Assert.assertTrue(serializedPayload.contains(currency.toLowerCase()));
    Assert.assertTrue(serializedPayload.contains(contentCategory));
    Assert.assertTrue(serializedPayload.contains(contentName));
    Assert.assertTrue(serializedPayload.contains(DeliveryCategory.curbside.toString()));
}"
"@Test
public void recoverFromCancelReusesConnection() throws Exception {
    CountDownLatch responseDequeuedLatch = new CountDownLatch(1);
    CountDownLatch requestCanceledLatch = new CountDownLatch(1);
    QueueDispatcher dispatcher = new QueueDispatcher() {
        @Override
        public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
            MockResponse response = super.dispatch(request);
            responseDequeuedLatch.countDown();
            requestCanceledLatch.await();
            return response;
        }
    };
    server.setDispatcher(dispatcher);
    dispatcher.enqueueResponse(new MockResponse().setBodyDelay(10, TimeUnit.SECONDS).setBody(""abc""));
    dispatcher.enqueueResponse(new MockResponse().setBody(""def""));
    client = client.newBuilder().dns(new DoubleInetAddressDns()).build();
    callAndCancel(0, responseDequeuedLatch, requestCanceledLatch);
    Call call = client.newCall(new Request.Builder().url(server.url(""/"")).build());
    Response response = call.execute();
    assertThat(response.body().string()).isEqualTo(""def"");
    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
}"
"@Test
public void indexCreationDateReturnsIndexCreationDateOfExistingIndexAsDateTime() {
    final DateTime now = DateTime.now(DateTimeZone.UTC);
    final String indexName = client().createRandomIndex(""indices_it_"");
    final Optional<DateTime> indexCreationDate = indices.indexCreationDate(indexName);
    assertThat(indexCreationDate).isNotEmpty()
    .hasValueSatisfying(date -> Assertions.assertThat(date).isEqualToIgnoringMillis(now));
}"
"@Test
public void testRejectionsEAP6() throws Exception {
    testTransformer(""subsystem.xml"", ModelTestControllerVersion.EAP_6_4_0, ModelVersion.create(1, 3),""jboss-as-naming"");
}"
"@Test
public void testBasicRollingRestart() throws Exception {
    final int NUM_MASTERS = 2;
    final int NUM_RS = 3;
    final int NUM_REGIONS_TO_CREATE = 20;
    int expectedNumRS = 3;
    log(""Starting cluster"");
    Configuration conf = HBaseConfiguration.create();
    conf.setInt(""hbase.master.assignment.timeoutmonitor.period"", 2000);
    conf.setInt(""hbase.master.assignment.timeoutmonitor.timeout"", 5000);
    HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility(conf);
    TEST_UTIL.startMiniCluster(NUM_MASTERS, NUM_RS);
    MiniHBaseCluster cluster = TEST_UTIL.getHBaseCluster();
    log(""Waiting for active/ready master"");
    cluster.waitForActiveAndReadyMaster();
    ZooKeeperWatcher zkw = new ZooKeeperWatcher(conf, ""testRollingRestart"", null);
    HMaster master = cluster.getMaster();
    byte[] table = Bytes.toBytes(""tableRestart"");
    byte[] family = Bytes.toBytes(""family"");
    log((""Creating table with "" + NUM_REGIONS_TO_CREATE) + "" regions"");
    HTable ht = TEST_UTIL.createTable(table, family);
    int numRegions = TEST_UTIL.createMultiRegions(conf, ht, family, NUM_REGIONS_TO_CREATE);
    numRegions += 2;
    log(""Waiting for no more RIT\n"");
    blockUntilNoRIT(zkw, master);
    log(""Disabling table\n"");
    TEST_UTIL.getHBaseAdmin().disableTable(table);
    log(""Waiting for no more RIT\n"");
    blockUntilNoRIT(zkw, master);
    NavigableSet<String> regions = getAllOnlineRegions(cluster);
    log(""Verifying only catalog regions are assigned\n"");
    if (regions.size() != 2) {
        for (String oregion : regions) {
            log(""Region still online: "" + oregion);
        }
    }
    assertEquals(2, regions.size());
    log(""Enabling table\n"");
    TEST_UTIL.getHBaseAdmin().enableTable(table);
    log(""Waiting for no more RIT\n"");
    blockUntilNoRIT(zkw, master);
    log((""Verifying there are "" + numRegions) + "" assigned on cluster\n"");
    regions = getAllOnlineRegions(cluster);
    assertRegionsAssigned(cluster, regions);
    assertEquals(expectedNumRS, cluster.getRegionServerThreads().size());
    log(""Adding a fourth RS"");
    RegionServerThread restarted = cluster.startRegionServer();
    expectedNumRS++;
    restarted.waitForServerOnline();
    log(""Additional RS is online"");
    log(""Waiting for no more RIT"");
    blockUntilNoRIT(zkw, master);
    log((""Verifying there are "" + numRegions) + "" assigned on cluster"");
    assertRegionsAssigned(cluster, regions);
    assertEquals(expectedNumRS, cluster.getRegionServerThreads().size());
    List<MasterThread> masterThreads = cluster.getMasterThreads();
    MasterThread activeMaster = null;
    MasterThread backupMaster = null;
    assertEquals(2, masterThreads.size());
    if (masterThreads.get(0).getMaster().isActiveMaster()) {
        activeMaster = masterThreads.get(0);
        backupMaster = masterThreads.get(1);
    } else {
        activeMaster = masterThreads.get(1);
        backupMaster = masterThreads.get(0);
    }
    log(""Stopping backup master\n\n"");
    backupMaster.getMaster().stop(""Stop of backup during rolling restart"");
    cluster.hbaseCluster.waitOnMaster(backupMaster);
    log(""Stopping primary master\n\n"");
    activeMaster.getMaster().stop(""Stop of active during rolling restart"");
    cluster.hbaseCluster.waitOnMaster(activeMaster);
    log(""Restarting primary master\n\n"");
    activeMaster = cluster.startMaster();
    cluster.waitForActiveAndReadyMaster();
    master = activeMaster.getMaster();
    log(""Restarting backup master\n\n"");
    backupMaster = cluster.startMaster();
    assertEquals(expectedNumRS, cluster.getRegionServerThreads().size());
    List<RegionServerThread> regionServers = cluster.getLiveRegionServerThreads();
    int num = 1;
    int total = regionServers.size();
    for (RegionServerThread rst : regionServers) {
        ServerName serverName = rst.getRegionServer().getServerName();
        log((((((""Stopping region server "" + num) + "" of "") + total) + "" [ "") + serverName) + ""]"");
        rst.getRegionServer().stop(""Stopping RS during rolling restart"");
        cluster.hbaseCluster.waitOnRegionServer(rst);
        log(""Waiting for RS shutdown to be handled by master"");
        waitForRSShutdownToStartAndFinish(activeMaster, serverName);
        log(""RS shutdown done, waiting for no more RIT"");
        blockUntilNoRIT(zkw, master);
        log((""Verifying there are "" + numRegions) + "" assigned on cluster"");
        assertRegionsAssigned(cluster, regions);
        expectedNumRS--;
        assertEquals(expectedNumRS, cluster.getRegionServerThreads().size());
        log(((""Restarting region server "" + num) + "" of "") + total);
        restarted = cluster.startRegionServer();
        restarted.waitForServerOnline();
        expectedNumRS++;
        log((""Region server "" + num) + "" is back online"");
        log(""Waiting for no more RIT"");
        blockUntilNoRIT(zkw, master);
        log((""Verifying there are "" + numRegions) + "" assigned on cluster"");
        assertRegionsAssigned(cluster, regions);
        assertEquals(expectedNumRS, cluster.getRegionServerThreads().size());
        num++;
    }
    Thread.sleep(2000);
    assertRegionsAssigned(cluster, regions);
    RegionServerThread rootServer = getServerHostingRoot(cluster);
    RegionServerThread metaServer = getServerHostingMeta(cluster);
    if (rootServer == metaServer) {
        log(""ROOT and META on the same server so killing another random server"");
        int i = 0;
        while (rootServer == metaServer) {
            metaServer = cluster.getRegionServerThreads().get(i);
            i++;
        }
    }
    log(""Stopping server hosting ROOT"");
    rootServer.getRegionServer().stop(""Stopping ROOT server"");
    log(""Stopping server hosting META #1"");
    metaServer.getRegionServer().stop(""Stopping META server"");
    cluster.hbaseCluster.waitOnRegionServer(rootServer);
    log(""Root server down"");
    cluster.hbaseCluster.waitOnRegionServer(metaServer);
    log(""Meta server down #1"");
    expectedNumRS -= 2;
    log(""Waiting for meta server #1 RS shutdown to be handled by master"");
    waitForRSShutdownToStartAndFinish(activeMaster, metaServer.getRegionServer().getServerName());
    log(""Waiting for no more RIT"");
    blockUntilNoRIT(zkw, master);
    log((""Verifying there are "" + numRegions) + "" assigned on cluster"");
    assertRegionsAssigned(cluster, regions);
    assertEquals(expectedNumRS, cluster.getRegionServerThreads().size());
    metaServer = getServerHostingMeta(cluster);
    log(""Stopping server hosting META #2"");
    metaServer.getRegionServer().stop(""Stopping META server"");
    cluster.hbaseCluster.waitOnRegionServer(metaServer);
    log(""Meta server down"");
    expectedNumRS--;
    log(""Waiting for RS shutdown to be handled by master"");
    waitForRSShutdownToStartAndFinish(activeMaster, metaServer.getRegionServer().getServerName());
    log(""RS shutdown done, waiting for no more RIT"");
    blockUntilNoRIT(zkw, master);
    log((""Verifying there are "" + numRegions) + "" assigned on cluster"");
    assertRegionsAssigned(cluster, regions);
    assertEquals(expectedNumRS, cluster.getRegionServerThreads().size());
    cluster.startRegionServer().waitForServerOnline();
    cluster.startRegionServer().waitForServerOnline();
    cluster.startRegionServer().waitForServerOnline();
    Thread.sleep(1000);
    log(""Waiting for no more RIT"");
    blockUntilNoRIT(zkw, master);
    log((""Verifying there are "" + numRegions) + "" assigned on cluster"");
    assertRegionsAssigned(cluster, regions);
    metaServer = getServerHostingMeta(cluster);
    log(""Stopping server hosting META (1 of 3)"");
    metaServer.getRegionServer().stop(""Stopping META server"");
    cluster.hbaseCluster.waitOnRegionServer(metaServer);
    log(""Meta server down (1 of 3)"");
    log(""Waiting for RS shutdown to be handled by master"");
    waitForRSShutdownToStartAndFinish(activeMaster, metaServer.getRegionServer().getServerName());
    log(""RS shutdown done, waiting for no more RIT"");
    blockUntilNoRIT(zkw, master);
    log((""Verifying there are "" + numRegions) + "" assigned on cluster"");
    assertRegionsAssigned(cluster, regions);
    metaServer = getServerHostingMeta(cluster);
    log(""Stopping server hosting META (2 of 3)"");
    metaServer.getRegionServer().stop(""Stopping META server"");
    cluster.hbaseCluster.waitOnRegionServer(metaServer);
    log(""Meta server down (2 of 3)"");
    log(""Waiting for RS shutdown to be handled by master"");
    waitForRSShutdownToStartAndFinish(activeMaster, metaServer.getRegionServer().getServerName());
    log(""RS shutdown done, waiting for no more RIT"");
    blockUntilNoRIT(zkw, master);
    log((""Verifying there are "" + numRegions) + "" assigned on cluster"");
    assertRegionsAssigned(cluster, regions);
    metaServer = getServerHostingMeta(cluster);
    log(""Stopping server hosting META (3 of 3)"");
    metaServer.getRegionServer().stop(""Stopping META server"");
    cluster.hbaseCluster.waitOnRegionServer(metaServer);
    log(""Meta server down (3 of 3)"");
    log(""Waiting for RS shutdown to be handled by master"");
    waitForRSShutdownToStartAndFinish(activeMaster, metaServer.getRegionServer().getServerName());
    log(""RS shutdown done, waiting for no more RIT"");
    blockUntilNoRIT(zkw, master);
    log((""Verifying there are "" + numRegions) + "" assigned on cluster"");
    assertRegionsAssigned(cluster, regions);
    if (cluster.getRegionServerThreads().size() != 1) {
        log(""Online regionservers:"");
        for (RegionServerThread rst : cluster.getRegionServerThreads()) {
            log(""RS: "" + rst.getRegionServer().getServerName());
        }
    }
    assertEquals(1, cluster.getRegionServerThreads().size());
    TEST_UTIL.shutdownMiniCluster();
}"
"@Test
public void testStartProgramWithDisabledRuntimeArgs() throws Exception {
    ProfileId profileId = new NamespaceId(TEST_NAMESPACE1).profile(""MyProfile"");
    Profile profile = new Profile(""MyProfile"", Profile.NATIVE.getLabel(), Profile.NATIVE.getDescription(),Profile.NATIVE.getScope(), Profile.NATIVE.getProvisioner());
    putProfile(profileId, profile, 200);
    disableProfile(profileId, 200);
    deploy(AppWithWorkflow.class, 200, Constants.Gateway.API_VERSION_3_TOKEN,TEST_NAMESPACE1);
    ProgramId programId = new NamespaceId(TEST_NAMESPACE1).app(APP_WITH_WORKFLOW_APP_ID).workflow(APP_WITH_WORKFLOW_WORKFLOW_NAME);
    Assert.assertEquals(STOPPED, getProgramStatus(programId));
    startProgram(programId, Collections.singletonMap(SystemArguments.PROFILE_NAME, profileId.getScopedName()), 409);
    Assert.assertEquals(STOPPED, getProgramStatus(programId));
    startProgram(programId, Collections.singletonMap(SystemArguments.PROFILE_NAME, ProfileId.NATIVE.getScopedName()),200);
    waitState(programId, STOPPED);
}"
"@Test
public void test_6() throws Exception {
    JSONObject jsonObject = new JSONObject();
    jsonObject.put(""val"", new Character[]{  });
    jsonObject.put(""cls"", Number.class);
    jsonObject.put(""nums"", new Number[]{  });
    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
    ObjectOutputStream objOut = new ObjectOutputStream(bytesOut);
    objOut.writeObject(jsonObject);
    objOut.flush();
    byte[] bytes = bytesOut.toByteArray();
    ByteArrayInputStream bytesIn = new ByteArrayInputStream(bytes);
    ObjectInputStream objIn = new ObjectInputStream(bytesIn);
    Object obj = objIn.readObject();
    assertEquals(JSONObject.class, obj.getClass());
    assertEquals(jsonObject.toJSONString(), JSON.toJSONString(obj));
}"
"@Test
public void regexp_validator() {
    clickThru(""Regexp Demo"");
    String update = SUBMIT;
    type(""zipCode"", ""abc"");
    click(update);
    assertTextPresent(""A zip code consists of five or nine digits"");
    type(""zipCode"", ""12345"");
    clickAndWait(update);
    assertTextPresent(""Zip code: [12345]"");
    type(""zipCode"", ""12345-9876"");
    clickAndWait(update);
    assertTextPresent(""Zip code: [12345-9876]"");
}"
"@Test
public void testWorkflowTokenPut() throws Exception {
    Assert.assertEquals(200, deploy(WorkflowTokenTestPutApp.class).getStatusLine().getStatusCode());
    Id.Application appId = Id.Application.from(Id.Namespace.DEFAULT, WorkflowTokenTestPutApp.NAME);
    Id.Workflow workflowId = Id.Workflow.from(appId, WorkflowTokenTestPutApp.WorkflowTokenTestPut.NAME);
    Id.Program mapReduceId = Id.Program.from(appId, ProgramType.MAPREDUCE, WorkflowTokenTestPutApp.RecordCounter.NAME);
    Id.Program sparkId = Id.Program.from(appId, ProgramType.SPARK, WorkflowTokenTestPutApp.SparkTestApp.NAME);
    String outputPath = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
    startProgram(workflowId, ImmutableMap.of(""inputPath"", createInputForRecordVerification(""firstInput""),
    ""outputPath"", outputPath, ""put.in.mapper.initialize"", ""true""));
    waitState(workflowId, ProgramRunStatus.RUNNING.name());
    waitState(workflowId, ""STOPPED"");
    List<RunRecord> workflowProgramRuns = getProgramRuns(workflowId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(1, workflowProgramRuns.size());
    List<RunRecord> mapReduceProgramRuns = getProgramRuns(mapReduceId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(1, mapReduceProgramRuns.size());
    outputPath = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
    startProgram(workflowId, ImmutableMap.of(""inputPath"", createInputForRecordVerification(""secondInput""),
    ""outputPath"", outputPath, ""put.in.map"", ""true""));
    waitState(workflowId, ProgramRunStatus.RUNNING.name());
    waitState(workflowId, ""STOPPED"");
    workflowProgramRuns = getProgramRuns(workflowId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(2, workflowProgramRuns.size());
    mapReduceProgramRuns = getProgramRuns(mapReduceId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(2, mapReduceProgramRuns.size());
    outputPath = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
    startProgram(workflowId, ImmutableMap.of(""inputPath"", createInputForRecordVerification(""thirdInput""),
    ""outputPath"", outputPath, ""put.in.reducer.initialize"", ""true""));
    waitState(workflowId, ProgramRunStatus.RUNNING.name());
    waitState(workflowId, ""STOPPED"");
    workflowProgramRuns = getProgramRuns(workflowId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(3, workflowProgramRuns.size());
    mapReduceProgramRuns = getProgramRuns(mapReduceId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(3, mapReduceProgramRuns.size());
    outputPath = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
    startProgram(workflowId, ImmutableMap.of(""inputPath"", createInputForRecordVerification(""fourthInput""),
    ""outputPath"", outputPath, ""put.in.reduce"", ""true""));
    waitState(workflowId, ProgramRunStatus.RUNNING.name());
    waitState(workflowId, ""STOPPED"");
    workflowProgramRuns = getProgramRuns(workflowId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(4, workflowProgramRuns.size());
    mapReduceProgramRuns = getProgramRuns(mapReduceId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(4, mapReduceProgramRuns.size());
    outputPath = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
    startProgram(workflowId, ImmutableMap.of(""inputPath"", createInputForRecordVerification(""fifthInput""),
    ""outputPath"", outputPath, ""closurePutToken"", ""true""));
    waitState(workflowId, ProgramRunStatus.RUNNING.name());
    waitState(workflowId, ""STOPPED"");
    workflowProgramRuns = getProgramRuns(workflowId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(5, workflowProgramRuns.size());
    mapReduceProgramRuns = getProgramRuns(mapReduceId, ProgramRunStatus.COMPLETED.name());
    Assert.assertEquals(1, mapReduceProgramRuns.size());
    List<RunRecord> sparkProgramRuns = getProgramRuns(sparkId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(1, sparkProgramRuns.size());
    outputPath = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
    startProgram(workflowId, ImmutableMap.of(""inputPath"", createInputForRecordVerification(""sixthInput""),
    ""outputPath"", outputPath));
    waitState(workflowId, ProgramRunStatus.RUNNING.name());
    waitState(workflowId, ""STOPPED"");
    workflowProgramRuns = getProgramRuns(workflowId, ProgramRunStatus.COMPLETED.name());
    Assert.assertEquals(1, workflowProgramRuns.size());
    workflowProgramRuns = getProgramRuns(sparkId, ProgramRunStatus.COMPLETED.name());
    Assert.assertEquals(1, workflowProgramRuns.size());
}"
"@Test
public void testReassignFailOnStopAndSync() throws IOException {
    ReceiverAdminClient receiverAdminClient = mockReceiverClientFailOnStopAndSync();
    coordinator = new Coordinator(metadataStore, receiverAdminClient);
    Map<Integer, List<Partition>> preAssignMap = metadataStore.getAssignmentsByCube(cubeName).getAssignments();
    Map<Integer, List<Partition>> newAssignMap = new HashMap<>();
    newAssignMap.put(1, Lists.newArrayList(p1, p2, p3));
    newAssignMap.put(2, Lists.newArrayList(p4, p5));
    newAssignMap.put(3, Lists.newArrayList(p6));
    CubeAssignment preAssigment = new CubeAssignment(cube.getName(), preAssignMap);
    CubeAssignment newAssigment = new CubeAssignment(cube.getName(), newAssignMap);
    try {
        coordinator.doReassign(cube, preAssigment, newAssigment);
    } catch (ClusterStateException rune) {
        assertSame(ROLLBACK_FAILED, rune.getClusterState());
        assertSame(STOP_AND_SNYC, rune.getTransactionStep());
        System.out.println(rune.getMessage());
        throw rune;
    }
}"
"@Test
public void testPublishFailsForClosedConnection() throws JMSException {
    Connection tempConnection = factory.createConnection();
    Session tempSession = tempConnection.createSession(false, AUTO_ACKNOWLEDGE);
    TemporaryQueue queue = tempSession.createTemporaryQueue();
    Session session = connection.createSession(false, AUTO_ACKNOWLEDGE);
    connection.start();
    MessageProducer producer = session.createProducer(queue);
    producer.setDeliveryMode(NON_PERSISTENT);
    TextMessage message = session.createTextMessage(""First"");
    producer.send(message);
    tempConnection.close();
    try {
        message = session.createTextMessage(""Hello"");
        producer.send(message);
        fail(""Send should fail since temp destination should not exist anymore."");
    } catch (JMSException e) {
        assertTrue(""failed to throw an exception"", true);
    }
}"
"@Test public void testLogicDeleteSql(){
    String wherePKColumns=SqlHelper.wherePKColumns(User.class);
    Assert.assertEquals(""<where> AND id = #{id} AND is_valid = 1</where>"",wherePKColumns);
    String whereAllIfColumns=SqlHelper.whereAllIfColumns(User.class,false);
    Assert.assertEquals(""<where><if test=\""id != null\""> AND id = #{id}</if><if test=\""username != null\""> AND username = #{username}</if> AND is_valid = 1</where>"",whereAllIfColumns);
    String isLogicDeletedColumn=SqlHelper.whereLogicDelete(User.class,true);
    Assert.assertEquals("" AND is_valid = 0"",isLogicDeletedColumn);
    String notLogicDeletedColumn=SqlHelper.whereLogicDelete(User.class,false);
    Assert.assertEquals("" AND is_valid = 1"",notLogicDeletedColumn);
    String updateSetColumns=SqlHelper.updateSetColumns(User.class,null,false,false);
    Assert.assertEquals(""<set>is_valid = 1,username = #{username},</set>"",updateSetColumns);
}"
"@Test
public void test_1() throws Exception {
    V1 entity = new V1();
    String text = JSON.toJSONString(entity, SortField);
    System.out.println(text);
    Assert.assertEquals(""{\""f1\"":0,\""f2\"":0,\""f3\"":0,\""f4\"":0,\""f5\"":0}"", text);
    JSONObject object = JSON.parseObject(text);
    text = JSON.toJSONString(object, SortField);
    Assert.assertEquals(""{\""f1\"":0,\""f2\"":0,\""f3\"":0,\""f4\"":0,\""f5\"":0}"", text);
}"
"/**
* Tests add/remove (again).
*/
@Test public void testAddRemove(){
    CollectionValuedMap<Integer,Integer> fooMap=new CollectionValuedMap<>();
    CollectionValuedMap<Integer,Integer> expectedMap=new CollectionValuedMap<>();
    for (int i=0; i < 4; i++) {
        for (int j=0; j < 4; j++) {
            fooMap.add(new Integer(i),new Integer(j));
            if (i != 2) {
                expectedMap.add(new Integer(i),new Integer(j));
            }
        }
    }
    fooMap.remove(new Integer(2));
    Assert.assertEquals(expectedMap,fooMap);
}"
"@Test
public void invalidationInAnotherInstance_closed() throws Exception {
    final SampleDatabase db1 = openDatabase(true);
    final SampleDatabase db2 = openDatabase(true);
    final SampleDatabase db3 = openDatabase(true);
    final CountDownLatch invalidated1 = prepareTableObserver(db1);
    final Pair<CountDownLatch, CountDownLatch> changed1 = prepareLiveDataObserver(db1);
    final CountDownLatch invalidated2 = prepareTableObserver(db2);
    final Pair<CountDownLatch, CountDownLatch> changed2 = prepareLiveDataObserver(db2);
    final CountDownLatch invalidated3 = prepareTableObserver(db3);
    final Pair<CountDownLatch, CountDownLatch> changed3 = prepareLiveDataObserver(db3);
    db2.getCustomerDao().insert(CUSTOMER_1);
    assertTrue(invalidated1.await(3, TimeUnit.SECONDS));
    assertTrue(changed1.first.await(3, TimeUnit.SECONDS));
    assertTrue(invalidated2.await(3, TimeUnit.SECONDS));
    assertTrue(changed2.first.await(3, TimeUnit.SECONDS));
    assertTrue(invalidated3.await(3, TimeUnit.SECONDS));
    assertTrue(changed3.first.await(3, TimeUnit.SECONDS));
    db3.close();
    db2.getCustomerDao().insert(CUSTOMER_2);
    assertTrue(changed1.second.await(3, TimeUnit.SECONDS));
    assertTrue(changed2.second.await(3, TimeUnit.SECONDS));
    assertFalse(changed3.second.await(300, TimeUnit.MILLISECONDS));
}"
"@Test public void enums() throws Exception {
    assertThat(testResult(Enums.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),Enums.iterations);
    Enums.iterations=0;
}"
"@Test public void testAdditionalModelTypeAnnotationsMixed() throws Exception {
    OpenAPI openAPI=TestUtils.createOpenAPI();
    final AbstractJavaCodegen codegen=new P_AbstractJavaCodegen();
    codegen.additionalProperties().put(AbstractJavaCodegen.ADDITIONAL_MODEL_TYPE_ANNOTATIONS,"" \t @Foo;\r\n@Bar  ;\n @Foobar  "");
    codegen.processOpts();
    codegen.preprocessOpenAPI(openAPI);
    final List<String> additionalModelTypeAnnotations=new ArrayList<String>();
    additionalModelTypeAnnotations.add(""@Foo"");
    additionalModelTypeAnnotations.add(""@Bar"");
    additionalModelTypeAnnotations.add(""@Foobar"");
    final List<String> sortedCodegenAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    final List<String> sortedAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    Collections.sort(sortedCodegenAdditionalModelTypeAnnotations);
    Collections.sort(sortedAdditionalModelTypeAnnotations);
    Assert.assertEquals(sortedCodegenAdditionalModelTypeAnnotations,sortedAdditionalModelTypeAnnotations);
}"
"@Test
public synchronized void testLockExpiration() throws RepositoryException, NotExecutableException {
    lockedNode.unlock();
    long hint = 1;
    lock = lockMgr.lock(lockedNode.getPath(), isDeep(), isSessionScoped(), hint, null);
    long remaining = lock.getSecondsRemaining();
    if (remaining <= hint) {
        try {
            wait(remaining * 2000);
        } catch (InterruptedException ignore) {
        }
        long secs = lock.getSecondsRemaining();
        assertTrue(""A released lock must return a negative number of seconds, was: "" + secs, secs < 0);
        String message = ""If the timeout hint is respected the lock"" + "" must be automatically released."";
        assertFalse(message, lock.isLive());
        assertFalse(message, lockedNode.isLocked());
        assertFalse(message, lockMgr.isLocked(lockedNode.getPath()));
        assertFalse(message, lockedNode.hasProperty(JCR_LOCK_IS_DEEP));
        assertFalse(message, lockedNode.hasProperty(JCR_LOCK_OWNER));
    } else {
        throw new NotExecutableException(""timeout hint was ignored."");
    }
}"
"@Test public void testKeyValueSchemaInfoToString() throws JSONException {
    String havePrimitiveType=DefaultImplementation.convertKeyValueSchemaInfoDataToString(KeyValueSchemaInfo.decodeKeyValueSchemaInfo(Schema.KeyValue(Schema.AVRO(Foo.class),Schema.STRING).getSchemaInfo()));
    JSONSchemaTest.assertJSONEqual(havePrimitiveType,KEY_VALUE_SCHEMA_INFO_INCLUDE_PRIMITIVE);
    String notHavePrimitiveType=DefaultImplementation.convertKeyValueSchemaInfoDataToString(KeyValueSchemaInfo.decodeKeyValueSchemaInfo(Schema.KeyValue(Schema.AVRO(Foo.class),Schema.AVRO(Foo.class)).getSchemaInfo()));
    JSONSchemaTest.assertJSONEqual(notHavePrimitiveType,KEY_VALUE_SCHEMA_INFO_NOT_INCLUDE_PRIMITIVE);
}"
"@Test
public void testStoredContext() throws Exception {
    final ServiceName bindingName = ServiceName.JBOSS.append(""foo-stored"").append(""again"");
    bindObject(bindingName, new Context() {
        @Override
        public Object lookup(Name name) throws NamingException {
            if (""blah/blah2"".equals(name.toString())) {
                return new Integer(5);
            }
            return null;
        }
        @Override
        public Object lookup(String name) throws NamingException {
            return lookup(new CompositeName(name));
        }
        @Override
        public void bind(Name name, Object obj) throws NamingException {
        }
        @Override
        public void bind(String name, Object obj) throws NamingException {
        }
        @Override
        public void rebind(Name name, Object obj) throws NamingException {
        }
        @Override
        public void rebind(String name, Object obj) throws NamingException {
        }
        @Override
        public void unbind(Name name) throws NamingException {
        }
        @Override
        public void unbind(String name) throws NamingException {
        }
        @Override
        public void rename(Name oldName, Name newName) throws NamingException {
        }
        @Override
        public void rename(String oldName, String newName) throws NamingException {
        }
        @Override
        public NamingEnumeration<NameClassPair> list(Name name) throws NamingException {
            return null;
        }
        @Override
        public NamingEnumeration<NameClassPair> list(String name) throws NamingException {
            return null;
        }
        @Override
        public NamingEnumeration<Binding> listBindings(Name name) throws NamingException {
            if (!""hi/there"".equals(name.toString()))
            throw new IllegalArgumentException(""Expected hi/there"");
            return null;
        }
        @Override
        public NamingEnumeration<Binding> listBindings(String name) throws NamingException {
            return null;
        }
        @Override
        public void destroySubcontext(Name name) throws NamingException {
        }
        @Override
        public void destroySubcontext(String name) throws NamingException {
        }
        @Override
        public Context createSubcontext(Name name) throws NamingException {
            return null;
        }
        @Override
        public Context createSubcontext(String name) throws NamingException {
            return null;
        }
        @Override
        public Object lookupLink(Name name) throws NamingException {
            return null;
        }
        @Override
        public Object lookupLink(String name) throws NamingException {
            return null;
        }
        @Override
        public NameParser getNameParser(Name name) throws NamingException {
            return null;
        }
        @Override
        public NameParser getNameParser(String name) throws NamingException {
            return null;
        }
        @Override
        public Name composeName(Name name, Name prefix) throws NamingException {
            return null;
        }
        @Override
        public String composeName(String name, String prefix) throws NamingException {
            return null;
        }
        @Override
        public Object addToEnvironment(String propName, Object propVal) throws NamingException {
            return null;
        }
        @Override
        public Object removeFromEnvironment(String propName) throws NamingException {
            return null;
        }
        @Override
        public Hashtable<?, ?> getEnvironment() throws NamingException {
            return null;
        }
        @Override
        public void close() throws NamingException {
        }
        @Override
        public String getNameInNamespace() throws NamingException {
            return null;
        }
    });
    final NamingContext ctx = new NamingContext(new CompositeName(), store, null);
    final Object obj = ctx.lookup(new CompositeName(""foo-stored/again/blah/blah2""));
    ctx.listBindings(""foo-stored/again/hi/there"");
    assertNotNull(obj);
    assertEquals(new Integer(5), obj);
}"
"@Test
public void canHandleUnfragmentedMessageReceived() {
    NMEAMessage unfragmentedNMEAMessage = NMEAMessage.fromString(""!AIVDM,1,1,,B,15MqdBP000G@qoLEi69PVGaN0D0=,0*3A"");
    final ArgumentCaptor<AISMessage> aisMessage = new ArgumentCaptor<>();
    context.checking(new Expectations() {{
        oneOf(aisMessageHandler).accept(with(aisMessage.getMatcher()));
    }});
    aisMessageReceiver.accept(unfragmentedNMEAMessage);
    assertEquals(AISMessageType.PositionReportClassAScheduled, aisMessage.getCapturedObject().getMessageType());
}"
"@Test
public void testWorkflowClient() throws Exception {
    String outputPath = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
    Map<String, String> runtimeArgs = ImmutableMap.of(""inputPath"", createInput(""input""),
    ""outputPath"", outputPath);
    Id.Workflow workflowId = Id.Workflow.from(appId, AppWithWorkflow.SampleWorkflow.NAME);
    programClient.start(workflowId, false, runtimeArgs);
    programClient.waitForStatus(workflowId, ""STOPPED"", 60, TimeUnit.SECONDS);
    List<RunRecord> workflowRuns = programClient.getProgramRuns(workflowId, ProgramRunStatus.COMPLETED.name(), 0,
    Long.MAX_VALUE, 10);
    Assert.assertEquals(1, workflowRuns.size());
    Id.Run workflowRunId = new Id.Run(workflowId, workflowRuns.get(0).getPid());
    try {
        workflowClient.getWorkflowToken(new Id.Run(Id.Workflow.from(appId, ""random""), workflowRunId.getId()));
        Assert.fail(""Should not find a workflow token for a non-existing workflow"");
    } catch (NotFoundException expected) {
    }
    try {
        workflowClient.getWorkflowToken(new Id.Run(workflowId, RunIds.generate().getId()));
        Assert.fail(""Should not find a workflow token for a random run id"");
    } catch (NotFoundException expected) {
    }
    WorkflowTokenDetail workflowToken = workflowClient.getWorkflowToken(workflowRunId);
    Assert.assertEquals(3, workflowToken.getTokenData().size());
    workflowToken = workflowClient.getWorkflowToken(workflowRunId, WorkflowToken.Scope.SYSTEM);
    Assert.assertTrue(workflowToken.getTokenData().size() > 0);
    workflowToken = workflowClient.getWorkflowToken(workflowRunId, ""start_time"");
    Map<String, List<WorkflowTokenDetail.NodeValueDetail>> tokenData = workflowToken.getTokenData();
    Assert.assertEquals(AppWithWorkflow.WordCountMapReduce.NAME, tokenData.get(""start_time"").get(0).getNode());
    Assert.assertTrue(Long.parseLong(tokenData.get(""start_time"").get(0).getValue()) < System.currentTimeMillis());
    workflowToken = workflowClient.getWorkflowToken(workflowRunId, WorkflowToken.Scope.USER, ""action_type"");
    tokenData = workflowToken.getTokenData();
    Assert.assertEquals(AppWithWorkflow.WordCountMapReduce.NAME, tokenData.get(""action_type"").get(0).getNode());
    Assert.assertEquals(""MapReduce"", tokenData.get(""action_type"").get(0).getValue());
    String nodeName = AppWithWorkflow.SampleWorkflow.firstActionName;
    WorkflowTokenNodeDetail workflowTokenAtNode =
    workflowClient.getWorkflowTokenAtNode(workflowRunId, nodeName);
    Assert.assertEquals(AppWithWorkflow.DummyAction.TOKEN_VALUE,
    workflowTokenAtNode.getTokenDataAtNode().get(AppWithWorkflow.DummyAction.TOKEN_KEY));
    workflowTokenAtNode = workflowClient.getWorkflowTokenAtNode(workflowRunId, nodeName, WorkflowToken.Scope.SYSTEM);
    Assert.assertEquals(0, workflowTokenAtNode.getTokenDataAtNode().size());
    workflowTokenAtNode = workflowClient.getWorkflowTokenAtNode(workflowRunId, nodeName,
    AppWithWorkflow.DummyAction.TOKEN_KEY);
    Assert.assertEquals(AppWithWorkflow.DummyAction.TOKEN_VALUE,
    workflowTokenAtNode.getTokenDataAtNode().get(AppWithWorkflow.DummyAction.TOKEN_KEY));
    String reduceOutputRecordsCounter = ""org.apache.hadoop.mapreduce.TaskCounter.REDUCE_OUTPUT_RECORDS"";
    workflowTokenAtNode = workflowClient.getWorkflowTokenAtNode(workflowRunId, AppWithWorkflow.WordCountMapReduce.NAME,
    WorkflowToken.Scope.SYSTEM, reduceOutputRecordsCounter);
    Assert.assertEquals(6, Integer.parseInt(workflowTokenAtNode.getTokenDataAtNode().get(reduceOutputRecordsCounter)));
}"
"@Test public void testParametersFromOriginalPostRequest() throws IOException {
    TestHttpClient client=createHttpClient();
    HttpResponse result=executePostRequest(client,""/servletContext/dumpRequest"",new BasicNameValuePair(""param1"",""param1Value""),new BasicNameValuePair(""param2"",""param2Value""));
    assertEquals(StatusCodes.OK,result.getStatusLine().getStatusCode());
    String response=HttpClientUtils.readResponse(result);
    assertTrue(response.contains(""param1=param1Value""));
    assertTrue(response.contains(""param2=param2Value""));
    result=executePostRequest(client,""/servletContext/secured/dumpRequest"",new BasicNameValuePair(""securedParam1"",""securedParam1Value""),new BasicNameValuePair(""securedParam2"",""securedParam2Value""));
    assertEquals(StatusCodes.OK,result.getStatusLine().getStatusCode());
    Assert.assertTrue(HttpClientUtils.readResponse(result).startsWith(""j_security_check""));
    result=executePostRequest(client,""/servletContext/j_security_check"",new BasicNameValuePair(""j_username"",""user1""),new BasicNameValuePair(""j_password"",""password1""));
    assertEquals(StatusCodes.OK,result.getStatusLine().getStatusCode());
    response=HttpClientUtils.readResponse(result);
    assertTrue(response.contains(""securedParam1=securedParam1Value""));
    assertTrue(response.contains(""securedParam2=securedParam2Value""));
}"
"@Test
public void assertGetCurrentShardingTotalCountIfNull() {
    assertThat(JobRegistry.getInstance().getCurrentShardingTotalCount(""exist_job_instance""), is(0));
}"
"@Test public void explicitConversion() throws Exception {
    assertThat(testResult(ExplicitConversion.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ExplicitConversion.iterations);
    ExplicitConversion.iterations=0;
}"
"/**
* Tests ReflectionToStringBuilder.toString() for statics.
*/
@Test public void testReflectionStatics(){
    final ReflectionStaticFieldsFixture instance1=new ReflectionStaticFieldsFixture();
    assertEquals(this.toBaseString(instance1) + ""[instanceInt=67890,instanceString=instanceString,staticInt=12345,staticString=staticString]"",ReflectionToStringBuilder.toString(instance1,null,false,true,ReflectionStaticFieldsFixture.class));
    assertEquals(this.toBaseString(instance1) + ""[instanceInt=67890,instanceString=instanceString,staticInt=12345,staticString=staticString,staticTransientInt=54321,staticTransientString=staticTransientString,transientInt=98765,transientString=transientString]"",ReflectionToStringBuilder.toString(instance1,null,true,true,ReflectionStaticFieldsFixture.class));
    assertEquals(this.toBaseString(instance1) + ""[instanceInt=67890,instanceString=instanceString,staticInt=12345,staticString=staticString]"",this.toStringWithStatics(instance1,null,ReflectionStaticFieldsFixture.class));
    assertEquals(this.toBaseString(instance1) + ""[instanceInt=67890,instanceString=instanceString,staticInt=12345,staticString=staticString]"",this.toStringWithStatics(instance1,null,ReflectionStaticFieldsFixture.class));
}"
"@Test public void enums() throws Exception {
    assertThat(testResult(Enums.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),Enums.iterations);
    assertEquals(EnumSet.of(HALF_UP,HALF_EVEN),new HashSet<>(Enums.values.subList(0,2)));
    Enums.iterations=0;
}"
"@Test
public void testLookupWitResolveResult() throws Exception {
    namingStore.bind(new CompositeName(""test/nested""), ""test"");
    final Reference reference = new Reference(String.class.getName(), new StringRefAddr(""blahh"", ""test""), TestObjectFactoryWithNameResolution.class.getName(), null);
    namingStore.bind(new CompositeName(""comp""), reference);
    Object result = namingContext.lookup(new CompositeName(""comp/nested""));
    assertEquals(""test"", result);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, Arrays.asList(new JndiPermission(""test/nested"", ""lookup"")), namingContext, ""comp/nested"");
    assertEquals(""test"", result);
}"
"@Test public void testAsync(){
    RpcContext rpcContext=RpcContext.getContext();
    Assertions.assertFalse(rpcContext.isAsyncStarted());
    AsyncContext asyncContext=RpcContext.startAsync();
    Assertions.assertTrue(rpcContext.isAsyncStarted());
    asyncContext.write(new Object());
    Assertions.assertTrue(((AsyncContextImpl)asyncContext).getInternalFuture().isDone());
    rpcContext.stopAsync();
    Assertions.assertTrue(rpcContext.isAsyncStarted());
    RpcContext.removeContext();
}"
"@Test public void test_AddExtension_Adaptive() throws Exception {
    ExtensionLoader<AddExt2> loader=getExtensionLoader(AddExt2.class);
    loader.addExtension(null,AddExt2_ManualAdaptive.class);
    AddExt2 adaptive=loader.getAdaptiveExtension();
    assertTrue(adaptive instanceof AddExt2_ManualAdaptive);
    ExtensionLoader.resetExtensionLoader(AddExt2.class);
}"
"public void test_for_issue() throws Exception {
    String test=""{\""distinct\"":false,\""oredCriteria\"":[{\""allCriteria\"":[{\""betweenValue\"":false,\""condition\"":\""area_id =\"",\""listValue\"":false,\""noValue\"":false,\""singleValue\"":true,\""value\"":917477670000000000},{\""betweenValue\"":false,\""condition\"":\""cabinet_id =\"",\""listValue\"":false,\""noValue\"":false,\""singleValue\"":true,\""value\"":500036},{\""betweenValue\"":false,\""condition\"":\""status =\"",\""listValue\"":false,\""noValue\"":false,\""singleValue\"":true,\""value\"":0}],\""criteria\"":[{\""$ref\"":\""$.oredCriteria[0].allCriteria[0]\""},{\""$ref\"":\""$.oredCriteria[0].allCriteria[1]\""},{\""$ref\"":\""$.oredCriteria[0].allCriteria[2]\""}],\""valid\"":true}],\""page\"":true,\""pageIndex\"":0,\""pageSize\"":1,\""pageStart\"":1}"";
    System.out.println(test);
    CabinetAuthCodeParam cabinetAuthCodeParam=JSONObject.toJavaObject(JSON.parseObject(test),CabinetAuthCodeParam.class);
    System.out.println(JSON.toJSONString(cabinetAuthCodeParam));
    final String jsonString=JSON.toJSONString(cabinetAuthCodeParam,SerializerFeature.MapSortField);
    assertEquals(""{\""distinct\"":false,\""oredCriteria\"":[{\""allCriteria\"":[{\""betweenValue\"":false,\""condition\"":\""area_id =\"",\""listValue\"":false,\""noValue\"":false,\""singleValue\"":true,\""value\"":917477670000000000},{\""betweenValue\"":false,\""condition\"":\""cabinet_id =\"",\""listValue\"":false,\""noValue\"":false,\""singleValue\"":true,\""value\"":500036},{\""betweenValue\"":false,\""condition\"":\""status =\"",\""listValue\"":false,\""noValue\"":false,\""singleValue\"":true,\""value\"":0}],\""criteria\"":[{\""$ref\"":\""$.oredCriteria[0].allCriteria[0]\""},{\""$ref\"":\""$.oredCriteria[0].allCriteria[1]\""},{\""$ref\"":\""$.oredCriteria[0].allCriteria[2]\""}],\""valid\"":true}],\""page\"":true,\""pageIndex\"":0,\""pageSize\"":1,\""pageStart\"":1}"",jsonString);
}"
"@Test
public void testSimpleConsumerEventsWithoutPartition() throws Exception {
    final String topicName = ""persistent"";
    final String subName = ""sub1"";
    final int numMsgs = 100;
    TestConsumerStateEventListener listener1 = new TestConsumerStateEventListener();
    TestConsumerStateEventListener listener2 = new TestConsumerStateEventListener();
    ConsumerBuilder<byte[]> consumerBuilder = pulsarClient.newConsumer().topic(topicName).subscriptionName(subName).acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscriptionType(Failover);
    ConsumerBuilder<byte[]> consumerBulder1 = consumerBuilder.clone().consumerName(""1"").consumerEventListener(listener1).acknowledgmentGroupTime(0, TimeUnit.SECONDS);
    Consumer<byte[]> consumer1 = consumerBulder1.subscribe();
    Consumer<byte[]> consumer2 = consumerBuilder.clone().consumerName(""2"").consumerEventListener(listener2).subscribe();
    verifyConsumerActive(listener1, -1);
    verifyConsumerInactive(listener2, -1);
    PersistentTopic topicRef = ((PersistentTopic) (pulsar.getBrokerService().getTopicReference(topicName).get()));
    PersistentSubscription subRef = topicRef.getSubscription(subName);
    assertNotNull(topicRef);
    assertNotNull(subRef);
    assertTrue(subRef.getDispatcher().isConsumerConnected());
    assertEquals(subRef.getDispatcher().getType(), Failover);
    List<CompletableFuture<MessageId>> futures = Lists.newArrayListWithCapacity(numMsgs);
    Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName).enableBatching(false).messageRoutingMode(SinglePartition).create();
    for (int i = 0; i < numMsgs; i++) {
        String message = ""my-message-"" + i;
        futures.add(producer.sendAsync(message.getBytes()));
    }
    FutureUtil.waitForAll(futures).get();
    futures.clear();
    rolloverPerIntervalStats();
    assertEquals(subRef.getNumberOfEntriesInBacklog(), numMsgs);
    Thread.sleep(ASYNC_EVENT_COMPLETION_WAIT);
    Message<byte[]> msg = null;
    Assert.assertNull(consumer2.receive(1, TimeUnit.SECONDS));
    for (int i = 0; i < numMsgs; i++) {
        msg = consumer1.receive(1, TimeUnit.SECONDS);
        Assert.assertNotNull(msg);
        Assert.assertEquals(new String(msg.getData()), ""my-message-"" + i);
        consumer1.acknowledge(msg);
    }
    rolloverPerIntervalStats();
    Thread.sleep(ASYNC_EVENT_COMPLETION_WAIT);
    assertEquals(subRef.getNumberOfEntriesInBacklog(), 0);
    for (int i = 0; i < numMsgs; i++) {
        String message = ""my-message-"" + i;
        futures.add(producer.sendAsync(message.getBytes()));
    }
    FutureUtil.waitForAll(futures).get();
    futures.clear();
    for (int i = 0; i < 5; i++) {
        msg = consumer1.receive(1, TimeUnit.SECONDS);
        Assert.assertNotNull(msg);
        Assert.assertEquals(new String(msg.getData()), ""my-message-"" + i);
        consumer1.acknowledge(msg);
    }
    for (int i = 5; i < 10; i++) {
        msg = consumer1.receive(1, TimeUnit.SECONDS);
        Assert.assertNotNull(msg);
        Assert.assertEquals(new String(msg.getData()), ""my-message-"" + i);
    }
    consumer1.close();
    Thread.sleep(CONSUMER_ADD_OR_REMOVE_WAIT_TIME);
    verifyConsumerActive(listener2, -1);
    verifyConsumerNotReceiveAnyStateChanges(listener1);
    for (int i = 5; i < numMsgs; i++) {
        msg = consumer2.receive(1, TimeUnit.SECONDS);
        Assert.assertNotNull(msg);
        Assert.assertEquals(new String(msg.getData()), ""my-message-"" + i);
        consumer2.acknowledge(msg);
    }
    Assert.assertNull(consumer2.receive(1, TimeUnit.SECONDS));
    rolloverPerIntervalStats();
    Thread.sleep(ASYNC_EVENT_COMPLETION_WAIT);
    assertEquals(subRef.getNumberOfEntriesInBacklog(), 0);
    for (int i = 0; i < numMsgs; i++) {
        String message = ""my-message-"" + i;
        futures.add(producer.sendAsync(message.getBytes()));
    }
    FutureUtil.waitForAll(futures).get();
    futures.clear();
    for (int i = 0; i < 5; i++) {
        msg = consumer2.receive(1, TimeUnit.SECONDS);
        Assert.assertNotNull(msg);
        Assert.assertEquals(new String(msg.getData()), ""my-message-"" + i);
        consumer2.acknowledge(msg);
    }
    consumer1 = consumerBulder1.subscribe();
    Thread.sleep(CONSUMER_ADD_OR_REMOVE_WAIT_TIME);
    for (int i = 5; i < numMsgs; i++) {
        msg = consumer1.receive(1, TimeUnit.SECONDS);
        Assert.assertNotNull(msg);
        Assert.assertEquals(new String(msg.getData()), ""my-message-"" + i);
        consumer1.acknowledge(msg);
    }
    Assert.assertNull(consumer1.receive(1, TimeUnit.SECONDS));
    rolloverPerIntervalStats();
    Thread.sleep(ASYNC_EVENT_COMPLETION_WAIT);
    assertEquals(subRef.getNumberOfEntriesInBacklog(), 0);
    for (int i = 0; i < numMsgs; i++) {
        String message = ""my-message-"" + i;
        futures.add(producer.sendAsync(message.getBytes()));
    }
    FutureUtil.waitForAll(futures).get();
    futures.clear();
    for (int i = 0; i < 5; i++) {
        msg = consumer1.receive(1, TimeUnit.SECONDS);
        Assert.assertNotNull(msg);
        Assert.assertEquals(new String(msg.getData()), ""my-message-"" + i);
        consumer1.acknowledge(msg);
    }
    TestConsumerStateEventListener listener3 = new TestConsumerStateEventListener();
    Consumer<byte[]> consumer3 = consumerBuilder.clone().consumerName(""3"").consumerEventListener(listener3).subscribe();
    Thread.sleep(CONSUMER_ADD_OR_REMOVE_WAIT_TIME);
    verifyConsumerInactive(listener3, -1);
    Assert.assertNull(consumer3.receive(1, TimeUnit.SECONDS));
    for (int i = 5; i < numMsgs; i++) {
        msg = consumer1.receive(1, TimeUnit.SECONDS);
        Assert.assertNotNull(msg);
        Assert.assertEquals(new String(msg.getData()), ""my-message-"" + i);
        consumer1.acknowledge(msg);
    }
    rolloverPerIntervalStats();
    Thread.sleep(ASYNC_EVENT_COMPLETION_WAIT);
    assertEquals(subRef.getNumberOfEntriesInBacklog(), 0);
    try {
        consumer1.unsubscribe();
        fail(""should fail"");
    } catch (PulsarClientException e) {
    }
    consumer1.close();
    Thread.sleep(CONSUMER_ADD_OR_REMOVE_WAIT_TIME);
    consumer2.close();
    Thread.sleep(CONSUMER_ADD_OR_REMOVE_WAIT_TIME);
    try {
        consumer3.unsubscribe();
    } catch (PulsarClientException e) {
        fail(""Should not fail"", e);
    }
    Thread.sleep(ASYNC_EVENT_COMPLETION_WAIT);
    subRef = topicRef.getSubscription(subName);
    assertNull(subRef);
    producer.close();
    consumer3.close();
    admin.topics().delete(topicName);
}"
"@Test
public void runProducerWithHungConsumer() throws Exception {
    final long origTempUsage = broker.getSystemUsage().getTempUsage().getUsage();
    ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(""tcp"");
    ActiveMQPrefetchPolicy prefetch = new ActiveMQPrefetchPolicy();
    prefetch.setTopicPrefetch(10);
    factory.setPrefetchPolicy(prefetch);
    Connection consumerConnection = factory.createConnection();
    consumerConnection.start();
    Session consumerSession = consumerConnection.createSession(false, AUTO_ACKNOWLEDGE);
    MessageConsumer consumer = consumerSession.createConsumer(destination);
    final Connection producerConnection = factory.createConnection();
    producerConnection.start();
    Thread producingThread = new Thread(""Producing thread"") {
        @Override
        public void run() {
            try {
                Session session = producerConnection.createSession(false, AUTO_ACKNOWLEDGE);
                MessageProducer producer = session.createProducer(destination);
                producer.setDeliveryMode(deliveryMode);
                for (int idx = 0; idx < MESSAGES_COUNT; ++idx) {
                    Message message = session.createTextMessage(new String(buf) + idx);
                    producer.send(message);
                    messagesSent.incrementAndGet();
                    Thread.sleep(10);
                    LOG.info(""Sent Message "" + idx);
                    LOG.info(""Temp Store Usage "" + broker.getSystemUsage().getTempUsage().getUsage());
                }
                producer.close();
                session.close();
            } catch (Throwable ex) {
                ex.printStackTrace();
            }
        }
    };
    producingThread.start();
    int count = 0;
    Message m = null;
    while ((m = consumer.receive(messageReceiveTimeout)) != null) {
        count++;
        LOG.info(((""Recieved Message ("" + count) + ""):"") + m);
        messagesConsumed.incrementAndGet();
        try {
            Thread.sleep(100);
        } catch (Exception e) {
            LOG.info(""error sleeping"");
        }
    }
    LOG.info(""Connection Timeout: Retrying"");
    while ((m = consumer.receive(messageReceiveTimeout)) != null) {
        count++;
        LOG.info(((""Recieved Message ("" + count) + ""):"") + m);
        messagesConsumed.incrementAndGet();
        try {
            Thread.sleep(100);
        } catch (Exception e) {
            LOG.info(""error sleeping"");
        }
    }
    LOG.info(""consumer session closing: consumed count: "" + count);
    consumerSession.close();
    producingThread.join();
    final long tempUsageBySubscription = broker.getSystemUsage().getTempUsage().getUsage();
    LOG.info(((""Orig Usage: "" + origTempUsage) + "", currentUsage: "") + tempUsageBySubscription);
    producerConnection.close();
    consumerConnection.close();
    LOG.info(((""Subscrition Usage: "" + tempUsageBySubscription) + "", endUsage: "") + broker.getSystemUsage().getTempUsage().getUsage());
    assertEquals(""Incorrect number of Messages Sent: "" + messagesSent.get(), messagesSent.get(), MESSAGES_COUNT);
    assertEquals(""Incorrect number of Messages Consumed: "" + messagesConsumed.get(), messagesConsumed.get(), MESSAGES_COUNT);
}"
"@Test public void testNotAllowNullSchema() throws JSONException {
    JSONSchema<Foo> jsonSchema=JSONSchema.of(SchemaDefinition.<Foo>builder().withPojo(Foo.class).withAlwaysAllowNull(false).build());
    Assert.assertEquals(jsonSchema.getSchemaInfo().getType(),SchemaType.JSON);
    Schema.Parser parser=new Schema.Parser();
    String schemaJson=new String(jsonSchema.getSchemaInfo().getSchema());
    assertJSONEqual(schemaJson,SCHEMA_JSON_NOT_ALLOW_NULL);
    Schema schema=parser.parse(schemaJson);
    for (  String fieldName : FOO_FIELDS) {
        Schema.Field field=schema.getField(fieldName);
        Assert.assertNotNull(field);
        if (field.name().equals(""field4"")) {
            Assert.assertNotNull(field.schema().getTypes().get(1).getField(""field1""));
        }
        if (field.name().equals(""fieldUnableNull"")) {
            Assert.assertNotNull(field.schema().getType());
        }
    }
}"
"@Test public void EventRequestTest(){
    APIContext context=new APIContext(""ACCESS_TOKEN"").enableDebug(true);
    UserData userData=new UserData().email(""aaa@fb.com"");
    UserData billingContact=new UserData().email(""bbb@fb.com"");
    UserData shippingContact=new UserData().email(""ccc@fb.com"");
    HashMap<String,String> customProperties=new HashMap<String,String>();
    customProperties.put(""Key1"",""Value1"");
    List<Content> contents=new ArrayList<Content>();
    contents.add(new Content().id(""1"").tax(1.2F));
    contents.add(new Content().id(""2"").brand(""brand""));
    CustomData customData=new CustomData().customProperties(customProperties).contents(contents).value(123.45F).billingContact(billingContact).shippingContact(shippingContact);
    List<Event> testEvents=new ArrayList<Event>();
    testEvents.add(new Event().eventName(""Purchase"").eventTime(123124125L).userData(userData).dataProcessingOptions(new String[]{}).customData(customData));
    EventRequest eventRequest=new EventRequest(""pixelID"",""pageID"",context);
    eventRequest.setData(testEvents);
    eventRequest.setPartnerAgent(""partnerAgent"");
    com.facebook.ads.sdk.businessdataapi.EventRequest bdapiEventRequest=eventRequest.getBusinessDataEventRequest();
    com.facebook.ads.sdk.businessdataapi.Event bdapiEvent=bdapiEventRequest.getData().get(0);
    Assert.assertTrue(bdapiEventRequest.getPartnerAgent() == ""partnerAgent"");
    Assert.assertTrue(bdapiEvent.getEventName() == ""Purchase"");
    Assert.assertTrue(bdapiEvent.getEventTime() == 123124125L);
    Assert.assertTrue(bdapiEvent.getDataProcessingOptions().length == 0);
    Assert.assertTrue(bdapiEvent.getUserData().getEmail() == ""aaa@fb.com"");
    Assert.assertTrue(bdapiEvent.getCustomData().getValue() == 123.45F);
    List<com.facebook.ads.sdk.businessdataapi.Content> bdapiContents=bdapiEvent.getCustomData().getContents();
    Assert.assertTrue(bdapiContents.get(0).getId() == ""1"");
    Assert.assertTrue(bdapiContents.get(0).getTax() == 1.2F);
    Assert.assertTrue(bdapiContents.get(1).getId() == ""2"");
    Assert.assertTrue(bdapiEvent.getCustomData().getBillingContact().getEmail() == ""bbb@fb.com"");
    Assert.assertTrue(bdapiEvent.getCustomData().getShippingContact().getEmail() == ""ccc@fb.com"");
    com.facebook.ads.sdk.serverside.EventRequest capiEventRequest=eventRequest.getServerSideEventRequest();
    com.facebook.ads.sdk.serverside.Event capiEvent=capiEventRequest.getData().get(0);
    Assert.assertTrue(capiEventRequest.getPartnerAgent() == ""partnerAgent"");
    Assert.assertTrue(capiEvent.getEventName() == ""Purchase"");
    Assert.assertTrue(capiEvent.getEventTime() == 123124125L);
    Assert.assertTrue(capiEvent.getDataProcessingOptions().length == 0);
    Assert.assertTrue(capiEvent.getUserData().getEmail() == ""aaa@fb.com"");
    Assert.assertTrue(capiEvent.getCustomData().getValue() == 123.45F);
    List<com.facebook.ads.sdk.serverside.Content> capiContents=capiEvent.getCustomData().getContents();
    Assert.assertTrue(capiContents.get(0).getProductId() == ""1"");
    Assert.assertTrue(capiContents.get(1).getProductId() == ""2"");
    Assert.assertTrue(capiContents.get(1).getBrand() == ""brand"");
    Assert.assertTrue(capiEvent.getCustomData().getCustomProperties().get(""Key1"") == ""Value1"");
    String bdapiDataJSON=(new Gson()).toJson(bdapiEventRequest.getData());
    String bdapiContentsJSON=(new Gson()).toJson(bdapiContents);
    Assert.assertTrue(bdapiDataJSON.contains(bdapiContentsJSON));
    Assert.assertTrue(bdapiDataJSON.contains(""\""event_name\"":\""Purchase\""""));
    String capiDataJSON=(new Gson()).toJson(capiEventRequest.getData());
    Map<String,String> mp=customProperties;
    mp.forEach((key,value) -> Assert.assertTrue(capiDataJSON.contains(""\"""" + key + ""\"":""+ ""\""""+ value+ ""\"""")));
}"
"public void test_f() throws Exception {
    String text=""parent.callback ({'id':1, 'name':'idonans'} );   /**/ "";
    JSONPObject jsonpObject=JSON.parseObject(text,JSONPObject.class);
    assertEquals(""parent.callback"",jsonpObject.getFunction());
    assertEquals(1,jsonpObject.getParameters().size());
    JSONObject param=(JSONObject)jsonpObject.getParameters().get(0);
    assertEquals(1,param.get(""id""));
    assertEquals(""idonans"",param.get(""name""));
    String json=JSON.toJSONString(jsonpObject,SerializerFeature.MapSortField);
    assertEquals(""parent.callback({\""id\"":1,\""name\"":\""idonans\""})"",json);
}"
"@Test public void BuilderAndGettersWithMultipleValuesTest(){
    List<String> emails=Arrays.asList(""email0"",""email1"");
    List<String> phones=Arrays.asList(""1234567890"",""2062062006"");
    List<GenderEnum> genders=Arrays.asList(GenderEnum.MALE,GenderEnum.FEMALE);
    List<String> datesOfBirth=Arrays.asList(""20000101"",""20000102"");
    List<String> lastNames=Arrays.asList(""lastname-1"",""lastname-2"");
    List<String> firstNames=Arrays.asList(""firstname-2"",""firstname-3"");
    List<String> cities=Arrays.asList(""Seattle"",""Portland"");
    List<String> states=Arrays.asList(""WA"",""CA"");
    List<String> zipcodes=Arrays.asList(""98123"",""98122"");
    List<String> countryCodes=Arrays.asList(""USA"",""CA"");
    List<String> externalIds=Arrays.asList(""external-1"",""external-2"",""external-2"");
    UserData userData=new UserData();
    userData.emails(emails).phones(phones).genders(genders).datesOfBirth(datesOfBirth).lastNames(lastNames).firstNames(firstNames).cities(cities).states(states).zipcodes(zipcodes).countryCodes(countryCodes).externalIds(externalIds);
    assertEquals(userData.getEmails(),emails);
    assertEquals(userData.getPhones(),phones);
    assertEquals(userData.getGenders(),genders);
    assertEquals(userData.getDatesOfBirth(),datesOfBirth);
    assertEquals(userData.getLastNames(),lastNames);
    assertEquals(userData.getFirstNames(),firstNames);
    assertEquals(userData.getCities(),cities);
    assertEquals(userData.getStates(),states);
    assertEquals(userData.getZipcodes(),zipcodes);
    assertEquals(userData.getCountryCodes(),countryCodes);
    List<String> sortedActualExternalIds=userData.getExternalIds();
    Collections.sort(sortedActualExternalIds);
    assertEquals(sortedActualExternalIds,externalIds.subList(0,2));
}"
"@Test void writesAndReadsCustomConvertedClass(){
    List<Object> converters=new ArrayList<>();
    converters.add(BigDecimalToStringConverter.INSTANCE);
    converters.add(StringToBigDecimalConverter.INSTANCE);
    CustomConversions customConversions=new CouchbaseCustomConversions(converters);
    converter.setCustomConversions(customConversions);
    converter.afterPropertiesSet();
    ((CouchbaseMappingContext)converter.getMappingContext()).setSimpleTypeHolder(customConversions.getSimpleTypeHolder());
    CouchbaseDocument converted=new CouchbaseDocument();
    final String valueStr=""12.345"";
    final BigDecimal value=new BigDecimal(valueStr);
    final String value2Str=""0.6789"";
    final BigDecimal value2=new BigDecimal(value2Str);
    List<BigDecimal> listOfValues=new ArrayList<>();
    listOfValues.add(value);
    listOfValues.add(value2);
    Map<String,BigDecimal> mapOfValues=new HashMap<>();
    mapOfValues.put(""val1"",value);
    mapOfValues.put(""val2"",value2);
    CustomEntity entity=new CustomEntity(value,listOfValues,mapOfValues);
    converter.write(entity,converted);
    CouchbaseDocument source=new CouchbaseDocument();
    source.put(""_class"",CustomEntity.class.getName());
    source.put(""value"",valueStr);
    CouchbaseList listOfValuesDoc=new CouchbaseList();
    listOfValuesDoc.put(valueStr);
    listOfValuesDoc.put(value2Str);
    source.put(""listOfValues"",listOfValuesDoc);
    CouchbaseDocument mapOfValuesDoc=new CouchbaseDocument();
    mapOfValuesDoc.put(""val1"",valueStr);
    mapOfValuesDoc.put(""val2"",value2Str);
    source.put(""mapOfValues"",mapOfValuesDoc);
    assertThat(valueStr).isEqualTo(((CouchbaseList)converted.getContent().get(""listOfValues"")).get(0));
    assertThat(value2Str).isEqualTo(((CouchbaseList)converted.getContent().get(""listOfValues"")).get(1));
    assertThat(converted.getContent().get(""listOfValues"").toString()).isEqualTo(source.getContent().get(""listOfValues"").toString());
    CouchbaseDocument sourceVals=(CouchbaseDocument)source.getContent().get(""mapOfValues"");
    CouchbaseDocument convertedVals=(CouchbaseDocument)converted.getContent().get(""mapOfValues"");
    assertThat(sourceVals.getContent().get(""val1"").toString()).isEqualTo(convertedVals.getContent().get(""val1"").toString());
    assertThat(sourceVals.getContent().get(""val2"").toString()).isEqualTo(convertedVals.getContent().get(""val2"").toString());
    CustomEntity readConverted=converter.read(CustomEntity.class,source);
    assertThat(readConverted.value).isEqualTo(value);
    assertThat(readConverted.listOfValues.get(0)).isEqualTo(listOfValues.get(0));
    assertThat(readConverted.listOfValues.get(1)).isEqualTo(listOfValues.get(1));
    assertThat(readConverted.mapOfValues.get(""val1"")).isEqualTo(mapOfValues.get(""val1""));
    assertThat(readConverted.mapOfValues.get(""val2"")).isEqualTo(mapOfValues.get(""val2""));
}"
"@Test public void testGetPartialRepairTasks(){
    Node node=mockNode(""DC1"");
    Node node2=mockNode(""DC1"");
    ImmutableList<LongTokenRange> vnodes=ImmutableList.of(new LongTokenRange(1,2),new LongTokenRange(2,3),new LongTokenRange(4,5));
    ReplicaRepairGroup replicaRepairGroup=new ReplicaRepairGroup(ImmutableSet.of(node,node2),vnodes);
    RepairGroup repairGroup=builderFor(replicaRepairGroup).build(priority);
    Collection<RepairTask> tasks=repairGroup.getRepairTasks();
    assertThat(tasks.size()).isEqualTo(3);
    Set<LongTokenRange> repairTaskRanges=new HashSet<>();
    for (  RepairTask repairTask : tasks) {
        assertThat(repairTask.getTokenRanges().size()).isEqualTo(1);
        LongTokenRange range=repairTask.getTokenRanges().iterator().next();
        repairTaskRanges.add(range);
        assertThat(repairTask.getReplicas()).containsExactlyInAnyOrder(node,node2);
        assertThat(repairTask.getTableReference()).isEqualTo(tableReference);
        assertThat(repairTask.getRepairConfiguration().getRepairParallelism()).isEqualTo(RepairOptions.RepairParallelism.PARALLEL);
    }
    assertThat(repairTaskRanges).containsExactlyInAnyOrderElementsOf(vnodes);
}"
"@Test
public void testTopicLevelInActiveTopicApi() throws Exception {
    super.resetConfig();
    conf.setSystemTopicEnabled(true);
    conf.setTopicLevelPoliciesEnabled(true);
    super.baseSetup();
    Thread.sleep(2000);
    final String topicName = ""persistent://prop/ns-abc/testMaxInactiveDuration-"" + UUID.randomUUID().toString();
    admin.topics().createPartitionedTopic(topicName, 3);
    InactiveTopicPolicies inactiveTopicPolicies = admin.topics().getInactiveTopicPolicies(topicName);
    assertNull(inactiveTopicPolicies);
    InactiveTopicPolicies policies = new InactiveTopicPolicies();
    policies.setDeleteWhileInactive(true);
    policies.setInactiveTopicDeleteMode(InactiveTopicDeleteMode.delete_when_no_subscriptions);
    policies.setMaxInactiveDurationSeconds(10);
    admin.topics().setInactiveTopicPolicies(topicName, policies);
    for (int i = 0; i < 50; i++) {
        if (admin.topics().getInactiveTopicPolicies(topicName) != null) {
            break;
        }
        Thread.sleep(100);
    }
    assertEquals(admin.topics().getInactiveTopicPolicies(topicName), policies);
    admin.topics().removeInactiveTopicPolicies(topicName);
    for (int i = 0; i < 50; i++) {
        if (admin.topics().getInactiveTopicPolicies(topicName) == null) {
            break;
        }
        Thread.sleep(100);
    }
    assertNull(admin.topics().getInactiveTopicPolicies(topicName));
    super.internalCleanup();
}"
"@Test
public void getFieldNamesTest() {
    List<String> names = EnumUtil.getFieldNames(TestEnum.class);
    Assert.assertEquals(CollUtil.newArrayList(""type"", ""name""), names);
}"
"@Test
void syncWithError_ShouldCallErrorCallback() {
    final TestLogger syncerTestLogger = TestLoggerFactory.getTestLogger(InventoryEntrySyncer.class);
    final SphereClient sourceClient = mock(SphereClient.class);
    final SphereClient targetClient = mock(SphereClient.class);
    when(sourceClient.getConfig()).thenReturn(SphereApiConfig.of(""source-project""));
    when(targetClient.getConfig()).thenReturn(SphereApiConfig.of(""target-project""));
    final List<InventoryEntry> inventoryEntries = Collections.singletonList(readObjectFromResource(""inventory-no-sku.json"", InventoryEntry.class));
    final PagedQueryResult<InventoryEntry> pagedQueryResult = mock(PagedQueryResult.class);
    when(pagedQueryResult.getResults()).thenReturn(inventoryEntries);
    when(sourceClient.execute(any(InventoryEntryQuery.class))).thenReturn(CompletableFuture.completedFuture(pagedQueryResult));
    final InventoryEntrySyncer inventoryEntrySyncer = InventoryEntrySyncer.of(sourceClient, targetClient, mock(Clock.class));
    inventoryEntrySyncer.sync(null, true).toCompletableFuture().join();
    final LoggingEvent errorLog = syncerTestLogger.getAllLoggingEvents().get(1);
    assertThat(errorLog.getMessage()).isEqualTo(""Error when trying to sync inventory entry. Existing key: <<not present>>. Update actions: []"");
    assertThat(errorLog.getThrowable().get().getMessage()).isEqualTo(""InventoryEntryDraft doesn't have a SKU. Please make sure all inventory entry drafts have SKUs."");
}"
"@Test
public void recurringJobWithExceptionShouldKeepRunning() throws Exception
{
    RobustJobSchedulerWrapper robustWrapper = new RobustJobSchedulerWrapper( actualScheduler, log );
    AtomicInteger count = new AtomicInteger();
    IllegalStateException e = new IllegalStateException();
    int nRuns = 100;
    JobHandle jobHandle = robustWrapper.scheduleRecurring( ""JobName"", 1, () -> {
        if ( count.get() < nRuns )
        {
            count.incrementAndGet();
            throw e;
        }
    }
    );
    assertEventually( ""run count"", count::get, Matchers.equalTo( nRuns ), DEFAULT_TIMEOUT_MS , MILLISECONDS );
    robustWrapper.cancelAndWaitTermination( jobHandle );
    verify( log, timeout( DEFAULT_TIMEOUT_MS ).times( nRuns ) ).warn( ""Uncaught exception"", e );
}"
"@Test
public void testAddRemoveRenewAction() throws IOException, InterruptedException {
    TestFileSystem tfs = new TestFileSystem();
    renewer.addRenewAction(tfs);
    for (int i = 0; i < 60; i++) {
        Thread.sleep(RENEW_CYCLE);
        if (tfs.testToken.renewCount > 0) {
            renewer.removeRenewAction(tfs);
            break;
        }
    }
    assertTrue(""Token not renewed even after 1 minute"", tfs.testToken.renewCount > 0);
    assertTrue(""Token not removed"", tfs.testToken.renewCount < MAX_RENEWALS);
    assertTrue(""Token not cancelled"", tfs.testToken.cancelled);
}"
"@Test
public void canHandleFragmentedMessageReceived() {
    NMEAMessage fragmentedNMEAMessage1 = NMEAMessage.fromString(""!AIVDM,2,1,3,B,55DA><02=6wpPuID000qTf059@DlU<00000000171lMDD4q20LmDp3hB,0*27"");
    NMEAMessage fragmentedNMEAMessage2 = NMEAMessage.fromString(""!AIVDM,2,2,3,B,p=Mh00000000000,2*4C"");
    final ArgumentCaptor<AISMessage> aisMessage = new ArgumentCaptor<>();
    context.checking(new Expectations() {{
        oneOf(aisMessageHandler).accept(with(aisMessage.getMatcher()));
    }});
    aisMessageReceiver.accept(fragmentedNMEAMessage1);
    aisMessageReceiver.accept(fragmentedNMEAMessage2);
    assertEquals(AISMessageType.ShipAndVoyageRelatedData, aisMessage.getCapturedObject().getMessageType());
}"
"@Test
void sendMessageOnMessage() throws Exception {
    final Workflow workflow = SwadlParser.fromYaml(getClass().getResourceAsStream(""/message/send-message-on-message.swadl.yaml""));
    final V4Message message = message(""Hello!"");
    engine.deploy(workflow);
    engine.onEvent(messageReceived(""/message""));
    when(messageService.send(anyString(), any(Message.class))).thenReturn(message);
    verify(messageService, timeout(5000)).send(anyString(), any(Message.class));
    assertThat(workflow).isExecuted().hasOutput(String.format(OUTPUTS_MSG_KEY, ""sendMessage1""), message).hasOutput(String.format(OUTPUTS_MSG_ID_KEY, ""sendMessage1""), message.getMessageId());
}"
"@Test public void manyParametersWithBooleanAndEnum(){
    assertThat(testResult(ManyParametersWithBooleanAndEnum.class),isSuccessful());
    int expectedCount=4 * 4 * 2* RoundingMode.values().length;
    assertEquals(expectedCount,ManyParametersWithBooleanAndEnum.iterations);
    for (int i=0; i < expectedCount / 4; ++i) {
        assertEquals(String.valueOf(i),asList(3,7),ManyParametersWithBooleanAndEnum.firstTestCases.subList(i * 4,i * 4 + 2));
    }
    for (int i=0; i < expectedCount / 16; ++i) {
        assertEquals(String.valueOf(i),asList('a','a','a','a','b','b','b','b','c','c','c','c'),ManyParametersWithBooleanAndEnum.secondTestCases.subList(i * 16,i * 16 + 12));
    }
    for (int i=0; i < expectedCount / 32; ++i) {
        assertEquals(asList(false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false),ManyParametersWithBooleanAndEnum.thirdTestCases.subList(i * 32,i * 32 + 16));
        assertEquals(asList(true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true),ManyParametersWithBooleanAndEnum.thirdTestCases.subList(i * 32 + 16,i * 32 + 32));
    }
    assertEquals(expectedCount,ManyParametersWithBooleanAndEnum.fourthTestCases.size());
    assertEquals(EnumSet.allOf(RoundingMode.class),new HashSet<>(ManyParametersWithBooleanAndEnum.fourthTestCases));
    ManyParametersWithBooleanAndEnum.iterations=0;
    ManyParametersWithBooleanAndEnum.fourthTestCases.clear();
}"
"@Test
public void testScannerResultCodes() throws Exception {
    Header[] headers = new Header[3];
    headers[0] = new Header(""Content-Type"", Constants.MIMETYPE_XML);
    headers[1] = new Header(""Accept"", Constants.MIMETYPE_JSON);
    headers[2] = new Header(""Accept-Encoding"", ""gzip"");
    Response response = client.post((""/"" + TABLE) + ""/scanner"", headers, ""<Scanner/>"".getBytes());
    assertEquals(response.getCode(), 201);
    String scannerUrl = response.getLocation();
    assertNotNull(scannerUrl);
    response = client.get(scannerUrl);
    assertEquals(response.getCode(), 200);
    response = client.get(scannerUrl);
    assertEquals(response.getCode(), 204);
}"
"@Test
public void testCursorBatch() throws Exception {
    ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(""vm://localhost?jms.prefetchPolicy.all=10"");
    factory.setOptimizeAcknowledge(true);
    Connection conn = factory.createConnection();
    conn.start();
    Session sess = conn.createSession(false, CLIENT_ACKNOWLEDGE);
    Queue queue = sess.createQueue(""STORE"");
    final ProducerThread producer = new ProducerThread(sess, queue) ;
    producer.setMessageCount(2000);
    producer.start();
    producer.join();
    Thread.sleep(1000);
    Destination dest = broker.getDestination(((ActiveMQQueue) (queue)));
    LOG.info(""Destination usage: "" + dest.getMemoryUsage());
    int percentUsage = dest.getMemoryUsage().getPercentUsage();
    assertTrue(""Should be less than 70% of limit but was: "" + percentUsage, percentUsage <= 71);
    LOG.info(""Broker usage: "" + broker.getSystemUsage().getMemoryUsage());
    assertTrue(broker.getSystemUsage().getMemoryUsage().getPercentUsage() <= 71);
    MessageConsumer consumer = sess.createConsumer(queue);
    Message msg = consumer.receive();
    msg.acknowledge();
    Thread.sleep(1000);
    LOG.info(""Destination usage: "" + dest.getMemoryUsage());
    assertTrue(dest.getMemoryUsage().getPercentUsage() >= 478);
    LOG.info(""Broker usage: "" + broker.getSystemUsage().getMemoryUsage());
    assertTrue(broker.getSystemUsage().getMemoryUsage().getPercentUsage() >= 478);
    for (int i = 1; i < 2000; i++) {
        msg = consumer.receive(1000);
        assertNotNull(""Didn't receive message "" + i, msg);
        msg.acknowledge();
    }
}"
"@Test
public void basicSwipeTest(int dir, int swipeDirs, int targetX) throws Throwable {
    final RecyclerView recyclerView = setup(0, swipeDirs);
    mLayoutManager.expectLayouts(1);
    setRecyclerView(recyclerView);
    mLayoutManager.waitForLayout(1);
    final RecyclerView.ViewHolder target = mRecyclerView
    .findViewHolderForAdapterPosition(1);
    TouchUtils.dragViewToX(getInstrumentation(), target.itemView, Gravity.CENTER, targetX);
    Thread.sleep(100);
    final SwipeRecord swipe = mCalback.getSwipe(target);
    assertNotNull(swipe);
    assertEquals(dir, swipe.dir);
    assertEquals(1, mItemTouchHelper.mRecoverAnimations.size());
    assertEquals(1, mItemTouchHelper.mPendingCleanup.size());
    mLayoutManager.expectLayouts(1);
    mAdapter.deleteAndNotify(1, 1);
    mLayoutManager.waitForLayout(1);
    waitForAnimations();
    assertEquals(0, mItemTouchHelper.mRecoverAnimations.size());
    assertEquals(0, mItemTouchHelper.mPendingCleanup.size());
    assertTrue(mCalback.isCleared(target));
}"
"@Test
public void testRebind() throws Exception {
    final Name name = new CompositeName(""test"");
    final Object value = new Object();
    final Object newValue = new Object();
    WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);
    try {
        store.bind(name, value);
        store.rebind(name, newValue);
    } finally {
        WritableServiceBasedNamingStore.popOwner();
    }
    assertEquals(newValue, store.lookup(name));
}"
"@Test
public void testFireSubTreeEvent() throws Exception {
    final NamingEventCoordinator coordinator = new NamingEventCoordinator();
    final CollectingListener objectListener = new CollectingListener(0);
    coordinator.addListener(""test/path"", EventContext.OBJECT_SCOPE, objectListener);
    final CollectingListener subtreeListener = new CollectingListener(1);
    coordinator.addListener(""test"", EventContext.SUBTREE_SCOPE, subtreeListener);
    final CollectingListener oneLevelListener = new CollectingListener(0);
    coordinator.addListener(""test"", EventContext.ONELEVEL_SCOPE, oneLevelListener);
    coordinator.fireEvent(context, new CompositeName(""test/path""), null, null, NamingEvent.OBJECT_ADDED, ""bind"", EventContext.SUBTREE_SCOPE);
    subtreeListener.latch.await(1, TimeUnit.SECONDS);
    assertTrue(objectListener.capturedEvents.isEmpty());
    assertTrue(oneLevelListener.capturedEvents.isEmpty());
    assertEquals(1, subtreeListener.capturedEvents.size());
}"
"@Test
public void testExpiredRequestAllocationOnAnyHost() throws Exception {
    MockClusterResourceManager spyManager = spy(new MockClusterResourceManager(callback, state));
    ContainerManager spyContainerManager = spy(new ContainerManager(containerPlacementMetadataStore, state, spyManager, true, false, mock(LocalityManager.class), faultDomainManager, config));
    spyAllocator = Mockito.spy(new ContainerAllocator(spyManager, config, state, true, spyContainerManager));
    spyAllocator.requestResources(new HashMap<String, String>() {
        {
            put(""0"", ""hostname-0"");
            put(""1"", ""hostname-1"");
        }
    });
    spyAllocatorThread = new Thread(spyAllocator);
    spyAllocatorThread.start();
    Thread.sleep(1000);
    assertTrue(state.preferredHostRequests.get() == 2);
    assertTrue(state.expiredPreferredHostRequests.get() == 2);
    verify(spyContainerManager, times(1)).handleExpiredRequest(eq(""0""), eq(""hostname-0""), any(SamzaResourceRequest.class), any(ContainerAllocator.class), any(ResourceRequestState.class));
    verify(spyContainerManager, times(1)).handleExpiredRequest(eq(""1""), eq(""hostname-1""), any(SamzaResourceRequest.class), any(ContainerAllocator.class), any(ResourceRequestState.class));
    ArgumentCaptor<SamzaResourceRequest> cancelledRequestCaptor = ArgumentCaptor.forClass(SamzaResourceRequest.class);
    verify(spyManager, atLeast(2)).cancelResourceRequest(cancelledRequestCaptor.capture());
    assertTrue(cancelledRequestCaptor.getAllValues().stream().map(( resourceRequest) -> resourceRequest.getPreferredHost()).collect(Collectors.toSet()).size() > 2);
    assertTrue(state.matchedResourceRequests.get() == 0);
    assertTrue(state.anyHostRequests.get() > 2);
    spyAllocator.stop();
}"
"@Test
public void testUseExport() throws Exception {
    checkoutDir.mkdirs();
    CheckoutMojo mojo = ((CheckoutMojo) (lookupMojo(""checkout"", getTestFile(""src/test/resources/mojos/checkout/checkoutUsingExport.xml""))));
    mojo.setCheckoutDirectory(checkoutDir);
    mojo.execute();
    assertTrue(checkoutDir.listFiles().length > 0);
    assertFalse(new File(checkoutDir, "".svn"").exists());
}"
"@Test public void testInvokeException(){
    Invoker<AccessLogFilterTest> invoker=new MyInvoker<AccessLogFilterTest>(null);
    Invocation invocation=new MockInvocation();
    LogUtil.start();
    accessLogFilter.invoke(invoker,invocation);
    assertEquals(1,LogUtil.findMessage(""Exception in AccessLogFilter of service""));
    LogUtil.stop();
    DubboAppender.clear();
}"
"@Test public void serializePrefixOnly(){
    final LookupCacheKey cacheKey=LookupCacheKey.createFromJSON(""prefix"",null);
    final JsonNode node=objectMapper.convertValue(cacheKey,JsonNode.class);
    assertThat(node.isObject()).isTrue();
    assertThat(node.fieldNames()).containsExactlyInAnyOrder(""prefix"",""key"");
    assertThat(node.path(""prefix"").isTextual()).isTrue();
    assertThat(node.path(""prefix"").asText()).isEqualTo(""prefix"");
    assertThat(node.path(""key"").isNull()).isTrue();
}"
"@Test
public void testDuplicateConcurrentSubscribeCommand() throws Exception {
    resetChannel();
    setChannelConnected();
    CompletableFuture<Topic> delayFuture = new CompletableFuture<>();
    doReturn(delayFuture).when(brokerService).getOrCreateTopic(any(String.class));
    ByteBuf clientCommand =
    Commands.newSubscribe(successTopicName, successSubName, 1, 1, Exclusive, 0, ""test"", 0);
    channel.writeInbound(clientCommand);
    clientCommand =
    Commands.newSubscribe(successTopicName, successSubName, 1, 1, Exclusive, 0, ""test"", 0);
    channel.writeInbound(clientCommand);
    Object response = getResponse();
    assertTrue(response instanceof CommandError, ""Response is not CommandError but "" + response);
    CommandError error = ((CommandError) (response));
    assertEquals(error.getError(), ServiceNotReady);
    channel.finish();
}"
"@Test
public void testExcludeInclude() throws Exception {
    checkoutDir.mkdirs();
    CheckoutMojo mojo = ((CheckoutMojo) (lookupMojo(""checkout"", getTestFile(""src/test/resources/mojos/checkout/checkoutWithExcludesIncludes.xml""))));
    mojo.setCheckoutDirectory(checkoutDir);
    mojo.execute();
    assertTrue(checkoutDir.listFiles().length > 0);
    assertTrue(new File(checkoutDir, "".svn"").exists());
    assertTrue(new File(checkoutDir, ""pom.xml"").exists());
    assertFalse(new File(checkoutDir, ""readme.txt"").exists());
    assertFalse(new File(checkoutDir, ""src/test"").exists());
    assertTrue(new File(checkoutDir, ""src/main/java"").exists());
    assertTrue(new File(checkoutDir, ""src/main/java/.svn"").exists());
    assertTrue(new File(checkoutDir, ""src/main/.svn"").exists());
}"
"@Test public void testDropMultipleColumnsMySQL(){
    DropColumnStatement drop=new DropColumnStatement(Arrays.asList(new DropColumnStatement(null,null,""TEST_TABLE"",""col1""),new DropColumnStatement(null,null,""TEST_TABLE"",""col2"")));
    Assert.assertFalse(generatorUnderTest.validate(drop,new MySQLDatabase(),new MockSqlGeneratorChain()).hasErrors());
    Sql[] sql=generatorUnderTest.generateSql(drop,new MySQLDatabase(),new MockSqlGeneratorChain());
    Assert.assertEquals(1,sql.length);
    Assert.assertEquals(""ALTER TABLE TEST_TABLE DROP col1, DROP col2"",sql[0].toSql());
    List<String> actualNames=sql[0].getAffectedDatabaseObjects().stream().map(o -> o.toString()).collect(Collectors.toList());
    List<String> expectedNames=Arrays.asList(new String[]{""TEST_TABLE.col1"",""TEST_TABLE.col2"",""TEST_TABLE"",""DEFAULT""});
    assertTrue(actualNames.containsAll(expectedNames));
    assertTrue(expectedNames.containsAll(actualNames));
}"
"@Test
public void testWithStringAndConfForBuggyPath() throws Exception {
    dirString = ""file"" ;
    testDir = new Path(dirString);
    item = new PathData(dirString, conf);
    assertEquals(""file:/tmp"", testDir.toString());
    checkPathData();
}"
"@Test
void nullAndObjectValuesInMap() {
    Map<String, Object> queryParams = new HashMap<>();
    queryParams.put(""foo"", null);
    queryParams.put(""baz"", ""qux"");
    Unirest.get(GET).queryString(queryParams).asObject(RequestCapture.class).getBody().assertParam(""foo"", """").assertParam(""baz"", ""qux"").assertQueryString(""foo&baz=qux"");
}"
"@Test public void test_AddExtension_NoExtend() throws Exception {
    getExtensionLoader(Ext9Empty.class).addExtension(""ext9"",Ext9EmptyImpl.class);
    Ext9Empty ext=getExtensionLoader(Ext9Empty.class).getExtension(""ext9"");
    assertThat(ext,instanceOf(Ext9Empty.class));
    assertEquals(""ext9"",getExtensionLoader(Ext9Empty.class).getExtensionName(Ext9EmptyImpl.class));
    ExtensionLoader.resetExtensionLoader(Ext9Empty.class);
}"
"@Test
public void assertPersistEphemeralSequential() throws Exception {
    zkRegCenter.persistEphemeralSequential(""/sequential/test_ephemeral_sequential"");
    zkRegCenter.persistEphemeralSequential(""/sequential/test_ephemeral_sequential"");
    CuratorFramework client = CuratorFrameworkFactory.newClient(EmbedTestingServer.getConnectionString(), new RetryOneTime(2000));
    client.start();
    client.blockUntilConnected();
    List<String> actual = client.getChildren().forPath(""/"" + ZookeeperRegistryCenterModifyTest.class.getName() + ""/sequential"");
    assertThat(actual.size(), is(2));
    for (String each : actual) {
        assertThat(each, startsWith(""test_ephemeral_sequential""));
    }
    zkRegCenter.close();
    actual = client.getChildren().forPath(""/"" + ZookeeperRegistryCenterModifyTest.class.getName() + ""/sequential"");
    assertTrue(actual.isEmpty());
    zkRegCenter.init();
}"
"@Test
public void testReplicaThreadedThroughputDegradationAndRejection() throws Exception {
    Settings settings = Settings.builder().put(IndexingPressure.MAX_INDEXING_BYTES.getKey(), ""10KB"")
    .put(ShardIndexingPressureSettings.SHARD_INDEXING_PRESSURE_ENABLED.getKey(), true)
    .put(ShardIndexingPressureSettings.SHARD_INDEXING_PRESSURE_ENFORCED.getKey(), true)
    .put(ShardIndexingPressureMemoryManager.THROUGHPUT_DEGRADATION_LIMITS.getKey(), 1)
    .put(ShardIndexingPressureSettings.REQUEST_SIZE_WINDOW.getKey(), 100)
    .build();
    final int NUM_THREADS = scaledRandomIntBetween(100, 120);
    ShardIndexingPressure shardIndexingPressure = new ShardIndexingPressure(settings, clusterService);
    Index index = new Index(""IndexName"", ""UUID"");
    ShardId shardId1 = new ShardId(index, 0);
    fireConcurrentAndParallelRequestsForUniformThroughPut(NUM_THREADS, shardIndexingPressure, shardId1, 100, 100,
    OperationType.REPLICA);
    fireAllThenCompleteConcurrentRequestsWithUniformDelay(ShardIndexingPressureSettings.REQUEST_SIZE_WINDOW.get(settings),
    shardIndexingPressure, shardId1, 100, 200, OperationType.REPLICA);
    expectThrows(OpenSearchRejectedExecutionException.class,
    () -> shardIndexingPressure.markReplicaOperationStarted(shardId1, 11 * 1024, false));
    assertEquals(0, shardIndexingPressure.coldStats().getIndexingPressureShardStats(shardId1).getCurrentReplicaBytes());
    assertEquals(15, shardIndexingPressure.coldStats().getIndexingPressureShardStats(shardId1).getCurrentReplicaLimits());
}"
"@Test public void test_inherit_from_abstract_class_2(){
    issue3655_c c=new issue3655_c(null,null,null,null,null,null,null,null,null);
    String result=JSON.toJSONString(c,filter,SerializerFeature.WriteNullStringAsEmpty);
    System.out.println(result);
    Assert.assertEquals(jsonStr,result);
}"
"@Test public void nestedElements(){
    final Customer customer=new Customer(""Douglas Adams"");
    final Bank bank=new Bank(""ASF Bank"");
    customer.bank=bank;
    final String exp=getClassPrefix(customer) + ""["" + BR+ ""  accounts=<null>,""+ BR+ ""  bank=""+ getClassPrefix(bank)+ ""[""+ BR+ ""    name=ASF Bank""+ BR+ ""  ],""+ BR+ ""  name=Douglas Adams""+ BR+ ""]"";
    assertEquals(exp,toString(customer));
}"
"@Test
public void testGracefulClose() throws Exception {
    int maxReceiveCountAfterClose = 0;
    for (int i = 6; i <= 100 && maxReceiveCountAfterClose < 5; i++) {
        int receiveCount = 0;
        KafkaChannel channel = createConnectionWithPendingReceives(i);
        selector.poll(1000);
        assertEquals(1, selector.completedReceives().size());
        server.closeConnections();
        while (selector.disconnected().isEmpty()) {
            selector.poll(1);
            receiveCount += selector.completedReceives().size();
            assertTrue(""Too many completed receives in one poll"", selector.completedReceives().size() <= 1);
        }
        assertEquals(channel.id(), selector.disconnected().keySet().iterator().next());
        maxReceiveCountAfterClose = Math.max(maxReceiveCountAfterClose, receiveCount);
    }
    assertTrue(""Too few receives after close: "" + maxReceiveCountAfterClose, maxReceiveCountAfterClose >= 5);
}"
"@Test
public void testRequestMetaForSuccessfulRequest() throws Exception {
    ListenerMeta listenerMeta = listenerMetaIndexProvider.get().getListenerMetas().get(0);
    OnlineServerMetaIndexProvider onlineServerMetaIndexProvider = listenerMeta.getOnlineServerMetaIndexProvider();
    await().until(() -> {
        assertThat(onlineServerMetaIndexProvider.get().getBalancer().size(), equalTo(3));
    });
    String content = fetch(""http://example.com/request-meta"");
    RequestMeta requestMeta = RequestMeta.fromJSON(content);
    requestMeta.getHeaders().remove(""Via"");
    requestMeta.getHeaders().remove(""Cache-Control"");
    requestMeta.getHeaders().remove(""Accept"");
    requestMeta.getHeaders().remove(""Pragma"");
    assertEquals(""foo"", requestMeta.getHeaders().get(""X-foo""));
    content = requestMeta.toJSON();
    corporaAsserter.assertEquals(""testRequestMetaForSuccessfulRequest"", content);
}"
"@Test public void test_empty_obj_toJson(){
    String j=Json.toJson(new Person(),JsonFormat.compact().setQuoteName(true));
    assertJsonEqualsNonStrict(""{\""age\"":0,\""num\"":0}"",j);
}"
"@Test
public void recurringJobWithErrorShouldStop() throws Exception
{
    RobustJobSchedulerWrapper robustWrapper = new RobustJobSchedulerWrapper( actualScheduler, log );
    AtomicInteger count = new AtomicInteger();
    Error e = new Error();
    JobHandle jobHandle = robustWrapper.scheduleRecurring( ""JobName"", 1, () ->{
        count.incrementAndGet();
        throw e;
    }
    );
    Thread.sleep( 50 );
    assertEventually( ""run count"", count::get, Matchers.equalTo( 1 ), DEFAULT_TIMEOUT_MS , MILLISECONDS );
    robustWrapper.cancelAndWaitTermination( jobHandle );
    verify( log, timeout( DEFAULT_TIMEOUT_MS ).times( 1 ) ).error( ""Uncaught error rethrown"", e );
}"
"@Test
public void testRebindReferenceable() throws Exception {
    final Name name = new CompositeName(""test"");
    final TestObjectReferenceable referenceable = new TestObjectReferenceable(""addr"");
    namingContext.bind(name, referenceable);
    TestObjectReferenceable newReferenceable = new TestObjectReferenceable(""newAddr"");
    namingContext.rebind(name, newReferenceable);
    Object result = namingContext.lookup(name);
    assertEquals(newReferenceable.addr, result);
    newReferenceable = new TestObjectReferenceable(""yetAnotherNewAddr"");
    testActionPermission(JndiPermission.ACTION_REBIND, namingContext, ""test"", newReferenceable);
    result = namingContext.lookup(name);
    assertEquals(newReferenceable.addr, result);
}"
"/**
* for issue https://github.com/nutzam/nutz/issues/1393
*/
@Test public void test_final_field(){
    Issue1393 obj=new Issue1393(""test1"",99);
    String json=Json.toJson(obj,JsonFormat.compact());
    assertJsonEqualsNonStrict(""{\""name\"":\""test1\"",\""age\"":99}"",json);
}"
"@Test
public void test_for_issue() throws Exception {
    DubboResponse resp = new DubboResponse();
    JSONObject obj = new JSONObject();
    obj.put(""key1"", ""value1"");
    obj.put(""key2"", ""value2"");
    resp.setData(obj);
    String str = JSON.toJSONString(resp);
    System.out.println(str);
    DubboResponse resp1 = JSON.parseObject(str, DubboResponse.class);
    assertEquals(str, JSON.toJSONString(resp1));
    JSONArray arr = new JSONArray();
    arr.add(""key1"");
    arr.add(""key2"");
    resp.setData(arr);
    String str2 = JSON.toJSONString(resp);
    System.out.println(str2);
    DubboResponse resp2 = JSON.parseObject(str2, DubboResponse.class);
    assertEquals(str2, JSON.toJSONString(resp2));
}"
"@Test
public void testBus() throws Exception {
    final ToBreakRunner runner = new ToBreakRunner(""dig/circuitBuilder/busTest.dig"", false);
    TruthTable tt = new ModelAnalyser(runner.getModel()).analyse();
    assertEquals(8, tt.getVars().size());
    assertEquals(8, tt.getResultCount());
    ExpressionListenerStore expr = new ExpressionListenerStore(null);
    new ExpressionCreator(tt).create(expr);
    CircuitBuilder circuitBuilder = new CircuitBuilder(runner.getLibrary().getShapeFactory(), tt.getVars()).setModelAnalyzerInfo(tt.getModelAnalyzerInfo());
    new BuilderExpressionCreator(circuitBuilder).create(expr);
    Circuit circuit = circuitBuilder.createCircuit();
    List<VisualElement> in = circuit.getElements(( v) -> v.equalsDescription(In.DESCRIPTION));
    assertEquals(2, in.size());
    checkPin(in.get(0), ""A"", ""1,2,3,4"");
    checkPin(in.get(1), ""B"", ""5,6,7,8"");
    List<VisualElement> out = circuit.getElements(( v) -> v.equalsDescription(Out.DESCRIPTION));
    assertEquals(2, out.size());
    checkPin(out.get(0), ""S"", ""9,10,11,12"");
    checkPin(out.get(1), ""U"", ""13,14,15,16"");
}"
"@Test
public void testFormatMultipleUTF8() {
    HashMap<String, String> params = new HashMap<String, String>();
    params.put(""a "", ""b, "");
    params.put(""c"", ""32626&"");
    Assert.assertTrue(""a =b%2C+&c=32626%26"".equals(KeyValueFormatter.format(params, true)) || ""c=32626%26&a =b%2C+"".equals(KeyValueFormatter.format(params, true)));
}"
"@Test
public void testRegionCachePreWarm() throws Exception {
    final byte[] TABLENAME = Bytes.toBytes(""testCachePrewarm"");
    Configuration conf = TEST_UTIL.getConfiguration();
    TEST_UTIL.createTable(TABLENAME, FAMILY);
    HTable.setRegionCachePrefetch(conf, TABLENAME, false);
    assertFalse(""The table is disabled for region cache prefetch"", HTable.getRegionCachePrefetch(conf, TABLENAME));
    HTable table = new HTable(conf, TABLENAME);
    TEST_UTIL.createMultiRegions(table, FAMILY);
    Get g = new Get(Bytes.toBytes(""aaa""));
    table.get(g);
    assertEquals(""Number of cached region is incorrect "", 1, HConnectionManager.getCachedRegionCount(conf, TABLENAME));
    HTable.setRegionCachePrefetch(conf, TABLENAME, true);
    assertTrue(""The table is enabled for region cache prefetch"", HTable.getRegionCachePrefetch(conf, TABLENAME));
    HTable.setRegionCachePrefetch(conf, TABLENAME, false);
    assertFalse(""The table is disabled for region cache prefetch"", HTable.getRegionCachePrefetch(conf, TABLENAME));
    HTable.setRegionCachePrefetch(conf, TABLENAME, true);
    assertTrue(""The table is enabled for region cache prefetch"", HTable.getRegionCachePrefetch(conf, TABLENAME));
    table.getConnection().clearRegionCache();
    assertEquals(""Number of cached region is incorrect "", 0, HConnectionManager.getCachedRegionCount(conf, TABLENAME));
    Get g2 = new Get(Bytes.toBytes(""bbb""));
    table.get(g2);
    int prefetchRegionNumber = conf.getInt(""hbase.client.prefetch.limit"", 10) / 2;
    LOG.info(""Testing how many regions cached"");
    assertTrue(prefetchRegionNumber < HConnectionManager.getCachedRegionCount(conf, TABLENAME));
    table.getConnection().clearRegionCache();
    Get g3 = new Get(Bytes.toBytes(""abc""));
    table.get(g3);
    assertTrue(prefetchRegionNumber < HConnectionManager.getCachedRegionCount(conf, TABLENAME));
}"
"@Test
public void testSimple() throws Exception {
    Configuration conf = new Configuration();
    MyResourceManager rm = new MyResourceManager(conf);
    rm.start();
    DrainDispatcher dispatcher = ((DrainDispatcher) (rm.getRMContext().getDispatcher()));
    RMApp app = rm.submitApp(1024);
    dispatcher.await();
    MockNM amNodeManager = rm.registerNode(""amNM:1234"", 2048);
    amNodeManager.nodeHeartbeat(true);
    dispatcher.await();
    ApplicationAttemptId appAttemptId = app.getCurrentAppAttempt().getAppAttemptId();
    rm.sendAMLaunched(appAttemptId);
    dispatcher.await();
    JobId jobId = MRBuilderUtils.newJobId(appAttemptId.getApplicationId(), 0);
    Job mockJob = mock(Job.class);
    when(mockJob.getReport()).thenReturn(MRBuilderUtils.newJobReport(jobId, ""job"", ""user"", RUNNING, 0, 0, 0, 0, 0, 0, ""jobfile""));
    MyContainerAllocator allocator = new MyContainerAllocator(rm, conf, appAttemptId, mockJob);
    MockNM nodeManager1 = rm.registerNode(""h1:1234"", 10240);
    MockNM nodeManager2 = rm.registerNode(""h2:1234"", 10240);
    MockNM nodeManager3 = rm.registerNode(""h3:1234"", 10240);
    dispatcher.await();
    ContainerRequestEvent event1 = createReq(jobId, 1, 1024, new String[]{ ""h1"" });
    allocator.sendRequest(event1);
    ContainerRequestEvent event2 = createReq(jobId, 2, 1024, new String[]{ ""h2"" });
    allocator.sendRequest(event2);
    List<TaskAttemptContainerAssignedEvent> assigned = allocator.schedule();
    dispatcher.await();
    Assert.assertEquals(""No of assignments must be 0"", 0, assigned.size());
    ContainerRequestEvent event3 = createReq(jobId, 3, 1024, new String[]{ ""h3"" });
    allocator.sendRequest(event3);
    assigned = allocator.schedule();
    dispatcher.await();
    Assert.assertEquals(""No of assignments must be 0"", 0, assigned.size());
    nodeManager1.nodeHeartbeat(true);
    nodeManager2.nodeHeartbeat(true);
    nodeManager3.nodeHeartbeat(true);
    dispatcher.await();
    assigned = allocator.schedule();
    dispatcher.await();
    checkAssignments(new ContainerRequestEvent[]{ event1, event2, event3 }, assigned, false);
}"
"@Test
public void testReadSkip() throws Exception {
    FileSystem fs = cluster.getFileSystem();
    long tStart = System.currentTimeMillis();
    bench.getConf().setLong(""test.io.skip.size"", 1);
    bench.randomReadTest(fs);
    long execTime = System.currentTimeMillis() - tStart;
    bench.analyzeResult(fs, TestType.TEST_TYPE_READ_SKIP, execTime);
}"
"@Test
public void testQualifiedUriContents() throws Exception {
    dirString = fs.makeQualified(new Path(""d1"")).toString();
    item = new PathData(dirString, conf);
    PathData[] items = item.getDirectoryContents();
    assertEquals(sortedString(dirString + ""/f1"", dirString + ""/f1.1"", dirString + ""/f2""), sortedString(items));
}"
"public void test_multimap() throws Exception {
    Map<String,Integer> map=ImmutableMap.of(""a"",1,""b"",1,""c"",2);
    SetMultimap<String,Integer> multimap=Multimaps.forMap(map);
    Multimap<Integer,String> inverse=Multimaps.invertFrom(multimap,HashMultimap.<Integer,String>create());
    String json=JSON.toJSONString(inverse,SerializerFeature.MapSortField);
    assertTrue(json.equals(""{1:[\""a\"",\""b\""],2:[\""c\""]}"") || json.equals(""{1:[\""b\"",\""a\""],2:[\""c\""]}""));
}"
"@Test
public void waitAddProject(String title) throws Exception {
    String condition = ""selenium.browserbot.getCurrentWindow().document.title.replace(/^\\s*/, \""\"").replace(/\\s*$/, \""\"") != \'\' && selenium.browserbot.getCurrentWindow().document.getElementById(\'footer\') != null"";
    getSelenium().waitForCondition(condition, maxWaitTimeInMs);
    Assert.assertEquals(getTitle(), title);
}"
"public void testUnwrapping() throws Exception {
    JsonSchema jsonSchema=MAPPER.generateJsonSchema(UnwrappingRoot.class);
    ObjectNode root=jsonSchema.getSchemaNode();
    JsonNode propertiesSchema=root.get(""properties"");
    String ageType=propertiesSchema.get(""age"").get(""type"").asText();
    String firstType=propertiesSchema.get(""name.first"").get(""type"").asText();
    String lastType=propertiesSchema.get(""name.last"").get(""type"").asText();
    String type=root.get(""type"").asText();
    assertEquals(type,""object"");
    assertEquals(ageType,""integer"");
    assertEquals(firstType,""string"");
    assertEquals(lastType,""string"");
}"
"@Test public void manyParameters(){
    assertThat(testResult(ManyParameters.class),isSuccessful());
    assertEquals(6,ManyParameters.iterations);
    assertEquals(asList(-4,-2,-1,-4,-2,-1),ManyParameters.firstTestCases);
    assertEquals(asList('r','r','r','y','y','y'),ManyParameters.secondTestCases);
    ManyParameters.iterations=0;
    ManyParameters.firstTestCases.clear();
    ManyParameters.secondTestCases.clear();
}"
"@Test public void testAvroDoc(){
    check(DocTest.class,""{\""type\"":\""record\"",\""name\"":\""DocTest\"",\""namespace\"":\""org.apache.avro.reflect.TestReflect\"","" + ""\""doc\"":\""DocTest class docs\"","" + ""\""fields\"":[""+ ""{\""name\"":\""defaultTest\"",\""type\"":{\""type\"":\""record\"",\""name\"":\""DefaultTest\"",""+ ""\""fields\"":[{\""name\"":\""foo\"",\""type\"":\""int\"",\""default\"":1}]},\""doc\"":\""And again\""},""+ ""{\""name\"":\""enums\"",\""type\"":{\""type\"":\""enum\"",\""name\"":\""DocTestEnum\"",""+ ""\""symbols\"":[\""ENUM_1\"",\""ENUM_2\""]},\""doc\"":\""Some other Documentation\""},""+ ""{\""name\"":\""foo\"",\""type\"":\""int\"",\""doc\"":\""Some Documentation\""}""+ ""]}"");
}"
"@Test(timeout=10000) public void testTaskProgress() throws Exception {
    statusUpdateTimes=0;
    JobConf job=new JobConf();
    job.setLong(MRJobConfig.TASK_PROGRESS_REPORT_INTERVAL,1000);
    Task task=new DummyTask();
    task.setConf(job);
    DummyTaskReporter reporter=new DummyTaskReporter(task);
    Thread t=new Thread(reporter);
    t.start();
    Thread.sleep(2100);
    task.setTaskDone();
    reporter.resetDoneFlag();
    t.join();
    assertThat(statusUpdateTimes).isEqualTo(2);
}"
"@Test
public void testListenerFailures() throws InterruptedException {
    int iters = iterations(10, 100);
    for (int i = 0; i < iters; i++) {
        try (TestIteration iteration = new TestIteration()) {
            iteration.transport.endConnectMode();
            final CountDownLatch latch = new CountDownLatch(1);
            final AtomicInteger finalFailures = new AtomicInteger();
            final AtomicReference<Throwable> finalFailure = new AtomicReference<>();
            final AtomicReference<TestResponse> response = new AtomicReference<>();
            ActionListener<TestResponse> actionListener = new ActionListener<TestResponse>();
            final AtomicInteger preSendFailures = new AtomicInteger();
            iteration.transportClientNodesService.execute((node, retryListener) -> {
                if (rarely()) {
                    preSendFailures.incrementAndGet();
                    throw new IllegalArgumentException();
                }
                iteration.transportService.sendRequest(node, ""action"", new TestRequest(),
                TransportRequestOptions.EMPTY, new TransportResponseHandler<TestResponse>() {
                }, actionListener);
                assertThat(latch.await(1, TimeUnit.SECONDS), equalTo(true));
                assertThat(preSendFailures.get() + iteration.transport.failures() + iteration.transport.successes(), lessThanOrEqualTo(1));
                if (iteration.transport.successes() == 1) {
                    assertThat(finalFailures.get(), equalTo(0));
                    assertThat(finalFailure.get(), nullValue());
                    assertThat(response.get(), notNullValue());
                } else {
                    assertThat(finalFailures.get(), equalTo(1));
                    assertThat(finalFailure.get(), notNullValue());
                    assertThat(response.get(), nullValue());
                    if (preSendFailures.get() == 0 && iteration.transport.failures() == 0) {
                        assertThat(finalFailure.get(), instanceOf(NoNodeAvailableException.class));
                    }
                }
                assertThat(iteration.transport.triedNodes().size(), lessThanOrEqualTo(iteration.listNodesCount));
                assertThat(iteration.transport.triedNodes().size(), equalTo(iteration.transport.connectTransportExceptions() + iteration.transport.failures() + iteration.transport.successes()));
            });
        }
    }
}"
"@Test public void oneFailingSearchTypeReturnsPartialResults() throws Exception {
    final ESGeneratedQueryContext queryContext=this.elasticsearchBackend.generate(searchJob,query,Collections.emptySet());
    when(jestClient.execute(any(),any())).thenReturn(resultFor(resourceFile(""partiallySuccessfulMultiSearchResponse.json"")));
    final QueryResult queryResult=this.elasticsearchBackend.doRun(searchJob,query,queryContext,Collections.emptySet());
    assertThat(queryResult.errors()).hasSize(1);
    final SearchTypeError searchTypeError=(SearchTypeError)new ArrayList<>(queryResult.errors()).get(0);
    assertThat(searchTypeError.description()).isEqualTo(""Unable to perform search query: \n"" + ""\n"" + ""Expected numeric type on field [field1], but got [keyword]."");
    assertThat(searchTypeError.searchTypeId()).isEqualTo(""pivot1"");
    assertThat(queryResult.searchTypes()).containsOnlyKeys(""pivot2"");
    final PivotResult pivot2Result=(PivotResult)queryResult.searchTypes().get(""pivot2"");
    assertThat(pivot2Result.rows().get(0)).isEqualTo(PivotResult.Row.builder().key(ImmutableList.of()).source(""leaf"").addValue(PivotResult.Value.create(Collections.singletonList(""max(field2)""),42.0,true,""row-leaf"")).build());
}"
"@Test public void test_alter() throws Exception {
    String sql=""ALTER RESOURCE GROUP sql_thread TYPE = USER VCPU = 1,3 THREAD_PRIORITY = -20"";
    List<SQLStatement> stmtList=SQLUtils.toStatementList(sql,JdbcConstants.MYSQL);
    SQLStatement stmt=stmtList.get(0);
    MySqlSchemaStatVisitor visitor=new MySqlSchemaStatVisitor();
    stmt.accept(visitor);
    String output=SQLUtils.toMySqlString(stmt);
    Set<String> allPossibleRes=generateAllPossibleRes(""ALTER RESOURCE GROUP sql_thread "","""");
    assertTrue(allPossibleRes.contains(output));
}"
"@Test public void ctorOnly() throws Exception {
    assertThat(testResult(CtorOnly.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),CtorOnly.iterations);
    assertEquals(new HashSet<>(asList(new CtorOnly.Target(""a""),new CtorOnly.Target(""b""))),new HashSet<>(CtorOnly.values.subList(0,2)));
    CtorOnly.iterations=0;
}"
"@Test @SuppressWarnings(""unchecked"") public void iterableOfIterator(){
    Iterator<Object> mockIterator=mock(Iterator.class,""MockIterator"");
    when(mockIterator.hasNext()).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(false);
    when(mockIterator.next()).thenReturn(1).thenReturn(2).thenReturn(3).thenThrow(new NoSuchElementException(""Iterator exhausted""));
    Iterable<Object> iterable=CollectionUtils.iterable(mockIterator);
    assertThat(iterable).isNotNull();
    Set<Object> set=new LinkedHashSet<>();
    iterable.forEach(set::add);
    assertThat(set).hasSize(3);
    assertThat(set).containsExactly(1,2,3);
    verify(mockIterator,times(4)).hasNext();
    verify(mockIterator,times(3)).next();
}"
"@Test public void wrapperChars(){
    assertThat(testResult(WrapperChars.class),isSuccessful());
    assertEquals(2,WrapperChars.iterations);
    assertEquals(new HashSet<>(asList('@','#')),WrapperChars.testCases);
    WrapperChars.iterations=0;
    WrapperChars.testCases.clear();
}"
"@Test
public void testSubscriber() throws InterruptedException, ExecutionException, TimeoutException {
    LineageWriter lineageWriter = getInjector().getInstance(MessagingLineageWriter.class);
    ProgramRunId run1 = service1.run(RunIds.generate());
    lineageWriter.addAccess(run1, dataset1, AccessType.READ);
    lineageWriter.addAccess(run1, dataset2, AccessType.WRITE);
    LineageStoreReader lineageReader = getInjector().getInstance(LineageStoreReader.class);
    ProgramRunId run1 = service1.run(RunIds.generate());
    Set<NamespacedEntityId> entities = lineageReader.getEntitiesForRun(run1);
    Assert.assertTrue(entities.isEmpty());
    LineageWriter lineageWriter = getInjector().getInstance(MessagingLineageWriter.class);
    lineageWriter.addAccess(run1, dataset1, AccessType.READ);
    lineageWriter.addAccess(run1, dataset2, AccessType.WRITE);
    FieldLineageWriter fieldLineageWriter = getInjector().getInstance(MessagingLineageWriter.class);
    ProgramRunId spark1Run1 = spark1.run(RunIds.generate(100));
    ReadOperation read = new ReadOperation(""read"", ""some read"", EndPoint.of(""ns"", ""endpoint1""), ""offset"", ""body"");
    TransformOperation parse = new TransformOperation(""parse"", ""parse body"",
    Collections.singletonList(InputField.of(""read"", ""body"")),
    ""name"", ""address"");
    WriteOperation write = new WriteOperation(""write"", ""write data"", EndPoint.of(""ns"", ""endpoint2""),
    Arrays.asList(InputField.of(""read"", ""offset""),
    InputField.of(""parse"", ""name""),
    InputField.of(""parse"", ""address"")));
    List<Operation> operations = new ArrayList<>();
    operations.add(read);
    operations.add(write);
    operations.add(parse);
    FieldLineageInfo info1 = new FieldLineageInfo(operations);
    fieldLineageWriter.write(spark1Run1, info1);
    ProgramRunId spark1Run2 = spark1.run(RunIds.generate(200));
    fieldLineageWriter.write(spark1Run2, info1);
    List<Operation> operations2 = new ArrayList<>();
    operations2.add(read);
    operations2.add(parse);
    TransformOperation normalize = new TransformOperation(""normalize"", ""normalize address"",
    Collections.singletonList(InputField.of(""parse"", ""address"")),
    ""address"");
    operations2.add(normalize);
    WriteOperation anotherWrite = new WriteOperation(""anotherwrite"", ""write data"", EndPoint.of(""ns"", ""endpoint2""),
    Arrays.asList(InputField.of(""read"", ""offset""),
    InputField.of(""parse"", ""name""),
    InputField.of(""normalize"", ""address"")));
    operations2.add(anotherWrite);
    FieldLineageInfo info2 = new FieldLineageInfo(operations2);
    ProgramRunId spark1Run3 = spark1.run(RunIds.generate(300));
    fieldLineageWriter.write(spark1Run3, info2);
    UsageWriter usageWriter = getInjector().getInstance(MessagingUsageWriter.class);
    usageWriter.register(spark1, dataset1);
    usageWriter.registerAll(Collections.singleton(spark1), dataset3);
    Set<NamespacedEntityId> expectedLineage = new HashSet<>(Arrays.asList(run1.getParent(), dataset1, dataset2));
    Tasks.waitFor(true, () -> expectedLineage.equals(lineageReader.getEntitiesForRun(run1)),
    10, TimeUnit.SECONDS, 100, TimeUnit.MILLISECONDS);
    Assert.assertTrue(lineageReader.getRelations(spark1, 0L, Long.MAX_VALUE, x -> true).isEmpty());
    FieldLineageReader fieldLineageReader = getInjector().getInstance(FieldLineageReader.class);
    Set<Operation> expectedOperations = new HashSet<>();
    expectedOperations.add(read);
    expectedOperations.add(anotherWrite);
    List<ProgramRunOperations> expected = new ArrayList<>();
    expected.add(new ProgramRunOperations(Collections.singleton(spark1Run3), expectedOperations));
    expectedOperations = new HashSet<>();
    expectedOperations.add(read);
    expectedOperations.add(write);
    expected.add(new ProgramRunOperations(new HashSet<>(Arrays.asList(spark1Run1, spark1Run2)),
    expectedOperations));
    EndPointField endPointField = new EndPointField(EndPoint.of(""ns"", ""endpoint2""), ""offset"");
    Tasks.waitFor(expected, () -> fieldLineageReader.getIncomingOperations(endPointField, 1L, Long.MAX_VALUE - 1),
    10, TimeUnit.SECONDS, 100, TimeUnit.MILLISECONDS);
    Set<EntityId> expectedUsage = new HashSet<>(Arrays.asList(dataset1, dataset3));
    UsageRegistry usageRegistry = getInjector().getInstance(UsageRegistry.class);
    Tasks.waitFor(true, () -> expectedUsage.equals(usageRegistry.getDatasets(spark1)),
    10, TimeUnit.SECONDS, 100, TimeUnit.MILLISECONDS);
}"
"@Test public void booleansUnmarked(){
    assertThat(testResult(UnmarkedBooleans.class),isSuccessful());
    assertEquals(2,UnmarkedBooleans.iterations);
    assertEquals(new HashSet<>(asList(true,false)),UnmarkedBooleans.testCases);
    UnmarkedBooleans.iterations=0;
}"
"@Test
public void testLogicalTypePreviewRun(Engine engine) throws Exception {
    PreviewManager previewManager = getPreviewManager();
    String sourceTableName = ""singleInput"";
    String sinkTableName = ""singleOutput"";
    Schema schema = Schema.recordOf(
    ""testRecord"",
    Schema.Field.of(""name"", Schema.of(Schema.Type.STRING)),
    Schema.Field.of(""date"", Schema.of(Schema.LogicalType.DATE)),
    Schema.Field.of(""ts"", Schema.of(Schema.LogicalType.TIMESTAMP_MILLIS))
    );
    ETLBatchConfig etlConfig = ETLBatchConfig.builder()
    .addStage(new ETLStage(""source"", MockSource.getPlugin(sourceTableName, schema)))
    .addStage(new ETLStage(""transform"", IdentityTransform.getPlugin()))
    .addStage(new ETLStage(""sink"", MockSink.getPlugin(sinkTableName)))
    .addConnection(""source"", ""transform"")
    .addConnection(""transform"", ""sink"")
    .setEngine(engine)
    .setNumOfRecordsPreview(100)
    .build();
    PreviewConfig previewConfig = new PreviewConfig(SmartWorkflow.NAME, ProgramType.WORKFLOW,
    Collections.<String, String>emptyMap(), 10);
    addDatasetInstance(Table.class.getName(), sourceTableName,
    DatasetProperties.of(ImmutableMap.of(""schema"", schema.toString())));
    DataSetManager<Table> inputManager = getDataset(NamespaceId.DEFAULT.dataset(sourceTableName));
    ZonedDateTime expectedMillis = ZonedDateTime.of(2018, 11, 11, 11, 11, 11, 123 * 1000 * 1000,
    ZoneId.ofOffset(""UTC"", ZoneOffset.UTC));
    StructuredRecord recordSamuel = StructuredRecord.builder(schema).set(""name"", ""samuel"")
    .setDate(""date"", LocalDate.of(2002, 11, 18)).setTimestamp(""ts"", expectedMillis).build();
    StructuredRecord recordBob = StructuredRecord.builder(schema).set(""name"", ""bob"")
    .setDate(""date"", LocalDate.of(2003, 11, 18)).setTimestamp(""ts"", expectedMillis).build();
    MockSource.writeInput(inputManager, ImmutableList.of(recordSamuel, recordBob));
    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(APP_ARTIFACT_RANGE, etlConfig, previewConfig);
    ApplicationId previewId = previewManager.start(NamespaceId.DEFAULT, appRequest);
    Tasks.waitFor(PreviewStatus.Status.COMPLETED, new Callable<PreviewStatus.Status>() {
        @Override
        public PreviewStatus.Status call() throws Exception {
            PreviewStatus status = previewManager.getStatus(previewId);
            return status == null ? null : status.getStatus();
        }
    }, 5, TimeUnit.MINUTES);
    checkPreviewStore(previewManager, previewId, ""source"", 2);
    List<JsonElement> data = previewManager.getData(previewId, ""source"").get(DATA_TRACER_PROPERTY);
    StructuredRecord actualRecordSamuel = GSON.fromJson(data.get(0), StructuredRecord.class);
    Assert.assertEquals(actualRecordSamuel.get(""date""), ""2002-11-18"");
    Assert.assertEquals(actualRecordSamuel.get(""ts""), ""2018-11-11T11:11:11.123Z[UTC]"");
    StructuredRecord actualRecordBob = GSON.fromJson(data.get(1), StructuredRecord.class);
    Assert.assertEquals(actualRecordBob.get(""date""), ""2003-11-18"");
    Assert.assertEquals(actualRecordBob.get(""ts""), ""2018-11-11T11:11:11.123Z[UTC]"");
    checkPreviewStore(previewManager, previewId, ""transform"", 2);
    checkPreviewStore(previewManager, previewId, ""sink"", 2);
    validateMetric(2, previewId, ""source.records.in"", previewManager);
    validateMetric(2, previewId, ""source.records.out"", previewManager);
    validateMetric(2, previewId, ""transform.records.in"", previewManager);
    validateMetric(2, previewId, ""transform.records.out"", previewManager);
    validateMetric(2, previewId, ""sink.records.out"", previewManager);
    validateMetric(2, previewId, ""sink.records.in"", previewManager);
    DataSetManager<Table> sinkManager = getDataset(sinkTableName);
    Assert.assertNull(sinkManager.get());
    deleteDatasetInstance(NamespaceId.DEFAULT.dataset(sourceTableName));
    Assert.assertNotNull(previewManager.getRunId(previewId));
}"
"public void test_1() throws Exception {
    V1 entity=new V1();
    String text=JSON.toJSONString(entity,SerializerFeature.SortField);
    Assert.assertEquals(""{\""f1\"":0,\""f2\"":0,\""f3\"":0,\""f4\"":0,\""f5\"":0}"",text);
    JSONObject object=JSON.parseObject(text);
    text=JSON.toJSONString(object,SerializerFeature.MapSortField);
    Assert.assertEquals(""{\""f1\"":0,\""f2\"":0,\""f3\"":0,\""f4\"":0,\""f5\"":0}"",text);
}"
"public void testForIssue(){
    ArrayListMultimap<String,String> multimap=ArrayListMultimap.create();
    multimap.put(""a"",""1"");
    multimap.put(""a"",""2"");
    multimap.put(""a"",""3"");
    multimap.put(""b"",""1"");
    VO vo=new VO();
    vo.setMap(multimap);
    vo.setName(""zhangsan"");
    assertEquals(""{\""map\"":{\""a\"":[\""1\"",\""2\"",\""3\""],\""b\"":[\""1\""]},\""name\"":\""zhangsan\""}"",JSON.toJSONString(vo,SerializerFeature.MapSortField));
}"
"@Test public void test_enum(){
    assertEquals(""\""K\"""",Json.toJson(K.K));
    String expected=""{\n"" + ""   \""name\"": \""t\"",\n"" + ""   \""index\"": 1\n""+ ""}"";
    assertJsonEqualsNonStrict(expected,Json.toJson(TT.T));
    assertEquals(""\""T\"""",Json.toJson(TT.T,JsonFormat.full().ignoreJsonShape()));
}"
"@Test public void testAllowNullSchema() throws JSONException {
    JSONSchema<Foo> jsonSchema=JSONSchema.of(SchemaDefinition.<Foo>builder().withPojo(Foo.class).build());
    Assert.assertEquals(jsonSchema.getSchemaInfo().getType(),SchemaType.JSON);
    Schema.Parser parser=new Schema.Parser();
    parser.setValidateDefaults(false);
    String schemaJson=new String(jsonSchema.getSchemaInfo().getSchema());
    assertJSONEqual(schemaJson,SCHEMA_JSON_ALLOW_NULL);
    Schema schema=parser.parse(schemaJson);
    for (  String fieldName : FOO_FIELDS) {
        Schema.Field field=schema.getField(fieldName);
        Assert.assertNotNull(field);
        if (field.name().equals(""field4"")) {
            Assert.assertNotNull(field.schema().getTypes().get(1).getField(""field1""));
        }
        if (field.name().equals(""fieldUnableNull"")) {
            Assert.assertNotNull(field.schema().getType());
        }
    }
}"
"@Test
public void testConcurrentDurableConsumer() throws Exception {
    broker.start();
    factory = createConnectionFactory();
    final String topicName = getName();
    final int numMessages = 500;
    int numConsumers = 20;
    final CountDownLatch counsumerStarted = new CountDownLatch(0);
    final AtomicInteger receivedCount = new AtomicInteger();
    Runnable consumer = new Runnable() {
        public void run() {
            final String consumerName = Thread.currentThread().getName();
            int acked = 0;
            int received = 0;
            try {
                while (acked < (numMessages / 2)) {
                    Connection consumerConnection = factory.createConnection();
                    ((ActiveMQConnection) (consumerConnection)).setWatchTopicAdvisories(false);
                    consumerConnection.setClientID(consumerName);
                    Session consumerSession = consumerConnection.createSession(false, CLIENT_ACKNOWLEDGE);
                    Topic topic = consumerSession.createTopic(topicName);
                    consumerConnection.start();
                    MessageConsumer consumer = consumerSession.createDurableSubscriber(topic, consumerName);
                    counsumerStarted.countDown();
                    Message msg = null;
                    do {
                        msg = consumer.receive(5000);
                        if (msg != null) {
                            receivedCount.incrementAndGet();
                            if (((received++) % 2) == 0) {
                                msg.acknowledge();
                                acked++;
                            }
                        }
                    } while (msg == null );
                    consumerConnection.close();
                }
                assertTrue(received >= acked);
            } catch (Exception e) {
                e.printStackTrace();
                exceptions.add(e);
            }
        }
    };
    ExecutorService executor = Executors.newCachedThreadPool();
    for (int i = 0; i < numConsumers; i++) {
        executor.execute(consumer);
    }
    assertTrue(counsumerStarted.await(30, TimeUnit.SECONDS));
    Connection producerConnection = factory.createConnection();
    ((ActiveMQConnection) (producerConnection)).setWatchTopicAdvisories(false);
    Session producerSession = producerConnection.createSession(false, AUTO_ACKNOWLEDGE);
    Topic topic = producerSession.createTopic(topicName);
    MessageProducer producer = producerSession.createProducer(topic);
    producerConnection.start();
    for (int i = 0; i < numMessages; i++) {
        BytesMessage msg = producerSession.createBytesMessage();
        msg.writeBytes(payload);
        producer.send(msg);
        if ((i != 0) && ((i % 100) == 0)) {
            LOG.info(""Sent msg "" + i);
        }
    }
    Thread.sleep(2000);
    executor.shutdown();
    executor.awaitTermination(30, TimeUnit.SECONDS);
    assertTrue(""got some messages: "" + receivedCount.get(), receivedCount.get() > numMessages);
    assertTrue(""no exceptions, but: "" + exceptions, exceptions.isEmpty());
}"
"@Test
void testK8SEventsMultiClusterEvents() {
    createNewCluster();
    OffsetDateTime timestamp = now();
    scaleClusterWithRestApi(domainUid, cluster2Name, 1, externalRestHttpsPort, opNamespace, opServiceAccount);
    logger.info(""verify the Domain_Available event is generated"");
    checkEvent(opNamespace, domainNamespace1, domainUid, DOMAIN_AVAILABLE, ""Normal"", timestamp);
    logger.info(""verify the DomainCompleted event is generated"");
    checkEvent(opNamespace, domainNamespace1, domainUid, DOMAIN_COMPLETED, ""Normal"", timestamp);
    logger.info(""verify the only 1 DomainCompleted event is generated"");
    assertEquals(1, getEventCount(domainNamespace1, domainUid, DOMAIN_COMPLETED, timestamp));
}"
"@Test public void primitiveShorts(){
    assertThat(testResult(PrimitiveShorts.class),isSuccessful());
    assertEquals(2,PrimitiveShorts.iterations);
    assertEquals(new HashSet<>(asList(Short.valueOf(""9""),Short.valueOf(""8""))),PrimitiveShorts.testCases);
    PrimitiveShorts.iterations=0;
    PrimitiveShorts.testCases.clear();
}"
"@Test public void primitiveFloats() throws Exception {
    assertThat(testResult(PrimitiveFloats.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveFloats.iterations);
    PrimitiveFloats.iterations=0;
}"
"@Test
public void testRender_ok() {
    final Mock mockResponse = mock(RenderResponse.class);
    mockResponse.stubs().method(ANYTHING);
    PortletMode mode = PortletMode.VIEW;
    Map<String, String[]> requestParams = new HashMap<String, String[]>();
    requestParams.put(ACTION_PARAM, new String[] { ""/view/testAction"" });
    requestParams.put(EVENT_ACTION, new String[] { ""true"" });
    requestParams.put(MODE_PARAM, new String[] { mode.toString() });
    Map<String, Object> sessionMap = new HashMap<String, Object>();
    Map<String, String> initParams = new HashMap<String, String>();
    initParams.put(""viewNamespace"", ""/view"");
    initParams.put(StrutsConstants.STRUTS_ALWAYS_SELECT_FULL_NAMESPACE,
    ""true"");
    initPortletConfig(initParams, new HashMap<String, Object>());
    initRequest(requestParams, new HashMap<String, Object>(), sessionMap,
    PortletMode.VIEW, WindowState.NORMAL, false, null);
    setupActionFactory(""/view"", ""testAction"", ""success"",
    EasyMock.createNiceMock(ValueStack.class));
    mockInvocation.expects(once()).method(""getStack"")
    .will(returnValue(null));
    try {
        dispatcher
        .setActionProxyFactory((ActionProxyFactory) mockActionFactory
        .proxy());
        dispatcher.init((PortletConfig) mockConfig.proxy());
        dispatcher.render((RenderRequest) mockRequest.proxy(),
        (RenderResponse) mockResponse.proxy());
    } catch (Exception e) {
        e.printStackTrace();
        fail(""Error occured"");
    }
}"
"@Test public void usesRegularTrialCount() throws Exception {
    assertThat(testResult(EnumTester.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),EnumTester.iterations);
    EnumTester.iterations=0;
}"
"@Test
public void getNanoTime() {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
        long time = mRecyclerView.getNanoTime();
        assertNotEquals(0, time);
        assertNotEquals(time, mRecyclerView.getNanoTime());
    } else {
        assertEquals(0, mRecyclerView.getNanoTime());
    }
}"
"@Test
public void testInitFirstVerifyCallBacks() throws Exception {
    DefaultMetricsSystem.shutdown();
    new ConfigBuilder().add(""*.period"", 8).add(""test.sink.test.class"", TestSink.class.getName()).add(""test.*.source.filter.exclude"", ""s0"").add(""test.source.s1.metric.filter.exclude"", ""X*"").add(""test.sink.sink1.metric.filter.exclude"", ""Y*"").add(""test.sink.sink2.metric.filter.exclude"", ""Y*"").save(TestMetricsConfig.getTestFilename(""hadoop-metrics2-test""));
    MetricsSystemImpl ms = new MetricsSystemImpl(""Test"");
    ms.start();
    ms.register(""s0"", ""s0 desc"", new TestSource(""s0rec""));
    TestSource s1 = ms.register(""s1"", ""s1 desc"", new TestSource(""s1rec""));
    s1.c1.incr();
    s1.xxx.incr();
    s1.g1.set(2);
    s1.yyy.incr(2);
    s1.s1.add(0);
    MetricsSink sink1 = mock(MetricsSink.class);
    MetricsSink sink2 = mock(MetricsSink.class);
    ms.registerSink(""sink1"", ""sink1 desc"", sink1);
    ms.registerSink(""sink2"", ""sink2 desc"", sink2);
    ms.publishMetricsNow();
    try {
        verify(sink1, timeout(200).times(2)).putMetrics(r1.capture());
        verify(sink2, timeout(200).times(2)).putMetrics(r2.capture());
    } finally {
        ms.stop();
        ms.shutdown();
    }
    List<MetricsRecord> mr1 = r1.getAllValues();
    List<MetricsRecord> mr2 = r2.getAllValues();
    checkMetricsRecords(mr1);
    assertEquals(""output"", mr1, mr2);
}"
"@Test
public void testGettersAfterConnected() throws InterruptedException {
    prepareLooper();
    final int state = MediaPlayerBase.PLAYER_STATE_PLAYING;
    final long position = 150000;
    final long bufferedPosition = 900000;
    final float speed = 0.5f;
    mPlayer.mLastPlayerState = state;
    mPlayer.mCurrentPosition = position;
    mPlayer.mBufferedPosition = bufferedPosition;
    mPlayer.mPlaybackSpeed = speed;
    long time = System.currentTimeMillis();
    MediaController2 controller = createController(mSession.getToken());
    assertEquals(state, controller.getPlayerState());
    assertEquals(bufferedPosition, controller.getBufferedPosition());
    assertEquals(speed, controller.getPlaybackSpeed());
    long elapsedTime = System.currentTimeMillis() - time;
    final long tolerance = 10;
    assertEquals(position + speed * elapsedTime, controller.getCurrentPosition(), tolerance);
}"
"@Test public void test1_2() throws Exception {
    JSONObject json=new JSONObject();
    json.put(""id"",123);
    json.put(""name"",""哈哈哈"");
    ResultActions actions=mockMvc.perform((post(""/fastjson/test1?callback=fnUpdateSome"").characterEncoding(""UTF-8"").content(json.toJSONString()).contentType(MediaType.APPLICATION_JSON)));
    actions.andDo(print());
    actions.andExpect(status().isOk()).andExpect(content().contentType(APPLICATION_JAVASCRIPT));
    String content=actions.andReturn().getResponse().getContentAsString();
    assertTrue(content.equals(""/**/fnUpdateSome({\""name\"":\""哈哈哈\"",\""id\"":123})"") || content.equals(""/**/fnUpdateSome({\""id\"":123,\""name\"":\""哈哈哈\""})""));
}"
"@Test @SuppressWarnings(""unchecked"") public void iterableOfEnumeration(){
    Enumeration<Object> mockEnumeration=mock(Enumeration.class,""MockEnumeration"");
    when(mockEnumeration.hasMoreElements()).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(false);
    when(mockEnumeration.nextElement()).thenReturn(1).thenReturn(2).thenReturn(3).thenThrow(new NoSuchElementException(""Enumeration exhausted""));
    Iterable<Object> iterable=CollectionUtils.iterable(mockEnumeration);
    assertThat(iterable).isNotNull();
    LinkedHashSet<Object> set=StreamSupport.stream(iterable.spliterator(),false).collect(Collectors.toCollection(LinkedHashSet::new));
    assertThat(set).containsExactly(1,2,3);
    verify(mockEnumeration,times(4)).hasMoreElements();
    verify(mockEnumeration,times(3)).nextElement();
}"
"@Test public void mergesResultsFromMultipleChecks(){
    final Map<String,PluginMetadataSummary> result=new ViewRequirements(ImmutableSet.of(view -> Collections.singletonMap(""aioverlord"",plugin),view -> Collections.emptyMap(),view -> Collections.singletonMap(""parameters"",new EnterpriseMetadataSummary())),view);
    assertThat(result).containsOnly(Maps.immutableEntry(""aioverlord"",plugin),Maps.immutableEntry(""parameters"",new EnterpriseMetadataSummary()));
}"
"@Test public void wrapperChars() throws Exception {
    assertThat(testResult(WrapperChars.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperChars.iterations);
    assertEquals(new HashSet<>(asList('@','#')),new HashSet<>(WrapperChars.values.subList(0,2)));
    WrapperChars.iterations=0;
}"
"@Test
public void testFireObjectEvent() throws Exception {
    final NamingEventCoordinator coordinator = new NamingEventCoordinator();
    final CollectingListener objectListener = new CollectingListener(1);
    coordinator.addListener(""test/path"", EventContext.OBJECT_SCOPE, objectListener);
    final CollectingListener subtreeListener = new CollectingListener(0);
    coordinator.addListener(""test"", EventContext.SUBTREE_SCOPE, subtreeListener);
    final CollectingListener oneLevelListener = new CollectingListener(0);
    coordinator.addListener(""test"", EventContext.ONELEVEL_SCOPE, oneLevelListener);
    coordinator.fireEvent(context, new CompositeName(""test/path""), null, null, NamingEvent.OBJECT_ADDED, ""bind"", EventContext.OBJECT_SCOPE);
    objectListener.latch.await(1, TimeUnit.SECONDS);
    assertEquals(1, objectListener.capturedEvents.size());
    assertTrue(oneLevelListener.capturedEvents.isEmpty());
    assertTrue(subtreeListener.capturedEvents.isEmpty());
}"
"@Test
public void testPriorityReadOnlyCancelsReaders() throws Exception {
    Thread.interrupted();
    XtextDocument document = new XtextDocument(createTokenSource(), null, outdatedStateManager, operationCanceledManager);
    XtextResource resource = new XtextResource();
    new XtextResourceSet().getResources().add(resource);
    document.setInput(resource);
    CountDownLatch check = new CountDownLatch(1);
    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            document.readOnly(new CancelableUnitOfWork<Object, XtextResource>() {
                @Override
                public Object exec(XtextResource state, CancelIndicator cancelIndicator) throws Exception {
                    check.countDown();
                    int wait = 4000;
                    int i = 0;
                    while (!cancelIndicator.isCanceled()) {
                        Thread.sleep(10L);
                        if (i > wait) {
                            throw new InterruptedException();
                        }
                        i = i + 1;
                    }
                    return null;
                }
            });
        }
    };
    Thread thread = new Thread(runnable);
    thread.start();
    check.await();
    document.priorityReadOnly(( r) -> null);
    Assert.assertFalse(thread.isInterrupted());
}"
"@Test
public void test_parseLString() throws Exception {
    DateFormat format = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL, Locale.US);
    try {
        Date date = format.parse(format.format(current).toString());
        assertEquals(current.getDate(), date.getDate());
        assertEquals(current.getDay(), date.getDay());
        assertEquals(current.getMonth(), date.getMonth());
        assertEquals(current.getYear(), date.getYear());
        assertEquals(current.getHours(), date.getHours());
        assertEquals(current.getMinutes(), date.getMinutes());
    } catch(ParseException pe) {
    fail(""ParseException was thrown for current Date.""); }
    try {
        format.parse(""January 16, 1970 8:03:52 PM CET"");
        fail(""ParseException was not thrown."");
    } catch(ParseException pe) { }
}"
"@Test
public void test_multimap() throws Exception {
    Map<String, Integer> map = ImmutableMap.of(""a"", 1, ""b"", 1, ""c"", 2);
    SetMultimap<String, Integer> multimap = Multimaps.forMap(map);
    Multimap<Integer, String> inverse = Multimaps.invertFrom(multimap, HashMultimap.<Integer, String>create());
    String json = JSON.toJSONString(inverse);
    assertEquals(""{1:[\""a\"",\""b\""],2:[\""c\""]}"", json);
}"
"@Test public void primitiveDoubles() throws Exception {
    assertThat(testResult(PrimitiveDoubles.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveDoubles.iterations);
    assertEquals(new HashSet<>(asList(3.2,-4D)),new HashSet<>(PrimitiveDoubles.values.subList(0,2)));
    PrimitiveDoubles.iterations=0;
}"
"@Test public void orderingOfStatements(){
    assertThat(testResult(PropertyBasedTests.class),failureCountIs(1));
    assertEquals(expectedStatements,PropertyBasedTests.LOGS);
    PropertyBasedTests.clearLogs();
}"
"@Test
void canOffsetMutableClock() {
    final var offset = Duration.ofMinutes(10);
    final var response = endpoint.modify(""add"", null, offset.toMillis());
    final var offsetMinimum = Instant.now().plus(offset).truncatedTo(ChronoUnit.MILLIS);
    final var offsetMaximum = Instant.now().plus(offset.plus(Duration.ofMinutes(1)));
    assertThat(response.getStatus()).isEqualTo(200);
    assertThat(response.getBody()).isNotNull().asInstanceOf(instanceOfRecord).satisfies(( body) -> assertThat(body.instant).isBetween(offsetMinimum, offsetMaximum));
}"
"@Test public void manyParameters(){
    assertThat(testResult(ManyParameters.class),isSuccessful());
    assertEquals(16,ManyParameters.iterations);
    assertEquals(asList(-4,-2,-1),ManyParameters.firstTestCases.subList(0,3));
    assertEquals(asList(-4,-2,-1),ManyParameters.firstTestCases.subList(4,7));
    assertEquals(asList(-4,-2,-1),ManyParameters.firstTestCases.subList(8,11));
    assertEquals(asList(-4,-2,-1),ManyParameters.firstTestCases.subList(12,15));
    assertEquals(asList('r','r','r','r','y','y','y','y'),ManyParameters.secondTestCases.subList(0,8));
    ManyParameters.iterations=0;
}"
"@SuppressWarnings(""unchecked"") @Test public void testStandardUnionObjectInspector() throws Throwable {
    try {
        ArrayList<ObjectInspector> objectInspectors=new ArrayList<ObjectInspector>();
        objectInspectors.add(PrimitiveObjectInspectorFactory.javaIntObjectInspector);
        objectInspectors.add(PrimitiveObjectInspectorFactory.javaStringObjectInspector);
        objectInspectors.add(PrimitiveObjectInspectorFactory.javaBooleanObjectInspector);
        objectInspectors.add(ObjectInspectorFactory.getStandardListObjectInspector(PrimitiveObjectInspectorFactory.javaIntObjectInspector));
        objectInspectors.add(ObjectInspectorFactory.getStandardMapObjectInspector(PrimitiveObjectInspectorFactory.javaIntObjectInspector,PrimitiveObjectInspectorFactory.javaStringObjectInspector));
        List<String> fieldNames=new ArrayList<String>();
        fieldNames.add(""myDouble"");
        fieldNames.add(""myLong"");
        ArrayList<ObjectInspector> fieldObjectInspectors=new ArrayList<ObjectInspector>();
        fieldObjectInspectors.add(PrimitiveObjectInspectorFactory.javaDoubleObjectInspector);
        fieldObjectInspectors.add(PrimitiveObjectInspectorFactory.javaLongObjectInspector);
        objectInspectors.add(ObjectInspectorFactory.getStandardStructObjectInspector(fieldNames,fieldObjectInspectors));
        StandardUnionObjectInspector uoi1=ObjectInspectorFactory.getStandardUnionObjectInspector(objectInspectors);
        StandardUnionObjectInspector uoi2=ObjectInspectorFactory.getStandardUnionObjectInspector((ArrayList<ObjectInspector>)objectInspectors.clone());
        assertEquals(uoi1,uoi2);
        assertEquals(ObjectInspectorUtils.getObjectInspectorName(uoi1),ObjectInspectorUtils.getObjectInspectorName(uoi2));
        assertTrue(ObjectInspectorUtils.compareTypes(uoi1,uoi2));
        assertFalse(ObjectInspectorUtils.compareSupported(uoi1));
        ArrayList<ObjectInspector> ois=(ArrayList<ObjectInspector>)objectInspectors.clone();
        ois.set(4,PrimitiveObjectInspectorFactory.javaIntObjectInspector);
        assertTrue(ObjectInspectorUtils.compareSupported(ObjectInspectorFactory.getStandardUnionObjectInspector(ois)));
        assertEquals(Category.UNION,uoi1.getCategory());
        List<? extends ObjectInspector> uois=uoi1.getObjectInspectors();
        assertEquals(6,uois.size());
        for (int i=0; i < 6; i++) {
            assertEquals(objectInspectors.get(i),uois.get(i));
        }
        StringBuilder unionTypeName=new StringBuilder();
        unionTypeName.append(""uniontype<"");
        for (int i=0; i < uois.size(); i++) {
            if (i > 0) {
                unionTypeName.append("","");
            }
            unionTypeName.append(uois.get(i).getTypeName());
        }
        unionTypeName.append("">"");
        assertEquals(unionTypeName.toString(),uoi1.getTypeName());
        TypeInfo typeInfo1=TypeInfoUtils.getTypeInfoFromObjectInspector(uoi1);
        assertEquals(Category.UNION,typeInfo1.getCategory());
        assertEquals(UnionTypeInfo.class.getName(),typeInfo1.getClass().getName());
        assertEquals(typeInfo1.getTypeName(),uoi1.getTypeName());
        assertEquals(typeInfo1,TypeInfoUtils.getTypeInfoFromTypeString(uoi1.getTypeName()));
        TypeInfo typeInfo2=TypeInfoUtils.getTypeInfoFromObjectInspector(uoi2);
        assertEquals(typeInfo1,typeInfo2);
        assertEquals(TypeInfoUtils.getStandardJavaObjectInspectorFromTypeInfo(typeInfo1),TypeInfoUtils.getStandardJavaObjectInspectorFromTypeInfo(typeInfo2));
        assertEquals(TypeInfoUtils.getStandardWritableObjectInspectorFromTypeInfo(typeInfo1),TypeInfoUtils.getStandardWritableObjectInspectorFromTypeInfo(typeInfo2));
        assertNull(uoi1.getField(null));
        assertEquals(-1,uoi1.getTag(null));
        UnionObject union=new StandardUnion((byte)0,1);
        assertEquals(0,uoi1.getTag(union));
        assertEquals(1,uoi1.getField(union));
        assertEquals(""{0:1}"",SerDeUtils.getJSONString(union,uoi1));
        assertEquals(0,ObjectInspectorUtils.compare(union,uoi1,new StandardUnion((byte)0,1),uoi2));
        assertTrue(ObjectInspectorUtils.copyToStandardObject(union,uoi1).equals(1));
        union=new StandardUnion((byte)1,""two"");
        assertEquals(1,uoi1.getTag(union));
        assertEquals(""two"",uoi1.getField(union));
        assertEquals(""{1:\""two\""}"",SerDeUtils.getJSONString(union,uoi1));
        assertEquals(0,ObjectInspectorUtils.compare(union,uoi1,new StandardUnion((byte)1,""two""),uoi2));
        assertTrue(ObjectInspectorUtils.copyToStandardObject(union,uoi1).equals(""two""));
        union=new StandardUnion((byte)2,true);
        assertEquals(2,uoi1.getTag(union));
        assertEquals(true,uoi1.getField(union));
        assertEquals(""{2:true}"",SerDeUtils.getJSONString(union,uoi1));
        assertEquals(0,ObjectInspectorUtils.compare(union,uoi1,new StandardUnion((byte)2,true),uoi2));
        assertTrue(ObjectInspectorUtils.copyToStandardObject(union,uoi1).equals(true));
        ArrayList<Integer> iList=new ArrayList<Integer>();
        iList.add(4);
        iList.add(5);
        union=new StandardUnion((byte)3,iList);
        assertEquals(3,uoi1.getTag(union));
        assertEquals(iList,uoi1.getField(union));
        assertEquals(""{3:[4,5]}"",SerDeUtils.getJSONString(union,uoi1));
        assertEquals(0,ObjectInspectorUtils.compare(union,uoi1,new StandardUnion((byte)3,iList.clone()),uoi2));
        assertTrue(ObjectInspectorUtils.copyToStandardObject(union,uoi1).equals(iList));
        HashMap<Integer,String> map=new LinkedHashMap<Integer,String>();
        map.put(6,""six"");
        map.put(7,""seven"");
        map.put(8,""eight"");
        union=new StandardUnion((byte)4,map);
        assertEquals(4,uoi1.getTag(union));
        assertEquals(map,uoi1.getField(union));
        assertEquals(""{4:{6:\""six\"",7:\""seven\"",8:\""eight\""}}"",SerDeUtils.getJSONString(union,uoi1));
        Throwable th=null;
        try {
            ObjectInspectorUtils.compare(union,uoi1,new StandardUnion((byte)4,map.clone()),uoi2,null);
        }
        catch (    Throwable t) {
            th=t;
        }
        assertNotNull(th);
        assertEquals(""Compare on map type not supported!"",th.getMessage());
        assertTrue(ObjectInspectorUtils.copyToStandardObject(union,uoi1).equals(map));
        ArrayList<Object> struct=new ArrayList<Object>(2);
        struct.add(9.0);
        struct.add(10L);
        union=new StandardUnion((byte)5,struct);
        assertEquals(5,uoi1.getTag(union));
        assertEquals(struct,uoi1.getField(union));
        assertEquals(""{5:{\""mydouble\"":9.0,\""mylong\"":10}}"",SerDeUtils.getJSONString(union,uoi1));
        assertEquals(0,ObjectInspectorUtils.compare(union,uoi1,new StandardUnion((byte)5,struct.clone()),uoi2));
        assertTrue(ObjectInspectorUtils.copyToStandardObject(union,uoi1).equals(struct));
    }
    catch (  Throwable e) {
        e.printStackTrace();
        throw e;
    }
}"
"@Test
public void testEmptyByteArrayForEmptyInput() throws IOException {
    this.fstObjectInput = new FstObjectInput(new ByteArrayInputStream("""".getBytes()));
    byte[] bytes = fstObjectInput.readBytes();
    assertThat(bytes.length, is(0));
}"
"@Test
public void testAdditionalModelTypeAnnotationsSemiColon() throws Exception {
    OpenAPI openAPI = TestUtils.createOpenAPI();
    final AbstractJavaCodegen codegen = new P_AbstractJavaCodegen();
    codegen.additionalProperties().put(ADDITIONAL_MODEL_TYPE_ANNOTATIONS, ""@Foo;@Bar"");
    codegen.processOpts();
    codegen.preprocessOpenAPI(openAPI);
    final List<String> additionalModelTypeAnnotations = new ArrayList<String>();
    additionalModelTypeAnnotations.add(""@Foo"");
    additionalModelTypeAnnotations.add(""@Bar"");
    Assert.assertEquals(codegen.getAdditionalModelTypeAnnotations(), additionalModelTypeAnnotations);
}"
"@Test public void wrapperFloats() throws Exception {
    assertThat(testResult(WrapperFloats.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperFloats.iterations);
    WrapperFloats.iterations=0;
}"
"@Test public void strings() throws Exception {
    assertThat(testResult(Strings.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),Strings.iterations);
    Strings.iterations=0;
}"
"@Test
public void iterableOfIterator() {
    Iterator<Object> mockIterator = mock(Iterator.class, ""MockIterator"");
    when(mockIterator.hasNext()).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(false);
    when(mockIterator.next()).thenReturn(1).thenReturn(2).thenReturn(3).thenThrow(new NoSuchElementException(""Iterator exhausted""));
    Iterable<Object> iterable = CollectionUtils.iterable(mockIterator);
    assertThat(iterable).isNotNull();
    Set<Object> set = new HashSet<>();
    iterable.forEach(set::add);
    assertThat(set).hasSize(3);
    assertThat(set).containsExactly(1, 2, 3);
    verify(mockIterator, times(4)).hasNext();
    verify(mockIterator, times(3)).next();
}"
"@Test
public void testCloseReason() throws Exception {
    MessageEndpoint.reset();
    Session session = deployment.connectToServer(AnnotatedClientEndpoint.class, new URI(""ws://"" + DefaultServer.getHostAddress(""default"") + "":"" + DefaultServer.getHostPort(""default"") + ""/ws/chat/Bob""));
    Assert.assertEquals(""hi Bob (protocol=foo)"", AnnotatedClientEndpoint.message());
    session.close(new CloseReason(CloseReason.CloseCodes.VIOLATED_POLICY, ""Foo!""));
    Assert.assertEquals(""CLOSED"", AnnotatedClientEndpoint.message());
    CloseReason cr = MessageEndpoint.getReason();
    Assert.assertEquals(CloseReason.CloseCodes.VIOLATED_POLICY.getCode(), cr.getCloseCode().getCode());
    Assert.assertEquals(""Foo!"", cr.getReasonPhrase());
}"
"@Test public void primitiveIntegers() throws Exception {
    assertThat(testResult(PrimitiveIntegers.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveIntegers.iterations);
    assertEquals(new HashSet<>(asList(1,2,3)),new HashSet<>(PrimitiveIntegers.values.subList(0,3)));
    PrimitiveIntegers.iterations=0;
}"
"@Test
public void testRefactorXtextGrammarWithoutGeneratedClassifier() throws Exception {
    waitForBuild();
    final XtextEditor editor = openEditor(grammarFile);
    doRefactoring(editor);
    waitForReconciler(editor);
    waitForDisplay();
    waitForBuild();
    checkConsistenceOfGrammar(editor);
}"
"@Test
public void earlyUnstableStatusShouldReportPunStateAsRunningAndResultAsUnknown() throws Exception {
    WorkflowJob p = j.createProject(WorkflowJob.class, ""project"");
    URL resource = Resources.getResource(getClass(), ""earlyUnstableStatusShouldReportPunStateAsRunningAndResultAsUnknown.jenkinsfile"");
    String jenkinsFile = Resources.toString(resource, Charsets.UTF_8);
    p.setDefinition(new CpsFlowDefinition(jenkinsFile, true));
    p.save();
    Run r = p.scheduleBuild2(0).waitForStart();
    String url = ""/organizations/jenkins/pipelines/project/runs/"" + r.getId() + ""/"";
    Map m = request().get(url).build(Map.class);
    j.waitForMessage(""Running on master"", r);
    while (!""FINISHED"".equals(m.get(""state"").toString())) {
        Assert.assertEquals(""RUNNING"", m.get(""state""));
        Assert.assertEquals(""UNKNOWN"", m.get(""result""));
        Thread.sleep(1000);
        m = request().get(url).build(Map.class);
    }
    Assert.assertEquals(""FINISHED"", m.get(""state""));
    Assert.assertEquals(""UNSTABLE"", m.get(""result""));
}"
"@Test public void primitiveChars() throws Exception {
    assertThat(testResult(PrimitiveChars.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveChars.iterations);
    assertEquals(new HashSet<>(asList('Z','z')),new HashSet<>(PrimitiveChars.values.subList(0,2)));
    PrimitiveChars.iterations=0;
}"
"@Test
public void testPasswordHistory() throws Exception {
    assertTrue(""should be allowed to authenticate"", ums.authenticate(""testcred"", ""password""));
    Thread.sleep(10);
    ums.setPassword(""testcred"", ""password"", ""password1"");
    Thread.sleep(10);
    ums.setPassword(""testcred"", ""password1"", ""password2"");
    assertTrue(""should be allowed to authenticate"", ums.authenticate(""testcred"", ""password2""));
    try {
        Thread.sleep(10);
        ums.setPassword(""testcred"", ""password2"", ""password"");
        fail(""Should not be allowed to reuse a password from password history"");
    } catch (SecurityException sex) {
        assertTrue(SecurityException.PASSWORD_ALREADY_USED.equals(sex.getKeyedMessage()));
    }
    Thread.sleep(10);
    ums.setPassword(""testcred"", ""password2"", ""password3"");
    Thread.sleep(10);
    ums.setPassword(""testcred"", ""password3"", ""password4"");
    Thread.sleep(10);
    ums.setPassword(""testcred"", ""password4"", ""password"");
    assertTrue(""should be allowed to authenticate"", ums.authenticate(""testcred"", ""password""));
}"
"@Test
public void testFireAllEvent() throws Exception {
    final NamingEventCoordinator coordinator = new NamingEventCoordinator();
    final CollectingListener objectListener = new CollectingListener(1);
    coordinator.addListener(""test/path"", EventContext.OBJECT_SCOPE, objectListener);
    final CollectingListener subtreeListener = new CollectingListener(1);
    coordinator.addListener(""test"", EventContext.SUBTREE_SCOPE, subtreeListener);
    final CollectingListener oneLevelListener = new CollectingListener(1);
    coordinator.addListener(""test"", EventContext.ONELEVEL_SCOPE, oneLevelListener);
    coordinator.fireEvent(context, new CompositeName(""test/path""), null, null, NamingEvent.OBJECT_ADDED, ""bind"", EventContext.OBJECT_SCOPE, EventContext.ONELEVEL_SCOPE, EventContext.SUBTREE_SCOPE);
    objectListener.latch.await(1, TimeUnit.SECONDS);
    oneLevelListener.latch.await(1, TimeUnit.SECONDS);
    subtreeListener.latch.await(1, TimeUnit.SECONDS);
    assertEquals(1, objectListener.capturedEvents.size());
    assertEquals(1, subtreeListener.capturedEvents.size());
    assertEquals(1, oneLevelListener.capturedEvents.size());
}"
"@Test public void wrapperLongs() throws Exception {
    assertThat(testResult(WrapperLongs.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperLongs.iterations);
    assertEquals(new HashSet<>(asList(10L,11L,12L)),new HashSet<>(WrapperLongs.values.subList(0,3)));
    WrapperLongs.iterations=0;
}"
"@Test
public void testAutomaticStartStop() throws Exception {
    final TestRunnable task = new TestRunnable(500);
    e.execute(task);
    Thread thread = e.thread;
    assertThat(thread, is(not(nullValue())));
    assertThat(thread.isAlive(), is(true));
    Thread.sleep(1500);
    assertThat(thread.isAlive(), is(false));
    assertThat(task.ran.get(), is(true));
    task.ran.set(false);
    e.execute(task);
    assertThat(e.thread, not(sameInstance(thread)));
    thread = e.thread;
    Thread.sleep(1500);
    assertThat(thread.isAlive(), is(false));
    assertThat(task.ran.get(), is(true));
}"
"@Test
public void testSetName() throws Exception {
    Configuration conf = new Configuration();
    WritableName.setName(SimpleWritable.class, testName);
    Class<?> test = WritableName.getClass(testName, conf);
    assertTrue(test.equals(SimpleWritable.class));
}"
"@Test
public void testRITAssignmentManagerMetrics() throws Exception {
    final TableName TABLENAME = TableName.valueOf(name.getMethodName());
    final byte[] FAMILY = Bytes.toBytes(""family"");
    Table table = null;
    try {
        table = TEST_UTIL.createTable(TABLENAME, FAMILY);
        final byte[] row = Bytes.toBytes(""row"");
        final byte[] qualifier = Bytes.toBytes(""qualifier"");
        final byte[] value = Bytes.toBytes(""value"");
        Put put = new Put(row);
        put.addColumn(FAMILY, qualifier, value);
        table.put(put);
        Thread.sleep(msgInterval * 3);
        MetricsAssignmentManagerSource amSource =
        master.getAssignmentManager().getAssignmentManagerMetrics().getMetricsProcSource();
        metricsHelper.assertGauge(MetricsAssignmentManagerSource.RIT_COUNT_NAME, 0, amSource);
        metricsHelper.assertGauge(MetricsAssignmentManagerSource.RIT_COUNT_OVER_THRESHOLD_NAME, 0,
        amSource);
        ColumnFamilyDescriptor hcd = ColumnFamilyDescriptorBuilder.newBuilder(FAMILY).build();
        TableDescriptor htd = TableDescriptorBuilder.newBuilder(TABLENAME).addColumnFamily(hcd).
        addCoprocessorWithSpec(""hdfs:///foo.jar|com.foo.FooRegionObserver|1001|arg1=1,arg2=2"").
        build();
        try {
            TEST_UTIL.getAdmin().modifyTable(htd);
            fail(""Expected region failed to open"");
        } catch (IOException e) {
            LOG.info(""Expected exception"", e);
        }
        Thread.sleep(msgInterval * 3);
        metricsHelper.assertGauge(MetricsAssignmentManagerSource.RIT_COUNT_NAME, 2, amSource);
        metricsHelper.assertGauge(MetricsAssignmentManagerSource.RIT_COUNT_OVER_THRESHOLD_NAME, 2,
        amSource);
    } finally {
        if (table != null) {
            table.close();
        }
    }
}"
"public void test_for_issue() throws Exception {
    ParserConfig config=new ParserConfig();
    String json=""{\""k\"":1,\""v\"":\""A\""}"";
    {
        Map.Entry entry=JSON.parseObject(json,Map.Entry.class,config);
        Object key=entry.getKey();
        Object value=entry.getValue();
        assertTrue(key.equals(""v"") || key.equals(""k""));
        if (key.equals(""v"")) {
            assertEquals(""A"",value);
        }
        else {
            assertEquals(1,value);
        }
    }
    config.putDeserializer(Map.Entry.class,new ObjectDeserializer(){
        public <T>T deserialze(    DefaultJSONParser parser,    Type type,    Object fieldName){
            JSONObject object=parser.parseObject();
            Object k=object.get(""k"");
            Object v=object.get(""v"");
            return (T)Collections.singletonMap(k,v).entrySet().iterator().next();
        }
        public int getFastMatchToken(){
            return 0;
        }
    }
    );
    Map.Entry entry=JSON.parseObject(json,Map.Entry.class,config);
    assertEquals(1,entry.getKey());
    assertEquals(""A"",entry.getValue());
}"
"@Test public void ctorOnly(){
    assertThat(testResult(CtorOnly.class),isSuccessful());
    assertEquals(2,CtorOnly.iterations);
    assertEquals(new HashSet<>(asList(new CtorOnly.Target(""a""),new CtorOnly.Target(""b""))),CtorOnly.testCases);
    CtorOnly.iterations=0;
    CtorOnly.testCases.clear();
}"
"@Test
public void test_enum() {
    assertEquals(""\""K\"""", Json.toJson(K.K));
    String expected = ""{\n"" + ((""   \""name\"": \""t\"",\n"" + ""   \""index\"": 1\n"") + ""}"");
    assertEquals(expected, Json.toJson(TT.T));
    assertEquals(""\""T\"""", Json.toJson(TT.T, JsonFormat.full().ignoreJsonShape()));
}"
"@Test
public void testWrite() throws Exception {
    FileSystem fs = cluster.getFileSystem();
    long tStart = System.currentTimeMillis();
    bench.writeTest(fs);
    long execTime = System.currentTimeMillis() - tStart;
    bench.analyzeResult(fs, TestType.TEST_TYPE_WRITE, execTime);
}"
"@Test public void wrapperFloats() throws Exception {
    assertThat(testResult(WrapperFloats.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperFloats.iterations);
    assertEquals(new HashSet<>(asList(1.7F,-4.14F)),new HashSet<>(WrapperFloats.values.subList(0,2)));
    WrapperFloats.iterations=0;
}"
"@Test public void enums() throws Exception {
    assertThat(testResult(Enums.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),Enums.iterations);
    assertEquals(EnumSet.of(HALF_UP,HALF_EVEN),new HashSet<>(Enums.values.subList(0,2)));
    Enums.iterations=0;
}"
"@Test
public void testFlushThroughputTuning() throws Exception {
    Configuration conf = TEST_UTIL.getConfiguration();
    conf.set(StoreEngine.STORE_ENGINE_CLASS_KEY, DefaultStoreEngine.class.getName());
    conf.setLong(PressureAwareFlushThroughputController.HBASE_HSTORE_FLUSH_MAX_THROUGHPUT_UPPER_BOUND,20L * 1024 * 1024);
    conf.setLong(PressureAwareFlushThroughputController.HBASE_HSTORE_FLUSH_MAX_THROUGHPUT_LOWER_BOUND,10L * 1024 * 1024);
    conf.set(FlushThroughputControllerFactory.HBASE_FLUSH_THROUGHPUT_CONTROLLER_KEY,PressureAwareFlushThroughputController.class.getName());
    conf.setInt(PressureAwareFlushThroughputController.HBASE_HSTORE_FLUSH_THROUGHPUT_TUNE_PERIOD,3000);
    TEST_UTIL.startMiniCluster(1);
    Connection conn = ConnectionFactory.createConnection(conf);
    try {
        HTableDescriptor htd = new HTableDescriptor(tableName);
        htd.addFamily(new HColumnDescriptor(family));
        htd.setCompactionEnabled(false);
        TEST_UTIL.getHBaseAdmin().createTable(htd);
        TEST_UTIL.waitTableAvailable(tableName);
        HRegionServer regionServer = TEST_UTIL.getRSForFirstRegionInTable(tableName);
        PressureAwareFlushThroughputController throughputController = (PressureAwareFlushThroughputController) regionServer.getFlushThroughputController();
        for (Region region : regionServer.getOnlineRegions()) {
            region.flush(true);
        }
        assertEquals(0.0, regionServer.getFlushPressure(), EPSILON);
        Thread.sleep(5000);
        assertEquals(10L * 1024 * 1024, throughputController.getMaxThroughput(), EPSILON);
        Table table = conn.getTable(tableName);
        Random rand = new Random();
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                byte[] value = new byte[256 * 1024];
                rand.nextBytes(value);
                table.put(new Put(Bytes.toBytes(i * 10 + j)).addColumn(family, qualifier, value));
            }
        }
        Thread.sleep(5000);
        double expectedThroughPut = 10L * 1024 * 1024 * (1 + regionServer.getFlushPressure());
        assertEquals(expectedThroughPut, throughputController.getMaxThroughput(), EPSILON);
        conf.set(FlushThroughputControllerFactory.HBASE_FLUSH_THROUGHPUT_CONTROLLER_KEY,NoLimitThroughputController.class.getName());
        regionServer.onConfigurationChange(conf);
        assertTrue(throughputController.isStopped());
        assertTrue(regionServer.getFlushThroughputController() instanceof NoLimitThroughputController);
    } finally {
        conn.close();
        TEST_UTIL.shutdownMiniCluster();
    }"
"@Test
public void testMaxLimits() throws Exception {
    LocalConnFactory connFactory = Mockito.mock(LocalConnFactory.class);
    HttpConnection conn1 = Mockito.mock(HttpConnection.class);
    Mockito.when(connFactory.create(Mockito.eq(""somehost""))).thenReturn(conn1);
    HttpConnection conn2 = Mockito.mock(HttpConnection.class);
    Mockito.when(connFactory.create(Mockito.eq(""otherhost""))).thenReturn(conn2);
    LocalConnPool pool = new LocalConnPool(connFactory, 2, 10);
    pool.setMaxPerRoute(""somehost"", 2);
    pool.setMaxPerRoute(""otherhost"", 1);
    pool.setMaxTotal(3);
    Future<LocalPoolEntry> future1 = pool.lease(""somehost"", null);
    GetPoolEntryThread t1 = new GetPoolEntryThread(future1);
    t1.start();
    Future<LocalPoolEntry> future2 = pool.lease(""somehost"", null);
    GetPoolEntryThread t2 = new GetPoolEntryThread(future2);
    t2.start();
    Future<LocalPoolEntry> future3 = pool.lease(""otherhost"", null);
    GetPoolEntryThread t3 = new GetPoolEntryThread(future3);
    t3.start();
    t1.join(GRACE_PERIOD);
    Assert.assertTrue(future1.isDone());
    LocalPoolEntry entry1 = t1.getEntry();
    Assert.assertNotNull(entry1);
    t2.join(GRACE_PERIOD);
    Assert.assertTrue(future2.isDone());
    LocalPoolEntry entry2 = t2.getEntry();
    Assert.assertNotNull(entry2);
    t3.join(GRACE_PERIOD);
    Assert.assertTrue(future3.isDone());
    LocalPoolEntry entry3 = t3.getEntry();
    Assert.assertNotNull(entry3);
    pool.release(entry1, true);
    pool.release(entry2, true);
    pool.release(entry3, true);
    PoolStats totals = pool.getTotalStats();
    Assert.assertEquals(3, totals.getAvailable());
    Assert.assertEquals(0, totals.getLeased());
    Future<LocalPoolEntry> future4 = pool.lease(""somehost"", null);
    GetPoolEntryThread t4 = new GetPoolEntryThread(future4);
    t4.start();
    Future<LocalPoolEntry> future5 = pool.lease(""somehost"", null);
    GetPoolEntryThread t5 = new GetPoolEntryThread(future5);
    t5.start();
    Future<LocalPoolEntry> future6 = pool.lease(""otherhost"", null);
    GetPoolEntryThread t6 = new GetPoolEntryThread(future6);
    t6.start();
    t4.join(GRACE_PERIOD);
    Assert.assertTrue(future4.isDone());
    LocalPoolEntry entry4 = t4.getEntry();
    Assert.assertNotNull(entry4);
    t5.join(GRACE_PERIOD);
    Assert.assertTrue(future5.isDone());
    LocalPoolEntry entry5 = t5.getEntry();
    Assert.assertNotNull(entry5);
    t6.join(GRACE_PERIOD);
    Assert.assertTrue(future6.isDone());
    LocalPoolEntry entry6 = t6.getEntry();
    Assert.assertNotNull(entry6);
    Future<LocalPoolEntry> future7 = pool.lease(""somehost"", null);
    GetPoolEntryThread t7 = new GetPoolEntryThread(future7);
    t7.start();
    Future<LocalPoolEntry> future8 = pool.lease(""somehost"", null);
    GetPoolEntryThread t8 = new GetPoolEntryThread(future8);
    t8.start();
    Future<LocalPoolEntry> future9 = pool.lease(""otherhost"", null);
    GetPoolEntryThread t9 = new GetPoolEntryThread(future9);
    t9.start();
    Assert.assertFalse(t7.isDone());
    Assert.assertFalse(t8.isDone());
    Assert.assertFalse(t9.isDone());
    Mockito.verify(connFactory, Mockito.times(3)).create(Mockito.any(String.class));
    pool.release(entry4, true);
    pool.release(entry5, false);
    pool.release(entry6, true);
    t7.join();
    Assert.assertTrue(future7.isDone());
    t8.join();
    Assert.assertTrue(future8.isDone());
    t9.join();
    Assert.assertTrue(future9.isDone());
    Mockito.verify(connFactory, Mockito.times(4)).create(Mockito.any(String.class));
}"
"@Test public void favorValueOf() throws Exception {
    assertThat(testResult(FavorValueOf.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),FavorValueOf.iterations);
    assertEquals(new HashSet<>(asList(FavorValueOf.Target.valueOf(""a""),FavorValueOf.Target.valueOf(""b""))),new HashSet<>(FavorValueOf.values.subList(0,2)));
    FavorValueOf.iterations=0;
}"
"@Test public void serializeParameter() throws IOException {
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.createParameter(""Test"")),""{\""@type\"":\""parameter\"",\""@value\"":\""Test\""}"");
}"
"public void testForIssue2(){
    String jsonString=""{\""map\"":{\""a\"":[\""1\"",\""2\"",\""3\""],\""b\"":[\""1\""]},\""name\"":\""zhangsan\""}"";
    VO vo=JSON.parseObject(jsonString,VO.class);
    assertEquals(""VO:{name->zhangsan,map->{a=[1, 2, 3], b=[1]}}"",JSON.toJSONString(vo,SerializerFeature.MapSortField));
}"
"@Test public void test_create() throws Exception {
    String sql=""CREATE RESOURCE GROUP sql_thread TYPE = USER VCPU = 1,3 THREAD_PRIORITY = -20"";
    List<SQLStatement> stmtList=SQLUtils.toStatementList(sql,JdbcConstants.HIVE);
    SQLStatement stmt=stmtList.get(0);
    MySqlSchemaStatVisitor visitor=new MySqlSchemaStatVisitor();
    stmt.accept(visitor);
    String output=SQLUtils.toMySqlString(stmt);
    Set<String> allPossibleRes=generateAllPossibleRes(""CREATE RESOURCE GROUP sql_thread "");
    assertTrue(allPossibleRes.contains(output));
}"
"@Test public void testToString() throws Exception {
    PMML model=buildDummyModel();
    model.getHeader().setTimestamp(null);
    assertThat(PMMLUtils.toString(model),anyOf(is(""<?xml version=\""1.0\"" encoding=\""UTF-8\"" standalone=\""yes\""?>"" + ""<PMML version=\""4.3\"" xmlns=\""http://www.dmg.org/PMML-4_3\"" "" + ""xmlns:data=\""http://jpmml.org/jpmml-model/InlineTable\"">""+ ""<Header>""+ ""<Application name=\""Oryx\""/>""+ ""</Header>""+ ""<TreeModel functionName=\""classification\"">""+ ""<Node recordCount=\""123.0\""/>""+ ""</TreeModel>""+ ""</PMML>""),is(""<?xml version=\""1.0\"" encoding=\""UTF-8\"" standalone=\""yes\""?>"" + ""<PMML version=\""4.3\"" xmlns:data=\""http://jpmml.org/jpmml-model/InlineTable\"" "" + ""xmlns=\""http://www.dmg.org/PMML-4_3\"">""+ ""<Header>""+ ""<Application name=\""Oryx\""/>""+ ""</Header>""+ ""<TreeModel functionName=\""classification\"">""+ ""<Node recordCount=\""123.0\""/>""+ ""</TreeModel>""+ ""</PMML>"")));
}"
"@Test
void logWithExtras() {
    Instant start = Instant.now();
    List<LogData> logDataList = logExporter.getFinishedLogItems();
    assertThat(logDataList).hasSize(1);
    LogData logData = logDataList.get(0);
    assertThat(logData.getResource()).isEqualTo(resource);
    assertThat(logData.getInstrumentationLibraryInfo()).isEqualTo(instrumentationLibraryInfo);
    assertThat(logData.getBody().asString()).isEqualTo(""log message 1"");
    assertThat(logData.getEpochNanos()).isGreaterThanOrEqualTo(TimeUnit.MILLISECONDS.toNanos(start.toEpochMilli())).isLessThanOrEqualTo(TimeUnit.MILLISECONDS.toNanos(Instant.now().toEpochMilli()));
    assertThat(logData.getSeverity()).isEqualTo(INFO);
    assertThat(logData.getSeverityText()).isEqualTo(""INFO"");
    assertThat(logData.getAttributes().size()).isEqualTo(3);
    assertThat(logData.getAttributes().get(EXCEPTION_TYPE)).isEqualTo(IllegalStateException.class.getName());
    assertThat(logData.getAttributes().get(EXCEPTION_MESSAGE)).isEqualTo(""Error!"");
    assertThat(logData.getAttributes().get(EXCEPTION_STACKTRACE)).contains(""logWithExtras"");
}"
"@Test public void serializeBoolean() throws IOException {
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of(true)),""{\""@type\"":\""boolean\"",\""@value\"":true}"");
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of(false)),""{\""@type\"":\""boolean\"",\""@value\"":false}"");
}"
"@Test public void test_create2() throws Exception {
    String sql=""CREATE RESOURCE GROUP sql_thread TYPE = USER VCPU = 1,3 THREAD_PRIORITY = -20 disable"";
    List<SQLStatement> stmtList=SQLUtils.toStatementList(sql,JdbcConstants.MYSQL);
    SQLStatement stmt=stmtList.get(0);
    MySqlSchemaStatVisitor visitor=new MySqlSchemaStatVisitor();
    stmt.accept(visitor);
    String output=SQLUtils.toMySqlString(stmt);
    Set<String> allPossibleRes=generateAllPossibleRes(""CREATE RESOURCE GROUP sql_thread "","" DISABLE"");
    assertTrue(allPossibleRes.contains(output));
}"
"@Test public void testGetAllMetaAnnotations(){
    List<Annotation> metaAnnotations=getAllMetaAnnotations(Service5.class);
    int offset=0;
    HashSet<Object> set1=new HashSet<>();
    metaAnnotations.forEach(t -> set1.add(t.annotationType()));
    HashSet<Object> set2=new HashSet<>();
    set2.add(Inherited.class);
    set2.add(DubboService.class);
    set2.add(Service4.class);
    set2.add(Service3.class);
    set2.add(Service2.class);
    assertEquals(9,metaAnnotations.size());
    assertEquals(set1,set2);
    metaAnnotations=getAllMetaAnnotations(MyAdaptive.class);
    HashSet<Object> set3=new HashSet<>();
    metaAnnotations.forEach(t -> set3.add(t.annotationType()));
    HashSet<Object> set4=new HashSet<>();
    metaAnnotations.forEach(t -> set3.add(t.annotationType()));
    set4.add(Inherited.class);
    set4.add(Adaptive.class);
    assertEquals(2,metaAnnotations.size());
    assertEquals(set3,set4);
}"
"@Test
public void legalToExecuteTwiceCloning_Async() throws Exception {
    server.enqueue(new MockResponse().setBody(""abc""));
    server.enqueue(new MockResponse().setBody(""def""));
    Request request = new Request.Builder().url(server.url(""/"")).build();
    Call call = client.newCall(request);
    call.enqueue(callback);
    Call cloned = call.clone();
    cloned.enqueue(callback);
    callback.await(request.url()).assertBody(""abc"");
    callback.await(request.url()).assertBody(""def"");
}"
"public void test_for_multimap() throws Exception {
    ArrayListMultimap<String,Integer> multimap=ArrayListMultimap.create();
    multimap.putAll(""b"",Ints.asList(2,4,6));
    multimap.putAll(""a"",Ints.asList(4,2,1));
    multimap.putAll(""c"",Ints.asList(2,5,3));
    String json=JSON.toJSONString(multimap,SerializerFeature.MapSortField);
    assertEquals(""{\""a\"":[4,2,1],\""b\"":[2,4,6],\""c\"":[2,5,3]}"",json);
    TreeMultimap treeMultimap=TreeMultimap.create(multimap);
    String json2=JSON.toJSONString(treeMultimap);
    assertEquals(""{\""a\"":[1,2,4],\""b\"":[2,4,6],\""c\"":[2,3,5]}"",json2);
}"
"@Test
public void testRemoveFirstConsumer() throws Exception {
    this.conf.setSubscriptionKeySharedEnable(true);
    String topic = ""testReadAheadWhenAddingConsumers-"" + UUID.randomUUID();
    @Cleanup
    Producer<Integer> producer = createProducer(topic, false);
    @Cleanup
    Consumer<Integer> c1 = pulsarClient.newConsumer(INT32).topic(topic).subscriptionName(""key_shared"").subscriptionType(Key_Shared).receiverQueueSize(10).consumerName(""c1"").subscribe();
    for (int i = 0; i < 10; i++) {
        producer.newMessage().key(String.valueOf(random.nextInt(NUMBER_OF_KEYS))).value(i).send();
    }
    @Cleanup
    Consumer<Integer> c2 = pulsarClient.newConsumer(INT32).topic(topic).subscriptionName(""key_shared"").subscriptionType(Key_Shared).receiverQueueSize(10).consumerName(""c2"").subscribe();
    for (int i = 10; i < 20; i++) {
        producer.newMessage().key(String.valueOf(random.nextInt(NUMBER_OF_KEYS))).value(i).send();
    }
    assertNull(c2.receive(100, TimeUnit.MILLISECONDS));
    c1.close();
    for (int i = 0; i < 20; i++) {
        Message<Integer> msg = c2.receive();
        assertEquals(msg.getValue().intValue(), i);
        c2.acknowledge(msg);
    }
}"
"@Test public void favorValueOf() throws Exception {
    assertThat(testResult(FavorValueOf.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),FavorValueOf.iterations);
    FavorValueOf.iterations=0;
}"
"@Test public void wrapperChars() throws Exception {
    assertThat(testResult(WrapperChars.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperChars.iterations);
    WrapperChars.iterations=0;
}"
"@Test
public void testLookup() throws Exception {
    final Name name = new CompositeName(""test"");
    final Object object = new Object();
    namingStore.bind(name, object);
    Object result = namingContext.lookup(name);
    assertEquals(object, result);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, ""test"");
    assertEquals(object, result);
}"
"@Test
public void CustomDataParametersTest() {
    APIContext context = new APIContext(""ACCESS_TOKEN"").enableDebug(true);
    UserData userData = new UserData().email(""abc@eg.com"");
    HashMap<String, String> customProperties = new HashMap<String, String>();
    customProperties.put(""Key1"", ""Value1"");
    customProperties.put(""Key2"", ""Value2"");
    List<Content> contents = new ArrayList<Content>();
    contents.add(new Content().productId(""1"").brand(""brandA""));
    contents.add(new Content().productId(""2"").brand(""brandB""));
    List<String> contentIds = new ArrayList<String>();
    contentIds.add(""123"");
    contentIds.add(""456"");
    String contentCategory = ""content_categoryA"";
    String contentName = ""content_nameA"";
    String currency = ""USD"";
    CustomData customData = new CustomData().contentIds(contentIds).customProperties(customProperties).contents(contents).contentCategory(contentCategory).contentName(contentName).currency(currency).deliveryCategory(curbside).value(123.45F);
    Event testEvent = new Event();
    testEvent.eventName(""Purchase"").eventTime(System.currentTimeMillis() / 1000L).userData(userData).dataProcessingOptions(new String[]{  }).customData(customData);
    EventRequest eventRequest = new EventRequest(""123"", context);
    eventRequest.addDataItem(testEvent);
    String serializedPayload = eventRequest.getSerializedPayload();
    String cpString = new Gson().toJson(customProperties);
    String serializedContents = new Gson().toJson(contents);
    String serializedContentIds = new Gson().toJson(contentIds);
    Assert.assertTrue(serializedPayload.contains(cpString.substring(1, cpString.length() - 1)));
    Assert.assertTrue(serializedPayload.contains(serializedContents));
    Assert.assertTrue(serializedPayload.contains(serializedContentIds));
    Assert.assertTrue(serializedPayload.contains(currency.toLowerCase()));
    Assert.assertTrue(serializedPayload.contains(contentCategory));
    Assert.assertTrue(serializedPayload.contains(contentName));
    Assert.assertTrue(serializedPayload.contains(curbside.toString()));
}"
"@Test
public void healthCheckTest() throws Exception {
    RssGetShuffleAssignmentsRequest request = new RssGetShuffleAssignmentsRequest(""1"", 1, 1, 1, 1, Sets.newHashSet(SHUFFLE_SERVER_VERSION));
    Uninterruptibles.sleepUninterruptibly(3, TimeUnit.SECONDS);
    assertEquals(2, coordinatorClient.getShuffleServerList().getServersCount());
    List<ServerNode> nodes = coordinators.get(0).getClusterManager().getServerList(Sets.newHashSet(SHUFFLE_SERVER_VERSION));
    assertEquals(2, coordinatorClient.getShuffleServerList().getServersCount());
    assertEquals(2, nodes.size());
    RssGetShuffleAssignmentsResponse response = coordinatorClient.getShuffleAssignments(request);
    assertFalse(response.getPartitionToServers().isEmpty());
    for (ServerNode node : nodes) {
        assertTrue(node.isHealthy());
    }
    byte[] bytes = new byte[writeDataSize];
    new Random().nextBytes(bytes);
    try (final FileOutputStream out = new FileOutputStream(tempDataFile)) {
        out.write(bytes);
    }
    Uninterruptibles.sleepUninterruptibly(3, TimeUnit.SECONDS);
    CoordinatorTestUtils.waitForRegister(coordinatorClient, 2);
    nodes = coordinators.get(0).getClusterManager().getServerList(Sets.newHashSet(SHUFFLE_SERVER_VERSION));
    for (ServerNode node : nodes) {
        assertFalse(node.isHealthy());
    }
    assertEquals(0, nodes.size());
    response = coordinatorClient.getShuffleAssignments(request);
    assertEquals(INTERNAL_ERROR, response.getStatusCode());
    tempDataFile.delete();
    int i = 0;
    do {
        Uninterruptibles.sleepUninterruptibly(3, TimeUnit.SECONDS);
        nodes = coordinators.get(0).getClusterManager().getServerList(Sets.newHashSet(SHUFFLE_SERVER_VERSION));
        i++;
        if (i == 10) {
            fail();
        }
    } while (nodes.size() != 2 );
    for (ServerNode node : nodes) {
        assertTrue(node.isHealthy());
    }
    assertEquals(2, nodes.size());
    response = coordinatorClient.getShuffleAssignments(request);
    assertFalse(response.getPartitionToServers().isEmpty());
}"
"@Test public void wrapperChars(){
    assertThat(testResult(WrapperChars.class),isSuccessful());
    assertEquals(23,WrapperChars.iterations);
    assertEquals(new HashSet<>(asList('@','#')),new HashSet<>(WrapperChars.values.subList(0,2)));
    WrapperChars.iterations=0;
}"
"@Test
public void testShortCircuited() {
    HystrixCommandKey key = Factory.asKey(""CMD-Health-G"");
    stream = HealthCountsStream.getInstance(key, 10, 100);
    final CountDownLatch latch = new CountDownLatch(1);
    stream.observe().take(10).subscribe(getSubscriber(latch));
    CommandStreamTest.Command failure1 = Command.from(groupKey, key, FAILURE, 20);
    CommandStreamTest.Command failure2 = Command.from(groupKey, key, FAILURE, 20);
    CommandStreamTest.Command failure3 = Command.from(groupKey, key, FAILURE, 20);
    CommandStreamTest.Command shortCircuit1 = Command.from(groupKey, key, SUCCESS);
    CommandStreamTest.Command shortCircuit2 = Command.from(groupKey, key, SUCCESS);
    failure1.observe();
    failure2.observe();
    failure3.observe();
    try {
        Thread.sleep(100);
    } catch (InterruptedException ie) {
        fail(ie.getMessage());
    }
    shortCircuit1.observe();
    shortCircuit2.observe();
    try {
        assertTrue(latch.await(10000, TimeUnit.MILLISECONDS));
    } catch (InterruptedException ex) {
        fail(""Interrupted ex"");
    }
    assertTrue(shortCircuit1.isResponseShortCircuited());
    assertTrue(shortCircuit2.isResponseShortCircuited());
    System.out.println(""ReqLog : "" + HystrixRequestLog.getCurrentRequest().getExecutedCommandsAsString());
    assertEquals(3L, stream.getLatest().getErrorCount());
    assertEquals(3L, stream.getLatest().getTotalRequests());
}"
"/**
* Test destory registry, exporter can be normal by destroyed
*/
@Test public void testDestoryRegistry(){
    URL newRegistryUrl=registryUrl.addParameter(Constants.EXPORT_KEY,serviceUrl);
    Invoker<RegistryProtocolTest> invoker=new MockInvoker<RegistryProtocolTest>(RegistryProtocolTest.class,newRegistryUrl);
    Exporter<?> exporter=protocol.export(invoker);
    destroyRegistryProtocol();
    try {
        Thread.sleep(ConfigurationUtils.getServerShutdownTimeout() + 100);
    }
    catch (  InterruptedException e) {
        e.printStackTrace();
    }
    assertEquals(false,exporter.getInvoker().isAvailable());
}"
"@Test
public void testMultiReaderIsAbleToSeekWithTimeOnMiddleOfTopic() throws Exception {
    final String topicName = ""persistent"";
    final int numOfMessage = 10;
    final int halfMessages = numOfMessage / 2;
    admin.topics().createPartitionedTopic(topicName, 3);
    Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName).create();
    long l = System.currentTimeMillis();
    for (int i = 0; i < numOfMessage; i++) {
        producer.send(String.format(""msg num %d"", i).getBytes());
    }
    Reader<byte[]> reader = pulsarClient.newReader().topic(topicName).startMessageId(earliest).create();
    int plusTime = (halfMessages + 1) * 100;
    reader.seek(l + plusTime);
    Set<String> messageSet = Sets.newHashSet();
    for (int i = halfMessages + 1; i < numOfMessage; i++) {
        Message<byte[]> message = reader.readNext();
        String receivedMessage = new String(message.getData());
        Assert.assertTrue(messageSet.add(receivedMessage), ""Received duplicate message "" + receivedMessage);
    }
    reader.close();
    producer.close();
}"
"@Test
public void testSessionCreated() throws Exception {
    final Semaphore semaphore = new Semaphore(0);
    final StringBuffer stringBuffer = new StringBuffer();
    VmPipeAcceptor vmPipeAcceptor = new VmPipeAcceptor();
    final VmPipeAddress vmPipeAddress = new VmPipeAddress(12345);
    vmPipeAcceptor.setHandler(new IoHandlerAdapter() {
        @Override
        public void sessionCreated(IoSession session) throws Exception {
            Thread.sleep(1000);
            stringBuffer.append(""A"");
        }
        @Override
        public void sessionOpened(IoSession session) throws Exception {
            stringBuffer.append(""B"");
        }
        @Override
        public void messageReceived(IoSession session, Object message) throws Exception {
            stringBuffer.append(""C"");
        }
        @Override
        public void sessionClosed(IoSession session) throws Exception {
            stringBuffer.append(""D"");
            semaphore.release();
        }
    });
    vmPipeAcceptor.bind(vmPipeAddress);
    final VmPipeConnector vmPipeConnector = new VmPipeConnector();
    vmPipeConnector.getFilterChain().addLast(""executor"", new ExecutorFilter());
    vmPipeConnector.setHandler(new IoHandlerAdapter() {
        @Override
        public void sessionOpened(IoSession session) throws Exception {
            session.write(IoBuffer.wrap(new byte[1]));
        }
    });
    ConnectFuture connectFuture = vmPipeConnector.connect(vmPipeAddress);
    connectFuture.awaitUninterruptibly();
    connectFuture.getSession().close();
    semaphore.tryAcquire(1, TimeUnit.SECONDS);
    vmPipeAcceptor.unbind(vmPipeAddress);
    Assert.assertEquals(""ABCD"", stringBuffer.toString());
}"
"@Test public void test2_2() throws Exception {
    String jsonStr=""[{\""name\"":\""p1\"",\""sonList\"":[{\""name\"":\""s1\""}]},{\""name\"":\""p2\"",\""sonList\"":[{\""name\"":\""s2\""},{\""name\"":\""s3\""}]}]"";
    ResultActions actions=mockMvc.perform((post(""/fastjson/test2?jsonp=fnUpdateSome"").characterEncoding(""UTF-8"").content(jsonStr).contentType(MediaType.APPLICATION_JSON)));
    actions.andDo(print());
    actions.andExpect(status().isOk()).andExpect(content().contentType(APPLICATION_JAVASCRIPT));
    String content=actions.andReturn().getResponse().getContentAsString();
    assertTrue(content.equals(""/**/fnUpdateSome({\""p1\"":1,\""p2\"":2})"") || content.equals(""/**/fnUpdateSome({\""p2\"":2,\""p1\"":1})""));
}"
"@Test public void enums(){
    assertThat(testResult(Enums.class),isSuccessful());
    assertEquals(2,Enums.iterations);
    assertEquals(EnumSet.of(HALF_UP,HALF_EVEN),Enums.testCases);
    Enums.iterations=0;
}"
"@Test
public void testRemoveSuperColumn() throws IOException, ExecutionException, InterruptedException {
    Table table = Table.open(""Table1"");
    ColumnFamilyStore store = table.getColumnFamilyStore(""Super1"");
    RowMutation rm;
    rm = new RowMutation(""Table1"", ""key1"");
    rm.add(""Super1:SC1:Column1"", ""asdf"".getBytes(), 0);
    rm.apply();
    store.forceBlockingFlush();
    rm = new RowMutation(""Table1"", ""key1"");
    rm.delete(""Super1:SC1"", 1);
    rm.apply();
    List<ColumnFamily> families = store.getColumnFamilies(""key1"", ""Super1"", new IdentityFilter());
    assert families.get(0).getAllColumns().first().getMarkedForDeleteAt() == 1;
    assert !families.get(1).getAllColumns().first().isMarkedForDelete();
    ColumnFamily resolved = ColumnFamily.resolve(families);
    assert resolved.getAllColumns().first().getMarkedForDeleteAt() == 1;
    Collection<IColumn> subColumns = resolved.getAllColumns().first().getSubColumns();
    assert subColumns.size() == 1;
    assert subColumns.iterator().next().timestamp() == 0;
    assertNull(ColumnFamilyStore.removeDeleted(resolved, Integer.MAX_VALUE));
}"
"public void test_for_issue() throws Exception {
    HashSet<Map.Entry<String,Map.Entry<String,String>>> nestedSet=new HashSet<Map.Entry<String,Map.Entry<String,String>>>();
    nestedSet.add(new AbstractMap.SimpleEntry<String,Map.Entry<String,String>>(""a"",new AbstractMap.SimpleEntry<String,String>(""b"",""c"")));
    nestedSet.add(new AbstractMap.SimpleEntry<String,Map.Entry<String,String>>(""d"",new AbstractMap.SimpleEntry<String,String>(""e"",""f"")));
    String content=JSON.toJSONString(nestedSet);
    HashSet<Map.Entry<String,Map.Entry<String,String>>> deserializedNestedSet;
    Type type=new TypeReference<HashSet<Map.Entry<String,Map.Entry<String,String>>>>(){
    }
    .getType();
    deserializedNestedSet=JSON.parseObject(content,type);
    assertEquals(nestedSet,deserializedNestedSet);
}"
"@Test
public void testGetContextTypeLoader() throws Exception {
    SchemaTypeLoader stl = XmlBeans.getContextTypeLoader();
    if (stl == null) {
        fail(""getContextTypeLoader failed"");
    }
    Vector vThreads = new Vector();
    Set STLset = Collections.synchronizedSortedSet(new TreeSet());
    for (int i = 0; i < 10; i++) {
        Thread t = new BogusThread(STLset);
        vThreads.add(t);
        t.start();
    }
    for (int i = 0; i < 10; i++) {
        ((BogusThread) (vThreads.elementAt(i))).join();
    }
    assertEquals(10, STLset.size());
}"
"@Test
public void testContinuousScheduling() throws Exception {
    FairScheduler fs = new FairScheduler();
    Configuration conf = createConfiguration();
    conf.setBoolean(CONTINUOUS_SCHEDULING_ENABLED, true);
    fs.reinitialize(conf, resourceManager.getRMContext());
    Assert.assertTrue(""Continuous scheduling should be enabled."", fs.isContinuousSchedulingEnabled());
    RMNode node1 = MockNodes.newNodeInfo(1, Resources.createResource(8 * 1024, 8), 1, ""127.0.0.1"");
    NodeAddedSchedulerEvent nodeEvent1 = new NodeAddedSchedulerEvent(node1);
    fs.handle(nodeEvent1);
    Assert.assertEquals(fs.getClusterCapacity().getMemory(), 8 * 1024);
    Assert.assertEquals(fs.getClusterCapacity().getVirtualCores(), 8);
    ApplicationAttemptId appAttemptId = createAppAttemptId(this.APP_ID++, this.ATTEMPT_ID++);
    fs.addApplication(appAttemptId, ""queue11"", ""user11"");
    List<ResourceRequest> ask = new ArrayList<ResourceRequest>();
    ResourceRequest request = createResourceRequest(1024, 1, ANY, 1, 1, true);
    ask.add(request);
    fs.allocate(appAttemptId, ask, new ArrayList<ContainerId>(), null, null);
    Thread.sleep(fs.getConf().getContinuousSchedulingSleepMs() + 500);
    Resource consumption = fs.applications.get(appAttemptId).getCurrentConsumption();
    Assert.assertEquals(1024, consumption.getMemory());
    Assert.assertEquals(1, consumption.getVirtualCores());
}"
"@Test
public void testListTaskWithCriteria() throws Exception {
    requireDockerApiVersionAtLeast(""1.24"", ""swarm support"");
    final ServiceSpec spec = createServiceSpec(randomName());
    assertThat(sut.listTasks().size(), is(0));
    sut.createService(spec);
    await().until(numberOfTasks(sut), is(greaterThan(0)));
    final Task task = sut.listTasks().get(1);
    final List<Task> tasksWithId = sut.listTasks(Task.find().taskId(task.id()).build());
    assertThat(tasksWithId.size(), is(1));
    assertThat(tasksWithId.get(0), equalTo(task));
    final List<Task> tasksWithServiceName = sut.listTasks(Task.find().serviceName(spec.name()).build());
    assertThat(tasksWithServiceName.size(), is(greaterThanOrEqualTo(1)));
    final Set<String> taskIds = Sets.newHashSet(Lists.transform(tasksWithServiceName, new Function<Task, String>()));
    assertThat(task.id(), isIn(taskIds));
}"
"@Test
public void should_try_to_verify_correct_number_of_times() {
    Timeout t = new Timeout(10, 50, mode, durationChecker);
    doThrow(error).when(mode).verify(data);
    when(durationChecker.isVerificationStillInProgress(anyLong())).thenReturn(true, true, true, true, true, false);
    try {
        t.verify(data);
        fail();
    } catch (MockitoAssertionError e) {
    }
    verify(mode, times(5)).verify(data);
}"
"@Test
public void testConsumerBacklogEvictionTimeQuotaWithEmptyLedger() throws Exception {
    assertEquals(admin.namespaces().getBacklogQuotaMap(""prop/ns-quota""), Maps.newHashMap());
    admin.namespaces().setBacklogQuota(""prop/ns-quota"", BacklogQuota.builder().limitTime(TIME_TO_CHECK_BACKLOG_QUOTA).retentionPolicy(consumer_backlog_eviction).build(), message_age);
    PulsarClient client = PulsarClient.builder().serviceUrl(adminUrl.toString()).statsInterval(0, TimeUnit.SECONDS).build();
    final String topic = ""persistent"";
    final String subName = ""c1"";
    Consumer<byte[]> consumer = client.newConsumer().topic(topic).subscriptionName(subName).subscribe();
    Producer<byte[]> producer = createProducer(client, topic);
    producer.send(new byte[1024]);
    consumer.receive();
    admin.topics().unload(topic);
    PersistentTopicInternalStats internalStats = admin.topics().getInternalStats(topic);
    assertEquals(internalStats.ledgers.size(), 2);
    assertEquals(internalStats.ledgers.get(1).entries, 0);
    TopicStats stats = admin.topics().getStats(topic);
    assertEquals(stats.getSubscriptions().get(subName).getMsgBacklog(), 1);
    TimeUnit.SECONDS.sleep(TIME_TO_CHECK_BACKLOG_QUOTA);
    Awaitility.await().pollInterval(Duration.ofSeconds(1)).atMost(Duration.ofSeconds(TIME_TO_CHECK_BACKLOG_QUOTA)).untilAsserted(() -> {
        rolloverStats();
        PersistentTopicInternalStats latestInternalStats = admin.topics().getInternalStats(topic);
        assertEquals(latestInternalStats.ledgers.size(), 2);
        assertEquals(latestInternalStats.ledgers.get(1).entries, 0);
        TopicStats latestStats = admin.topics().getStats(topic);
        assertEquals(latestStats.getSubscriptions().get(subName).getMsgBacklog(), 0);
    });
    client.close();
}"
"@Test
public void testiParameterized18nWithSpeciali18nPlaceholder() {
    when(ninjaProperties.getStringArray(applicationLanguages)).thenReturn(new String[]{ ""en"", ""de"", ""fr-FR"" });
    Lang lang = new LangImpl(ninjaProperties);
    Messages messages = new MessagesImpl(ninjaProperties, lang);
    Optional<String> language = Optional.absent();
    Optional<String> result = messages.get(""message_with_placeholder_date"", language, new Date(0));
    assertEquals(""that's a date: Jan 1, 1970"", result.get());
    language = Optional.of(""de"");
    result = messages.get(""message_with_placeholder_date"", language, new Date(0));
    assertEquals(""das ist ein datum: 01.01.1970"", result.get());
    language = Optional.of(""fr-FR"");
    result = messages.get(""message_with_placeholder_date"", language, new Date(0));
    assertEquals(""c`est la date: 1 janv. 1970"", result.get());
    language = Optional.of(""en"");
    result = messages.get(""message_with_placeholder_date"", language, new Date(0));
    assertEquals(""that's a date: Jan 1, 1970"", result.get());
}"
"@Test
public void testVersion2ClientVersion2Server() throws Exception {
    ProtocolSignature.resetCache();
    TestImpl2 impl = new TestImpl2();
    server = new RPC.Builder(conf).setProtocol(TestProtocol2.class).setInstance(impl).setBindAddress(ADDRESS).setPort(0).setNumHandlers(2).setVerbose(false).build();
    server.addProtocol(RPC_WRITABLE, TestProtocol0.class, impl);
    server.start();
    addr = NetUtils.getConnectAddress(server);
    Version2Client client = new Version2Client();
    client.ping();
    assertEquals(""hello"", client.echo(""hello""));
    assertEquals(-3, client.echo(3));
}"
"@Test
public void testBind() throws Exception {
    Name name = new CompositeName(""test"");
    final Object value = new Object();
    namingContext.bind(name, value);
    assertEquals(value, namingStore.lookup(name));
    name = new CompositeName(""securitytest"");
    testActionPermission(JndiPermission.ACTION_BIND, namingContext, ""securitytest"", value);
    assertEquals(value, namingStore.lookup(name));
}"
"@Test
public void testLookupContextLink() throws Exception {
    final Name name = new CompositeName(""test/value"");
    namingStore.bind(name, ""testValue"");
    final Name linkName = new CompositeName(""link"");
    namingStore.bind(linkName, new LinkRef(""./test""));
    Object result = namingContext.lookup(""link/value"");
    assertEquals(""testValue"", result);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, Arrays.asList(new JndiPermission(""test"", ""lookup""),
    new JndiPermission(""test/value"", ""lookup"")), namingContext, ""link/value"");
    assertEquals(""testValue"", result);
}"
"@Test public void testFormatMultipleUTF8(){
    HashMap<String,String> params=new HashMap<String,String>();
    params.put(""a "",""b, "");
    params.put(""c"",""32626&"");
    String s=KeyValueFormatter.format(params,true);
    Assert.assertTrue((""a =b%2C+&c=32626%26"").equals(s) || (""c=32626%26&a =b%2C+"").equals(s));
}"
"@Test
public void testRecoverExpiredMessages() throws Exception {
    ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory( ) ;
    connection = factory.createConnection();
    connection.start();
    session = connection.createSession(false, AUTO_ACKNOWLEDGE);
    producer = session.createProducer(destination);
    producer.setTimeToLive(2000);
    producer.setDeliveryMode(PERSISTENT);
    Thread producingThread = new Thread(""Producing Thread"") {
        public void run() {
            try {
                int i = 0;
                while ((i++) < 1000) {
                    Message message = (useTextMessage) ? session.createTextMessage(""test"") : session.createObjectMessage(""test"");
                    producer.send(message);
                }
                producer.close();
            } catch (Throwable ex) {
                ex.printStackTrace();
            }
        }
    };
    producingThread.start();
    producingThread.join();
    DestinationViewMBean view = createView(destination);
    LOG.info(((((((((((""Stats: size: "" + view.getQueueSize()) + "", enqueues: "") + view.getDequeueCount()) + "", dequeues: "") + view.getDequeueCount()) + "", dispatched: "") + view.getDispatchCount()) + "", inflight: "") + view.getInFlightCount()) + "", expiries: "") + view.getExpiredCount());
    LOG.info(""stopping broker"");
    broker.stop();
    broker.waitUntilStopped();
    Thread.sleep(5000);
    LOG.info(""recovering broker"");
    final boolean deleteAllMessages = false;
    broker = createBroker(deleteAllMessages, 5000);
    Wait.waitFor(new Wait.Condition() {
        public boolean isSatisified() throws Exception {
            boolean result = false;
            try {
                DestinationViewMBean view = createView(destination);
                LOG.info(((((((((((""Stats: size: "" + view.getQueueSize()) + "", enqueues: "") + view.getDequeueCount()) + "", dequeues: "") + view.getDequeueCount()) + "", dispatched: "") + view.getDispatchCount()) + "", inflight: "") + view.getInFlightCount()) + "", expiries: "") + view.getExpiredCount());
                result = view.getQueueSize() == 0;
            } catch (Exception notFoundExpectedOnSlowMachines) {
            }
            return result;
        }
    });
    view = createView(destination);
    assertEquals(""Expect empty queue, QueueSize: "", 0, view.getQueueSize());
    assertEquals(""all dequeues were expired"", view.getDequeueCount(), view.getExpiredCount());
}"
"@Test public void test_number_formt_tojson(){
    NumBean num=new NumBean();
    num.setNum1(1);
    String a=""{\n"" + ""   \""num1\"": \""01.00\"",\n"" + ""   \""num2\"": \""02.00\""\n""+ ""}"";
    String str=Json.toJson(num);
    assertJsonEqualsNonStrict(a,str);
    System.out.println(str);
}"
"@Test
void testBytes() throws InterruptedException {
    final CountDownLatch countDownLatch = new CountDownLatch(1);
    final Metrics metrics = new Metrics();
    final LongAdder longAdder = new LongAdder();
    final long input = 100;
    final int loopCount = 10000;
    Thread adder = new Thread(() -> {
        try {
            countDownLatch.await();
        } catch (InterruptedException ignore) {
        }
        for (int i = 0; i < loopCount; ++i) {
            metrics.addBytes(input);
        }
    });
    Thread getter = new Thread(() -> {
        try {
            countDownLatch.await();
        } catch (InterruptedException ignore) {
        }
        for (int i = 0; i < loopCount; ++i) {
            longAdder.add(metrics.bytesThenReset());
        }
    });
    adder.start();
    getter.start();
    countDownLatch.countDown();
    adder.join();
    longAdder.add(metrics.bytesThenReset());
    Assertions.assertEquals(loopCount * input, longAdder.sum());
}"
"@Test
public void testNotAllowNullSchema() {
    AvroSchema<Foo> avroSchema = AvroSchema.of(SchemaDefinition.<Foo>builder().withPojo(Foo.class).withAlwaysAllowNull(false).build());
    assertEquals(avroSchema.getSchemaInfo().getType(), AVRO);
    Schema.Parser parser = new Schema.Parser();
    String schemaJson = new String(avroSchema.getSchemaInfo().getSchema());
    assertEquals(schemaJson, SCHEMA_AVRO_NOT_ALLOW_NULL);
    Schema schema = parser.parse(schemaJson);
    for (String fieldName : FOO_FIELDS) {
        Schema.Field field = schema.getField(fieldName);
        Assert.assertNotNull(field);
        if (field.name().equals(""field4"")) {
            Assert.assertNotNull(field.schema().getTypes().get(1).getField(""field1""));
        }
        if (field.name().equals(""fieldUnableNull"")) {
            Assert.assertNotNull(field.schema().getType());
        }
    }
}"
"@Test
public void testClientConnecting() throws Exception {
    PipelineOptions options = PipelineOptionsFactory.create();
    Endpoints.ApiServiceDescriptor descriptor = findOpenPort();
    BeamFnControlService service =
    new BeamFnControlService(
    descriptor,
    ServerStreamObserverFactory.fromOptions(options)::from,
    GrpcContextHeaderAccessorProvider.getHeaderAccessor());
    Server server =
    ServerFactory.fromOptions(options).create(descriptor, ImmutableList.of(service));
    String url = service.getApiServiceDescriptor().getUrl();
    BeamFnControlGrpc.BeamFnControlStub clientStub =
    BeamFnControlGrpc.newStub(ManagedChannelBuilder.forTarget(url).usePlaintext(true).build());
    clientStub.control(requestObserver);
    try (FnApiControlClient client = service.get()) {
        assertNotNull(client);
    }
    server.shutdown();
    server.awaitTermination(1, TimeUnit.SECONDS);
    server.shutdownNow();
    verify(requestObserver).onCompleted();
    verifyNoMoreInteractions(requestObserver);
}"
"@Test public void wrapperBooleans() throws Exception {
    assertThat(testResult(WrapperBooleans.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperBooleans.iterations);
    assertEquals(singletonList(false),WrapperBooleans.values.subList(0,1));
    WrapperBooleans.iterations=0;
}"
"@Test
public void assertGetLocalFailoverItemsIfShutdown() {
    assertThat(failoverService.getLocalFailoverItems(), is(Collections.<Integer>emptyList()));
    verify(jobNodeStorage, times(0)).getJobNodeChildrenKeys(""sharding"");
}"
"@Test
public void journalBlockCreation() throws Exception {
    FileSystem fs = mCluster.getClient();
    BlockMaster blockMaster =
    mCluster.getLocalAlluxioMaster().getMasterProcess().getMaster(BlockMaster.class);
    AlluxioURI file = new AlluxioURI(""/test"");
    FileSystemTestUtils.createByteFile(fs, file, WritePType.MUST_CACHE, 10);
    URIStatus status = fs.getStatus(file);
    Long blockId = status.getBlockIds().get(0);
    assertNotNull(blockMaster.getBlockInfo(blockId));
    mCluster.stopMasters();
    mCluster.startMasters();
    AlluxioMasterProcess masterProcess = mCluster.getLocalAlluxioMaster().getMasterProcess();
    assertNotNull(masterProcess.getMaster(BlockMaster.class).getBlockInfo(blockId));
}"
"@Test public void testAddMultiple(){
    builder.addScopes(RedditScope.EDIT,RedditScope.FLAIR);
    String s=builder.build();
    assertTrue((RedditScope.EDIT.value() + RedditScope.SEPARATOR + RedditScope.FLAIR.value()).equals(s) || (RedditScope.FLAIR.value() + RedditScope.SEPARATOR + RedditScope.EDIT.value()).equals(s));
    builder.removeScopes(RedditScope.EDIT,RedditScope.FLAIR);
}"
"@Test(timeout=60000) public void testNfsRenameSingleNN() throws Exception {
    DFSTestUtil.createFile(viewFs,new Path(""/hdfs1/renameSingleNN""),0,(short)1,0);
    HdfsFileStatus fromFileStatus=nn1.getRpcServer().getFileInfo(""/user1"");
    int fromNNId=Nfs3Utils.getNamenodeId(config,hdfs1.getUri());
    FileHandle fromHandle=new FileHandle(fromFileStatus.getFileId(),fromNNId);
    HdfsFileStatus statusBeforeRename=nn1.getRpcServer().getFileInfo(""/user1/renameSingleNN"");
    Assert.assertEquals(statusBeforeRename.isDirectory(),false);
    Path successFilePath=new Path(""/user1/renameSingleNNSucess"");
    hdfs1.delete(successFilePath,false);
    testNfsRename(fromHandle,""renameSingleNN"",fromHandle,""renameSingleNNSucess"",Nfs3Status.NFS3_OK);
    HdfsFileStatus statusAfterRename=nn1.getRpcServer().getFileInfo(""/user1/renameSingleNNSucess"");
    Assert.assertEquals(statusAfterRename.isDirectory(),false);
    statusAfterRename=nn1.getRpcServer().getFileInfo(""/user1/renameSingleNN"");
    Assert.assertEquals(statusAfterRename,null);
}"
"@Test
public void testApiAuthToken() {
    ApiDoc apiDoc = jsondocScanner.getApiDocs(Sets.<Class<?>>newHashSet(Controller.class), URI).iterator().next();
    Assert.assertEquals(""TOKEN"", apiDoc.getAuth().getType());
    Assert.assertEquals("""", apiDoc.getAuth().getScheme());
    Assert.assertEquals(""abc"", apiDoc.getAuth().getTesttokens().iterator().next());
    for (ApiMethodDoc apiMethodDoc : apiDoc.getMethods()) {
        if (apiMethodDoc.getPath().contains(""/inherit"")) {
            Assert.assertEquals(""TOKEN"", apiMethodDoc.getAuth().getType());
            Assert.assertEquals("""", apiMethodDoc.getAuth().getScheme());
            Assert.assertEquals(""abc"", apiMethodDoc.getAuth().getTesttokens().iterator().next());
        }
        if (apiMethodDoc.getPath().contains(""/override"")) {
            Assert.assertEquals(""TOKEN"", apiMethodDoc.getAuth().getType());
            Assert.assertEquals(""Bearer"", apiMethodDoc.getAuth().getScheme());
            Assert.assertEquals(""xyz"", apiMethodDoc.getAuth().getTesttokens().iterator().next());
        }
    }
}"
"@Test
public void testOneTimeWorkRequest_backedOff() {
    val now = System.currentTimeMillis() ;
    when(mTaskConverter.now()).thenReturn(now) ;
    val request = OneTimeWorkRequestBuilder<TestWorker>().setInitialRunAttemptCount(1).build() ;
    val workSpec = request.workSpec ;
    val expected = workSpec.calculateNextRunTime();
    val offset = offset(expected, now) ,
    val delta = task.windowEnd - (offset + EXECUTION_WINDOW_SIZE_IN_SECONDS);
    val task = mTaskConverter.convert(request.workSpec);
    assertEquals(task.serviceName, WorkManagerGcmService::class.java.name);
    assertEquals(task.isPersisted, false);
    assertEquals(task.isUpdateCurrent, true);
    assertEquals(task.requiredNetwork, Task.NETWORK_STATE_ANY);
    assertEquals(task.requiresCharging, false);
    assertEquals(task.windowStart, offset);
    assertEquals(task.windowEnd, offset + EXECUTION_WINDOW_SIZE_IN_SECONDS);
}"
"@Test
public void testConduitBridge() throws Exception {
    MessageConsumer consumer1 = remoteSession.createConsumer(included);
    MessageConsumer consumer2 = remoteSession.createConsumer(included);
    MessageProducer producer = localSession.createProducer(included);
    producer.setDeliveryMode(NON_PERSISTENT);
    Thread.sleep(2000);
    for (int i = 0; i < MESSAGE_COUNT; i++) {
        Message test = localSession.createTextMessage(""test-"" + i);
        producer.send(test);
        assertNotNull(consumer1.receive(1000));
        assertNotNull(consumer2.receive(1000));
    }
    assertNull(consumer1.receive(1000));
    assertNull(consumer2.receive(1000));
}"
"@Test
public void testSkipCheckoutWithoutConnectionUrl() throws Exception {
    CheckoutMojo mojo = ((CheckoutMojo) (lookupMojo(""checkout"", getTestFile(""src/test/resources/mojos/checkout/checkoutWithoutConnectionUrl.xml""))));
    try {
        mojo.execute();
        fail(""mojo execution must fail."");
    } catch (MojoExecutionException e) {
        assertTrue(true);
    }
}"
"@Test public void testSimpleReflectionStatics(){
    final SimpleReflectionStaticFieldsFixture instance1=new SimpleReflectionStaticFieldsFixture();
    assertEquals(this.toBaseString(instance1) + ""[staticInt=12345,staticString=staticString]"",ReflectionToStringBuilder.toString(instance1,null,false,true,SimpleReflectionStaticFieldsFixture.class));
    assertEquals(this.toBaseString(instance1) + ""[staticInt=12345,staticString=staticString]"",ReflectionToStringBuilder.toString(instance1,null,true,true,SimpleReflectionStaticFieldsFixture.class));
    assertEquals(this.toBaseString(instance1) + ""[staticInt=12345,staticString=staticString]"",this.toStringWithStatics(instance1,null,SimpleReflectionStaticFieldsFixture.class));
    assertEquals(this.toBaseString(instance1) + ""[staticInt=12345,staticString=staticString]"",this.toStringWithStatics(instance1,null,SimpleReflectionStaticFieldsFixture.class));
}"
"@Test public void callable() throws Exception {
    assertThat(testResult(CallableOfInt.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),CallableOfInt.iterations);
    CallableOfInt.iterations=0;
}"
"@Test
public void testSimpleClassloading() throws Exception {
    final AtomicInteger count = new AtomicInteger(0);
    final List<Event> finishedEvents = Collections.synchronizedList(new ArrayList<Event>());
    final ServiceRegistration jcReg = this.registerJobConsumer(TOPIC, new JobConsumer() {
        @Override
        public JobResult process(Job job) {
            count.incrementAndGet();
            return JobResult.OK;
        }
    });
    final ServiceRegistration ehReg = this.registerEventHandler(TOPIC_JOB_FINISHED, new EventHandler() {
        @Override
        public void handleEvent(Event event) {
            finishedEvents.add(event);
        }
    });
    try {
        final JobManager jobManager = this.getJobManager();
        final List<String> list = new ArrayList<String>();
        list.add(""1"");
        list.add(""2"");
        final EventPropertiesMap map = new EventPropertiesMap();
        map.put(""a"", ""a1"");
        map.put(""b"", ""b2"");
        final Map<String, Object> props = new HashMap<String, Object>();
        props.put(""string"", ""Hello"");
        props.put(""int"", new Integer(5));
        props.put(""long"", new Long(7));
        props.put(""list"", list);
        props.put(""map"", map);
        jobManager.addJob(TOPIC, null, props);
        while (finishedEvents.size() < 1) {
            Thread.sleep(100);
        }
        Thread.sleep(100);
        assertEquals(0, jobManager.getStatistics().getNumberOfQueuedJobs());
        assertEquals(1, count.get());
        assertEquals(0, jobManager.findJobs(ALL, TOPIC, -1, ((Map<String, Object>[]) (null))).size());
        final String jobTopic = ((String) (finishedEvents.get(0).getProperty(NOTIFICATION_PROPERTY_JOB_TOPIC)));
        assertNotNull(jobTopic);
        assertEquals(""Hello"", finishedEvents.get(0).getProperty(""string""));
        assertEquals(new Integer(5), Integer.valueOf(finishedEvents.get(0).getProperty(""int"").toString()));
        assertEquals(new Long(7), Long.valueOf(finishedEvents.get(0).getProperty(""long"").toString()));
        assertEquals(list, finishedEvents.get(0).getProperty(""list""));
        assertEquals(map, finishedEvents.get(0).getProperty(""map""));
    } finally {
        jcReg.unregister();
        ehReg.unregister();
    }
}"
"@Test public void manyParameters(){
    assertThat(testResult(ManyParameters.class),isSuccessful());
    assertEquals(10,ManyParameters.iterations);
    assertEquals(new HashSet<>(asList(-1,-2,-4)),new HashSet<>(ManyParameters.firstValues.subList(0,3)));
    assertEquals(new HashSet<>(asList('r','y')),new HashSet<>(ManyParameters.secondValues.subList(0,2)));
    ManyParameters.iterations=0;
}"
"@Test(expected=ClusterStateException.class) public void testReassignFailOnStopAndSync() throws IOException {
    ReceiverAdminClient receiverAdminClient=mockReceiverClientFailOnStopAndSync();
    coordinator=new Coordinator(metadataStore,receiverAdminClient);
    Map<Integer,List<Partition>> preAssignMap=metadataStore.getAssignmentsByCube(cubeName).getAssignments();
    Map<Integer,List<Partition>> newAssignMap=new LinkedHashMap<>();
    newAssignMap.put(1,Lists.newArrayList(p1,p2,p3));
    newAssignMap.put(2,Lists.newArrayList(p4,p5));
    newAssignMap.put(3,Lists.newArrayList(p6));
    CubeAssignment preAssigment=new CubeAssignment(cube.getName(),preAssignMap);
    CubeAssignment newAssigment=new CubeAssignment(cube.getName(),newAssignMap);
    try {
        coordinator.doReassign(cube,preAssigment,newAssigment);
    }
    catch (  ClusterStateException rune) {
        assertSame(ClusterStateException.ClusterState.ROLLBACK_FAILED,rune.getClusterState());
        assertSame(ClusterStateException.TransactionStep.STOP_AND_SNYC,rune.getTransactionStep());
        System.out.println(rune.getMessage());
        throw rune;
    }
}"
"@Test public void unboxingAFoo() throws Exception {
    assertThat(testResult(UnboxingAFoo.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),UnboxingAFoo.iterations);
    UnboxingAFoo.iterations=0;
}"
"@Test
public void testCheckoutPrepareBuildMultiModuleProject() throws Exception {
    PrepareBuildProjectsTask task = createTask(""src/test-projects/multi-module/pom.xml"", false, false);
    this.prepareBuildQueue.put(task);
    List<Project> projects = getProjectDao().getProjectsInGroup(task.getProjectGroupId());
    assertEquals(""failed to add all projects"", 3, projects.size());
    Project rootProject = getProjectDao().getProjectByName(""multi-module-parent"");
    Project moduleA = getProjectDao().getProjectByName(""module-A"");
    Project moduleB = getProjectDao().getProjectByName(""module-B"");
    while ((!prepareBuildQueue.getQueueSnapshot().isEmpty()) || (prepareBuildTaskQueueExecutor.getCurrentTask() != null)) {
        Thread.sleep(10);
    }
    ProjectScmRoot scmRoot = projectScmRootDao.getProjectScmRoot(task.getProjectScmRootId());
    assertEquals(""Failed to update multi-module project"", UPDATED, scmRoot.getState());
    File workingDir = configurationService.getWorkingDirectory();
    assertTrue(""checkout directory of project 'multi-module-parent' does not exist."", new File(workingDir, Integer.toString(rootProject.getId())).exists());
    assertTrue(""checkout directory of project 'module-A' does not exist."", new File(workingDir, Integer.toString(moduleA.getId())).exists());
    assertTrue(""checkout directory of project 'module-B' does not exist."", new File(workingDir, Integer.toString(moduleB.getId())).exists());
}"
"public void test_for_issue() throws Exception {
    String text=""{\""a\"":{\""x\"":\""y\""},\""b\"":{\""x\"":\""y\""}}"";
    JSONObject jsonObject=JSONObject.parseObject(text);
    System.out.println(jsonObject);
    String jsonpath=""$..x"";
    String value=""y2"";
    JSONPath.set(jsonObject,jsonpath,value);
    assertEquals(""{\""a\"":{\""x\"":\""y2\""},\""b\"":{\""x\"":\""y2\""}}"",JSON.toJSONString(jsonObject,SerializerFeature.MapSortField));
}"
"@Test
public void testWithDirStringAndConf() throws Exception {
    dirString = ""d1"";
    item = new PathData(dirString, conf);
    checkPathData();
    dirString = ""d1/"";
    item = new PathData(dirString, conf);
    checkPathData();
}"
"@Test
public void assertDurationIsInRange(long expectedMillis) {
    long minimum = (long) ((double) expectedMillis * 0.90);
    long maximum =
    Math.max((long) ((double) expectedMillis * 1.10), 10);
    long waitMillis = Math.max(expectedMillis * 10, 10);
    long duration = getDurationMillis(waitMillis);
    if (duration < minimum) {
        Assert.fail(""expected duration: "" + expectedMillis +
        "" minimum duration: "" + minimum +
        "" actual duration too short: "" + duration);
    } else if (duration > maximum) {
        Assert.fail(""expected duration: "" + expectedMillis +
        "" maximum duration: "" + maximum +
        "" actual duration too long: "" + duration);
    }
}"
"@Test
public void testRegisterURLSchemeHandler() throws Exception {
    InitialContext ictx = new InitialContext(null);
    try {
        ictx.lookup(""foobar:something"");
        Assert.fail(""Precondition: the foobar: scheme should not yet be registered"");
    } catch (NamingException ne) {
    }
    ObjectFactory tof = new TestObjectFactory();
    InitialContext.addUrlContextFactory(""foobar"", tof);
    String something = (String) ictx.lookup(""foobar:something"");
    Assert.assertTrue(""The object should now be provided by our TestObjectFactory"", something.startsWith(""TestObject:""));
    try {
        InitialContext.removeUrlContextFactory(""foobar:"", new TestObjectFactory());
        Assert.fail(""Should throw an IllegalArgumentException since the associated factory object doesn't match the registration"");
    } catch (IllegalArgumentException iae) {
    }
    Assert.assertEquals(""The foobar: scheme should still be registered"", something, ictx.lookup(""foobar:something""));
    InitialContext.removeUrlContextFactory(""foobar"", tof);
    try {
        ictx.lookup(""foobar:something"");
        Assert.fail(""The foobar: scheme should not be registered any more"");
    } catch (NamingException ne) {
    }
}"
"@Test
public void testTrackMetadata_rowMarkerDelete() throws Throwable
{
    createTable(""CREATE TABLE %s (a int, PRIMARY KEY (a))"");
    ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(currentTable());
    execute(""DELETE FROM %s USING TIMESTAMP 9999 WHERE a=1"");
    cfs.forceBlockingFlush();
    assertEquals(1, cfs.getLiveSSTables().size());
    StatsMetadata metadata = cfs.getLiveSSTables().iterator().next().getSSTableMetadata();
    assertEquals(9999, metadata.minTimestamp);
    assertEquals(9999, metadata.maxTimestamp);
    assertEquals(System.currentTimeMillis()/1000, metadata.maxLocalDeletionTime, 5);
    cfs.forceMajorCompaction();
    StatsMetadata metadata2 = cfs.getLiveSSTables().iterator().next().getSSTableMetadata();
    assertEquals(metadata.maxLocalDeletionTime, metadata2.maxLocalDeletionTime);
    assertEquals(metadata.minTimestamp, metadata2.minTimestamp);
    assertEquals(metadata.maxTimestamp, metadata2.maxTimestamp);
}"
"@Test public void testSerialize() throws SerializationException {
    GetUserIdSerializableRequest request=new GetUserIdSerializableRequest();
    request.setOperation(InstantAccessOperationValue.GETUSERID);
    request.setInfoField1(""nobody@amazon.com"");
    request.setInfoField2(""AMZN"");
    String requestString=serializer.encode(request);
    requestString=requestString.replace(""{"","""").replace(""}"","""").replace(""\"""","""");
    HashMap<String,String> requestMap=new HashMap<String,String>();
    String[] pairs=requestString.split("","");
    for (int i=0; i < pairs.length; i++) {
        String pair=pairs[i];
        String[] keyValue=pair.split("":"");
        requestMap.put(keyValue[0],keyValue[1]);
    }
    HashMap<String,String> expected=new HashMap<String,String>();
    expected.put(""operation"",""GetUserId"");
    expected.put(""infoField1"",""nobody@amazon.com"");
    expected.put(""infoField2"",""AMZN"");
    assertEquals(requestMap,expected);
}"
"@Test
public void notifyAboutChangesConcurrently() {
    final int numberOfThreads = 100;
    final TestSubscriber<Changes> testSubscriber = new TestSubscriber<Changes>();
    final Set<String> tables = new HashSet<String>();
    final List<Changes> expectedChanges = new ArrayList<Changes>();
    for (int i = 0; i < numberOfThreads; i++) {
        final String table = ""test_table"" + i;
        tables.add(table);
        expectedChanges.add(Changes.newInstance(table));
    }
    storIOSQLite.observeChanges(LATEST).subscribe(testSubscriber);
    final CountDownLatch startAllThreadsLock = new CountDownLatch(1);
    for (int i = 0; i < numberOfThreads; i++) {
        final int finalI = i;
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    startAllThreadsLock.await();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                storIOSQLite.lowLevel().notifyAboutChanges(Changes.newInstance(""test_table"" + finalI));
            }
        }).start();
    }
    startAllThreadsLock.countDown();
    final long startTime = SystemClock.elapsedRealtime();
    while ((testSubscriber.valueCount() != tables.size()) && ((SystemClock.elapsedRealtime() - startTime) < 20000)) {
        Thread.yield();
    }
    testSubscriber.assertNoErrors();
    testSubscriber.assertValueCount(expectedChanges.size());
    assertThat(expectedChanges.containsAll(testSubscriber.values())).isTrue();
}"
"@Test public void testToQueryUrl(){
    Map<String,String> parameters=new LinkedHashMap<String,String>();
    parameters.put(CommonParams.NAMESPACE_ID,""namespace"");
    parameters.put(CommonParams.SERVICE_NAME,""service"");
    parameters.put(CommonParams.GROUP_NAME,""group"");
    parameters.put(CommonParams.CLUSTER_NAME,null);
    parameters.put(""ip"",""1.1.1.1"");
    parameters.put(""port"",String.valueOf(9999));
    parameters.put(""weight"",String.valueOf(1.0));
    parameters.put(""ephemeral"",String.valueOf(true));
    String excepted=""namespaceId=namespace&serviceName=service&groupName=group&ip=1.1.1.1&port=9999&weight=1.0&ephemeral=true"";
    assertEquals(excepted,Query.newInstance().initParams(parameters).toQueryUrl());
}"
"@Test public void onlyTrumpsGenerators() throws Exception {
    assertThat(testResult(OnlyTrumpsGenerators.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),OnlyTrumpsGenerators.iterations);
    OnlyTrumpsGenerators.iterations=0;
}"
"@Test
public void testCompositeKeys() {
    EntityHelper.initEntityNameMap(UserCompositeKeys.class, config);
    EntityTable entityTable = EntityHelper.getEntityTable(UserCompositeKeys.class);
    Assert.assertNotNull(entityTable);
    Set<EntityColumn> columns = entityTable.getEntityClassColumns();
    Assert.assertEquals(2, columns.size());
    Assert.assertEquals(2, entityTable.getEntityClassPKColumns().size());
    for (EntityColumn column : columns) {
        Assert.assertTrue(column.isId());
    }
    ResultMap resultMap = entityTable.getResultMap(configuration);
    Assert.assertEquals(2, resultMap.getResultMappings().size());
    Assert.assertTrue(resultMap.getResultMappings().get(0).getFlags().contains(ID));
    Assert.assertTrue(resultMap.getResultMappings().get(1).getFlags().contains(ID));
    Assert.assertEquals(""<where> AND name = #{name} AND orgId = #{orgId}</where>"", SqlHelper.wherePKColumns(UserCompositeKeys.class));
}"
"@Test
public void testALSInputProducer() throws Exception {
    Map<String, Object> overlayConfig = new HashMap<>();
    overlayConfig.put(""oryx.serving.application-resources"", ""\""com.cloudera.oryx.app.serving,com.cloudera.oryx.app.serving.als\"""");
    overlayConfig.put(""oryx.serving.model-manager-class"", ALSServingModelManager.class.getName());
    Config config = ConfigUtils.overlayOn(overlayConfig, getConfig());
    startMessaging();
    startServer(config);
    @SuppressWarnings(""unchecked"")
    TopicProducer<String, String> inputProducer = ((TopicProducer<String, String>) (getServingLayer().getContext().getServletContext().getAttribute(INPUT_PRODUCER_KEY)));
    String[] inputs = new String[]{ ""abc,123,1.5"", ""xyz,234,-0.5"", ""AB,10,0"" };
    List<Pair<String, String>> keyMessages;
    try (final CloseableIterator<Pair<String, String>> data = new ConsumeData(INPUT_TOPIC, getZKPort()).iterator()) {
        log.info(""Starting consumer thread"");
        ConsumeTopicRunnable consumeInput = new ConsumeTopicRunnable(data);
        new Thread(consumeInput).start();
        Thread.sleep(3000);
        for (String input : inputs) {
            inputProducer.send("""", input);
        }
        Thread.sleep(1000);
        keyMessages = consumeInput.getKeyMessages();
    }
    for (int i = 0; i < keyMessages.size(); i++) {
        Pair<String, String> keyMessage = keyMessages.get(i);
        assertEquals("""", keyMessage.getFirst());
        assertEquals(inputs[i], keyMessage.getSecond());
    }
    assertEquals(inputs.length, keyMessages.size());
}"
"@Test
public void testMatchesSpeedTest() throws Exception {
    int iterations = 15;
    String password = new RandomValueStringGenerator().generate();
    String encodedBcrypt = cachingPasswordEncoder.encode(password);
    long nanoStart = System.nanoTime();
    for (int i = 0; i < iterations; i++) {
        assertTrue(cachingPasswordEncoder.getPasswordEncoder().matches(password, encodedBcrypt));
        long nanoStop = System.nanoTime();
        long bcryptTime = nanoStop - nanoStart;
        nanoStart = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            nanoStop = System.nanoTime();
            long cacheTime = nanoStop - nanoStart;
            assertTrue(bcryptTime > (10 * cacheTime));
        }
    }
}"
"@Test public void primitiveBytes() throws Exception {
    assertThat(testResult(PrimitiveBytes.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveBytes.iterations);
    PrimitiveBytes.iterations=0;
}"
"public void test_for_issue() throws Exception {
    Map<Integer,Integer> map=new LinkedHashMap<Integer,Integer>();
    map.put(1,10);
    map.put(2,4);
    map.put(3,5);
    map.put(4,5);
    map.put(37306,98);
    map.put(36796,9);
    String json=JSON.toJSONString(map);
    System.out.println(json);
    Assert.assertEquals(""{1:10,2:4,3:5,4:5,37306:98,36796:9}"",json);
    Map<Integer,Integer> map1=JSON.parseObject(json,new TypeReference<HashMap<Integer,Integer>>(){
    }
    );
    Assert.assertEquals(map1.get(Integer.valueOf(1)),Integer.valueOf(10));
    Assert.assertEquals(map1.get(Integer.valueOf(2)),Integer.valueOf(4));
    Assert.assertEquals(map1.get(Integer.valueOf(3)),Integer.valueOf(5));
    Assert.assertEquals(map1.get(Integer.valueOf(4)),Integer.valueOf(5));
    Assert.assertEquals(map1.get(Integer.valueOf(37306)),Integer.valueOf(98));
    Assert.assertEquals(map1.get(Integer.valueOf(36796)),Integer.valueOf(9));
    JSONObject map2=JSON.parseObject(""{35504:1,1:10,2:4,3:5,4:5,37306:98,36796:9\n"" + ""}"");
    Assert.assertEquals(map2.get(Integer.valueOf(1)),Integer.valueOf(10));
    Assert.assertEquals(map2.get(Integer.valueOf(2)),Integer.valueOf(4));
    Assert.assertEquals(map2.get(Integer.valueOf(3)),Integer.valueOf(5));
    Assert.assertEquals(map2.get(Integer.valueOf(4)),Integer.valueOf(5));
    Assert.assertEquals(map2.get(Integer.valueOf(37306)),Integer.valueOf(98));
    Assert.assertEquals(map2.get(Integer.valueOf(36796)),Integer.valueOf(9));
}"
"@Test public void assertPersistSequential() throws Exception {
    assertThat(zkRegCenter.persistSequential(""/sequential/test_sequential"",""test_value""),startsWith(""/sequential/test_sequential""));
    assertThat(zkRegCenter.persistSequential(""/sequential/test_sequential"",""test_value""),startsWith(""/sequential/test_sequential""));
    CuratorFramework client=CuratorFrameworkFactory.newClient(EmbedTestingServer.getConnectionString(),new RetryOneTime(2000));
    client.start();
    client.blockUntilConnected();
    List<String> actual=client.getChildren().forPath(""/"" + ZookeeperRegistryCenterModifyTest.class.getName() + ""/sequential"");
    assertThat(actual.size(),is(2));
    for (  String each : actual) {
        assertThat(each,startsWith(""test_sequential""));
        assertThat(zkRegCenter.get(""/sequential/"" + each),startsWith(""test_value""));
    }
    zkRegCenter.remove(""/sequential"");
    assertFalse(zkRegCenter.isExisted(""/sequential""));
}"
