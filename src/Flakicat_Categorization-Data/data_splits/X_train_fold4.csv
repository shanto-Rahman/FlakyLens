full_code
"@Test public void favorValueOf() throws Exception {
    assertThat(testResult(FavorValueOf.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),FavorValueOf.iterations);
    FavorValueOf.iterations=0;
}"
"@Test public void alsoHonorsGeneratorsApartFromFixedSet() throws Exception {
    assertThat(testResult(AlsoHonorsGenerators.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),AlsoHonorsGenerators.iterations);
    assertEquals(new HashSet<>(asList(1,2,3)),new HashSet<>(AlsoHonorsGenerators.values.subList(0,3)));
    assertEquals(new HashSet<>(asList(4,5)),new HashSet<>(AlsoHonorsGenerators.values.subList(3,AlsoHonorsGenerators.values.size())));
    AlsoHonorsGenerators.iterations=0;
    AlsoHonorsGenerators.values.clear();
}"
"public void test_for_issue(){
    org.json.JSONObject req=new org.json.JSONObject();
    SerializeConfig config=new SerializeConfig();
    config.register(new myModule());
    req.put(""id"",1111);
    req.put(""name"",""name11"");
    String text=JSON.toJSONString(req,SerializerFeature.SortField);
    Assert.assertEquals(""{\""id\"":1111,\""name\"":\""name11\""}"",text);
}"
"@Test public void testAllowNullSchema() throws JSONException {
    JSONSchema<Foo> jsonSchema=JSONSchema.of(SchemaDefinition.<Foo>builder().withPojo(Foo.class).build());
    Assert.assertEquals(jsonSchema.getSchemaInfo().getType(),SchemaType.JSON);
    Schema.Parser parser=new Schema.Parser();
    parser.setValidateDefaults(false);
    String schemaJson=new String(jsonSchema.getSchemaInfo().getSchema());
    assertJSONEqual(schemaJson,SCHEMA_JSON_ALLOW_NULL);
    Schema schema=parser.parse(schemaJson);
    for (  String fieldName : FOO_FIELDS) {
        Schema.Field field=schema.getField(fieldName);
        Assert.assertNotNull(field);
        if (field.name().equals(""field4"")) {
            Assert.assertNotNull(field.schema().getTypes().get(1).getField(""field1""));
        }
        if (field.name().equals(""fieldUnableNull"")) {
            Assert.assertNotNull(field.schema().getType());
        }
    }
}"
"@Test
public void testOneTimeRequest_noInitialDelay_withConstraintNetworkConnected() {
    val now = System.currentTimeMillis() ;
    when(mTaskConverter.now()).thenReturn(now) ;
    val constraints = Constraints.Builder().setRequiredNetworkType(NetworkType.METERED).setRequiresCharging(true).build() ;
    val request = OneTimeWorkRequestBuilder<TestWorker>()
    .setConstraints(constraints)
    .build() ;
    val task = mTaskConverter.convert(request.workSpec) ;
    val expected = request.workSpec.calculateNextRunTime() ;
    val offset = offset(expected, now) ;
    assertEquals(task.serviceName, WorkManagerGcmService::class.java.name) ;
    assertEquals(task.isPersisted, false) ;
    assertEquals(task.isUpdateCurrent, true) ;
    assertEquals(task.requiredNetwork, Task.NETWORK_STATE_CONNECTED) ;
    assertEquals(task.requiresCharging, true) ;
    assertEquals(task.windowStart, offset) ;
    assertEquals(task.windowEnd, offset + EXECUTION_WINDOW_SIZE_IN_SECONDS) ;
}"
"@Test public void test_replaceExtension_Adaptive() throws Exception {
    ExtensionLoader<AddExt3> loader=getExtensionLoader(AddExt3.class);
    AddExt3 adaptive=loader.getAdaptiveExtension();
    assertFalse(adaptive instanceof AddExt3_ManualAdaptive);
    loader.replaceExtension(null,AddExt3_ManualAdaptive.class);
    adaptive=loader.getAdaptiveExtension();
    assertTrue(adaptive instanceof AddExt3_ManualAdaptive);
    ExtensionLoader.resetExtensionLoader(AddExt3.class);
}"
"@Test
public void testScanPolicyObserver() throws Exception {
    byte[] tableName = Bytes.toBytes(""testScanPolicyObserver"");
    HTableDescriptor desc = new HTableDescriptor(tableName);
    HColumnDescriptor hcd = new HColumnDescriptor(F).setMaxVersions(10).setTimeToLive(1);
    desc.addFamily(hcd);
    TEST_UTIL.getHBaseAdmin().createTable(desc);
    HTable t = new HTable(new Configuration(TEST_UTIL.getConfiguration()), tableName);
    long now = EnvironmentEdgeManager.currentTimeMillis();
    ZooKeeperWatcher zkw = HConnectionManager.getConnection(TEST_UTIL.getConfiguration()).getZooKeeperWatcher();
    ZooKeeper zk = zkw.getRecoverableZooKeeper().getZooKeeper();
    ZKUtil.createWithParents(zkw, node);
    zk.setData(node, Bytes.toBytes(now - (3600 * 1000)), -1);
    LOG.debug(""Set time: "" + Bytes.toLong(Bytes.toBytes(now - (3600 * 1000))));
    long ts = now - 2000;
    Put p = new Put(R);
    p.add(F, Q, ts, Q);
    t.put(p);
    p = new Put(R);
    p.add(F, Q, ts + 1, Q);
    t.put(p);
    Get g = new Get(R);
    g.setMaxVersions(10);
    Result r = t.get(g);
    assertEquals(2, r.size());
    TEST_UTIL.flush(tableName);
    TEST_UTIL.compact(tableName, true);
    g = new Get(R);
    g.setMaxVersions(10);
    r = t.get(g);
    assertEquals(2, r.size());
    zk.setData(node, Bytes.toBytes(now), -1);
    LOG.debug(""Set time: "" + now);
    TEST_UTIL.compact(tableName, true);
    g = new Get(R);
    g.setMaxVersions(10);
    r = t.get(g);
    assertEquals(0, r.size());
    t.close();
}"
"@Test public void primitiveLongs() throws Exception {
    assertThat(testResult(PrimitiveLongs.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveLongs.iterations);
    PrimitiveLongs.iterations=0;
}"
"public void test_1() throws Exception {
    String sql=""CREATE EXTERNAL CATALOG user_db.mysql_1 PROPERTIES ("" + ""'connector.name'='mysql' "" + ""'connection-url'='jdbc:mysql://1.1.1.1:3306' ""+ ""'connection-user'=\""x'!xx\"" ""+ ""'connection-password'=\""x'xx\"")"";
    MySqlStatementParser parser=new MySqlStatementParser(sql);
    List<SQLStatement> stmtList=parser.parseStatementList();
    assertEquals(1,stmtList.size());
    SQLStatement stmt=stmtList.get(0);
    Set<String> allPossibleRes=generateAllPossibleRes4test1();
    assertTrue(allPossibleRes.contains(stmt.toString()));
}"
"@Test
public void testExpiredRequestAllocationOnAnyHost() throws Exception {
    MockClusterResourceManager spyManager = spy(new MockClusterResourceManager(callback, state));
    ContainerManager spyContainerManager = spy(new ContainerManager(containerPlacementMetadataStore, state, spyManager, true, false, mock(LocalityManager.class), faultDomainManager, config));
    spyAllocator = Mockito.spy(new ContainerAllocator(spyManager, config, state, true, spyContainerManager));
    spyAllocator.requestResources(new HashMap<String, String>() {
        {
            put(""0"", ""hostname-0"");
            put(""1"", ""hostname-1"");
        }
    });
    spyAllocatorThread = new Thread(spyAllocator);
    spyAllocatorThread.start();
    Thread.sleep(1000);
    assertTrue(state.preferredHostRequests.get() == 2);
    assertTrue(state.expiredPreferredHostRequests.get() == 2);
    verify(spyContainerManager, times(1)).handleExpiredRequest(eq(""0""), eq(""hostname-0""), any(SamzaResourceRequest.class), any(ContainerAllocator.class), any(ResourceRequestState.class));
    verify(spyContainerManager, times(1)).handleExpiredRequest(eq(""1""), eq(""hostname-1""), any(SamzaResourceRequest.class), any(ContainerAllocator.class), any(ResourceRequestState.class));
    ArgumentCaptor<SamzaResourceRequest> cancelledRequestCaptor = ArgumentCaptor.forClass(SamzaResourceRequest.class);
    verify(spyManager, atLeast(2)).cancelResourceRequest(cancelledRequestCaptor.capture());
    assertTrue(cancelledRequestCaptor.getAllValues().stream().map(( resourceRequest) -> resourceRequest.getPreferredHost()).collect(Collectors.toSet()).size() > 2);
    assertTrue(state.matchedResourceRequests.get() == 0);
    assertTrue(state.anyHostRequests.get() > 2);
    spyAllocator.stop();
}"
"@Test public void manyParameters(){
    assertThat(testResult(ManyParameters.class),isSuccessful());
    assertEquals(10,ManyParameters.iterations);
    assertEquals(new HashSet<>(asList(-1,-2,-4)),new HashSet<>(ManyParameters.firstValues.subList(0,3)));
    assertEquals(new HashSet<>(asList('r','y')),new HashSet<>(ManyParameters.secondValues.subList(0,2)));
    ManyParameters.iterations=0;
}"
"@Test public void strings() throws Exception {
    assertThat(testResult(Strings.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),Strings.iterations);
    Strings.iterations=0;
}"
"@Test
public void testNotAllowNullSchema() {
    AvroSchema<Foo> avroSchema = AvroSchema.of(SchemaDefinition.<Foo>builder().withPojo(Foo.class).withAlwaysAllowNull(false).build());
    assertEquals(avroSchema.getSchemaInfo().getType(), AVRO);
    Schema.Parser parser = new Schema.Parser();
    String schemaJson = new String(avroSchema.getSchemaInfo().getSchema());
    assertEquals(schemaJson, SCHEMA_AVRO_NOT_ALLOW_NULL);
    Schema schema = parser.parse(schemaJson);
    for (String fieldName : FOO_FIELDS) {
        Schema.Field field = schema.getField(fieldName);
        Assert.assertNotNull(field);
        if (field.name().equals(""field4"")) {
            Assert.assertNotNull(field.schema().getTypes().get(1).getField(""field1""));
        }
        if (field.name().equals(""fieldUnableNull"")) {
            Assert.assertNotNull(field.schema().getType());
        }
    }
}"
"@Test public void wrapperShorts() throws Exception {
    assertThat(testResult(WrapperShorts.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperShorts.iterations);
    assertEquals(new HashSet<>(asList(Short.valueOf(""-13""),Short.valueOf(""-14""))),new HashSet<>(WrapperShorts.values.subList(0,2)));
    WrapperShorts.iterations=0;
}"
"@Test public void canSerializeMapKeysWithDotAndSlash() throws Exception {
    String serialized=new JacksonAdapter().serialize(prepareSchoolModel());
    String expected=""{\""teacher\"":{\""students\"":{\""af.B/D\"":{},\""af.B/C\"":{}}},\""tags\"":{\""foo.aa\"":\""bar\"",\""x.y\"":\""zz\""},\""properties\"":{\""name\"":\""school1\""}}"";
    assertJsonEqualsNonStrict(expected,serialized);
}"
"@Test
public void test() throws Exception {
    JBIContainer jbi = new JBIContainer();
    jbi.setEmbedded(true);
    jbi.init();
    QuartzComponent quartz = new QuartzComponent();
    QuartzEndpoint endpoint = new QuartzEndpoint();
    endpoint.setService(new QName(""quartz""));
    endpoint.setEndpoint(""endpoint"");
    endpoint.setTargetService(new QName(""countDownReceiver""));
    SimpleTriggerBean trigger = new SimpleTriggerBean();
    trigger.setRepeatInterval(100);
    trigger.setName(""trigger"");
    trigger.afterPropertiesSet();
    endpoint.setTrigger(trigger);
    quartz.setEndpoints(new QuartzEndpoint[]{ endpoint });
    jbi.activateComponent(quartz, ""servicemix-quartz"");
    CountDownReceiverComponent receiver = new CountDownReceiverComponent(new QName(""countDownReceiver""), ""endpoint"", 1, 3000);
    jbi.activateComponent(receiver, ""countDownReceiver"");
    jbi.start();
    assertTrue(receiver.getMessageList().flushMessages().size() > 0);
    quartz.stop();
    receiver.getMessageList().flushMessages();
    Thread.sleep(1000);
    assertEquals(0, receiver.getMessageList().flushMessages().size());
    quartz.start();
    receiver.reset();
    assertTrue(receiver.getMessageList().flushMessages().size() > 0);
    jbi.shutDown();
}"
"@Test
private Void returnAny1(Context context) {
    Notifier notifier = testUtilities.rhinoCallConvert(""testAny1ToClientChalk"", Notifier.class, testUtilities.javaToJS(getAddress()));
    boolean notified = notifier.waitForJavascript(1000 * 10);
    assertTrue(notified);
    Integer errorStatus = testUtilities.rhinoEvaluateConvert(""globalErrorStatus"", Integer.class);
    assertNull(errorStatus);
    String errorText = testUtilities.rhinoEvaluateConvert(""globalErrorStatusText"", String.class);
    assertNull(errorText);
    String chalk = ((String) (testUtilities.rhinoEvaluate(""globalResponseObject._any.object._chalk"")));
    assertEquals(""dover"", chalk);
    return null;
}"
"@Test public void testAvroDoc(){
    check(DocTest.class,""{\""type\"":\""record\"",\""name\"":\""DocTest\"",\""namespace\"":\""org.apache.avro.reflect.TestReflect\"","" + ""\""doc\"":\""DocTest class docs\"","" + ""\""fields\"":[""+ ""{\""name\"":\""defaultTest\"",\""type\"":{\""type\"":\""record\"",\""name\"":\""DefaultTest\"",""+ ""\""fields\"":[{\""name\"":\""foo\"",\""type\"":\""int\"",\""default\"":1}]},\""doc\"":\""And again\""},""+ ""{\""name\"":\""enums\"",\""type\"":{\""type\"":\""enum\"",\""name\"":\""DocTestEnum\"",""+ ""\""symbols\"":[\""ENUM_1\"",\""ENUM_2\""]},\""doc\"":\""Some other Documentation\""},""+ ""{\""name\"":\""foo\"",\""type\"":\""int\"",\""doc\"":\""Some Documentation\""}""+ ""]}"");
}"
"@Test
public void testPredictiveLayoutAdd2() throws Throwable {
    preparePredictiveLayout();
    mActivityTestRule.runOnUiThread(new Runnable() {
        @Override
        public void run() {
            mActivity.addItems(50, new int[]{300, 300, 300, 300});
        }
    });
    waitForItemAnimationStart();
    waitForItemAnimation(5000);
    assertEquals(54, mGridView.getSelectedPosition());
    assertEquals(RecyclerView.SCROLL_STATE_IDLE, mGridView.getScrollState());
}"
"@Test public void assumptionFailureWhileShrinking(){
    assertThat(testResult(FailedAssumptionDuringShrinking.class),hasSingleFailureContaining(""With arguments: [""));
    FailedAssumptionDuringShrinking.shrinking=false;
}"
"@Test public void testAdditionalModelTypeAnnotationsNewLineLinux() throws Exception {
    OpenAPI openAPI=TestUtils.createOpenAPI();
    final AbstractJavaCodegen codegen=new P_AbstractJavaCodegen();
    codegen.additionalProperties().put(AbstractJavaCodegen.ADDITIONAL_MODEL_TYPE_ANNOTATIONS,""@Foo\n@Bar"");
    codegen.processOpts();
    codegen.preprocessOpenAPI(openAPI);
    final List<String> additionalModelTypeAnnotations=new ArrayList<String>();
    additionalModelTypeAnnotations.add(""@Foo"");
    additionalModelTypeAnnotations.add(""@Bar"");
    final List<String> sortedCodegenAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    final List<String> sortedAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    Collections.sort(sortedCodegenAdditionalModelTypeAnnotations);
    Collections.sort(sortedAdditionalModelTypeAnnotations);
    Assert.assertEquals(sortedCodegenAdditionalModelTypeAnnotations,sortedAdditionalModelTypeAnnotations);
}"
"@Test
public void testErrorNotGzipped() throws Exception {
    Header[] headers = new Header[2];
    headers[0] = new Header(""Accept"", Constants.MIMETYPE_BINARY);
    headers[1] = new Header(""Accept-Encoding"", ""gzip"");
    Response response = client.get(((((""/"" + TABLE) + ""/"") + ROW_1) + ""/"") + COLUMN_2, headers);
    assertEquals(response.getCode(), 404);
    String contentEncoding = response.getHeader(""Content-Encoding"");
    assertTrue((contentEncoding == null) || (!contentEncoding.contains(""gzip"")));
    response = client.get(""/"" + TABLE, headers);
    assertEquals(response.getCode(), 405);
    contentEncoding = response.getHeader(""Content-Encoding"");
    assertTrue((contentEncoding == null) || (!contentEncoding.contains(""gzip"")));
}"
"@Test public void wrapperLongs() throws Exception {
    assertThat(testResult(WrapperLongs.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperLongs.iterations);
    assertEquals(new HashSet<>(asList(10L,11L,12L)),new HashSet<>(WrapperLongs.values.subList(0,3)));
    WrapperLongs.iterations=0;
}"
"@Test
public void testListBindingsWithContinuation() throws Exception {
    bindListWithContinuations();
    NamingEnumeration<Binding> results = namingContext.listBindings(new CompositeName(""comp""));
    checkListWithContinuationsResults(results);
    results = (NamingEnumeration<Binding>) testActionPermission(JndiPermission.ACTION_LIST_BINDINGS, Arrays.asList(
    new JndiPermission(""test"", ""listBindings"")), namingContext, ""comp"");
    checkListWithContinuationsResults(results);
}"
"@Test
public void testBrokerSelectionForAntiAffinityGroup() throws Exception {
    final String broker1 = primaryHost;
    final String broker2 = secondaryHost;
    final String cluster = pulsar1.getConfiguration().getClusterName();
    final String tenant = ""tenant-"" + UUID.randomUUID().toString();
    final String namespace1 = ((tenant + ""/"") + cluster) + ""/ns1"";
    final String namespace2 = ((tenant + ""/"") + cluster) + ""/ns2"";
    final String namespaceAntiAffinityGroup = ""group"";
    FailureDomain domain1 = new FailureDomain();
    domain1.brokers = Sets.newHashSet(broker1);
    admin1.clusters().createFailureDomain(cluster, ""domain1"", domain1);
    FailureDomain domain2 = new FailureDomain();
    domain2.brokers = Sets.newHashSet(broker2);
    admin1.clusters().createFailureDomain(cluster, ""domain2"", domain2);
    admin1.tenants().createTenant(tenant, new TenantInfo(null, Sets.newHashSet(cluster)));
    admin1.namespaces().createNamespace(namespace1);
    admin1.namespaces().createNamespace(namespace2);
    admin1.namespaces().setNamespaceAntiAffinityGroup(namespace1, namespaceAntiAffinityGroup);
    admin1.namespaces().setNamespaceAntiAffinityGroup(namespace2, namespaceAntiAffinityGroup);
    for (int i = 0; i < 5; i++) {
        if ((!isLoadManagerUpdatedDomainCache(primaryLoadManager)) || (!isLoadManagerUpdatedDomainCache(secondaryLoadManager))) {
            Thread.sleep(200);
        } else {
            break;
        }
    }
    assertTrue(isLoadManagerUpdatedDomainCache(primaryLoadManager));
    assertTrue(isLoadManagerUpdatedDomainCache(secondaryLoadManager));
    ServiceUnitId serviceUnit1 = makeBundle(tenant, cluster, ""ns1"");
    String selectedBroker1 = primaryLoadManager.selectBrokerForAssignment(serviceUnit1).get();
    ServiceUnitId serviceUnit2 = makeBundle(tenant, cluster, ""ns2"");
    String selectedBroker2 = primaryLoadManager.selectBrokerForAssignment(serviceUnit2).get();
    assertNotEquals(selectedBroker1, selectedBroker2);
}"
"@Test
void testK8SEventsMultiClusterEvents() {
    createNewCluster();
    OffsetDateTime timestamp = now();
    scaleClusterWithRestApi(domainUid, cluster2Name, 1, externalRestHttpsPort, opNamespace, opServiceAccount);
    logger.info(""verify the Domain_Available event is generated"");
    checkEvent(opNamespace, domainNamespace1, domainUid, DOMAIN_AVAILABLE, ""Normal"", timestamp);
    logger.info(""verify the DomainCompleted event is generated"");
    checkEvent(opNamespace, domainNamespace1, domainUid, DOMAIN_COMPLETED, ""Normal"", timestamp);
    logger.info(""verify the only 1 DomainCompleted event is generated"");
    assertEquals(1, getEventCount(domainNamespace1, domainUid, DOMAIN_COMPLETED, timestamp));
}"
"@Test
public void testHftpCustomDefaultPorts() throws IOException {
    resetFileSystem();
    Configuration conf = new Configuration();
    conf.setInt(""dfs.http.port"", 123);
    conf.setInt(""dfs.https.port"", 456);
    URI uri = URI.create();
    HftpFileSystem fs = ((HftpFileSystem) (FileSystem.get(uri, conf)));
    assertEquals(123, fs.getDefaultPort());
    assertEquals(456, fs.getDefaultSecurePort());
    assertEquals(uri, fs.getUri());
    assertEquals(""127.0.0.1:456"", fs.getCanonicalServiceName());
}"
"@Test
public void testUpdatePerOperationSamplerUpdatesExistingPerOperationSampler() throws Exception {
    PerOperationSampler perOperationSampler = mock(PerOperationSampler.class);
    OperationSamplingParameters parameters = mock(OperationSamplingParameters.class);
    when(samplingManager.getSamplingStrategy(SERVICE_NAME)).thenReturn(
    new SamplingStrategyResponse(null, null, parameters));
    undertest = new RemoteControlledSampler(SERVICE_NAME, samplingManager, perOperationSampler, metrics);
    undertest.updateSampler();
    Thread.sleep(20);
    verify(perOperationSampler, times(2)).update(parameters);
}"
"@Test public void voidParameter() throws Exception {
    assertThat(testResult(VoidParameter.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),VoidParameter.iterations);
    VoidParameter.iterations=0;
}"
"@Test
public void testModTime() throws IOException {
    Configuration conf = new Configuration();
    MiniDFSCluster cluster = new MiniDFSCluster(conf, numDatanodes, true, null);
    cluster.waitActive();
    InetSocketAddress addr = new InetSocketAddress(""localhost"", cluster.getNameNodePort());
    DFSClient client = new DFSClient(addr, conf);
    DatanodeInfo[] info = client.datanodeReport(LIVE);
    assertEquals(""Number of Datanodes "", numDatanodes, info.length);
    FileSystem fileSys = cluster.getFileSystem();
    int replicas = numDatanodes - 1;
    assertTrue(fileSys instanceof DistributedFileSystem);
    try {
        System.out.println(""Creating testdir1 and testdir1/test1.dat."");
        Path dir1 = new Path(""testdir1"");
        Path file1 = new Path(dir1, ""test1.dat"");
        writeFile(fileSys, file1, replicas);
        FileStatus stat = fileSys.getFileStatus(file1);
        long mtime1 = stat.getModificationTime();
        assertTrue(mtime1 != 0);
        stat = fileSys.getFileStatus(dir1);
        long mdir1 = stat.getModificationTime();
        System.out.println(""Creating testdir1/test2.dat."");
        Path file2 = new Path(dir1, ""test2.dat"");
        writeFile(fileSys, file2, replicas);
        stat = fileSys.getFileStatus(file2);
        stat = fileSys.getFileStatus(dir1);
        assertTrue(stat.getModificationTime() >= mdir1);
        mdir1 = stat.getModificationTime();
        Path dir2 = new Path(""testdir2/"").makeQualified(fileSys);
        System.out.println(""Creating testdir2 "" + dir2);
        assertTrue(fileSys.mkdirs(dir2));
        stat = fileSys.getFileStatus(dir2);
        long mdir2 = stat.getModificationTime();
        Path newfile = new Path(dir2, ""testnew.dat"");
        System.out.println(((""Moving "" + file1) + "" to "") + newfile);
        fileSys.rename(file1, newfile);
        stat = fileSys.getFileStatus(newfile);
        assertTrue(stat.getModificationTime() == mtime1);
        stat = fileSys.getFileStatus(dir1);
        assertTrue(stat.getModificationTime() != mdir1);
        mdir1 = stat.getModificationTime();
        stat = fileSys.getFileStatus(dir2);
        assertTrue(stat.getModificationTime() != mdir2);
        mdir2 = stat.getModificationTime();
        System.out.println(""Deleting testdir2/testnew.dat."");
        assertTrue(fileSys.delete(newfile, true));
        stat = fileSys.getFileStatus(dir1);
        assertTrue(stat.getModificationTime() == mdir1);
        stat = fileSys.getFileStatus(dir2);
        assertTrue(stat.getModificationTime() != mdir2);
        mdir2 = stat.getModificationTime();
        cleanupFile(fileSys, file2);
        cleanupFile(fileSys, dir1);
        cleanupFile(fileSys, dir2);
    } catch (IOException e) {
        info = client.datanodeReport(ALL);
        printDatanodeReport(info);
        throw e;
    } finally {
        fileSys.close();
        cluster.shutdown();
    }
}"
"public void test_for_issue() throws Exception {
    JSONObject jsonObject=new JSONObject();
    final JSONObject a=new JSONObject();
    final JSONObject b=new JSONObject();
    a.put(""b"",b);
    b.put(""c"",""2018-04"");
    b.put(""d"",new JSONArray());
    Integer obj=Integer.valueOf(123);
    jsonObject.put(""a"",a);
    JSONPath.arrayAdd(jsonObject,""$.a.b[c = '2018-04'].d"",obj);
    assertEquals(""{\""a\"":{\""b\"":{\""c\"":\""2018-04\"",\""d\"":[123]}}}"",JSON.toJSONString(jsonObject,SerializerFeature.MapSortField));
}"
"@Test public void doubleArray(){
    final WithArrays wa=new WithArrays();
    wa.doubleArray=new double[]{1,2};
    final String exp=getClassPrefix(wa) + ""["" + BR+ ""  boolArray=<null>,""+ BR+ ""  charArray=<null>,""+ BR+ ""  doubleArray={""+ BR+ ""    1.0,""+ BR+ ""    2.0""+ BR+ ""  },""+ BR+ ""  intArray=<null>,""+ BR+ ""  longArray=<null>,""+ BR+ ""  stringArray=<null>""+ BR+ ""]"";
    assertEquals(exp,toString(wa));
}"
"@Test
public void playbackRate() throws Exception {
    final int toleranceMs = 1000;
    Future<PlayerResult> setSurfaceFuture = mPlayer.setSurface(
    mActivity.getSurfaceHolder().getSurface());
    Future<PlayerResult> prepareFuture = mPlayer.prepare();
    assertFutureSuccess(setSurfaceFuture);
    assertFutureSuccess(prepareFuture);
    float[] rates = {0.25f, 0.5f, 1.0f, 2.0f};
    for (float playbackRate : rates) {
        Future<PlayerResult> seekFuture = mPlayer.seekTo(0, MediaPlayer.SEEK_PREVIOUS_SYNC);
        Thread.sleep(1000);
        int playTime = 4000;
        int privState = mPlayer.getPlayerState();
        Future<PlayerResult> setParamsFuture = mPlayer.setPlaybackParams(
        new PlaybackParams.Builder().setSpeed(playbackRate).build());
        assertFutureSuccess(seekFuture);
        assertFutureSuccess(setParamsFuture);
        assertEquals(""setPlaybackParams() should not change player state. ""
        + mPlayer.getPlayerState(), privState, mPlayer.getPlayerState());
        Future<PlayerResult> playFuture = mPlayer.play();
        Thread.sleep(playTime);
        PlaybackParams pbp = mPlayer.getPlaybackParams();
        assertEquals(playbackRate, pbp.getSpeed(), FLOAT_TOLERANCE);
        assertEquals(""The player should still be playing"",
        MediaPlayer.PLAYER_STATE_PLAYING, mPlayer.getPlayerState());
        long playedMediaDurationMs = mPlayer.getCurrentPosition();
        long expectedPosition = (long) (playTime * playbackRate);
        int diff = (int) Math.abs(playedMediaDurationMs - expectedPosition);
        if (diff > toleranceMs) {
            fail(""Media player had error in playback rate "" + playbackRate
            + "". expected position after playing "" + playTime
            + "" was "" + expectedPosition + "", but actually "" + playedMediaDurationMs);
        }
        assertFutureSuccess(playFuture);
        assertFutureSuccess(mPlayer.pause());
        pbp = mPlayer.getPlaybackParams();
        assertEquals(""pause() should not change the playback rate property."",
        playbackRate, pbp.getSpeed(), FLOAT_TOLERANCE);
    }
    mPlayer.reset();
}"
"@Test
public void testRebindReferenceable() throws Exception {
    final Name name = new CompositeName(""test"");
    final TestObjectReferenceable referenceable = new TestObjectReferenceable(""addr"");
    namingContext.bind(name, referenceable);
    TestObjectReferenceable newReferenceable = new TestObjectReferenceable(""newAddr"");
    namingContext.rebind(name, newReferenceable);
    Object result = namingContext.lookup(name);
    assertEquals(newReferenceable.addr, result);
    newReferenceable = new TestObjectReferenceable(""yetAnotherNewAddr"");
    testActionPermission(JndiPermission.ACTION_REBIND, namingContext, ""test"", newReferenceable);
    result = namingContext.lookup(name);
    assertEquals(newReferenceable.addr, result);
}"
"@Test
public void testSetrepIncWithUnderReplicatedBlocks() throws Exception {
    Configuration conf = new HdfsConfiguration();
    final short REPLICATION_FACTOR = 2;
    final String FILE_NAME = ""/testFile"";
    final Path FILE_PATH = new Path(FILE_NAME);
    MiniDFSCluster cluster = new MiniDFSCluster.Builder(conf).numDataNodes(REPLICATION_FACTOR + 1).build();
    try {
        final FileSystem fs = cluster.getFileSystem();
        DFSTestUtil.createFile(fs, FILE_PATH, 1L, REPLICATION_FACTOR, 1L);
        DFSTestUtil.waitReplication(fs, FILE_PATH, REPLICATION_FACTOR);
        final BlockManager bm = cluster.getNamesystem().getBlockManager();
        ExtendedBlock b = DFSTestUtil.getFirstBlock(fs, FILE_PATH);
        DatanodeDescriptor dn = bm.blocksMap.nodeIterator(b.getLocalBlock()).next();
        bm.addToInvalidates(b.getLocalBlock(), dn);
        bm.blocksMap.removeNode(b.getLocalBlock(), dn);
        FsShell shell = new FsShell(conf);
        assertEquals(0, shell.run(new String[]{ ""-setrep"", ""-w"", Integer.toString(1 + REPLICATION_FACTOR), FILE_NAME }));
    } finally {
        cluster.shutdown();
    }
}"
"@Test public void testDuplicateArrayList(){
    A a=new A();
    a.list1=new ArrayList<String>();
    a.list1.add(""aaa"");
    a.list2=new ArrayList<String>();
    a.list2.add(""aaa"");
    String json=Json.toJson(a,JsonFormat.compact().setQuoteName(false));
    String exp=""{list1:[\""aaa\""],list2:[\""aaa\""]}"";
    assertJsonEqualsNonStrict(exp,json);
}"
"@Test public void testOneResponse() throws Exception {
    QueryResponse r=new QueryResponse();
    r.setMetric(""sys.cpu.user"");
    r.putTag(""host"",""localhost"");
    r.putTag(""rack"",""r1"");
    r.putDps(""1234567890"",4.5);
    r.putDps(""1234567900"",3.5);
    r.putDps(""1234567910"",2.5);
    String result=JsonUtil.getObjectMapper().writeValueAsString(Collections.singletonList(r));
    String expected=""[{\""metric\"":\""sys.cpu.user\"",\""tags\"":{\""host\"":\""localhost\"",\""rack\"":\""r1\""},\""aggregatedTags\"":[],\""dps\"":{\""1234567890\"":4.5,\""1234567900\"":3.5,\""1234567910\"":2.5}}]"";
    Assert.assertEquals(expected,result);
}"
"@Test
public void testSessionCreated() throws Exception {
    final Semaphore semaphore = new Semaphore(0);
    final StringBuffer stringBuffer = new StringBuffer();
    VmPipeAcceptor vmPipeAcceptor = new VmPipeAcceptor();
    final VmPipeAddress vmPipeAddress = new VmPipeAddress(12345);
    vmPipeAcceptor.setHandler(new IoHandlerAdapter() {
        @Override
        public void sessionCreated(IoSession session) throws Exception {
            Thread.sleep(1000);
            stringBuffer.append(""A"");
        }
        @Override
        public void sessionOpened(IoSession session) throws Exception {
            stringBuffer.append(""B"");
        }
        @Override
        public void messageReceived(IoSession session, Object message) throws Exception {
            stringBuffer.append(""C"");
        }
        @Override
        public void sessionClosed(IoSession session) throws Exception {
            stringBuffer.append(""D"");
            semaphore.release();
        }
    });
    vmPipeAcceptor.bind(vmPipeAddress);
    final VmPipeConnector vmPipeConnector = new VmPipeConnector();
    vmPipeConnector.getFilterChain().addLast(""executor"", new ExecutorFilter());
    vmPipeConnector.setHandler(new IoHandlerAdapter() {
        @Override
        public void sessionOpened(IoSession session) throws Exception {
            session.write(IoBuffer.wrap(new byte[1]));
        }
    });
    ConnectFuture connectFuture = vmPipeConnector.connect(vmPipeAddress);
    connectFuture.awaitUninterruptibly();
    connectFuture.getSession().close();
    semaphore.tryAcquire(1, TimeUnit.SECONDS);
    vmPipeAcceptor.unbind(vmPipeAddress);
    Assert.assertEquals(""ABCD"", stringBuffer.toString());
}"
"@Test public void primitiveDoubles(){
    assertThat(testResult(PrimitiveDoubles.class),isSuccessful());
    assertEquals(2,PrimitiveDoubles.iterations);
    assertEquals(new HashSet<>(asList(3.2,-4D)),PrimitiveDoubles.testCases);
    PrimitiveDoubles.iterations=0;
    PrimitiveDoubles.testCases.clear();
}"
"@Test
public void testLookupReference() throws Exception {
    final Name name = new CompositeName(""test"");
    final Reference reference = new Reference(String.class.getName(), new StringRefAddr(""blah"", ""test""), TestObjectFactory.class.getName(), null);
    namingStore.bind(name, reference);
    Object result = namingContext.lookup(name);
    assertEquals(""test"", result);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, ""test"");
    assertEquals(""test"", result);
}"
"@Test public void testParametersFromOriginalPostRequest() throws IOException {
    TestHttpClient client=createHttpClient();
    HttpResponse result=executePostRequest(client,""/servletContext/dumpRequest"",new BasicNameValuePair(""param1"",""param1Value""),new BasicNameValuePair(""param2"",""param2Value""));
    assertEquals(StatusCodes.OK,result.getStatusLine().getStatusCode());
    String response=HttpClientUtils.readResponse(result);
    assertTrue(response.contains(""param1=param1Value""));
    assertTrue(response.contains(""param2=param2Value""));
    result=executePostRequest(client,""/servletContext/secured/dumpRequest"",new BasicNameValuePair(""securedParam1"",""securedParam1Value""),new BasicNameValuePair(""securedParam2"",""securedParam2Value""));
    assertEquals(StatusCodes.OK,result.getStatusLine().getStatusCode());
    Assert.assertTrue(HttpClientUtils.readResponse(result).startsWith(""j_security_check""));
    result=executePostRequest(client,""/servletContext/j_security_check"",new BasicNameValuePair(""j_username"",""user1""),new BasicNameValuePair(""j_password"",""password1""));
    assertEquals(StatusCodes.OK,result.getStatusLine().getStatusCode());
    response=HttpClientUtils.readResponse(result);
    assertTrue(response.contains(""securedParam1=securedParam1Value""));
    assertTrue(response.contains(""securedParam2=securedParam2Value""));
}"
"@Test public void testAddMultiple(){
    builder.addScopes(RedditScope.EDIT,RedditScope.FLAIR);
    String s=builder.build();
    assertTrue((RedditScope.EDIT.value() + RedditScope.SEPARATOR + RedditScope.FLAIR.value()).equals(s) || (RedditScope.FLAIR.value() + RedditScope.SEPARATOR + RedditScope.EDIT.value()).equals(s));
    builder.removeScopes(RedditScope.EDIT,RedditScope.FLAIR);
}"
"@Test
public void testAddAnExistingBuildAgent() {
    String BUILD_AGENT_NAME = getProperty(""BUILD_AGENT_NAME"");
    String BUILD_AGENT_DESCRIPTION = getProperty(""BUILD_AGENT_DESCRIPTION"");
    enableDistributedBuilds();
    goToAddBuildAgent();
    addBuildAgent(BUILD_AGENT_NAME, BUILD_AGENT_DESCRIPTION, false, false);
    assertTextPresent(""Build agent already exists"");
    disableDistributedBuilds();
}"
"@Test
public void shouldContainSyncCommitteeAggregates() throws Exception {
    primaryNode.start();
    primaryNode.startEventListener(List.of(contribution_and_proof));
    secondaryNode.start();
    secondaryNode.startEventListener(List.of(contribution_and_proof));
    validatorClient.start();
    primaryNode.waitForEpoch(1);
    secondaryNode.waitForFullSyncCommitteeAggregate();
    validatorClient.stop();
    secondaryNode.stop();
    primaryNode.stop();
    assertThat(primaryNode.getContributionAndProofEvents().stream().filter(( proof) -> proof.message.aggregatorIndex.isGreaterThanOrEqualTo(8)).count()).isGreaterThan(0);
    assertThat(secondaryNode.getContributionAndProofEvents().stream().filter(( proof) -> proof.message.aggregatorIndex.isLessThan(8)).count()).isGreaterThan(0);
}"
"@Test
public void indexCreationDateReturnsIndexCreationDateOfExistingIndexAsDateTime() {
    final DateTime now = DateTime.now(DateTimeZone.UTC);
    final String indexName = client().createRandomIndex(""indices_it_"");
    final Optional<DateTime> indexCreationDate = indices.indexCreationDate(indexName);
    assertThat(indexCreationDate).isNotEmpty()
    .hasValueSatisfying(date -> Assertions.assertThat(date).isEqualToIgnoringMillis(now));
}"
"@Test
public void testBindReferenceable() throws Exception {
    Name name = new CompositeName(""test"");
    final TestObjectReferenceable referenceable = new TestObjectReferenceable(""addr"");
    namingContext.bind(name, referenceable);
    Object result = namingContext.lookup(name);
    assertEquals(referenceable.addr, result);
    name = new CompositeName(""securitytest"");
    testActionPermission(JndiPermission.ACTION_BIND, namingContext, ""securitytest"", referenceable);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, ""securitytest"");
    assertEquals(referenceable.addr, result);
}"
"@Test
public void testTopicLevelInactivePolicyUpdateAndClean() throws Exception {
    super.resetConfig();
    conf.setSystemTopicEnabled(true);
    conf.setTopicLevelPoliciesEnabled(true);
    conf.setBrokerDeleteInactiveTopicsEnabled(true);
    conf.setBrokerDeleteInactiveTopicsMaxInactiveDurationSeconds(1000);
    conf.setBrokerDeleteInactiveTopicsMode(delete_when_no_subscriptions);
    InactiveTopicPolicies defaultPolicy = new InactiveTopicPolicies(InactiveTopicDeleteMode.delete_when_no_subscriptions, 1000, true);
    super.baseSetup();
    Thread.sleep(2000);
    final String namespace = ""prop/ns-abc"";
    final String topic = ""persistent"";
    final String topic2 = ""persistent"";
    final String topic3 = ""persistent"";
    List<String> topics = Arrays.asList(topic, topic2, topic3);
    for (String tp : topics) {
        admin.topics().createNonPartitionedTopic(tp);
    }
    InactiveTopicPolicies inactiveTopicPolicies = new InactiveTopicPolicies(InactiveTopicDeleteMode.delete_when_no_subscriptions, 1, true);
    admin.topics().setInactiveTopicPolicies(topic, inactiveTopicPolicies);
    inactiveTopicPolicies.setInactiveTopicDeleteMode(delete_when_subscriptions_caught_up);
    admin.topics().setInactiveTopicPolicies(topic2, inactiveTopicPolicies);
    inactiveTopicPolicies.setInactiveTopicDeleteMode(delete_when_no_subscriptions);
    admin.topics().setInactiveTopicPolicies(topic3, inactiveTopicPolicies);
    for (int i = 0; i < 50; i++) {
        if (admin.topics().getInactiveTopicPolicies(topic) != null) {
            break;
        }
        Thread.sleep(100);
    }
    InactiveTopicPolicies policies = ((PersistentTopic) (pulsar.getBrokerService().getTopic(topic, false).get().get())).inactiveTopicPolicies;
    Assert.assertTrue(policies.isDeleteWhileInactive());
    assertEquals(policies.getInactiveTopicDeleteMode(), delete_when_no_subscriptions);
    assertEquals(policies.getMaxInactiveDurationSeconds(), 1);
    assertEquals(policies, admin.topics().getInactiveTopicPolicies(topic));
    admin.topics().removeInactiveTopicPolicies(topic);
    for (int i = 0; i < 50; i++) {
        if (admin.topics().getInactiveTopicPolicies(topic) == null) {
            break;
        }
        Thread.sleep(100);
    }
    assertEquals(((PersistentTopic) (pulsar.getBrokerService().getTopic(topic, false).get().get())).inactiveTopicPolicies, defaultPolicy);
    policies = ((PersistentTopic) (pulsar.getBrokerService().getTopic(topic2, false).get().get())).inactiveTopicPolicies;
    Assert.assertTrue(policies.isDeleteWhileInactive());
    assertEquals(policies.getInactiveTopicDeleteMode(), delete_when_subscriptions_caught_up);
    assertEquals(policies.getMaxInactiveDurationSeconds(), 1);
    assertEquals(policies, admin.topics().getInactiveTopicPolicies(topic2));
    inactiveTopicPolicies.setMaxInactiveDurationSeconds(999);
    admin.namespaces().setInactiveTopicPolicies(namespace, inactiveTopicPolicies);
    Thread.sleep(1000);
    admin.topics().removeInactiveTopicPolicies(topic2);
    for (int i = 0; i < 50; i++) {
        if (admin.topics().getInactiveTopicPolicies(topic2) == null) {
            break;
        }
        Thread.sleep(100);
    }
    InactiveTopicPolicies nsPolicies = ((PersistentTopic) (pulsar.getBrokerService().getTopic(topic2, false).get().get())).inactiveTopicPolicies;
    assertEquals(nsPolicies.getMaxInactiveDurationSeconds(), 999);
    super.internalCleanup();
}"
"@Test
public void testPasswordHistory() throws Exception {
    assertTrue(""should be allowed to authenticate"", ums.authenticate(""testcred"", ""password""));
    Thread.sleep(10);
    ums.setPassword(""testcred"", ""password"", ""password1"");
    Thread.sleep(10);
    ums.setPassword(""testcred"", ""password1"", ""password2"");
    assertTrue(""should be allowed to authenticate"", ums.authenticate(""testcred"", ""password2""));
    try {
        Thread.sleep(10);
        ums.setPassword(""testcred"", ""password2"", ""password"");
        fail(""Should not be allowed to reuse a password from password history"");
    } catch (SecurityException sex) {
        assertTrue(SecurityException.PASSWORD_ALREADY_USED.equals(sex.getKeyedMessage()));
    }
    Thread.sleep(10);
    ums.setPassword(""testcred"", ""password2"", ""password3"");
    Thread.sleep(10);
    ums.setPassword(""testcred"", ""password3"", ""password4"");
    Thread.sleep(10);
    ums.setPassword(""testcred"", ""password4"", ""password"");
    assertTrue(""should be allowed to authenticate"", ums.authenticate(""testcred"", ""password""));
}"
"@Test
public void kafkaTopicIsPattern() throws Exception {
    to.expectedMessageCount(5);
    to.expectedBodiesReceivedInAnyOrder(""message-0"", ""message-1"", ""message-2"", ""message-3"", ""message-4"");
    to.allMessages().header(TOPIC).isEqualTo(""test"");
    to.expectedHeaderValuesReceivedInAnyOrder(LAST_RECORD_BEFORE_COMMIT, null, null, null, null, null);
    for (int k = 0; k < 5; k++) {
        String msg = ""message-"" + k;
        ProducerRecord<String, String> data = new ProducerRecord<>(TOPIC, ""1"", msg);
        producer.send(data);
    }
    to.assertIsSatisfied(3000);
    assertEquals(5, StreamSupport.stream(recordsCaptured.get(0).records(TOPIC).spliterator(), false).count());
}"
"public void testDynamicAttributesSupport() throws Exception {
    File file=new File(FreeMarkerResultTest.class.getResource(""dynaAttributes.ftl"").toURI());
    EasyMock.expect(servletContext.getRealPath(""/tutorial/org/apache/struts2/views/freemarker/dynaAttributes.ftl"")).andReturn(file.getAbsolutePath());
    file=new File(ClassLoaderUtil.getResource(""template/simple/text.ftl"",getClass()).toURI());
    EasyMock.expect(servletContext.getRealPath(""/template/simple/text.ftl"")).andReturn(file.getAbsolutePath());
    file=new File(ClassLoaderUtil.getResource(""template/simple/css.ftl"",getClass()).toURI());
    EasyMock.expect(servletContext.getRealPath(""/template/simple/css.ftl"")).andReturn(file.getAbsolutePath());
    EasyMock.expect(servletContext.getRealPath(""/template/~~~simple/css.ftl"")).andReturn(file.getAbsolutePath());
    file=new File(ClassLoaderUtil.getResource(""template/simple/scripting-events.ftl"",getClass()).toURI());
    EasyMock.expect(servletContext.getRealPath(""/template/simple/scripting-events.ftl"")).andReturn(file.getAbsolutePath());
    EasyMock.expect(servletContext.getRealPath(""/template/~~~simple/scripting-events.ftl"")).andReturn(file.getAbsolutePath());
    file=new File(ClassLoaderUtil.getResource(""template/simple/common-attributes.ftl"",getClass()).toURI());
    EasyMock.expect(servletContext.getRealPath(""/template/simple/common-attributes.ftl"")).andReturn(file.getAbsolutePath());
    EasyMock.expect(servletContext.getRealPath(""/template/~~~simple/common-attributes.ftl"")).andReturn(file.getAbsolutePath());
    file=new File(ClassLoaderUtil.getResource(""template/simple/dynamic-attributes.ftl"",getClass()).toURI());
    EasyMock.expect(servletContext.getRealPath(""/template/simple/dynamic-attributes.ftl"")).andReturn(file.getAbsolutePath());
    EasyMock.expect(servletContext.getRealPath(""/template/~~~simple/dynamic-attributes.ftl"")).andReturn(file.getAbsolutePath());
    EasyMock.replay(servletContext);
    init();
    request.setRequestURI(""/tutorial/test6.action"");
    ActionMapping mapping=container.getInstance(ActionMapper.class).getMapping(request,configurationManager);
    dispatcher.serviceAction(request,response,mapping);
    String result=stringWriter.toString();
    assertThat(result,allOf(startsWith(""<input type=\""text\"" name=\""test\"" value=\""\"" id=\""test\""""),containsString(""foo=\""bar\""""),containsString(""placeholder=\""input\""""),endsWith(""<input type=\""text\"" name=\""test\"" value=\""\"" id=\""test\"" break=\""true\""/>"" + ""<input type=\""text\"" name=\""required\"" value=\""\"" id=\""required\"" required=\""true\""/>"")));
}"
"@Test
public void testVersion2ClientVersion2Server() throws Exception {
    ProtocolSignature.resetCache();
    TestImpl2 impl = new TestImpl2();
    server = new RPC.Builder(conf).setProtocol(TestProtocol2.class).setInstance(impl).setBindAddress(ADDRESS).setPort(0).setNumHandlers(2).setVerbose(false).build();
    server.addProtocol(RPC_WRITABLE, TestProtocol0.class, impl);
    server.start();
    addr = NetUtils.getConnectAddress(server);
    Version2Client client = new Version2Client();
    client.ping();
    assertEquals(""hello"", client.echo(""hello""));
    assertEquals(-3, client.echo(3));
}"
"@Test
void scanShouldIterateOverAvailableEntries() {
    adapter.put(""1"", object1, COLLECTION_1);
    adapter.put(""2"", object2, COLLECTION_1);
    CloseableIterator<Map.Entry<Object, Object>> iterator = adapter.entries(COLLECTION_1);
    assertThat(iterator.next()).isEqualTo(new AbstractMap.SimpleEntry<>(""1"", object1));
    assertThat(iterator.next()).isEqualTo(new AbstractMap.SimpleEntry<>(""2"", object2));
    assertThat(iterator.hasNext()).isFalse();
}"
"@Test
public void testRebind() throws Exception {
    final Name name = new CompositeName(""test"");
    final Object value = new Object();
    namingStore.bind(name, value);
    Object newValue = new Object();
    namingContext.rebind(name, newValue);
    assertEquals(newValue, namingStore.lookup(name));
    newValue = new Object();
    testActionPermission(JndiPermission.ACTION_REBIND, namingContext, ""test"", newValue);
    assertEquals(newValue, namingStore.lookup(name));
}"
"@Test public void primitiveLongs(){
    assertThat(testResult(PrimitiveLongs.class),isSuccessful());
    assertEquals(3,PrimitiveLongs.iterations);
    assertEquals(new HashSet<>(asList(-6L,-7L,-8L)),PrimitiveLongs.testCases);
    PrimitiveLongs.iterations=0;
}"
"@Test
public void testTakeSnapshot() throws Exception {
    String snapshotName1 = ""snapshotName1"";
    String snapshotName2 = ""snapshotName2"";
    TableName tableName = TableName.valueOf(""testTakeSnapshot"");
    Admin syncAdmin = TEST_UTIL.getAdmin();
    try {
        Table table = TEST_UTIL.createTable(tableName, Bytes.toBytes(""f1""));
        for (int i = 0; i < 3000; i++) {
            table.put(new Put(Bytes.toBytes(i)).addColumn(Bytes.toBytes(""f1""), Bytes.toBytes(""cq""),
            Bytes.toBytes(i)));
        }
        admin.snapshot(snapshotName1, tableName).get();
        admin.snapshot(snapshotName2, tableName).get();
        List<SnapshotDescription> snapshots = syncAdmin.listSnapshots();
        Collections.sort(snapshots, (snap1, snap2) -> {
            Assert.assertNotNull(snap1);
            Assert.assertNotNull(snap1.getName());
            Assert.assertNotNull(snap2);
            Assert.assertNotNull(snap2.getName());
            return snap1.getName().compareTo(snap2.getName());
        });
        Assert.assertEquals(snapshotName1, snapshots.get(0).getName());
        Assert.assertEquals(tableName, snapshots.get(0).getTableName());
        Assert.assertEquals(SnapshotType.FLUSH, snapshots.get(0).getType());
        Assert.assertEquals(snapshotName2, snapshots.get(1).getName());
        Assert.assertEquals(tableName, snapshots.get(1).getTableName());
        Assert.assertEquals(SnapshotType.FLUSH, snapshots.get(1).getType());
    } finally {
        syncAdmin.deleteSnapshot(snapshotName1);
        syncAdmin.deleteSnapshot(snapshotName2);
        TEST_UTIL.deleteTable(tableName);
    }"
"@Test
public void testStoredContext() throws Exception {
    final ServiceName bindingName = ServiceName.JBOSS.append(""foo-stored"").append(""again"");
    bindObject(bindingName, new Context() {
        @Override
        public Object lookup(Name name) throws NamingException {
            if (""blah/blah2"".equals(name.toString())) {
                return new Integer(5);
            }
            return null;
        }
        @Override
        public Object lookup(String name) throws NamingException {
            return lookup(new CompositeName(name));
        }
        @Override
        public void bind(Name name, Object obj) throws NamingException {
        }
        @Override
        public void bind(String name, Object obj) throws NamingException {
        }
        @Override
        public void rebind(Name name, Object obj) throws NamingException {
        }
        @Override
        public void rebind(String name, Object obj) throws NamingException {
        }
        @Override
        public void unbind(Name name) throws NamingException {
        }
        @Override
        public void unbind(String name) throws NamingException {
        }
        @Override
        public void rename(Name oldName, Name newName) throws NamingException {
        }
        @Override
        public void rename(String oldName, String newName) throws NamingException {
        }
        @Override
        public NamingEnumeration<NameClassPair> list(Name name) throws NamingException {
            return null;
        }
        @Override
        public NamingEnumeration<NameClassPair> list(String name) throws NamingException {
            return null;
        }
        @Override
        public NamingEnumeration<Binding> listBindings(Name name) throws NamingException {
            if (!""hi/there"".equals(name.toString()))
            throw new IllegalArgumentException(""Expected hi/there"");
            return null;
        }
        @Override
        public NamingEnumeration<Binding> listBindings(String name) throws NamingException {
            return null;
        }
        @Override
        public void destroySubcontext(Name name) throws NamingException {
        }
        @Override
        public void destroySubcontext(String name) throws NamingException {
        }
        @Override
        public Context createSubcontext(Name name) throws NamingException {
            return null;
        }
        @Override
        public Context createSubcontext(String name) throws NamingException {
            return null;
        }
        @Override
        public Object lookupLink(Name name) throws NamingException {
            return null;
        }
        @Override
        public Object lookupLink(String name) throws NamingException {
            return null;
        }
        @Override
        public NameParser getNameParser(Name name) throws NamingException {
            return null;
        }
        @Override
        public NameParser getNameParser(String name) throws NamingException {
            return null;
        }
        @Override
        public Name composeName(Name name, Name prefix) throws NamingException {
            return null;
        }
        @Override
        public String composeName(String name, String prefix) throws NamingException {
            return null;
        }
        @Override
        public Object addToEnvironment(String propName, Object propVal) throws NamingException {
            return null;
        }
        @Override
        public Object removeFromEnvironment(String propName) throws NamingException {
            return null;
        }
        @Override
        public Hashtable<?, ?> getEnvironment() throws NamingException {
            return null;
        }
        @Override
        public void close() throws NamingException {
        }
        @Override
        public String getNameInNamespace() throws NamingException {
            return null;
        }
    });
    final NamingContext ctx = new NamingContext(new CompositeName(), store, null);
    final Object obj = ctx.lookup(new CompositeName(""foo-stored/again/blah/blah2""));
    ctx.listBindings(""foo-stored/again/hi/there"");
    assertNotNull(obj);
    assertEquals(new Integer(5), obj);
}"
"@Test public void wrapperChars(){
    assertThat(testResult(WrapperChars.class),isSuccessful());
    assertEquals(23,WrapperChars.iterations);
    assertEquals(new HashSet<>(asList('@','#')),new HashSet<>(WrapperChars.values.subList(0,2)));
    WrapperChars.iterations=0;
}"
"@Test
public void testWithMismatchingPending() throws Throwable
{
    try(Cluster cluster = init(Cluster.build(2).withConfig(config -> config.with(GOSSIP).with(NETWORK)).start()))
    {
        cluster.schemaChange(""create table "" + KEYSPACE + "".tbl (id int primary key, t int)"");
        insert(cluster.coordinator(1), 0, 100);
        cluster.forEach((node) -> node.flush(KEYSPACE));
        cluster.get(1).callOnInstance(repair(options(false)));
        insert(cluster.coordinator(1), 100, 100);
        cluster.forEach((node) -> node.flush(KEYSPACE));
        cluster.forEach((node) -> node.runOnInstance(() -> {
            ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(""tbl"");
            FBUtilities.waitOnFutures(CompactionManager.instance.submitBackground(cfs));
            cfs.disableAutoCompaction();
        }));
        cluster.get(1).callOnInstance(repair(options(false)));
        cluster.get(1).runOnInstance(() -> {
            ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(""tbl"");
            cfs.enableAutoCompaction();
            FBUtilities.waitOnFutures(CompactionManager.instance.submitBackground(cfs));
        });
        RepairResult rs = cluster.get(1).callOnInstance(repair(options(true)));
        assertTrue(rs.success);
        assertFalse(rs.wasInconsistent);
    }
}"
"@Test public void findingAnnotationsRecursively(){
    Method method=findMethod(this.getClass(),""withMarker"",String.class);
    List<Annotation> annotations=allAnnotations(method.getParameters()[0]);
    assertEquals(4,annotations.size());
    assertEquals(X.class,annotations.get(0).annotationType());
    assertEquals(Y.class,annotations.get(1).annotationType());
    assertTrue(Z.class.equals(annotations.get(2).annotationType()) || W.class.equals(annotations.get(2).annotationType()));
    if (Z.class.equals(annotations.get(2).annotationType())) {
        assertEquals(W.class,annotations.get(3).annotationType());
    }
    else {
        assertEquals(Z.class,annotations.get(3).annotationType());
    }
}"
"@Test public void testAdditionalModelTypeAnnotationsNewLineWindows() throws Exception {
    OpenAPI openAPI=TestUtils.createOpenAPI();
    final AbstractJavaCodegen codegen=new P_AbstractJavaCodegen();
    codegen.additionalProperties().put(AbstractJavaCodegen.ADDITIONAL_MODEL_TYPE_ANNOTATIONS,""@Foo\r\n@Bar"");
    codegen.processOpts();
    codegen.preprocessOpenAPI(openAPI);
    final List<String> additionalModelTypeAnnotations=new ArrayList<String>();
    additionalModelTypeAnnotations.add(""@Foo"");
    additionalModelTypeAnnotations.add(""@Bar"");
    final List<String> sortedCodegenAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    final List<String> sortedAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    Collections.sort(sortedCodegenAdditionalModelTypeAnnotations);
    Collections.sort(sortedAdditionalModelTypeAnnotations);
    Assert.assertEquals(sortedCodegenAdditionalModelTypeAnnotations,sortedAdditionalModelTypeAnnotations);
}"
"@Test
public void testUnqualifiedUriContents() throws Exception {
    dirString = ""d1"";
    item = new PathData(dirString, conf);
    PathData[] items = item.getDirectoryContents();
    assertEquals(sortedString(""d1/f1"", ""d1/f1.1"", ""d1/f2""), sortedString(items));
}"
"@Test
public void testNoTestClassesInDeploymentAssembly()
throws InvocationTargetException, CoreException {
    CreateAppEngineWtpProject creator = new CreateAppEngineStandardWtpProject(config, adaptable);
    creator.execute(monitor);
    ProjectUtils.waitForProjects(project);
    assertNoTestClassesInDeploymentAssembly();
}
private void assertNoTestClassesInDeploymentAssembly() throws CoreException {
    StructureEdit core = StructureEdit.getStructureEditForRead(project);
    WorkbenchComponent component = core.getComponent();
    assertNotNull(component);
    boolean seenMainSourcePath = false;
    List<ComponentResource> resources = component.getResources();
    for (ComponentResource resource : resources) {
        assertFalse(containsSegment(resource.getSourcePath(), ""test""));
        if (resource.getSourcePath().equals(new Path(""/src/main/java""))
        && resource.getRuntimePath().equals(new Path(""/WEB-INF/classes""))) {
            seenMainSourcePath = true;
        }
    }
    assertTrue(seenMainSourcePath);
}"
"@Test public void primitiveBooleans() throws Exception {
    assertThat(testResult(PrimitiveBooleans.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveBooleans.iterations);
    PrimitiveBooleans.iterations=0;
}"
"@Test
public void assertPersistEphemeralSequential() throws Exception {
    zkRegCenter.persistEphemeralSequential(""/sequential/test_ephemeral_sequential"");
    zkRegCenter.persistEphemeralSequential(""/sequential/test_ephemeral_sequential"");
    CuratorFramework client = CuratorFrameworkFactory.newClient(EmbedTestingServer.getConnectionString(), new RetryOneTime(2000));
    client.start();
    client.blockUntilConnected();
    List<String> actual = client.getChildren().forPath(""/"" + ZookeeperRegistryCenterModifyTest.class.getName() + ""/sequential"");
    assertThat(actual.size(), is(2));
    for (String each : actual) {
        assertThat(each, startsWith(""test_ephemeral_sequential""));
    }
    zkRegCenter.close();
    actual = client.getChildren().forPath(""/"" + ZookeeperRegistryCenterModifyTest.class.getName() + ""/sequential"");
    assertTrue(actual.isEmpty());
    zkRegCenter.init();
}"
"public void test_list() throws Exception {
    Model model=new Model();
    Map tables=new LinkedHashMap();
    tables.put(""1001"",new ExtTable(1001));
    tables.put(""1002"",new Table());
    model.setTables(tables);
    String json=JSON.toJSONString(model);
    assertEquals(""{\""tables\"":{\""1001\"":{\""@type\"":\""com.alibaba.json.bvt.writeClassName.WriteClassNameTest_Map$ExtTable\"",\""id\"":1001},\""1002\"":{}}}"",json);
    JSONObject jsonObject=JSON.parseObject(json,Feature.IgnoreAutoType);
    assertEquals(""{\""tables\"":{\""1001\"":{\""id\"":1001},\""1002\"":{}}}"",JSON.toJSONString(jsonObject,SerializerFeature.MapSortField));
    Model model2=JSON.parseObject(json,Model.class);
    assertEquals(ExtTable.class,model2.getTables().get(""1001"").getClass());
}"
"@Test
public void createDirectoryManagerIoException() throws IOException {
    DirectoryManagerFactory.createDirectoryManager(
    ""/nonexisting-directory/123456789/hopefully"", true);
}"
"@Test
public void twin() throws Exception {
    final ObjectMapper mapper = mapperWithModule();
    Object sampleOne = randomSample(Object.class);
    Object sampleTwo = randomSample(Object.class);
    String expectedJson = ""{\""one\"":"" + mapper.writeValueAsString(sampleOne);
    Twin<String> twin = Tuples.twin((String) sampleOne, (String) sampleTwo);
    Assert.assertEquals(expectedJson, mapper.writeValueAsString(twin));
    Assert.assertEquals(twin, mapper.readValue(expectedJson, new TypeReference<Twin<String>>() {}));
}"
"@Test
public void test_enum() {
    assertEquals(""\""K\"""", Json.toJson(K.K));
    String expected = ""{\n"" + ((""   \""name\"": \""t\"",\n"" + ""   \""index\"": 1\n"") + ""}"");
    assertEquals(expected, Json.toJson(TT.T));
    assertEquals(""\""T\"""", Json.toJson(TT.T, JsonFormat.full().ignoreJsonShape()));
}"
"@Test
public void testTokenExpiry() throws Exception {
    ClockMock clock = ClockMock.frozen();
    TokenService tokenService = createTokenService(tokenServiceEnabledSettings, clock);
    Authentication authentication = new Authentication(new User(""joe"", ""admin""), new RealmRef(""native_realm"", ""native"", ""node1""), null);
    PlainActionFuture<Tuple<UserToken, String>> tokenFuture = new PlainActionFuture<>();
    tokenService.createUserToken(authentication, authentication, tokenFuture, Collections.emptyMap(), true);
    final UserToken token = tokenFuture.get().v1();
    mockGetTokenFromId(token);
    mockCheckTokenInvalidationFromId(token);
    authentication = token.getAuthentication();
    ThreadContext requestContext = new ThreadContext(Settings.EMPTY);
    storeTokenHeader(requestContext, tokenService.getUserTokenString(token));
    try (ThreadContext.StoredContext ignore = requestContext.newStoredContext(true)) {
        PlainActionFuture<UserToken> future = new PlainActionFuture<>();
        tokenService.getAndValidateToken(requestContext, future);
        assertAuthenticationEquals(authentication, future.get().getAuthentication());
    }
    final TimeValue defaultExpiration = TokenService.TOKEN_EXPIRATION.get(Settings.EMPTY);
    final int fastForwardAmount = randomIntBetween(1, Math.toIntExact(defaultExpiration.getSeconds()) - 5);
    try (ThreadContext.StoredContext ignore = requestContext.newStoredContext(true)) {
        clock.fastForwardSeconds(Math.toIntExact(defaultExpiration.getSeconds()) - fastForwardAmount);
        clock.rewind(TimeValue.timeValueNanos(clock.instant().getNano()));
        PlainActionFuture<UserToken> future = new PlainActionFuture<>();
        tokenService.getAndValidateToken(requestContext, future);
        assertAuthenticationEquals(authentication, future.get().getAuthentication());
    }
    assertSettingDeprecationsAndWarnings(new Setting[] { TokenService.BWC_ENABLED });
}"
"@Test
private void multiClientTestBase() throws Exception {
    URL wsdl = getClass().getResource(""/wsdl/calculator.wsdl"");
    assertNotNull(wsdl);
    CalculatorService service = new CalculatorService(wsdl, new QName(""http://apache.org/cxf/calculator"", ""CalculatorService""));
    QName endpoint = new QName(""http://apache.org/cxf/calculator"", ""CalculatorPort"");
    service.addPort(endpoint, SOAPBinding.SOAP12HTTP_BINDING, ""http://localhost:19000/CalculatorService/SoapPort"");
    CalculatorPortType port = service.getPort(endpoint, CalculatorPortType.class);
    ClientProxy.getClient(port).getInInterceptors().add(new LoggingInInterceptor());
    ClientProxy.getClient(port).getOutInterceptors().add(new LoggingOutInterceptor());
    MultiClientThread[] clients = new MultiClientThread[2];
    for (int i = 0; i < clients.length; i++) {
        clients[i] = new MultiClientThread(port, i);
    }
    for (int i = 0; i < clients.length; i++) {
        clients[i].start();
        Thread.sleep(2000);
    }
    for (int i = 0; i < clients.length; i++) {
        clients[i].join();
        assertEquals(clients[i].getResult(), ""20"");
    }
}"
"@Test public void primitiveBooleans() throws Exception {
    assertThat(testResult(PrimitiveBooleans.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveBooleans.iterations);
    assertEquals(true,PrimitiveBooleans.values.get(0));
    assertEquals(new HashSet<>(asList(true,false)),new HashSet<>(PrimitiveBooleans.values));
    PrimitiveBooleans.iterations=0;
}"
"@Test
public void testKmeansSVD() throws Exception {
    DistanceMeasure measure = new EuclideanDistanceMeasure();
    Path output = getTestTempDirPath(""output"");
    Path tmp = getTestTempDirPath(""tmp"");
    DistributedLanczosSolver solver = new DistributedLanczosSolver();
    Configuration conf = new Configuration();
    solver.setConf(conf);
    Path testData = getTestTempDirPath(""testdata"");
    int sampleDimension = sampleData.get(0).get().size();
    int desiredRank = 15;
    solver.run(testData, output, tmp, null, sampleData.size(), sampleDimension, false, desiredRank, 0.5, 0.0, true);
    Path cleanEigenvectors = new Path(output, EigenVerificationJob.CLEAN_EIGENVECTORS);
    Matrix a = new DenseMatrix(sampleData.size(), sampleDimension);
    int i = 0;
    for (VectorWritable vw : sampleData) {
        a.assignRow(i++, vw.get());
    }
    Matrix p = new DenseMatrix(39, desiredRank - 1);
    FileSystem fs = FileSystem.get(cleanEigenvectors.toUri(), conf);
    i = 0;
    for (VectorWritable value : new SequenceFileValueIterable<VectorWritable>(cleanEigenvectors, conf)) {
        Vector v = value.get();
        p.assignColumn(i, v);
        i++;
    }
    Matrix sData = a.times(p);
    Path svdData = new Path(output, ""svddata"");
    SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, svdData, IntWritable.class, VectorWritable.class);
    try {
        IntWritable key = new IntWritable();
        VectorWritable value = new VectorWritable();
        for (int row = 0; row < sData.numRows(); row++) {
            key.set(row);
            value.set(sData.viewRow(row));
            writer.append(key, value);
        }
    } finally {
        Closeables.closeQuietly(writer);
    }
    CanopyDriver.run(conf, svdData, output, measure, 8, 4, false, 0.0, true);
    KMeansDriver.run(svdData, new Path(output, ""clusters-0""), output, measure, 0.001, 10, true, true);
    ClusterDumper clusterDumper = new ClusterDumper(finalClusterPath(conf, output, 10), new Path(output, ""clusteredPoints""));
    clusterDumper.printClusters(termDictionary);
}"
"@Test(timeout=10000) public void testTaskProgress() throws Exception {
    statusUpdateTimes=0;
    JobConf job=new JobConf();
    job.setLong(MRJobConfig.TASK_PROGRESS_REPORT_INTERVAL,1000);
    Task task=new DummyTask();
    task.setConf(job);
    DummyTaskReporter reporter=new DummyTaskReporter(task);
    Thread t=new Thread(reporter);
    t.start();
    Thread.sleep(2100);
    task.setTaskDone();
    reporter.resetDoneFlag();
    t.join();
    assertThat(statusUpdateTimes).isEqualTo(2);
}"
"@Test
public void testConsumerClose() throws Exception {
    StubConnection connection1 = createConnection();
    ConnectionInfo connectionInfo1 = createConnectionInfo();
    SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
    ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
    connection1.send(connectionInfo1);
    connection1.send(sessionInfo1);
    connection1.send(producerInfo1);
    ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
    consumerInfo1.setPrefetchSize(100);
    consumerInfo1.setNoLocal(true);
    connection1.request(consumerInfo1);
    StubConnection connection2 = createConnection();
    ConnectionInfo connectionInfo2 = createConnectionInfo();
    SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
    ProducerInfo producerInfo2 = createProducerInfo(sessionInfo2);
    connection2.send(connectionInfo2);
    connection2.send(sessionInfo2);
    connection2.send(producerInfo2);
    connection2.send(createMessage(producerInfo2, destination, deliveryMode));
    connection2.send(createMessage(producerInfo2, destination, deliveryMode));
    connection2.send(createMessage(producerInfo2, destination, deliveryMode));
    connection2.send(createMessage(producerInfo2, destination, deliveryMode));
    for (int i = 0; i < 4; i++) {
        Message m1 = receiveMessage(connection1);
        assertNotNull(m1);
        connection1.send(createAck(consumerInfo1, m1, 1, STANDARD_ACK_TYPE));
    }
    connection1.request(closeConsumerInfo(consumerInfo1));
    connection2.request(createMessage(producerInfo2, destination, deliveryMode));
    assertNull(connection1.getDispatchQueue().poll(MAX_NULL_WAIT, TimeUnit.MILLISECONDS));
}"
"@Test public void manyParameters(){
    assertThat(testResult(ManyParameters.class),isSuccessful());
    assertEquals(6,ManyParameters.iterations);
    assertEquals(asList(-4,-2,-1,-4,-2,-1),ManyParameters.firstTestCases);
    assertEquals(asList('r','r','r','y','y','y'),ManyParameters.secondTestCases);
    ManyParameters.iterations=0;
    ManyParameters.firstTestCases.clear();
    ManyParameters.secondTestCases.clear();
}"
"@Test public void TestMultiTailedPostDom(){
    Node n1=new Node(1);
    Node n2=new Node(2);
    Node n3=new Node(3);
    Node n4=new Node(4);
    Node n5=new Node(5);
    Node n6=new Node(6);
    n1.addkid(n2).addkid(n3);
    n3.addkid(n4).addkid(n5);
    n4.addkid(n6);
    n5.addkid(n6);
    Graph g=new Graph(n1);
    MHGDominatorsFinder<Node> finder=new MHGDominatorsFinder<Node>(g);
    MHGDominatorTree<Node> tree=new MHGDominatorTree<Node>(finder);
    assertThat(tree.getHeads().size(),is(1));
    DominatorNode<Node> n=tree.getHeads().get(0);
    assertThat(n.getGode().id,is(1));
    Set<Integer> kids=kid_ids(n);
    assertThat(kids.size(),is(2));
    assertThat(kids,containsInAnyOrder(2,3));
    Map<Integer,DominatorNode<Node>> KM=kid_map(n);
    DominatorNode<Node> m=KM.get(2);
    kids=kid_ids(m);
    assertThat(kids.size(),is(0));
    n=KM.get(3);
    kids=kid_ids(n);
    assertThat(kids.size(),is(3));
    assertThat(kids,containsInAnyOrder(4,5,6));
    KM=kid_map(n);
    m=KM.get(4);
    kids=kid_ids(m);
    assertThat(kids.size(),is(0));
    m=KM.get(5);
    kids=kid_ids(m);
    assertThat(kids.size(),is(0));
    m=KM.get(6);
    kids=kid_ids(m);
    assertThat(kids.size(),is(0));
    MHGPostDominatorsFinder<Node> pfinder=new MHGPostDominatorsFinder<Node>(g);
    tree=new MHGDominatorTree<Node>(pfinder);
    Map<Integer,DominatorNode<Node>> heads=new HashMap<Integer,DominatorNode<Node>>();
    for (  DominatorNode<Node> dhead : tree.getHeads()) {
        Node head=dhead.getGode();
        heads.put(head.id,dhead);
    }
    Set<Integer> head_ids=heads.keySet();
    assertThat(head_ids.size(),is(3));
    assertThat(head_ids,containsInAnyOrder(1,2,6));
    m=heads.get(1);
    kids=kid_ids(m);
    assertThat(kids.size(),is(0));
    m=heads.get(2);
    kids=kid_ids(m);
    assertThat(kids.size(),is(0));
    n=heads.get(6);
    kids=kid_ids(n);
    assertThat(kids.size(),is(3));
    assertThat(kids,containsInAnyOrder(3,4,5));
    KM=kid_map(n);
    m=KM.get(3);
    kids=kid_ids(m);
    assertThat(kids.size(),is(0));
    m=KM.get(4);
    kids=kid_ids(m);
    assertThat(kids.size(),is(0));
    m=KM.get(5);
    kids=kid_ids(m);
    assertThat(kids.size(),is(0));
}"
"@Test
public void testFlowNoConflictsWithClients() throws Exception {
    startComputation(0, stopFlag0);
    if (!tcpDiscovery())
    return;
    startComputation(1, stopFlag1);
    startComputation(2, stopFlag2);
    startComputation(3, stopFlag3);
    startComputation(4, stopFlag4);
    final Set<Integer> deafClientObservedIds = new ConcurrentHashSet<>();
    startListening(5, true, deafClientObservedIds);
    final Set<Integer> regClientObservedIds = new ConcurrentHashSet<>();
    startListening(6, false, regClientObservedIds);
    START_LATCH.countDown();
    Thread killer = new Thread(new ServerNodeKiller());
    Thread resurrection = new Thread(new ServerNodeResurrection());
    killer.setName(""node-killer-thread"");
    killer.start();
    resurrection.setName(""node-resurrection-thread"");
    resurrection.start();
    while (!updatesQueue.isEmpty())
    Thread.sleep(1000);
    killer.interrupt();
    resurrection.interrupt();
}"
"@Test public void primitiveDoubles() throws Exception {
    assertThat(testResult(PrimitiveDoubles.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveDoubles.iterations);
    assertEquals(new HashSet<>(asList(3.2,-4D)),new HashSet<>(PrimitiveDoubles.values.subList(0,2)));
    PrimitiveDoubles.iterations=0;
}"
"public void test_for_multimap() throws Exception {
    ArrayListMultimap<String,Integer> multimap=ArrayListMultimap.create();
    multimap.putAll(""b"",Ints.asList(2,4,6));
    multimap.putAll(""a"",Ints.asList(4,2,1));
    multimap.putAll(""c"",Ints.asList(2,5,3));
    String json=JSON.toJSONString(multimap,SerializerFeature.MapSortField);
    assertEquals(""{\""a\"":[4,2,1],\""b\"":[2,4,6],\""c\"":[2,5,3]}"",json);
    TreeMultimap treeMultimap=TreeMultimap.create(multimap);
    String json2=JSON.toJSONString(treeMultimap);
    assertEquals(""{\""a\"":[1,2,4],\""b\"":[2,4,6],\""c\"":[2,3,5]}"",json2);
}"
"@Test
void nullAndObjectValuesInMap() {
    Map<String, Object> queryParams = new HashMap<>();
    queryParams.put(""foo"", null);
    queryParams.put(""baz"", ""qux"");
    Unirest.get(GET).queryString(queryParams).asObject(RequestCapture.class).getBody().assertParam(""foo"", """").assertParam(""baz"", ""qux"").assertQueryString(""foo&baz=qux"");
}"
"@Test
public void shouldBeAbleToCancelJob() throws Exception {
    RobustJobSchedulerWrapper robustWrapper = new RobustJobSchedulerWrapper(actualScheduler, log);
    AtomicInteger count = new AtomicInteger();
    JobHandle jobHandle = robustWrapper.scheduleRecurring(""JobName"", 1, count::incrementAndGet);
    assertEventually(""run count"", count::get, Matchers.greaterThanOrEqualTo(100), DEFAULT_TIMEOUT_MS, MILLISECONDS);
    robustWrapper.cancelAndWaitTermination(jobHandle);
    int finalCount = count.get();
    Thread.sleep(50);
    assertEquals(finalCount, count.get());
}"
"@Test
public class Test {
    @Test(timeout = 300000)
    public void testRSSplitEphemeralsDisappearButDaughtersAreOnlinedAfterShutdownHandling() throws IOException, InterruptedException, NodeExistsException, KeeperException {
        final byte[] tableName = Bytes.toBytes(""ephemeral"");
        HTable t = TESTING_UTIL.createTable(tableName, CATALOG_FAMILY);
        List<HRegion> regions = cluster.getRegions(tableName);
        HRegionInfo hri = getAndCheckSingleTableRegion(regions);
        int tableRegionIndex = ensureTableRegionNotOnSameServerAsMeta(admin, hri);
        this.admin.setBalancerRunning(false, true);
        cluster.getMaster().setCatalogJanitorEnabled(false);
        try {
            TESTING_UTIL.loadTable(t, CATALOG_FAMILY);
            HRegionServer server = cluster.getRegionServer(tableRegionIndex);
            printOutRegions(server, ""Initial regions: "");
            int regionCount = server.getOnlineRegions().size();
            SplitRegionHandler.TEST_SKIP = true;
            split(hri, server, regionCount);
            List<HRegion> daughters = cluster.getRegions(tableName);
            assertTrue(daughters.size() >= 2);
            String path = ZKAssign.getNodeName(t.getConnection().getZooKeeperWatcher(), hri.getEncodedName());
            Stat stats = t.getConnection().getZooKeeperWatcher().getRecoverableZooKeeper().exists(path, false);
            LOG.info(((""EPHEMERAL NODE BEFORE SERVER ABORT, path="" + path) + "", stats="") + stats);
            RegionTransitionData rtd = ZKAssign.getData(t.getConnection().getZooKeeperWatcher(), hri.getEncodedName());
            assertTrue(rtd.getEventType().equals(RS_ZK_REGION_SPLIT) || rtd.getEventType().equals(RS_ZK_REGION_SPLITTING));
            cluster.abortRegionServer(tableRegionIndex);
            waitUntilRegionServerDead();
            while (cluster.getRegions(tableName).size() < daughters.size()) {
                LOG.info(""Waiting for repair to happen"");
                Thread.sleep(1000);
            }
            regions = cluster.getRegions(tableName);
            for (HRegion r : regions) {
                assertTrue(daughters.contains(r));
            }
            stats = t.getConnection().getZooKeeperWatcher().getRecoverableZooKeeper().exists(path, false);
            LOG.info(((""EPHEMERAL NODE AFTER SERVER ABORT, path="" + path) + "", stats="") + stats);
            assertTrue(stats == null);
        } finally {
            SplitRegionHandler.TEST_SKIP = false;
            admin.setBalancerRunning(true, false);
            cluster.getMaster().setCatalogJanitorEnabled(true);
        }
    }
}"
"@Test public void orderingOfStatements(){
    assertThat(testResult(PropertyBasedTests.class),failureCountIs(1));
    assertEquals(expectedStatements,PropertyBasedTests.LOGS);
    PropertyBasedTests.clearLogs();
}"
"@Test
public void testLogicalTypePreviewRun(Engine engine) throws Exception {
    PreviewManager previewManager = getPreviewManager();
    String sourceTableName = ""singleInput"";
    String sinkTableName = ""singleOutput"";
    Schema schema = Schema.recordOf(
    ""testRecord"",
    Schema.Field.of(""name"", Schema.of(Schema.Type.STRING)),
    Schema.Field.of(""date"", Schema.of(Schema.LogicalType.DATE)),
    Schema.Field.of(""ts"", Schema.of(Schema.LogicalType.TIMESTAMP_MILLIS))
    );
    ETLBatchConfig etlConfig = ETLBatchConfig.builder()
    .addStage(new ETLStage(""source"", MockSource.getPlugin(sourceTableName, schema)))
    .addStage(new ETLStage(""transform"", IdentityTransform.getPlugin()))
    .addStage(new ETLStage(""sink"", MockSink.getPlugin(sinkTableName)))
    .addConnection(""source"", ""transform"")
    .addConnection(""transform"", ""sink"")
    .setEngine(engine)
    .setNumOfRecordsPreview(100)
    .build();
    PreviewConfig previewConfig = new PreviewConfig(SmartWorkflow.NAME, ProgramType.WORKFLOW,
    Collections.<String, String>emptyMap(), 10);
    addDatasetInstance(Table.class.getName(), sourceTableName,
    DatasetProperties.of(ImmutableMap.of(""schema"", schema.toString())));
    DataSetManager<Table> inputManager = getDataset(NamespaceId.DEFAULT.dataset(sourceTableName));
    ZonedDateTime expectedMillis = ZonedDateTime.of(2018, 11, 11, 11, 11, 11, 123 * 1000 * 1000,
    ZoneId.ofOffset(""UTC"", ZoneOffset.UTC));
    StructuredRecord recordSamuel = StructuredRecord.builder(schema).set(""name"", ""samuel"")
    .setDate(""date"", LocalDate.of(2002, 11, 18)).setTimestamp(""ts"", expectedMillis).build();
    StructuredRecord recordBob = StructuredRecord.builder(schema).set(""name"", ""bob"")
    .setDate(""date"", LocalDate.of(2003, 11, 18)).setTimestamp(""ts"", expectedMillis).build();
    MockSource.writeInput(inputManager, ImmutableList.of(recordSamuel, recordBob));
    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(APP_ARTIFACT_RANGE, etlConfig, previewConfig);
    ApplicationId previewId = previewManager.start(NamespaceId.DEFAULT, appRequest);
    Tasks.waitFor(PreviewStatus.Status.COMPLETED, new Callable<PreviewStatus.Status>() {
        @Override
        public PreviewStatus.Status call() throws Exception {
            PreviewStatus status = previewManager.getStatus(previewId);
            return status == null ? null : status.getStatus();
        }
    }, 5, TimeUnit.MINUTES);
    checkPreviewStore(previewManager, previewId, ""source"", 2);
    List<JsonElement> data = previewManager.getData(previewId, ""source"").get(DATA_TRACER_PROPERTY);
    StructuredRecord actualRecordSamuel = GSON.fromJson(data.get(0), StructuredRecord.class);
    Assert.assertEquals(actualRecordSamuel.get(""date""), ""2002-11-18"");
    Assert.assertEquals(actualRecordSamuel.get(""ts""), ""2018-11-11T11:11:11.123Z[UTC]"");
    StructuredRecord actualRecordBob = GSON.fromJson(data.get(1), StructuredRecord.class);
    Assert.assertEquals(actualRecordBob.get(""date""), ""2003-11-18"");
    Assert.assertEquals(actualRecordBob.get(""ts""), ""2018-11-11T11:11:11.123Z[UTC]"");
    checkPreviewStore(previewManager, previewId, ""transform"", 2);
    checkPreviewStore(previewManager, previewId, ""sink"", 2);
    validateMetric(2, previewId, ""source.records.in"", previewManager);
    validateMetric(2, previewId, ""source.records.out"", previewManager);
    validateMetric(2, previewId, ""transform.records.in"", previewManager);
    validateMetric(2, previewId, ""transform.records.out"", previewManager);
    validateMetric(2, previewId, ""sink.records.out"", previewManager);
    validateMetric(2, previewId, ""sink.records.in"", previewManager);
    DataSetManager<Table> sinkManager = getDataset(sinkTableName);
    Assert.assertNull(sinkManager.get());
    deleteDatasetInstance(NamespaceId.DEFAULT.dataset(sourceTableName));
    Assert.assertNotNull(previewManager.getRunId(previewId));
}"
"@Test
public void testBind() throws Exception {
    Name name = new CompositeName(""test"");
    final Object value = new Object();
    namingContext.bind(name, value);
    assertEquals(value, namingStore.lookup(name));
    name = new CompositeName(""securitytest"");
    testActionPermission(JndiPermission.ACTION_BIND, namingContext, ""securitytest"", value);
    assertEquals(value, namingStore.lookup(name));
}"
"@Test public void wrapperDoubles() throws Exception {
    assertThat(testResult(WrapperDoubles.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperDoubles.iterations);
    WrapperDoubles.iterations=0;
}"
"@Test
public void testSchedulingWithDueTime() throws InterruptedException {
    final CountDownLatch latch = new CountDownLatch(5);
    final AtomicInteger counter = new AtomicInteger();
    long start = System.currentTimeMillis();
    Schedulers.threadPoolForComputation().schedule(null, new Func2<Scheduler, String, Subscription>() {
        @Override
        public Subscription call(Scheduler scheduler, String state) {
            System.out.println(""doing work"");
            latch.countDown();
            counter.incrementAndGet();
            if (latch.getCount() == 0) {
                return Subscriptions.empty();
            } else {
                return scheduler.schedule(state, this, new Date(System.currentTimeMillis() + 50));
            }
        }
    }, new Date(System.currentTimeMillis() + 100));
    if (!latch.await(3000, TimeUnit.MILLISECONDS)) {
        fail(""didn't execute ... timed out"");
    }
    long end = System.currentTimeMillis();
    assertEquals(5, counter.get());
    if ((end - start) < 250) {
        fail(""it should have taken over 250ms since each step was scheduled 50ms in the future"");
    }
}"
"@Test
public void testDeserializeExtend() {
    String tcpString = ""{\""type\"":\""TEST\"",\""testValue\"":null}"";
    AbstractHealthChecker actual = HealthCheckerFactory.deserialize(tcpString);
    assertEquals(TestChecker.class, actual.getClass());
}"
"@Test
public void testAppWithServices() throws Exception {
    ApplicationManager applicationManager = deployApplication(AppWithServices.class);
    LOG.info(""Deployed."");
    ServiceManager serviceManager = applicationManager.getServiceManager(AppWithServices.SERVICE_NAME).start();
    serviceManager.waitForStatus(true);
    LOG.info(""Service Started"");
    URL serviceURL = serviceManager.getServiceURL(15, TimeUnit.SECONDS);
    Assert.assertNotNull(serviceURL);
    URL url = new URL(serviceURL, ""ping2"");
    HttpRequest request = HttpRequest.get(url).build();
    HttpResponse response = HttpRequests.execute(request);
    Assert.assertEquals(200, response.getResponseCode());
    url = new URL(serviceURL, ""failure"");
    request = HttpRequest.get(url).build();
    response = HttpRequests.execute(request);
    Assert.assertEquals(500, response.getResponseCode());
    Assert.assertTrue(response.getResponseBodyAsString().contains(""Exception""));
    url = new URL(serviceURL, ""verifyClassLoader"");
    request = HttpRequest.get(url).build();
    response = HttpRequests.execute(request);
    Assert.assertEquals(200, response.getResponseCode());
    RuntimeMetrics serviceMetrics = serviceManager.getMetrics();
    serviceMetrics.waitForinput(3, 5, TimeUnit.SECONDS);
    Assert.assertEquals(3, serviceMetrics.getInput());
    Assert.assertEquals(2, serviceMetrics.getProcessed());
    Assert.assertEquals(1, serviceMetrics.getException());
    RuntimeMetrics handlerMetrics = getMetricsManager().getServiceHandlerMetrics(Id.Namespace.DEFAULT.getId(),
    AppWithServices.APP_NAME,
    AppWithServices.SERVICE_NAME,
    AppWithServices.SERVICE_NAME);
    handlerMetrics.waitForinput(3, 5, TimeUnit.SECONDS);
    Assert.assertEquals(3, handlerMetrics.getInput());
    Assert.assertEquals(2, handlerMetrics.getProcessed());
    Assert.assertEquals(1, handlerMetrics.getException());
    LOG.info(""DatasetUpdateService Started"");
    Map<String, String> args
    = ImmutableMap.of(AppWithServices.WRITE_VALUE_RUN_KEY, AppWithServices.DATASET_TEST_VALUE,
    AppWithServices.WRITE_VALUE_STOP_KEY, AppWithServices.DATASET_TEST_VALUE_STOP);
    ServiceManager datasetWorkerServiceManager = applicationManager
    .getServiceManager(AppWithServices.DATASET_WORKER_SERVICE_NAME).start(args);
    WorkerManager datasetWorker =
    applicationManager.getWorkerManager(AppWithServices.DATASET_UPDATE_WORKER).start(args);
    datasetWorkerServiceManager.waitForStatus(true);
    ServiceManager noopManager = applicationManager.getServiceManager(""NoOpService"").start();
    serviceManager.waitForStatus(true, 2, 1);
    String result = callServiceGet(noopManager.getServiceURL(), ""ping/"" + AppWithServices.DATASET_TEST_KEY);
    String decodedResult = new Gson().fromJson(result, String.class);
    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE, decodedResult);
    handlerMetrics = getMetricsManager().getServiceHandlerMetrics(Id.Namespace.DEFAULT.getId(),
    AppWithServices.APP_NAME,
    ""NoOpService"",
    ""NoOpHandler"");
    handlerMetrics.waitForinput(1, 5, TimeUnit.SECONDS);
    Assert.assertEquals(1, handlerMetrics.getInput());
    Assert.assertEquals(1, handlerMetrics.getProcessed());
    Assert.assertEquals(0, handlerMetrics.getException());
    String path = String.format(""discover/%s/%s"",
    AppWithServices.APP_NAME, AppWithServices.DATASET_WORKER_SERVICE_NAME);
    url = new URL(serviceURL, path);
    request = HttpRequest.get(url).build();
    response = HttpRequests.execute(request);
    Assert.assertEquals(200, response.getResponseCode());
    datasetWorker.stop();
    datasetWorkerServiceManager.stop();
    datasetWorkerServiceManager.waitForStatus(false);
    LOG.info(""DatasetUpdateService Stopped"");
    serviceManager.stop();
    serviceManager.waitForStatus(false);
    LOG.info(""ServerService Stopped"");
    result = callServiceGet(noopManager.getServiceURL(), ""ping/"" + AppWithServices.DATASET_TEST_KEY_STOP);
    decodedResult = new Gson().fromJson(result, String.class);
    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE_STOP, decodedResult);
    result = callServiceGet(noopManager.getServiceURL(), ""ping/"" + AppWithServices.DATASET_TEST_KEY_STOP_2);
    decodedResult = new Gson().fromJson(result, String.class);
    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE_STOP_2, decodedResult);
}"
"@Test
public void testAsyncFunction() throws Exception {
    InstanceConfig instanceConfig = new InstanceConfig();
    Function<String, CompletableFuture<String>> function = (input, context) -> {
        log.info(""input string: {}"", input);
        CompletableFuture<String> result  = new CompletableFuture<>();
        Executors.newCachedThreadPool().submit(() -> {
            try {
                Thread.sleep(500);
                result.complete(String.format(""%s-lambda"", input));
            } catch (Exception e) {
                result.completeExceptionally(e);
            }
        });
        return result;
    };
    JavaInstance instance = new JavaInstance(
    mock(ContextImpl.class),
    function,
    instanceConfig);
    String testString = ""ABC123"";
    CompletableFuture<JavaExecutionResult> result = instance.handleMessage(mock(Record.class), testString);
    assertNotNull(result.get().getResult());
    assertEquals(new String(testString + ""-lambda""), result.get().getResult());
    instance.close();
}"
"@Test public void test2_2() throws Exception {
    String jsonStr=""[{\""name\"":\""p1\"",\""sonList\"":[{\""name\"":\""s1\""}]},{\""name\"":\""p2\"",\""sonList\"":[{\""name\"":\""s2\""},{\""name\"":\""s3\""}]}]"";
    ResultActions actions=mockMvc.perform((post(""/fastjson/test2?jsonp=fnUpdateSome"").characterEncoding(""UTF-8"").content(jsonStr).contentType(MediaType.APPLICATION_JSON)));
    actions.andDo(print());
    actions.andExpect(status().isOk()).andExpect(content().contentType(APPLICATION_JAVASCRIPT));
    String content=actions.andReturn().getResponse().getContentAsString();
    assertTrue(content.equals(""/**/fnUpdateSome({\""p1\"":1,\""p2\"":2})"") || content.equals(""/**/fnUpdateSome({\""p2\"":2,\""p1\"":1})""));
}"
"@Test
public void testBacklogLimiter() {
    long duration = runWithRate(2 * RateLimiting.DEFAULT_MAX_PARALLELISM,-1.0 , new DelayFn<Integer>());
    Assert.assertThat(duration,greaterThan(2 * DelayFn.DELAY_MS));
}"
"@Test
public void iterableOfIterator() {
    Iterator<Object> mockIterator = mock(Iterator.class, ""MockIterator"");
    when(mockIterator.hasNext()).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(false);
    when(mockIterator.next()).thenReturn(1).thenReturn(2).thenReturn(3).thenThrow(new NoSuchElementException(""Iterator exhausted""));
    Iterable<Object> iterable = CollectionUtils.iterable(mockIterator);
    assertThat(iterable).isNotNull();
    Set<Object> set = new HashSet<>();
    iterable.forEach(set::add);
    assertThat(set).hasSize(3);
    assertThat(set).containsExactly(1, 2, 3);
    verify(mockIterator, times(4)).hasNext();
    verify(mockIterator, times(3)).next();
}"
"@Test
public void testStopTimer_withCleanUp() throws InterruptedException {
    TestTimeLimitExceededListener listenerSpy = spy(mListener);
    mWorkTimer.startTimer(WORKSPEC_ID_1, 100, listenerSpy);
    mWorkTimer.stopTimer(WORKSPEC_ID_1);
    Thread.sleep(100);
    verify(listenerSpy, times(0)).onTimeLimitExceeded(WORKSPEC_ID_1);
    assertThat(mWorkTimer.getTimerMap().size(), is(0));
    assertThat(mWorkTimer.getListeners().size(), is(0));
}"
"@Test
public void testRender_ok() {
    final Mock mockResponse = mock(RenderResponse.class);
    mockResponse.stubs().method(ANYTHING);
    PortletMode mode = PortletMode.VIEW;
    Map<String, String[]> requestParams = new HashMap<String, String[]>();
    requestParams.put(ACTION_PARAM, new String[]{""/view/testAction""});
    requestParams.put(EVENT_ACTION, new String[]{""true""});
    requestParams.put(MODE_PARAM, new String[]{mode.toString()});
    Map<String, Object> sessionMap = new HashMap<String, Object>();
    Map<String, String> initParams = new HashMap<String, String>();
    initParams.put(""viewNamespace"", ""/view"");
    initParams.put(StrutsConstants.STRUTS_ALWAYS_SELECT_FULL_NAMESPACE, ""true"");
    initPortletConfig(initParams, new HashMap<String, Object>());
    initRequest(requestParams, new HashMap<String, Object>(), sessionMap, PortletMode.VIEW, WindowState.NORMAL, false, null);
    setupActionFactory(""/view"", ""testAction"", ""success"", EasyMock.createNiceMock(ValueStack.class));
    mockInvocation.expects(once()).method(""getStack"").will(
    returnValue(null));
    try {
        dispatcher
        .setActionProxyFactory((ActionProxyFactory) mockActionFactory
        .proxy());
        dispatcher.init((PortletConfig) mockConfig.proxy());
        dispatcher.render((RenderRequest) mockRequest.proxy(),
        (RenderResponse) mockResponse.proxy());
    } catch (Exception e) {
        e.printStackTrace();
        fail(""Error occured"");
    }
}"
"@Test
public void testDoNotPurgeRPCTask() throws Exception {
    int RPCTaskNums = 10;
    TaskMonitor tm = TaskMonitor.get();
    for(int i = 0; i < RPCTaskNums; i++) {
        tm.createRPCStatus(""PRCTask"" + i);
    }
    for(int i = 0; i < TaskMonitor.DEFAULT_MAX_TASKS; i++) {
        tm.createStatus(""otherTask"" + i);
    }
    int remainRPCTask = 0;
    for(MonitoredTask task: tm.getTasks()) {
        if(task instanceof MonitoredRPCHandler) {
            remainRPCTask++;
        }
    }
    assertEquals(""RPC Tasks have been purged!"", RPCTaskNums, remainRPCTask);
    tm.shutdown();
}"
"@Test
@LargeTest
public void testTimer_withListenerAndCleanUp() throws InterruptedException {
    TestTimeLimitExceededListener listenerSpy = spy(mListener);
    mWorkTimer.startTimer(WORKSPEC_ID_1, 0, listenerSpy);
    Thread.sleep(10);
    verify(listenerSpy, times(1)).onTimeLimitExceeded(WORKSPEC_ID_1);
    assertThat(mWorkTimer.getTimerMap().size(), is(0));
    assertThat(mWorkTimer.getListeners().size(), is(0));
}"
"@Test
void shouldCompleteLogWhenCancelledByClient(SessionProtocol protocol) {
    final ClientFactory factory = ClientFactory.builder().build();
    final WebClient client = WebClient.builder(server.uri(protocol)).factory(factory).build();
    final CompletableFuture<AggregatedHttpResponse> responseFuture = client.get(""/reset"").aggregate();
    await().untilAtomic(ctxRef, Matchers.notNullValue());
    factory.close();
    final RequestLog log = ctxRef.get().log().whenComplete().join();
    if (protocol.isMultiplex()) {
        assertThat(log.responseCause()).isInstanceOf(ClosedStreamException.class).hasMessageContaining(""received a RST_STREAM frame: CANCEL"");
        assertThatThrownBy(responseFuture::join).isInstanceOf(CompletionException.class).hasCauseInstanceOf(ClosedStreamException.class);
    } else {
        assertThat(log.responseCause()).isInstanceOf(ClosedSessionException.class);
        assertThatThrownBy(responseFuture::join).isInstanceOf(CompletionException.class).hasCauseInstanceOf(ClosedSessionException.class);
    }
}"
"@Test
public void serverStatusUnthrottledIfJournalUtilizationIsLowerThanThreshold() throws Exception {
    serverStatus.throttle();
    final Size segmentSize = Size.kilobytes(1L);
    final KafkaJournal journal = new KafkaJournal(journalDirectory, scheduler, segmentSize, Duration.standardSeconds(1L), Size.kilobytes(4L), Duration.standardSeconds(1L), 1000000, Duration.standardSeconds(1L), 90, new MetricRegistry(), serverStatus);
    journal.flushDirtyLogs();
    journal.cleanupLogs();
    assertThat(serverStatus.getLifecycle()).isEqualTo(RUNNING);
}"
"public void test_for_issue(){
    VO vo=new VO();
    vo.id=123;
    vo.location=new Location(127,37);
    Object obj=JSON.toJSON(vo);
    String text=JSON.toJSONString(obj,SerializerFeature.MapSortField);
    assertEquals(""{\""id\"":123,\""latitude\"":37,\""longitude\"":127}"",text);
}"
"public void test_for_issue(){
    Issue2428 demoBean=new Issue2428();
    demoBean.setMyName(""test name"");
    demoBean.setNestedBean(new NestedBean(""test id""));
    String text=JSON.toJSONString(JSON.toJSON(demoBean),SerializerFeature.MapSortField);
    assertEquals(""{\""myName\"":\""test name\"",\""nestedBean\"":{\""myId\"":\""test id\""}}"",text);
    SerializeConfig serializeConfig=new SerializeConfig();
    serializeConfig.propertyNamingStrategy=PropertyNamingStrategy.SnakeCase;
    text=JSON.toJSONString(JSON.toJSON(demoBean,serializeConfig),SerializerFeature.MapSortField);
    assertEquals(""{\""my_name\"":\""test name\"",\""nested_bean\"":{\""my_id\"":\""test id\""}}"",text);
}"
"@Test public void canFlatten() throws Exception {
    Foo foo=new Foo();
    foo.bar=""hello.world"";
    foo.baz=new ArrayList<>();
    foo.baz.add(""hello"");
    foo.baz.add(""hello.world"");
    foo.qux=new HashMap<>();
    foo.qux.put(""hello"",""world"");
    foo.qux.put(""a.b"",""c.d"");
    foo.qux.put(""bar.a"",""ttyy"");
    foo.qux.put(""bar.b"",""uuzz"");
    JacksonAdapter adapter=new JacksonAdapter();
    String serialized=adapter.serialize(foo);
    String expected=""{\""$type\"":\""foo\"",\""properties\"":{\""bar\"":\""hello.world\"",\""props\"":{\""baz\"":[\""hello\"",\""hello.world\""],\""q\"":{\""qux\"":{\""hello\"":\""world\"",\""a.b\"":\""c.d\"",\""bar.b\"":\""uuzz\"",\""bar.a\"":\""ttyy\""}}}}}"";
    assertJsonEqualsNonStrict(expected,serialized);
    Foo deserialized=adapter.deserialize(serialized,Foo.class);
    Assert.assertEquals(""hello.world"",deserialized.bar);
    Assert.assertArrayEquals(new String[]{""hello"",""hello.world""},deserialized.baz.toArray());
    Assert.assertNotNull(deserialized.qux);
    Assert.assertEquals(""world"",deserialized.qux.get(""hello""));
    Assert.assertEquals(""c.d"",deserialized.qux.get(""a.b""));
    Assert.assertEquals(""ttyy"",deserialized.qux.get(""bar.a""));
    Assert.assertEquals(""uuzz"",deserialized.qux.get(""bar.b""));
}"
"@Test public void wrapperBytes() throws Exception {
    assertThat(testResult(WrapperBytes.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperBytes.iterations);
    WrapperBytes.iterations=0;
}"
"@Test public void primitiveShorts(){
    assertThat(testResult(PrimitiveShorts.class),isSuccessful());
    assertEquals(2,PrimitiveShorts.iterations);
    assertEquals(new HashSet<>(asList(Short.valueOf(""9""),Short.valueOf(""8""))),PrimitiveShorts.testCases);
    PrimitiveShorts.iterations=0;
    PrimitiveShorts.testCases.clear();
}"
"@Test
public void testLookup() throws Exception {
    final Name name = new CompositeName(""test"");
    final Object object = new Object();
    namingStore.bind(name, object);
    Object result = namingContext.lookup(name);
    assertEquals(object, result);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, ""test"");
    assertEquals(object, result);
}"
"@Test public void twin() throws Exception {
    final ObjectMapper mapper=mapperWithModule();
    Object sampleOne=randomSample(Object.class);
    Object sampleTwo=randomSample(Object.class);
    String expectedJson1=""{\""one\"":"" + mapper.writeValueAsString(sampleOne) + "",\""two\"":""+ mapper.writeValueAsString(sampleTwo)+ ""}"";
    String expectedJson2=""{\""two\"":"" + mapper.writeValueAsString(sampleTwo) + "",\""one\"":""+ mapper.writeValueAsString(sampleOne)+ ""}"";
    Twin<String> twin=Tuples.twin((String)sampleOne,(String)sampleTwo);
    String writeValue=mapper.writeValueAsString(twin);
    boolean assert1=writeValue.equals(expectedJson1);
    boolean assert2=writeValue.equals(expectedJson2);
    Assert.assertTrue(assert1 || assert2);
    Assert.assertEquals(twin,mapper.readValue(expectedJson1,new TypeReference<Twin<String>>(){
    }
    ));
}"
"@Test
public void testHFileLink() throws IOException {
    final String columnFamily = ""f"";
    HRegionInfo hri = new HRegionInfo(Bytes.toBytes(""table-link""));
    Path storedir = new Path(new Path(FSUtils.getRootDir(conf), new Path(hri.getTableNameAsString(), hri.getEncodedName())), columnFamily);
    StoreFile.Writer writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs, 8 * 1024).withOutputDir(storedir).build();
    Path storeFilePath = writer.getPath();
    writeStoreFile(writer);
    writer.close();
    Path dstPath = new Path(FSUtils.getRootDir(conf), new Path(""test-region"", columnFamily));
    HFileLink.create(conf, this.fs, dstPath, hri, storeFilePath.getName());
    Path linkFilePath = new Path(dstPath, HFileLink.createHFileLinkName(hri, storeFilePath.getName()));
    StoreFile hsf = new StoreFile(this.fs, linkFilePath, conf, cacheConf, BloomType.NONE, NoOpDataBlockEncoder.INSTANCE);
    assertTrue(hsf.isLink());
    int count = 1;
    HFileScanner s = hsf.createReader().getScanner(false, false);
    s.seekTo();
    while (s.next()) {
        count++;
    }
    assertEquals(((LAST_CHAR - FIRST_CHAR) + 1) * ((LAST_CHAR - FIRST_CHAR) + 1), count);
}"
"@Test public void primitiveFloats() throws Exception {
    assertThat(testResult(PrimitiveFloats.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveFloats.iterations);
    assertEquals(new HashSet<>(asList(3.3F,-5F)),new HashSet<>(PrimitiveFloats.values.subList(0,2)));
    PrimitiveFloats.iterations=0;
}"
"@Test
public void testListWithContinuation() throws Exception {
    bindListWithContinuations();
    NamingEnumeration<NameClassPair> results = namingContext.list(new CompositeName(""comp""));
    checkListWithContinuationsResults(results);
    results = (NamingEnumeration<NameClassPair>) testActionPermission(JndiPermission.ACTION_LIST, Arrays.asList(
    new JndiPermission(""test"", ""list"")), namingContext, ""comp"");
    checkListWithContinuationsResults(results);
}"
"@Test public void wrapperIntegers() throws Exception {
    assertThat(testResult(WrapperIntegers.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperIntegers.iterations);
    WrapperIntegers.iterations=0;
}"
"@Test
public void testPauseResume() throws Exception {
    PullPoint pullPoint = wsnCreatePullPoint.createPullPoint();
    Subscription subscription = wsnBroker.subscribe(pullPoint.getEndpoint(), ""myTopic"", null);
    wsnBroker.notify(""myTopic"", new Notify());
    Thread.sleep(500);
    assertEquals(1, pullPoint.getMessages(0).size());
    subscription.pause();
    wsnBroker.notify(""myTopic"", new Notify());
    Thread.sleep(500);
    assertEquals(0, pullPoint.getMessages(0).size());
    subscription.resume();
    wsnBroker.notify(""myTopic"", new Notify());
    Thread.sleep(500);
    assertEquals(1, pullPoint.getMessages(0).size());
    Thread.sleep(500);
}"
"@Test
public void testTransactionMetaStoreAssignAndFailover() throws IOException, InterruptedException {
    int transactionMetaStoreCount = 0;
    for (PulsarService pulsarService : pulsarServices) {
        transactionMetaStoreCount += pulsarService.getTransactionMetadataStoreService().getStores().size();
    }
    Assert.assertEquals(transactionMetaStoreCount, 16);
    PulsarService crashedMetaStore = null;
    for (int i = pulsarServices.length - 1; i >= 0; i--) {
        if (pulsarServices[i].getTransactionMetadataStoreService().getStores().size() > 0) {
            crashedMetaStore = pulsarServices[i];
            break;
        }
    }
    Assert.assertNotNull(crashedMetaStore);
    List<PulsarService> services = new ArrayList<>(pulsarServices.length - 1);
    for (PulsarService pulsarService : pulsarServices) {
        if (pulsarService != crashedMetaStore) {
            services.add(pulsarService);
        }
    }
    pulsarServices = new PulsarService[pulsarServices.length - 1];
    for (int i = 0; i < services.size(); i++) {
        pulsarServices[i] = services.get(i);
    }
    crashedMetaStore.close();
    Thread.sleep(3000);
    transactionMetaStoreCount = 0;
    for (PulsarService pulsarService : pulsarServices) {
        transactionMetaStoreCount += pulsarService.getTransactionMetadataStoreService().getStores().size();
    }
    Assert.assertEquals(transactionMetaStoreCount, 16);
    transactionCoordinatorClient.close();
}"
"@Test
public void testFromDbField() throws Exception {
    Field[] fields = Foo.class.getDeclaredFields();
    assertTrue(fields.length >= 1);
    DatabaseFieldConfig config = DatabaseFieldConfig.fromField(databaseType, ""foo"", fields[0]);
    assertNotNull(config);
    assertTrue(config.isCanBeNull());
    assertEquals(fields[0].getName(), config.getFieldName());
}"
"@Test
public void testLookupBinding() throws Exception {
    final ServiceName bindingName = ServiceName.JBOSS.append(""foo"", ""bar"");
    final Object value = new Object();
    bindObject(bindingName, value);
    final Object obj = store.lookup(new CompositeName(""foo/bar""));
    assertNotNull(obj);
    assertEquals(value, obj);
}"
"@Test public void testCloseReason() throws Exception {
    AnnotatedClientEndpoint.reset();
    MessageEndpoint.reset();
    Session session=deployment.connectToServer(AnnotatedClientEndpoint.class,new URI(""ws://"" + DefaultServer.getHostAddress(""default"") + "":""+ DefaultServer.getHostPort(""default"")+ ""/ws/chat/Bob""));
    Assert.assertEquals(""hi Bob (protocol=foo)"",AnnotatedClientEndpoint.message());
    session.close(new CloseReason(CloseReason.CloseCodes.VIOLATED_POLICY,""Foo!""));
    Assert.assertEquals(""CLOSED"",AnnotatedClientEndpoint.message());
    CloseReason cr=MessageEndpoint.getReason();
    Assert.assertEquals(CloseReason.CloseCodes.VIOLATED_POLICY.getCode(),cr.getCloseCode().getCode());
    Assert.assertEquals(""Foo!"",cr.getReasonPhrase());
}"
"@Test public void manyParametersWithBooleanAndEnum(){
    assertThat(testResult(ManyParametersWithBooleanAndEnum.class),isSuccessful());
    assertEquals(2 * 5 * 2* RoundingMode.values().length,ManyParametersWithBooleanAndEnum.iterations);
    assertEquals(newHashSet(3,7),new HashSet<>(ManyParametersWithBooleanAndEnum.firstTestCases));
    assertEquals(newHashSet('a','b','c','d','e'),new HashSet<>(ManyParametersWithBooleanAndEnum.secondTestCases));
    assertEquals(newHashSet(false,true),new HashSet<>(ManyParametersWithBooleanAndEnum.thirdTestCases));
    assertEquals(EnumSet.allOf(RoundingMode.class),new HashSet<>(ManyParametersWithBooleanAndEnum.fourthTestCases));
    ManyParametersWithBooleanAndEnum.iterations=0;
    ManyParametersWithBooleanAndEnum.firstTestCases.clear();
    ManyParametersWithBooleanAndEnum.secondTestCases.clear();
    ManyParametersWithBooleanAndEnum.thirdTestCases.clear();
    ManyParametersWithBooleanAndEnum.fourthTestCases.clear();
}"
"@Test public void wrapperShorts(){
    assertThat(testResult(WrapperShorts.class),isSuccessful());
    assertEquals(2,WrapperShorts.iterations);
    assertEquals(new HashSet<>(asList(Short.valueOf(""-13""),Short.valueOf(""-14""))),WrapperShorts.testCases);
    WrapperShorts.iterations=0;
    WrapperShorts.testCases.clear();
}"
"@Test
void testTimedMethod() throws InterruptedException {
    assertTrue(Jobs.latch01.await(5, TimeUnit.SECONDS));
    assertTrue(Jobs.latch02.await(5, TimeUnit.SECONDS));
    Timer timer1 = registry.get(""scheduled.methods"")
    .tag(""method"", ""everySecond"")
    .tag(""class"", ""io.quarkus.scheduler.test.metrics.MicrometerTimedTest$Jobs"")
    .tag(""exception"", ""none"")
    .timer();
    assertNotNull(timer1);
    assertTrue(timer1.count() > 0);
    Timer timer2 = registry.get(""foo"")
    .tag(""method"", ""anotherEverySecond"")
    .tag(""class"", ""io.quarkus.scheduler.test.metrics.MicrometerTimedTest$Jobs"")
    .tag(""exception"", ""none"")
    .timer();
    assertNotNull(timer2);
    assertTrue(timer2.count() > 0);
}"
"@Test public void primitiveShorts() throws Exception {
    assertThat(testResult(PrimitiveShorts.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveShorts.iterations);
    PrimitiveShorts.iterations=0;
}"
"@Test public void testJSONMap(){
    Map<Object,Object> map=new LinkedHashMap<>();
    map.put(1,""bar"");
    map.put(""foo"",2);
    assertEquals(""[\""A\"",{\""1\"":\""bar\"",\""foo\"":2},\""B\""]"",TextUtils.joinJSON(Arrays.asList(""A"",map,""B"")));
}"
"@Test
public void shouldDeserializeSerializedContentPack() throws Exception {
    final ContentPack contentPack = createTestContentPack();
    final URL contentPackURL = ContentPackTest.class.getResource(""expected_content_pack.json"");
    Path path = Paths.get(contentPackURL.toURI());
    String expectedJSON = String.join("""", Files.readAllLines(path)).replace(""\n"", """").replace(""\r"", """");
    final String jsonTxt = objectMapper.writeValueAsString(contentPack);
    assertThat(jsonTxt).isEqualTo(expectedJSON);
    final ContentPack readContentPack = objectMapper.readValue(jsonTxt, ContentPack.class);
    assertThat(readContentPack.id()).isEqualTo(contentPack.id());
    assertThat(readContentPack.version()).isEqualTo(contentPack.version());
    assertThat(readContentPack.revision()).isEqualTo(contentPack.revision());
}"
"@Test public void testPartialRepair() throws InterruptedException {
    Collection<LongTokenRange> ranges=new ArrayList<>();
    LongTokenRange range1=new LongTokenRange(1,2);
    LongTokenRange range2=new LongTokenRange(3,4);
    ranges.add(range1);
    ranges.add(range2);
    final RepairTask repairTask=new RepairTask.Builder().withJMXProxyFactory(jmxProxyFactory).withTableReference(myTableReference).withTokenRanges(ranges).withTableRepairMetrics(myTableRepairMetrics).withRepairHistory(repairHistory).withJobId(jobId).withReplicas(participants).build();
    CountDownLatch cdl=startRepair(repairTask,false);
    Notification notification=new Notification(""progress"",""repair:1"",0,getRepairMessage(range1));
    notification.setUserData(getNotificationData(RepairTask.ProgressEventType.PROGRESS.ordinal(),1,2));
    proxy.notify(notification);
    notification=new Notification(""progress"",""repair:1"",1,getRepairMessage(range2));
    notification.setUserData(getNotificationData(RepairTask.ProgressEventType.PROGRESS.ordinal(),2,2));
    proxy.notify(notification);
    notification=new Notification(""progress"",""repair:1"",2,""Done with repair"");
    notification.setUserData(getNotificationData(RepairTask.ProgressEventType.COMPLETE.ordinal(),2,2));
    proxy.notify(notification);
    cdl.await();
    assertThat(repairTask.getUnknownRanges()).isNull();
    assertThat(repairTask.getCompletedRanges()).containsExactlyInAnyOrderElementsOf(ranges);
    assertThat(proxy.myOptions.get(RepairOptions.RANGES_KEY)).isNotEmpty();
    verify(myTableRepairMetrics).repairTiming(eq(TABLE_REFERENCE),anyLong(),any(TimeUnit.class),eq(true));
    verify(repairSessions.get(range1)).start();
    verify(repairSessions.get(range2)).start();
    verify(repairSessions.get(range1)).finish(eq(RepairStatus.SUCCESS));
    verify(repairSessions.get(range2)).finish(eq(RepairStatus.SUCCESS));
}"
"@Test
public void testRejectionsEAP7() throws Exception {
    testTransformer(""subsystem.xml"", ModelTestControllerVersion.EAP_7_0_0, ModelVersion.create(2, 0), ""wildfly-naming"");
}"
"public void testWrite() throws Exception {
    Resources res=new Resources();
    res.put(""menu_open"",""\u00D6ffnen"");
    res.put(""menu_save"",""Speichern"");
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    res.save(baos);
    assertTrue(Arrays.equals(example.getBytes(""utf-8""),baos.toByteArray()) || Arrays.equals(example2.getBytes(""utf-8""),baos.toByteArray()));
}"
"public void test_for_issue() throws Exception {
    DataSimpleVO a=new DataSimpleVO(""a"",1);
    DataSimpleVO b=new DataSimpleVO(""b"",2);
    b.value=a;
    Map<String,Object> map=new HashMap<String,Object>();
    map.put(a.name,a);
    b.value1=map;
    String jsonStr=JSON.toJSONString(b,SerializerFeature.MapSortField);
    System.out.println(jsonStr);
    DataSimpleVO obj=JSON.parseObject(jsonStr,DataSimpleVO.class);
    assertEquals(jsonStr,JSON.toJSONString(obj,SerializerFeature.MapSortField));
}"
"@Test public void wrapperIntegers() throws Exception {
    assertThat(testResult(WrapperIntegers.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperIntegers.iterations);
    assertEquals(new HashSet<>(asList(4,5)),new HashSet<>(WrapperIntegers.values.subList(0,2)));
    WrapperIntegers.iterations=0;
}"
"@Test
public void testVanishingTaskZNode() throws Exception {
    LOG.info(""testVanishingTaskZNode"");
    conf.setInt(""hbase.splitlog.manager.unassigned.timeout"", 0);
    slm = new SplitLogManager(zkw, conf, stopper, ""dummy-master"", null);
    slm.finishInitialization();
    FileSystem fs = TEST_UTIL.getTestFileSystem();
    final Path logDir = new Path(fs.getWorkingDirectory(), UUID.randomUUID().toString());
    fs.mkdirs(logDir);
    Thread thread = null;
    try {
        Path logFile = new Path(logDir, UUID.randomUUID().toString());
        fs.createNewFile(logFile);
        thread = new Thread() {
            public void run() {
                try {
                    slm.splitLogDistributed(logDir);
                } catch (Exception e) {
                    LOG.warn(""splitLogDistributed failed"", e);
                }
            }
        };
        thread.start();
        waitForCounter(tot_mgr_node_create_result, 0, 1, 10000);
        String znode = ZKSplitLog.getEncodedNodeName(zkw, logFile.toString());
        ZKUtil.deleteNode(zkw, znode);
        waitForCounter(tot_mgr_get_data_nonode, 0, 1, 30000);
        waitForCounter(tot_mgr_log_split_batch_success, 0, 1, 1000);
        assertTrue(fs.exists(logFile));
    } finally {
        if (thread != null) {
            thread.interrupt();
        }
        fs.delete(logDir, true);
    }
}"
"@Test
public void testFireMultiLevelEvent() throws Exception {
    final NamingEventCoordinator coordinator = new NamingEventCoordinator();
    final CollectingListener subtreeListener = new CollectingListener(1);
    coordinator.addListener(""foo"", EventContext.SUBTREE_SCOPE, subtreeListener);
    final CollectingListener subtreeListenerTwo = new CollectingListener(1);
    coordinator.addListener(""foo/bar"", EventContext.SUBTREE_SCOPE, subtreeListenerTwo);
    final CollectingListener subtreeListenerThree = new CollectingListener(1);
    coordinator.addListener(""foo/bar/baz"", EventContext.SUBTREE_SCOPE, subtreeListenerThree);
    coordinator.fireEvent(context, new CompositeName(""foo/bar/baz/boo""), null, null, NamingEvent.OBJECT_ADDED, ""bind"", EventContext.OBJECT_SCOPE, EventContext.ONELEVEL_SCOPE, EventContext.SUBTREE_SCOPE);
    subtreeListener.latch.await(1, TimeUnit.SECONDS);
    subtreeListenerTwo.latch.await(1, TimeUnit.SECONDS);
    subtreeListenerThree.latch.await(1, TimeUnit.SECONDS);
    assertEquals(1, subtreeListener.capturedEvents.size());
    assertEquals(1, subtreeListenerTwo.capturedEvents.size());
    assertEquals(1, subtreeListenerThree.capturedEvents.size());
}"
"@Test
public void assertIsShutdownAlready() {
    shutdownListenerManager.new InstanceShutdownStatusJobListener().dataChanged(""/test_job/instances/127.0.0.1@-@0"", Type.NODE_REMOVED, """");
    verify(schedulerFacade, times(0)).shutdownInstance();
}"
"/**
* Test a class that defines an ivar pointing to itself.  This test was created to show that handling cyclical object resulted in a missing endFieldSeparator call.
*/
@Test public void testSelfInstanceTwoVarsReflectionObjectCycle(){
    final SelfInstanceTwoVarsReflectionTestFixture test=new SelfInstanceTwoVarsReflectionTestFixture();
    assertEquals(this.toBaseString(test) + ""[otherType="" + test.getOtherType().toString()+ "",typeIsSelf=""+ this.toBaseString(test)+ ""]"",test.toString());
}"
"@Test
public void testCompositeKeys() {
    EntityHelper.initEntityNameMap(UserCompositeKeys.class, config);
    EntityTable entityTable = EntityHelper.getEntityTable(UserCompositeKeys.class);
    Assert.assertNotNull(entityTable);
    Set<EntityColumn> columns = entityTable.getEntityClassColumns();
    Assert.assertEquals(2, columns.size());
    Assert.assertEquals(2, entityTable.getEntityClassPKColumns().size());
    for (EntityColumn column : columns) {
        Assert.assertTrue(column.isId());
    }
    ResultMap resultMap = entityTable.getResultMap(configuration);
    Assert.assertEquals(2, resultMap.getResultMappings().size());
    Assert.assertTrue(resultMap.getResultMappings().get(0).getFlags().contains(ID));
    Assert.assertTrue(resultMap.getResultMappings().get(1).getFlags().contains(ID));
    Assert.assertEquals(""<where> AND name = #{name} AND orgId = #{orgId}</where>"", SqlHelper.wherePKColumns(UserCompositeKeys.class));
}"
"@Test
public void testStartStop() {
    final KafkaStream<String, String> kafkaStream = PowerMock.createStrictMock(KafkaStream.class);
    final ConsumerIterator<String, String> consumerIterator = PowerMock.createStrictMock(ConsumerIterator.class);
    final ConsumerConnector consumerConnector = PowerMock.createStrictMock(ConsumerConnector.class);
    EasyMock.expect(consumerConnector.createMessageStreamsByFilter(EasyMock.anyObject(TopicFilter.class), EasyMock.anyInt(), EasyMock.eq(DEFAULT_STRING_DECODER), EasyMock.eq(DEFAULT_STRING_DECODER))).andReturn(ImmutableList.of(kafkaStream)).once();
    EasyMock.expect(kafkaStream.iterator()).andReturn(consumerIterator).anyTimes();
    EasyMock.expect(consumerIterator.hasNext()).andAnswer(getBlockingAnswer()).anyTimes();
    EasyMock.expect(cacheManager.createCache()).andReturn(cacheHandler).once();
    EasyMock.expect(cacheHandler.getCache()).andReturn(new ConcurrentHashMap<String, String>()).once();
    cacheHandler.close();
    EasyMock.expectLastCall();
    final AtomicBoolean threadWasInterrupted = new AtomicBoolean(false);
    consumerConnector.shutdown();
    EasyMock.expectLastCall().andAnswer(new IAnswer<Object>() {
        @Override
        public Object answer() {
            threadWasInterrupted.set(Thread.currentThread().isInterrupted());
            return null;
        }
    }).times(2);
    PowerMock.replay(cacheManager, cacheHandler, kafkaStream, consumerConnector, consumerIterator);
    final KafkaLookupExtractorFactory factory = new KafkaLookupExtractorFactory(cacheManager, TOPIC, ImmutableMap.of(""zookeeper.connect"", ""localhost""), 10000L, false) {
        @Override
        ConsumerConnector buildConnector(Properties properties) {
            return consumerConnector;
        }
    };
    Assert.assertTrue(factory.start());
    Assert.assertTrue(factory.close());
    Assert.assertTrue(factory.getFuture().isDone());
    Assert.assertFalse(threadWasInterrupted.get());
    PowerMock.verify(cacheManager, cacheHandler);
}"
"@Test
public void journalBlockCreation() throws Exception {
    FileSystem fs = mCluster.getClient();
    BlockMaster blockMaster =
    mCluster.getLocalAlluxioMaster().getMasterProcess().getMaster(BlockMaster.class);
    AlluxioURI file = new AlluxioURI(""/test"");
    FileSystemTestUtils.createByteFile(fs, file, WritePType.MUST_CACHE, 10);
    URIStatus status = fs.getStatus(file);
    Long blockId = status.getBlockIds().get(0);
    assertNotNull(blockMaster.getBlockInfo(blockId));
    mCluster.stopMasters();
    mCluster.startMasters();
    AlluxioMasterProcess masterProcess = mCluster.getLocalAlluxioMaster().getMasterProcess();
    assertNotNull(masterProcess.getMaster(BlockMaster.class).getBlockInfo(blockId));
}"
"@Test
public void testOneTimeWorkRequest_backedOff() {
    val now = System.currentTimeMillis() ;
    when(mTaskConverter.now()).thenReturn(now) ;
    val request = OneTimeWorkRequestBuilder<TestWorker>().setInitialRunAttemptCount(1).build() ;
    val workSpec = request.workSpec ;
    val expected = workSpec.calculateNextRunTime();
    val offset = offset(expected, now) ,
    val delta = task.windowEnd - (offset + EXECUTION_WINDOW_SIZE_IN_SECONDS);
    val task = mTaskConverter.convert(request.workSpec);
    assertEquals(task.serviceName, WorkManagerGcmService::class.java.name);
    assertEquals(task.isPersisted, false);
    assertEquals(task.isUpdateCurrent, true);
    assertEquals(task.requiredNetwork, Task.NETWORK_STATE_ANY);
    assertEquals(task.requiresCharging, false);
    assertEquals(task.windowStart, offset);
    assertEquals(task.windowEnd, offset + EXECUTION_WINDOW_SIZE_IN_SECONDS);
}"
"@Test public void joinMultiArrayTest(){
    final StrJoiner append=StrJoiner.of("","");
    append.append(new Object[]{ListUtil.of(""1"",""2""),CollUtil.newHashSet(""3"",""4"")});
    Assert.assertThat(append.toString(),CoreMatchers.anyOf(CoreMatchers.is(""1,2,3,4""),CoreMatchers.is(""1,2,4,3"")));
}"
"@Test
public void testGenerateCleanupCallback_deletesOldFinishedWork() {
    Work work1 = new Work.Builder(TestWorker.class)
    .withInitialState(SUCCEEDED)
    .withPeriodStartTime(0L)
    .build();
    Work work2 = new Work.Builder(TestWorker.class).withPeriodStartTime(Long.MAX_VALUE).build();
    insertWorkSpecAndTags(work1);
    insertWorkSpecAndTags(work2);
    SupportSQLiteOpenHelper openHelper = mDatabase.getOpenHelper();
    SupportSQLiteDatabase db = openHelper.getWritableDatabase();
    WorkDatabase.generateCleanupCallback().onOpen(db);
    WorkSpecDao workSpecDao = mDatabase.workSpecDao();
    assertThat(workSpecDao.getWorkSpec(work1.getId()), is(nullValue()));
    assertThat(workSpecDao.getWorkSpec(work2.getId()), is(not(nullValue())));
}"
"@Test
public void testUnsubscribe() throws Exception {
    PullPoint pullPoint = wsnCreatePullPoint.createPullPoint();
    Subscription subscription = wsnBroker.subscribe(pullPoint.getEndpoint(), ""myTopic"", null);
    wsnBroker.notify(""myTopic"", new Notify());
    Thread.sleep(500);
    assertEquals(1, pullPoint.getMessages(0).size());
    subscription.unsubscribe();
    wsnBroker.notify(""myTopic"", new Notify());
    Thread.sleep(500);
    assertEquals(0, pullPoint.getMessages(0).size());
    Thread.sleep(500);
}"
"@Test public void test_AddExtension_Adaptive() throws Exception {
    ExtensionLoader<AddExt2> loader=getExtensionLoader(AddExt2.class);
    loader.addExtension(null,AddExt2_ManualAdaptive.class);
    AddExt2 adaptive=loader.getAdaptiveExtension();
    assertTrue(adaptive instanceof AddExt2_ManualAdaptive);
    ExtensionLoader.resetExtensionLoader(AddExt2.class);
}"
"@Test
public void test_for_issue() throws Exception {
    ParserConfig config = new ParserConfig();
    String json = ""{\""k\"":1,\""v\"":\""A\""}"";
    {
        Map.Entry entry = JSON.parseObject(json, Map.Entry.class, config);
        assertEquals(""v"", entry.getKey());
        assertEquals(""A"", entry.getValue());
    }
    config.putDeserializer(Map.Entry.class, new ObjectDeserializer() {
        public <T> T deserialze(DefaultJSONParser parser, Type type, Object fieldName) {
            JSONObject object = parser.parseObject();
            Object k = object.get(""k"");
            Object v = object.get(""v"");
            return ((T) (Collections.singletonMap(k, v).entrySet().iterator().next()));
        }
        public int getFastMatchToken() {
            return 0;
        }
    });
    Map.Entry entry = JSON.parseObject(json, Map.Entry.class, config);
    assertEquals(1, entry.getKey());
    assertEquals(""A"", entry.getValue());
}"
"@Test public void arrayOfFunction() throws Exception {
    assertThat(testResult(ArrayOfFunction.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ArrayOfFunction.iterations);
}"
"@Test public void orderingOfStatements(){
    assertThat(testResult(PropertyBasedTests.class),isSuccessful());
    assertEquals(expectedStatements,PropertyBasedTests.LOGS);
    PropertyBasedTests.clearLogs();
}"
"@Test
public void canHandleFragmentedMessageReceived() {
    NMEAMessage fragmentedNMEAMessage1 = NMEAMessage.fromString(""!AIVDM,2,1,3,B,55DA><02=6wpPuID000qTf059@DlU<00000000171lMDD4q20LmDp3hB,0*27"");
    NMEAMessage fragmentedNMEAMessage2 = NMEAMessage.fromString(""!AIVDM,2,2,3,B,p=Mh00000000000,2*4C"");
    final ArgumentCaptor<AISMessage> aisMessage = new ArgumentCaptor<>();
    context.checking(new Expectations() {{
        oneOf(aisMessageHandler).accept(with(aisMessage.getMatcher()));
    }});
    aisMessageReceiver.accept(fragmentedNMEAMessage1);
    aisMessageReceiver.accept(fragmentedNMEAMessage2);
    assertEquals(AISMessageType.ShipAndVoyageRelatedData, aisMessage.getCapturedObject().getMessageType());
}"
"@Test
public void testSniffStrategyWillConnectToAndDiscoverNodes() {
    List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();
    try (MockTransportService seedTransport = startTransport(""seed_node"", knownNodes, Version.CURRENT);
    MockTransportService discoverableTransport = startTransport(""discoverable_node"", knownNodes, Version.CURRENT)) {
        DiscoveryNode seedNode = seedTransport.getLocalNode();
        DiscoveryNode discoverableNode = discoverableTransport.getLocalNode();
        knownNodes.add(seedNode);
        knownNodes.add(discoverableNode);
        Collections.shuffle(knownNodes, random());
        try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {
            localService.start();
            localService.acceptIncomingRequests();
            ClusterConnectionManager connectionManager = new ClusterConnectionManager(profile, localService.transport);
            try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);
            SniffConnectionStrategy strategy = new SniffConnectionStrategy(clusterAlias, localService, remoteConnectionManager,
            null, 3, n -> true, seedNodes(seedNode))) {
                PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();
                strategy.connect(connectFuture);
                connectFuture.actionGet();
                assertTrue(connectionManager.nodeConnected(seedNode));
                assertTrue(connectionManager.nodeConnected(discoverableNode));
                assertTrue(strategy.assertNoRunningConnections());
            }
        }
    }
}"
"@Test public void oneFailingSearchTypeReturnsPartialResults() throws Exception {
    final ESGeneratedQueryContext queryContext=this.elasticsearchBackend.generate(searchJob,query,Collections.emptySet());
    when(jestClient.execute(any(),any())).thenReturn(resultFor(resourceFile(""partiallySuccessfulMultiSearchResponse.json"")));
    final QueryResult queryResult=this.elasticsearchBackend.doRun(searchJob,query,queryContext,Collections.emptySet());
    assertThat(queryResult.errors()).hasSize(1);
    final SearchTypeError searchTypeError=(SearchTypeError)new ArrayList<>(queryResult.errors()).get(0);
    assertThat(searchTypeError.description()).isEqualTo(""Unable to perform search query: \n"" + ""\n"" + ""Expected numeric type on field [field1], but got [keyword]."");
    assertThat(searchTypeError.searchTypeId()).isEqualTo(""pivot1"");
    assertThat(queryResult.searchTypes()).containsOnlyKeys(""pivot2"");
    final PivotResult pivot2Result=(PivotResult)queryResult.searchTypes().get(""pivot2"");
    assertThat(pivot2Result.rows().get(0)).isEqualTo(PivotResult.Row.builder().key(ImmutableList.of()).source(""leaf"").addValue(PivotResult.Value.create(Collections.singletonList(""max(field2)""),42.0,true,""row-leaf"")).build());
}"
"@Test
public void testChecksumReconnection() throws Exception {
    final String topicName = ""persistent"";
    ProducerImpl<byte[]> prod = ((ProducerImpl<byte[]>) (pulsarClient.newProducer().topic(topicName).enableBatching(false).messageRoutingMode(SinglePartition).create()));
    ProducerImpl<byte[]> producer = spy(prod);
    doReturn(producer.brokerChecksumSupportedVersion() + 1).when(producer).brokerChecksumSupportedVersion();
    doAnswer(( invocationOnMock) -> prod.getState()).when(producer).getState();
    doAnswer(( invocationOnMock) -> prod.getClientCnx()).when(producer).getClientCnx();
    doAnswer(( invocationOnMock) -> prod.cnx()).when(producer).cnx();
    Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(topicName).subscriptionName(""my-sub"").subscribe();
    stopBroker();
    ((PulsarClientImpl) (pulsarClient)).timer().stop();
    ClientCnx mockClientCnx = spy(new ClientCnx(new ClientConfigurationData(), ((PulsarClientImpl) (pulsarClient)).eventLoopGroup()));
    doReturn(producer.brokerChecksumSupportedVersion() - 1).when(mockClientCnx).getRemoteEndpointProtocolVersion();
    prod.setClientCnx(mockClientCnx);
    CompletableFuture<MessageId> future1 = producer.sendAsync(""message-1"".getBytes());
    byte[] a2 = ""message-2"".getBytes();
    TypedMessageBuilder<byte[]> msg2 = producer.newMessage().value(a2);
    CompletableFuture<MessageId> future2 = msg2.sendAsync();
    ((TypedMessageBuilderImpl<byte[]>) (msg2)).getContent().put(a2.length - 1, ((byte) ('3')));
    prod.setClientCnx(null);
    startBroker();
    prod.grabCnx();
    try {
        future1.get(10, TimeUnit.SECONDS);
        future2.get(10, TimeUnit.SECONDS);
    } catch (Exception e) {
        e.printStackTrace();
        fail(""Broker shouldn't verify checksum for corrupted message and it shouldn't fail"");
    }
    ((ConsumerImpl<byte[]>) (consumer)).grabCnx();
    Message<byte[]> msg = consumer.receive(1, TimeUnit.SECONDS);
    assertEquals(new String(msg.getData()), ""message-1"");
    msg = consumer.receive(1, TimeUnit.SECONDS);
    assertEquals(new String(msg.getData()), ""message-3"");
}"
"@Test public void primitiveIntegers() throws Exception {
    assertThat(testResult(PrimitiveIntegers.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveIntegers.iterations);
    assertEquals(new HashSet<>(asList(1,2,3)),new HashSet<>(PrimitiveIntegers.values.subList(0,3)));
    PrimitiveIntegers.iterations=0;
}"
"public void test_geo() throws Exception {
    String str=""{\n"" + ""    \""type\"": \""FeatureCollection\"",\n"" + ""    \""features\"": [{\n""+ ""       \""type\"": \""Feature\"",\n""+ ""       \""geometry\"": {\n""+ ""           \""type\"": \""Point\"",\n""+ ""           \""coordinates\"": [102.0, 0.5]\n""+ ""       },\n""+ ""       \""properties\"": {\n""+ ""           \""prop0\"": \""value0\""\n""+ ""       }\n""+ ""    }, {\n""+ ""       \""type\"": \""Feature\"",\n""+ ""       \""geometry\"": {\n""+ ""           \""type\"": \""LineString\"",\n""+ ""           \""coordinates\"": [\n""+ ""               [102.0, 0.0],\n""+ ""               [103.0, 1.0],\n""+ ""               [104.0, 0.0],\n""+ ""               [105.0, 1.0]\n""+ ""           ]\n""+ ""       },\n""+ ""       \""properties\"": {\n""+ ""           \""prop0\"": \""value0\"",\n""+ ""           \""prop1\"": 0.0\n""+ ""       }\n""+ ""    }, {\n""+ ""       \""type\"": \""Feature\"",\n""+ ""       \""geometry\"": {\n""+ ""           \""type\"": \""Polygon\"",\n""+ ""           \""coordinates\"": [\n""+ ""               [\n""+ ""                   [100.0, 0.0],\n""+ ""                   [101.0, 0.0],\n""+ ""                   [101.0, 1.0],\n""+ ""                   [100.0, 1.0],\n""+ ""                   [100.0, 0.0]\n""+ ""               ]\n""+ ""           ]\n""+ ""       },\n""+ ""       \""properties\"": {\n""+ ""           \""prop0\"": \""value0\"",\n""+ ""           \""prop1\"": {\n""+ ""               \""this\"": \""that\""\n""+ ""           }\n""+ ""       }\n""+ ""    }]\n""+ ""}\n"";
    Geometry geometry=JSON.parseObject(str,Geometry.class);
    assertEquals(FeatureCollection.class,geometry.getClass());
    assertEquals(""{\""type\"":\""FeatureCollection\"",\""features\"":[{\""type\"":\""Feature\"",\""properties\"":{\""prop0\"":\""value0\""},\""geometry\"":{\""type\"":\""Point\"",\""coordinates\"":[102.0,0.5]}},{\""type\"":\""Feature\"",\""properties\"":{\""prop0\"":\""value0\"",\""prop1\"":\""0.0\""},\""geometry\"":{\""type\"":\""LineString\"",\""coordinates\"":[[102.0,0.0],[103.0,1.0],[104.0,0.0],[105.0,1.0]]}},{\""type\"":\""Feature\"",\""properties\"":{\""prop0\"":\""value0\"",\""prop1\"":\""{\\\""this\\\"":\\\""that\\\""}\""},\""geometry\"":{\""type\"":\""Polygon\"",\""coordinates\"":[[[100.0,0.0],[101.0,0.0],[101.0,1.0],[100.0,1.0],[100.0,0.0]]]}}]}"",JSON.toJSONString(geometry,SerializerFeature.MapSortField));
    String str2=JSON.toJSONString(geometry,SerializerFeature.MapSortField);
    assertEquals(str2,JSON.toJSONString(JSON.parseObject(str2,Geometry.class),SerializerFeature.MapSortField));
}"
"@Test
public void shouldBeAbleToUpdateAllMessageTypes() throws Throwable
{
    int durationNanos = 5;
    for ( RaftMessages.Type type : RaftMessages.Type.values() )
    {
        metric.updateTimer( type, Duration.ofNanos( durationNanos ) );
        assertEquals( 1, metric.timer( type ).getCount() );
        assertEquals( durationNanos, metric.timer( type ).getSnapshot().getMean(), 0 );
    }
    assertEquals( RaftMessages.Type.values().length, metric.timer().getCount() );
    assertEquals( 0, metric.timer().getSnapshot().getMean(), durationNanos );
}"
"@Test
public void testEnumAsEnum() {
    final Settings settings = TestUtils.settings();
    settings.mapEnum = EnumMapping.asEnum;
    final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(AClass.class));
    final String expected = (""interface AClass {\n"" + ((((((((""    direction: Direction;\n"" + ""}\n"") + ""\n"") + ""declare const enum Direction {\n"") + ""    North = \'North\',\n"") + ""    East = \'East\',\n"") + ""    South = \'South\',\n"") + ""    West = \'West\',\n"") + ""}"")).replace(""'"", ""\"""");
    assertEquals(expected.trim(), output.trim());
}"
"@Test
public void testQueuePageWithProjectCurrentlyBuilding() throws Exception {
    String M2_PROJ_GRP_NAME = getProperty(""M2_PROJ_GRP_NAME"");
    String M2_PROJ_GRP_ID = getProperty(""M2_PROJ_GRP_ID"");
    String M2_PROJ_GRP_DESCRIPTION = getProperty(""M2_PROJ_GRP_DESCRIPTION"");
    buildProjectForQueuePageTest(M2_PROJ_GRP_NAME, M2_PROJ_GRP_ID, M2_PROJ_GRP_DESCRIPTION, M2_PROJ_GRP_NAME);
    String location = getSelenium().getLocation();
    clickAndWait(""link=Queues"");
    assertPage(""Continuum - Build Queue"");
    assertTextPresent(""Current Build"");
    assertTextPresent(""Build Queue"");
    assertTextPresent(""Current Checkout"");
    assertTextPresent(""Checkout Queue "");
    assertTextPresent(""Current Prepare Build"");
    assertTextPresent(""Prepare Build Queue"");
    assertElementPresent();
    assertTextPresent(M2_PROJ_GRP_NAME);
    getSelenium().open(location);
    waitPage();
    waitForElementPresent();
}"
"/**
* for issue https://github.com/nutzam/nutz/issues/1393
*/
@Test public void test_final_field(){
    Issue1393 obj=new Issue1393(""test1"",99);
    String json=Json.toJson(obj,JsonFormat.compact());
    assertJsonEqualsNonStrict(""{\""name\"":\""test1\"",\""age\"":99}"",json);
}"
"@Test
void testBytes() throws InterruptedException {
    final CountDownLatch countDownLatch = new CountDownLatch(1);
    final Metrics metrics = new Metrics();
    final LongAdder longAdder = new LongAdder();
    final long input = 100;
    final int loopCount = 10000;
    Thread adder = new Thread(() -> {
        try {
            countDownLatch.await();
        } catch (InterruptedException ignore) {
        }
        for (int i = 0; i < loopCount; ++i) {
            metrics.addBytes(input);
        }
    });
    Thread getter = new Thread(() -> {
        try {
            countDownLatch.await();
        } catch (InterruptedException ignore) {
        }
        for (int i = 0; i < loopCount; ++i) {
            longAdder.add(metrics.bytesThenReset());
        }
    });
    adder.start();
    getter.start();
    countDownLatch.countDown();
    adder.join();
    longAdder.add(metrics.bytesThenReset());
    Assertions.assertEquals(loopCount * input, longAdder.sum());
}"
"@Test
public void testUnwrapping() throws Exception {
    JsonSchema jsonSchema = MAPPER.generateJsonSchema(UnwrappingRoot.class);
    String json = jsonSchema.toString().replaceAll(""\"""", ""'"");
    String EXP = ""{'type':'object',"" + (""'properties':{'age':{'type':'integer'},"" + ""'name.first':{'type':'string'},'name.last':{'type':'string'}}}"");
    assertEquals(EXP, json);
}"
"@Test
public void testOneTimeRequest_noInitialDelay() {
    val request = OneTimeWorkRequestBuilder<TestWorker>().build();
    val task = mTaskConverter.convert(request.workSpec);
    assertEquals(task.serviceName, WorkManagerGcmService::class.java.name);
    assertEquals(task.isPersisted, false);
    assertEquals(task.isUpdateCurrent, true);
    assertEquals(task.requiredNetwork, Task.NETWORK_STATE_ANY);
    assertEquals(task.requiresCharging, false);
    assertEquals(task.windowStart, 0L);
    assertEquals(task.windowEnd, 0L + EXECUTION_WINDOW_SIZE_IN_SECONDS);
}"
"@Test public void indexesCreated(){
    QueryService queryService=gemfireCache.getQueryService();
    List<String> expectedDefinedIndexNames=Arrays.asList(id.getName(),birthDate.getName(),name.getName());
    expectedDefinedIndexNames.sort((a,b) -> (a.compareTo(b)));
    definedIndexNames.sort((a,b) -> (a.compareTo(b)));
    assertThat(definedIndexNames).isEqualTo(expectedDefinedIndexNames);
    assertThat(id).isEqualTo(queryService.getIndex(people,id.getName()));
    assertThat(birthDate).isEqualTo(queryService.getIndex(people,birthDate.getName()));
    assertThat(lastName).isEqualTo(queryService.getIndex(people,lastName.getName()));
    assertThat(name).isEqualTo(queryService.getIndex(people,name.getName()));
}"
"@Test
public void testApiAuthToken() {
    ApiDoc apiDoc = jsondocScanner.getApiDocs(Sets.<Class<?>>newHashSet(Controller.class), URI).iterator().next();
    Assert.assertEquals(""TOKEN"", apiDoc.getAuth().getType());
    Assert.assertEquals("""", apiDoc.getAuth().getScheme());
    Assert.assertEquals(""abc"", apiDoc.getAuth().getTesttokens().iterator().next());
    for (ApiMethodDoc apiMethodDoc : apiDoc.getMethods()) {
        if (apiMethodDoc.getPath().contains(""/inherit"")) {
            Assert.assertEquals(""TOKEN"", apiMethodDoc.getAuth().getType());
            Assert.assertEquals("""", apiMethodDoc.getAuth().getScheme());
            Assert.assertEquals(""abc"", apiMethodDoc.getAuth().getTesttokens().iterator().next());
        }
        if (apiMethodDoc.getPath().contains(""/override"")) {
            Assert.assertEquals(""TOKEN"", apiMethodDoc.getAuth().getType());
            Assert.assertEquals(""Bearer"", apiMethodDoc.getAuth().getScheme());
            Assert.assertEquals(""xyz"", apiMethodDoc.getAuth().getTesttokens().iterator().next());
        }
    }
}"
"@Test public void wrapperShorts() throws Exception {
    assertThat(testResult(WrapperShorts.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperShorts.iterations);
    assertEquals(new HashSet<>(asList(Short.valueOf(""-13""),Short.valueOf(""-14""))),new HashSet<>(WrapperShorts.values.subList(0,2)));
    WrapperShorts.iterations=0;
}"
"public void testSimpleEquals() throws Exception {
    ObjectMapper mapper=jsonMapperBuilder().enable(SerializationFeature.USE_EQUALITY_FOR_OBJECT_ID).configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY,true).build();
    Foo foo=new Foo(1);
    Bar bar1=new Bar(1);
    Bar bar2=new Bar(2);
    Bar anotherBar1=new Bar(1);
    foo.bars.add(bar1);
    foo.bars.add(bar2);
    foo.otherBars.add(anotherBar1);
    foo.otherBars.add(bar2);
    String json=mapper.writeValueAsString(foo);
    assertEquals(""{\""id\"":1,\""bars\"":[{\""id\"":1},{\""id\"":2}],\""otherBars\"":[1,2]}"",json);
    Foo foo2=mapper.readValue(json,Foo.class);
    assertNotNull(foo2);
    assertEquals(foo.id,foo2.id);
}"
"@Test public void primitiveBytes() throws Exception {
    assertThat(testResult(PrimitiveBytes.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveBytes.iterations);
    assertEquals(new HashSet<>(asList(Byte.valueOf(""12""),Byte.valueOf(""-13""))),new HashSet<>(PrimitiveBytes.values.subList(0,2)));
    PrimitiveBytes.iterations=0;
}"
"@Test
public void testRedeliverNewSession() throws Exception {
    String text = ""TEST"";
    Message sendMessage = session.createTextMessage(text);
    if (verbose) {
        log.info(((""About to send a message: "" + sendMessage) + "" with text: "") + text);
    }
    producer.send(producerDestination, sendMessage);
    Message unackMessage = consumer.receive(1000);
    assertNotNull(unackMessage);
    String unackId = unackMessage.getJMSMessageID();
    assertEquals(((TextMessage) (unackMessage)).getText(), text);
    assertFalse(unackMessage.getJMSRedelivered());
    assertEquals(unackMessage.getIntProperty(""JMSXDeliveryCount""), 1);
    consumeSession.close();
    consumer.close();
    consumeSession = connection.createSession(false, CLIENT_ACKNOWLEDGE);
    consumer = createConsumer();
    Message ackMessage = consumer.receive(1000);
    assertNotNull(ackMessage);
    ackMessage.acknowledge();
    String ackId = ackMessage.getJMSMessageID();
    assertEquals(((TextMessage) (ackMessage)).getText(), text);
    assertTrue(ackMessage.getJMSRedelivered());
    assertEquals(ackMessage.getIntProperty(""JMSXDeliveryCount""), 2);
    assertEquals(unackId, ackId);
    consumeSession.close();
    consumer.close();
    consumeSession = connection.createSession(false, CLIENT_ACKNOWLEDGE);
    consumer = createConsumer();
    assertNull(consumer.receiveNoWait());
}"
"@Test public void wrapperChars(){
    assertThat(testResult(WrapperChars.class),isSuccessful());
    assertEquals(2,WrapperChars.iterations);
    assertEquals(new HashSet<>(asList('@','#')),WrapperChars.testCases);
    WrapperChars.iterations=0;
    WrapperChars.testCases.clear();
}"
"@Test
void sendMessageOnMessage() throws Exception {
    final Workflow workflow = SwadlParser.fromYaml(getClass().getResourceAsStream(""/message/send-message-on-message.swadl.yaml""));
    final V4Message message = message(""Hello!"");
    engine.deploy(workflow);
    engine.onEvent(messageReceived(""/message""));
    when(messageService.send(anyString(), any(Message.class))).thenReturn(message);
    verify(messageService, timeout(5000)).send(anyString(), any(Message.class));
    assertThat(workflow).isExecuted().hasOutput(String.format(OUTPUTS_MSG_KEY, ""sendMessage1""), message).hasOutput(String.format(OUTPUTS_MSG_ID_KEY, ""sendMessage1""), message.getMessageId());
}"
"@Test
public void testSetCallbackWithNull() throws Exception {
    mSession.setActive(true);
    mCallback.reset(1);
    mSession.setCallback(null, mHandler);
    assertEquals(""Callback shouldn't be called."", 0, mCallback.mOnPlayCalledCount);
}"
"public void testObjectToXml() throws Exception {
    SimpleBean obj=new SimpleBean();
    obj.setName(""Jan"");
    obj.setAge(12L);
    obj.setParents(Arrays.asList(""Adam"",""Ewa""));
    Writer stream=new StringWriter();
    handler.fromObject(ai,obj,null,stream);
    stream.flush();
    String actual=stream.toString();
    assertTrue(actual.length() == xml.length() && actual.startsWith(prefix) && actual.contains(name) && actual.contains(age) && actual.contains(parents) && actual.endsWith(suffix));
}"
"@Test
public void testRead() throws Exception {
    FileSystem fs = cluster.getFileSystem();
    long tStart = System.currentTimeMillis();
    bench.readTest(fs);
    long execTime = System.currentTimeMillis() - tStart;
    bench.analyzeResult(fs, TestType.TEST_TYPE_READ, execTime);
}"
"@Test
public void primitivePairs() throws Exception {
    List<Class<?>> types = Arrays.asList(Object.class, boolean.class, byte.class, short.class, char.class, int.class, float.class, long.class, double.class);
    for (Class<?> oneType : types) {
        for (Class<?> twoType : types) {
            Class<?> pairClass;
            Method factory;
            if ((oneType == Object.class) && (twoType == Object.class)) {
                pairClass = Pair.class;
                factory = Tuples.class.getMethod(""pair"", Object.class, Object.class);
            } else {
                pairClass = Class.forName(((""org.eclipse.collections.api.tuple.primitive."" + capitalize(oneType.getSimpleName())) + capitalize(twoType.getSimpleName())) + ""Pair"");
                factory = PrimitiveTuples.class.getMethod(""pair"", oneType, twoType);
            }
            Object sampleOne = randomSample(oneType);
            Object sampleTwo = randomSample(twoType);
            JavaType pairType;
            if (oneType == Object.class) {
                if (twoType == Object.class) {
                    pairType = mapperWithModule().getTypeFactory().constructParametricType(pairClass, sampleOne.getClass(), sampleTwo.getClass());
                } else {
                    pairType = mapperWithModule().getTypeFactory().constructParametricType(pairClass, sampleOne.getClass());
                }
            } else if (twoType == Object.class) {
                pairType = mapperWithModule().getTypeFactory().constructParametricType(pairClass, sampleTwo.getClass());
            } else {
                pairType = mapperWithModule().constructType(pairClass);
            }
            String expectedJson = (((""{\""one\"":"" + mapperWithModule().writeValueAsString(sampleOne)) + "",\""two\"":"") + mapperWithModule().writeValueAsString(sampleTwo)) + ""}"";
            Object samplePair = factory.invoke(null, sampleOne, sampleTwo);
            Assert.assertEquals(expectedJson, mapperWithModule().writeValueAsString(samplePair));
            Assert.assertEquals(samplePair, mapperWithModule().readValue(expectedJson, pairType));
        }
    }
}"
"@Test public void primitiveShorts() throws Exception {
    assertThat(testResult(PrimitiveShorts.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveShorts.iterations);
    assertEquals(new HashSet<>(asList(Short.valueOf(""9""),Short.valueOf(""8""))),new HashSet<>(PrimitiveShorts.values.subList(0,2)));
    PrimitiveShorts.iterations=0;
}"
"@Test
public void testPerTopicStats() throws Exception {
    String randSeed = randomName(16);
    System.out.println(""The randSeed of testPerTopicStats() is: "" + randSeed);
    Producer<byte[]> p1 = pulsarClient.newProducer().topic(""persistent://my-property/use/"" + randSeed + ""/my-topic1"").create();
    Producer<byte[]> p2 = pulsarClient.newProducer().topic(""persistent://my-property/use/"" + randSeed + ""/my-topic2"").create();
    for (int i = 0; i < 10; i++) {
        String message = ""my-message-"" + i;
        p1.send(message.getBytes());
        p2.send(message.getBytes());
    }
    ByteArrayOutputStream statsOut = new ByteArrayOutputStream();
    PrometheusMetricsGenerator.generate(pulsar, true, false, statsOut);
    String metricsStr = new String(statsOut.toByteArray());
    Multimap<String, Metric> metrics = parseMetrics(metricsStr);
    metrics.entries().forEach(e -> {
        System.out.println(e.getKey() + "": "" + e.getValue());
    });
    List<Metric> cm = (List<Metric>) metrics.get(""pulsar_storage_write_latency_le_1"");
    List<Metric> matchingMetrics = cm.stream().filter(t -> t.tags.containsValue(""my-property/use/"" + randSeed)).collect(Collectors.toList());
    int positionOfTopic1;
    int positionOfTopic2;
    if(cm.get(0).tags.get(""topic"").equals(""persistent://my-property/use/"" + randSeed + ""/my-topic1"")) {
        positionOfTopic1 = 0;
        positionOfTopic2 = 1;
    } else {
        positionOfTopic2 = 0;
        positionOfTopic1 = 1;
    }
    matchingMetrics = cm.stream().filter(t -> t.tags.containsValue(""my-property/use/"" + randSeed)).collect(Collectors.toList());
    if(matchingMetrics.size() > 2){
        System.out.println(""matchingMetrics.size() > 2 in testPerTopicStats(). First check. Debug entries: "");
        matchingMetrics.forEach(t -> t.tags.entrySet().forEach(kv -> System.out.println(kv.getKey() + "":""  + kv.getValue())));
    }
    assertEquals(matchingMetrics.size(), 2);
    assertEquals(matchingMetrics.get(positionOfTopic2).tags.get(""topic""), ""persistent://my-property/use/"" + randSeed + ""/my-topic2"");
    assertEquals(matchingMetrics.get(positionOfTopic2).tags.get(""namespace""), ""my-property/use/"" + randSeed);
    assertEquals(matchingMetrics.get(positionOfTopic1).tags.get(""topic""), ""persistent://my-property/use/"" + randSeed + ""/my-topic1"");
    assertEquals(matchingMetrics.get(positionOfTopic1).tags.get(""namespace""), ""my-property/use/"" + randSeed);
    cm = (List<Metric>) metrics.get(""pulsar_producers_count"");
    if(cm.get(1).tags.get(""topic"").equals(""persistent://my-property/use/"" + randSeed + ""/my-topic1"")) {
        positionOfTopic1 = 1;
        positionOfTopic2 = 2;
    } else {
        positionOfTopic2 = 1;
        positionOfTopic1 = 2;
    }
    matchingMetrics = cm.stream().filter(t -> t.tags.containsValue(""my-property/use/"" + randSeed)).collect(Collectors.toList());
    if(matchingMetrics.size() > 2){
        System.out.println(""matchingMetrics.size() > 2 in testPerTopicStats(). Second check. Debug entries: "");
        matchingMetrics.forEach(t -> t.tags.entrySet().forEach(kv -> System.out.println(kv.getKey() + "":""  + kv.getValue())));
    }
    assertEquals(matchingMetrics.size(), 2);
    assertEquals(matchingMetrics.get(positionOfTopic2).tags.get(""topic""), ""persistent://my-property/use/"" + randSeed + ""/my-topic2"");
    assertEquals(matchingMetrics.get(positionOfTopic2).tags.get(""namespace""), ""my-property/use/"" + randSeed);
    assertEquals(matchingMetrics.get(positionOfTopic1).tags.get(""topic""), ""persistent://my-property/use/"" + randSeed + ""/my-topic1"");
    assertEquals(matchingMetrics.get(positionOfTopic1).tags.get(""namespace""), ""my-property/use/"" + randSeed);
    cm = (List<Metric>) metrics.get(""topic_load_times_count"");
    if(cm.size() > 1){
        System.out.println(""matchingMetrics.size() > 2 in testPerTopicStats(). Third check. Debug entries: "");
        cm.forEach(t -> t.tags.entrySet().forEach(kv -> System.out.println(kv.getKey() + "":""  + kv.getValue())));
    }
    assertEquals(cm.size(), 1);
    assertEquals(cm.get(0).tags.get(""cluster""), ""test"");
    cm = (List<Metric>) metrics.get(""pulsar_in_bytes_total"");
    if(cm.get(0).tags.get(""topic"").equals(""persistent://my-property/use/"" + randSeed + ""/my-topic1"")) {
        positionOfTopic1 = 0;
        positionOfTopic2 = 1;
    } else {
        positionOfTopic2 = 0;
        positionOfTopic1 = 1;
    }
    matchingMetrics = cm.stream().filter(t -> t.tags.containsValue(""my-property/use/"" + randSeed)).collect(Collectors.toList());
    if(matchingMetrics.size() > 2){
        System.out.println(""matchingMetrics.size() > 2 in testPerTopicStats(). Fourth check. Debug entries: "");
        matchingMetrics.forEach(t -> t.tags.entrySet().forEach(kv -> System.out.println(kv.getKey() + "":""  + kv.getValue())));
    }
    assertEquals(matchingMetrics.size(), 2);
    assertEquals(matchingMetrics.get(positionOfTopic2).tags.get(""topic""), ""persistent://my-property/use/"" + randSeed + ""/my-topic2"");
    assertEquals(matchingMetrics.get(positionOfTopic2).tags.get(""namespace""), ""my-property/use/"" + randSeed);
    assertEquals(matchingMetrics.get(positionOfTopic1).tags.get(""topic""), ""persistent://my-property/use/"" + randSeed + ""/my-topic1"");
    assertEquals(matchingMetrics.get(positionOfTopic1).tags.get(""namespace""), ""my-property/use/"" + randSeed);
    cm = (List<Metric>) metrics.get(""pulsar_in_messages_total"");
    if(cm.get(0).tags.get(""topic"").equals(""persistent://my-property/use/"" + randSeed + ""/my-topic1"")) {
        positionOfTopic1 = 0;
        positionOfTopic2 = 1;
    } else {
        positionOfTopic2 = 0;
        positionOfTopic1 = 1;
    }
    matchingMetrics = cm.stream().filter(t -> t.tags.containsValue(""my-property/use/"" + randSeed)).collect(Collectors.toList());
    if(matchingMetrics.size() > 2){
        System.out.println(""matchingMetrics.size() > 2 in testPerTopicStats(). Fifth check. Debug entries: "");
        matchingMetrics.forEach(t -> t.tags.entrySet().forEach(kv -> System.out.println(kv.getKey() + "":""  + kv.getValue())));
    }
    assertEquals(matchingMetrics.size(), 2);
    assertEquals(matchingMetrics.get(positionOfTopic2).tags.get(""topic""), ""persistent://my-property/use/"" + randSeed + ""/my-topic2"");
    assertEquals(matchingMetrics.get(positionOfTopic2).tags.get(""namespace""), ""my-property/use/"" + randSeed);
    assertEquals(matchingMetrics.get(positionOfTopic1).tags.get(""topic""), ""persistent://my-property/use/"" + randSeed + ""/my-topic1"");
    assertEquals(matchingMetrics.get(positionOfTopic1).tags.get(""namespace""), ""my-property/use/"" + randSeed);
    p1.close();
    p2.close();
}"
"@Test
public void testSerialize() throws SerializationException {
    GetUserIdSerializableRequest request = new GetUserIdSerializableRequest();
    request.setOperation(GETUSERID);
    request.setInfoField1(""nobody@amazon.com"");
    request.setInfoField2(""AMZN"");
    String requestString = serializer.encode(request);
    assertEquals(""{\""operation\"":\""GetUserId\"",\""infoField1\"":\""nobody@amazon.com\"",\""infoField2\"":\""AMZN\""}"", requestString);
}"
"@Test
public void appliesOuterTimeout() {
    final WaitStrategy underTest = new WaitAllStrategy()
    .withStrategy(strategy1)
    .withStartupTimeout(Duration.ofMillis(10));
    doAnswer(invocation -> {
        Uninterruptibles.sleepUninterruptibly(20, TimeUnit.MILLISECONDS);
        return null;
    }).when(strategy1).waitUntilReady(eq(container));
    assertThrows(""The outer strategy timeout applies"", TimeoutException.class, () -> {
        underTest.waitUntilReady(container);
    });
}"
"@Test public void strings() throws Exception {
    assertThat(testResult(Strings.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),Strings.iterations);
    assertEquals(new HashSet<>(asList(""some"",""values"")),new HashSet<>(Strings.values.subList(0,2)));
    Strings.iterations=0;
}"
"@Test
public void testPullWithFilter() throws Exception {
    PullPoint pullPoint1 = wsnCreatePullPoint.createPullPoint();
    PullPoint pullPoint2 = wsnCreatePullPoint.createPullPoint();
    wsnBroker.subscribe(pullPoint1.getEndpoint(), ""myTopic"", ""@type = 'a'"");
    wsnBroker.subscribe(pullPoint2.getEndpoint(), ""myTopic"", ""@type = 'b'"");
    wsnBroker.notify(""myTopic"", parse(""<msg type='a'/>""));
    Thread.sleep(500);
    assertEquals(1, pullPoint1.getMessages(0).size());
    assertEquals(0, pullPoint2.getMessages(0).size());
    wsnBroker.notify(""myTopic"", parse(""<msg type='b'/>""));
    Thread.sleep(500);
    assertEquals(0, pullPoint1.getMessages(0).size());
    assertEquals(1, pullPoint2.getMessages(0).size());
    wsnBroker.notify(""myTopic"", parse(""<msg type='c'/>""));
    Thread.sleep(500);
    assertEquals(0, pullPoint1.getMessages(0).size());
    assertEquals(0, pullPoint2.getMessages(0).size());
}"
"@Test
public void testRegisterURLSchemeHandler() throws Exception {
    InitialContext ictx = new InitialContext(null);
    try {
        ictx.lookup(""foobar:something"");
        Assert.fail(""Precondition: the foobar: scheme should not yet be registered"");
    } catch (NamingException ne) {
    }
    ObjectFactory tof = new TestObjectFactory();
    InitialContext.addUrlContextFactory(""foobar"", tof);
    String something = (String) ictx.lookup(""foobar:something"");
    Assert.assertTrue(""The object should now be provided by our TestObjectFactory"", something.startsWith(""TestObject:""));
    try {
        InitialContext.removeUrlContextFactory(""foobar:"", new TestObjectFactory());
        Assert.fail(""Should throw an IllegalArgumentException since the associated factory object doesn't match the registration"");
    } catch (IllegalArgumentException iae) {
    }
    Assert.assertEquals(""The foobar: scheme should still be registered"", something, ictx.lookup(""foobar:something""));
    InitialContext.removeUrlContextFactory(""foobar"", tof);
    try {
        ictx.lookup(""foobar:something"");
        Assert.fail(""The foobar: scheme should not be registered any more"");
    } catch (NamingException ne) {
    }
}"
"@Test public void ctorOnly() throws Exception {
    assertThat(testResult(CtorOnly.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),CtorOnly.iterations);
    CtorOnly.iterations=0;
}"
"@Test public void test_replaceExtension() throws Exception {
    try {
        getExtensionLoader(AddExt1.class).getExtension(""Manual2"");
        fail();
    }
    catch (  IllegalStateException expected) {
        assertThat(expected.getMessage(),containsString(""No such extension org.apache.dubbo.common.extension.ext8_add.AddExt1 by name Manual""));
    }
    {
        AddExt1 ext=getExtensionLoader(AddExt1.class).getExtension(""impl1"");
        assertThat(ext,instanceOf(AddExt1Impl1.class));
        assertEquals(""impl1"",getExtensionLoader(AddExt1.class).getExtensionName(AddExt1Impl1.class));
    }
    {
        getExtensionLoader(AddExt1.class).replaceExtension(""impl1"",AddExt1_ManualAdd2.class);
        AddExt1 ext=getExtensionLoader(AddExt1.class).getExtension(""impl1"");
        assertThat(ext,instanceOf(AddExt1_ManualAdd2.class));
        assertEquals(""impl1"",getExtensionLoader(AddExt1.class).getExtensionName(AddExt1_ManualAdd2.class));
    }
    ExtensionLoader.resetExtensionLoader(AddExt1.class);
}"
"@SuppressWarnings(""unchecked"") @Test public void testCollectorContextWithKeyword() throws Exception {
    ValidationResult validationResult=validate(""{\""test-property1\"":\""sample1\"",\""test-property2\"":\""sample2\""}"");
    Assertions.assertEquals(0,validationResult.getValidationMessages().size());
    List<String> contextValues=(List<String>)validationResult.getCollectorContext().get(SAMPLE_COLLECTOR);
    contextValues.sort(null);
    Assertions.assertEquals(0,validationResult.getValidationMessages().size());
    Assertions.assertEquals(2,contextValues.size());
    Assertions.assertEquals(contextValues.get(0),""actual_value_added_to_context1"");
    Assertions.assertEquals(contextValues.get(1),""actual_value_added_to_context2"");
}"
"@Test public void testKeyValueSchemaInfoToString() throws JSONException {
    String havePrimitiveType=DefaultImplementation.convertKeyValueSchemaInfoDataToString(KeyValueSchemaInfo.decodeKeyValueSchemaInfo(Schema.KeyValue(Schema.AVRO(Foo.class),Schema.STRING).getSchemaInfo()));
    JSONSchemaTest.assertJSONEqual(havePrimitiveType,KEY_VALUE_SCHEMA_INFO_INCLUDE_PRIMITIVE);
    String notHavePrimitiveType=DefaultImplementation.convertKeyValueSchemaInfoDataToString(KeyValueSchemaInfo.decodeKeyValueSchemaInfo(Schema.KeyValue(Schema.AVRO(Foo.class),Schema.AVRO(Foo.class)).getSchemaInfo()));
    JSONSchemaTest.assertJSONEqual(notHavePrimitiveType,KEY_VALUE_SCHEMA_INFO_NOT_INCLUDE_PRIMITIVE);
}"
"@Test public void trialCountHoldsForEntirePropertyRatherThanIndividualParameters(){
    assertThat(testResult(ForValuesOfMultipleParameters.class),isSuccessful());
    assertEquals(21,ForValuesOfMultipleParameters.iterations);
    ForValuesOfMultipleParameters.iterations=0;
}"
"@Test
public void testReassignFailOnStopAndSync() throws IOException {
    ReceiverAdminClient receiverAdminClient = mockReceiverClientFailOnStopAndSync();
    coordinator = new Coordinator(metadataStore, receiverAdminClient);
    Map<Integer, List<Partition>> preAssignMap = metadataStore.getAssignmentsByCube(cubeName).getAssignments();
    Map<Integer, List<Partition>> newAssignMap = new HashMap<>();
    newAssignMap.put(1, Lists.newArrayList(p1, p2, p3));
    newAssignMap.put(2, Lists.newArrayList(p4, p5));
    newAssignMap.put(3, Lists.newArrayList(p6));
    CubeAssignment preAssigment = new CubeAssignment(cube.getName(), preAssignMap);
    CubeAssignment newAssigment = new CubeAssignment(cube.getName(), newAssignMap);
    try {
        coordinator.doReassign(cube, preAssigment, newAssigment);
    } catch (ClusterStateException rune) {
        assertSame(ROLLBACK_FAILED, rune.getClusterState());
        assertSame(STOP_AND_SNYC, rune.getTransactionStep());
        System.out.println(rune.getMessage());
        throw rune;
    }
}"
"@Test
public void testListNameNotFound() throws Exception {
    try {
        namingContext.list(new CompositeName(""test""));
        fail(""Should have thrown and NameNotFoundException"");
    } catch (NameNotFoundException expected) {
    }
    try {
        testActionPermission(JndiPermission.ACTION_LIST, namingContext, ""test"");
        fail(""Should have thrown and NameNotFoundException with appropriate permissions"");
    } catch (NameNotFoundException expected) {
    }
}"
"@Test public void explicitGeneratorTakesPrecedence(){
    assertThat(testResult(WithExplicitGenerator.class),isSuccessful());
    assertEquals(asList(0,1,2,3,4),WithExplicitGenerator.values);
    WithExplicitGenerator.values.clear();
}"
"@Test
@Test(dependsOnMethods = ""testCreateJob"")
public void testGetJobListFromRoot() {
    JobList output = api().jobList("""");
    assertNotNull(output);
    assertFalse(output.jobs().isEmpty());
    assertEquals(output.jobs().size(), 2);
}"
"@Test
public void getNanoTime() {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
        long time = mRecyclerView.getNanoTime();
        assertNotEquals(0, time);
        assertNotEquals(time, mRecyclerView.getNanoTime());
    } else {
        assertEquals(0, mRecyclerView.getNanoTime());
    }
}"
"@Test
public void testRebind() throws Exception {
    final Name name = new CompositeName(""test"");
    final Object value = new Object();
    final Object newValue = new Object();
    WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);
    try {
        store.bind(name, value);
        store.rebind(name, newValue);
    } finally {
        WritableServiceBasedNamingStore.popOwner();
    }
    assertEquals(newValue, store.lookup(name));
}"
"@Test public void testDropMultipleColumnsMySQL(){
    DropColumnStatement drop=new DropColumnStatement(Arrays.asList(new DropColumnStatement(null,null,""TEST_TABLE"",""col1""),new DropColumnStatement(null,null,""TEST_TABLE"",""col2"")));
    Assert.assertFalse(generatorUnderTest.validate(drop,new MySQLDatabase(),new MockSqlGeneratorChain()).hasErrors());
    Sql[] sql=generatorUnderTest.generateSql(drop,new MySQLDatabase(),new MockSqlGeneratorChain());
    Assert.assertEquals(1,sql.length);
    Assert.assertEquals(""ALTER TABLE TEST_TABLE DROP col1, DROP col2"",sql[0].toSql());
    List<String> actualNames=sql[0].getAffectedDatabaseObjects().stream().map(o -> o.toString()).collect(Collectors.toList());
    List<String> expectedNames=Arrays.asList(new String[]{""TEST_TABLE.col1"",""TEST_TABLE.col2"",""TEST_TABLE"",""DEFAULT""});
    assertTrue(actualNames.containsAll(expectedNames));
    assertTrue(expectedNames.containsAll(actualNames));
}"
"@Test public void EventRequestTest(){
    APIContext context=new APIContext(""ACCESS_TOKEN"").enableDebug(true);
    UserData userData=new UserData().email(""aaa@fb.com"");
    UserData billingContact=new UserData().email(""bbb@fb.com"");
    UserData shippingContact=new UserData().email(""ccc@fb.com"");
    HashMap<String,String> customProperties=new HashMap<String,String>();
    customProperties.put(""Key1"",""Value1"");
    List<Content> contents=new ArrayList<Content>();
    contents.add(new Content().id(""1"").tax(1.2F));
    contents.add(new Content().id(""2"").brand(""brand""));
    CustomData customData=new CustomData().customProperties(customProperties).contents(contents).value(123.45F).billingContact(billingContact).shippingContact(shippingContact);
    List<Event> testEvents=new ArrayList<Event>();
    testEvents.add(new Event().eventName(""Purchase"").eventTime(123124125L).userData(userData).dataProcessingOptions(new String[]{}).customData(customData));
    EventRequest eventRequest=new EventRequest(""pixelID"",""pageID"",context);
    eventRequest.setData(testEvents);
    eventRequest.setPartnerAgent(""partnerAgent"");
    com.facebook.ads.sdk.businessdataapi.EventRequest bdapiEventRequest=eventRequest.getBusinessDataEventRequest();
    com.facebook.ads.sdk.businessdataapi.Event bdapiEvent=bdapiEventRequest.getData().get(0);
    Assert.assertTrue(bdapiEventRequest.getPartnerAgent() == ""partnerAgent"");
    Assert.assertTrue(bdapiEvent.getEventName() == ""Purchase"");
    Assert.assertTrue(bdapiEvent.getEventTime() == 123124125L);
    Assert.assertTrue(bdapiEvent.getDataProcessingOptions().length == 0);
    Assert.assertTrue(bdapiEvent.getUserData().getEmail() == ""aaa@fb.com"");
    Assert.assertTrue(bdapiEvent.getCustomData().getValue() == 123.45F);
    List<com.facebook.ads.sdk.businessdataapi.Content> bdapiContents=bdapiEvent.getCustomData().getContents();
    Assert.assertTrue(bdapiContents.get(0).getId() == ""1"");
    Assert.assertTrue(bdapiContents.get(0).getTax() == 1.2F);
    Assert.assertTrue(bdapiContents.get(1).getId() == ""2"");
    Assert.assertTrue(bdapiEvent.getCustomData().getBillingContact().getEmail() == ""bbb@fb.com"");
    Assert.assertTrue(bdapiEvent.getCustomData().getShippingContact().getEmail() == ""ccc@fb.com"");
    com.facebook.ads.sdk.serverside.EventRequest capiEventRequest=eventRequest.getServerSideEventRequest();
    com.facebook.ads.sdk.serverside.Event capiEvent=capiEventRequest.getData().get(0);
    Assert.assertTrue(capiEventRequest.getPartnerAgent() == ""partnerAgent"");
    Assert.assertTrue(capiEvent.getEventName() == ""Purchase"");
    Assert.assertTrue(capiEvent.getEventTime() == 123124125L);
    Assert.assertTrue(capiEvent.getDataProcessingOptions().length == 0);
    Assert.assertTrue(capiEvent.getUserData().getEmail() == ""aaa@fb.com"");
    Assert.assertTrue(capiEvent.getCustomData().getValue() == 123.45F);
    List<com.facebook.ads.sdk.serverside.Content> capiContents=capiEvent.getCustomData().getContents();
    Assert.assertTrue(capiContents.get(0).getProductId() == ""1"");
    Assert.assertTrue(capiContents.get(1).getProductId() == ""2"");
    Assert.assertTrue(capiContents.get(1).getBrand() == ""brand"");
    Assert.assertTrue(capiEvent.getCustomData().getCustomProperties().get(""Key1"") == ""Value1"");
    String bdapiDataJSON=(new Gson()).toJson(bdapiEventRequest.getData());
    String bdapiContentsJSON=(new Gson()).toJson(bdapiContents);
    Assert.assertTrue(bdapiDataJSON.contains(bdapiContentsJSON));
    Assert.assertTrue(bdapiDataJSON.contains(""\""event_name\"":\""Purchase\""""));
    String capiDataJSON=(new Gson()).toJson(capiEventRequest.getData());
    Map<String,String> mp=customProperties;
    mp.forEach((key,value) -> Assert.assertTrue(capiDataJSON.contains(""\"""" + key + ""\"":""+ ""\""""+ value+ ""\"""")));
}"
"@Test
public void testNotifyWithJbiWrapper() throws Exception {
    wsnBroker.setJbiWrapped(true);
    ReceiverComponent receiver = new ReceiverComponent();
    jbi.activateComponent(receiver, ""receiver"");
    W3CEndpointReference consumer = createEPR(SERVICE, ENDPOINT);
    wsnBroker.subscribe(consumer, ""myTopic"", null);
    wsnBroker.notify(""myTopic"", parse(""<hello>world</hello>""));
    Thread.sleep(500);
    receiver.getMessageList().assertMessagesReceived(1);
    NormalizedMessage msg = ((NormalizedMessage) (receiver.getMessageList().getMessages().get(0)));
    Node node = new SourceTransformer().toDOMNode(msg);
    assertEquals(""Notify"", node.getLocalName());
    Thread.sleep(500);
}"
"@Test
public void testUseExport() throws Exception {
    checkoutDir.mkdirs();
    CheckoutMojo mojo = ((CheckoutMojo) (lookupMojo(""checkout"", getTestFile(""src/test/resources/mojos/checkout/checkoutUsingExport.xml""))));
    mojo.setCheckoutDirectory(checkoutDir);
    mojo.execute();
    assertTrue(checkoutDir.listFiles().length > 0);
    assertFalse(new File(checkoutDir, "".svn"").exists());
}"
"@Test
public void incrementUpperLimitIfOneMinuteElapsedSinceLastUpdate() throws InterruptedException {
    Clock clock = mock(Clock.class);
    when(clock.getTimeMillis()).thenReturn(0L, TWO_MINUTES_IN_MILLIS, 2 * TWO_MINUTES_IN_MILLIS, 3 * TWO_MINUTES_IN_MILLIS);
    TimestampBoundStore timestampBoundStore = initialTimestampBoundStore();
    PersistentTimestampService persistentTimestampService = PersistentTimestampService.create(timestampBoundStore, clock);
    persistentTimestampService.getFreshTimestamp();
    Thread.sleep(10);
    persistentTimestampService.getFreshTimestamp();
    Thread.sleep(10);
    verify(timestampBoundStore, atLeast(2)).storeUpperLimit(anyLong());
}"
"public void testUnwrapping() throws Exception {
    JsonSchema jsonSchema=MAPPER.generateJsonSchema(UnwrappingRoot.class);
    ObjectNode root=jsonSchema.getSchemaNode();
    JsonNode propertiesSchema=root.get(""properties"");
    String ageType=propertiesSchema.get(""age"").get(""type"").asText();
    String firstType=propertiesSchema.get(""name.first"").get(""type"").asText();
    String lastType=propertiesSchema.get(""name.last"").get(""type"").asText();
    String type=root.get(""type"").asText();
    assertEquals(type,""object"");
    assertEquals(ageType,""integer"");
    assertEquals(firstType,""string"");
    assertEquals(lastType,""string"");
}"
"@Test public void wrapperBooleans(){
    assertThat(testResult(WrapperBooleans.class),isSuccessful());
    assertEquals(1,WrapperBooleans.iterations);
    assertEquals(singleton(false),WrapperBooleans.testCases);
    WrapperBooleans.iterations=0;
}"
"@Test
public void testScannerResultCodes() throws Exception {
    Header[] headers = new Header[3];
    headers[0] = new Header(""Content-Type"", Constants.MIMETYPE_XML);
    headers[1] = new Header(""Accept"", Constants.MIMETYPE_JSON);
    headers[2] = new Header(""Accept-Encoding"", ""gzip"");
    Response response = client.post((""/"" + TABLE) + ""/scanner"", headers, ""<Scanner/>"".getBytes());
    assertEquals(response.getCode(), 201);
    String scannerUrl = response.getLocation();
    assertNotNull(scannerUrl);
    response = client.get(scannerUrl);
    assertEquals(response.getCode(), 200);
    response = client.get(scannerUrl);
    assertEquals(response.getCode(), 204);
}"
"@Test public void acrossParametersOfSameParameterizedTypeWithOneConstant() throws Exception {
    assertThat(testResult(ParametersOfSameParameterizedTypeWithOneConstant.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ParametersOfSameParameterizedTypeWithOneConstant.iterations);
    ParametersOfSameParameterizedTypeWithOneConstant.iterations=0;
}"
"@Test
public class Test {
    public void onReceive() {
        object broadcastReceiver = TestBroadcast();
        context.registerReceiver(
        broadcastReceiver,
        IntentFilter(BROADCAST_ACTION)
        );
        String value = ""value"" ;
        context.sendBroadcast(Intent(BROADCAST_ACTION).putExtra(EXTRA_STRING, value));
        shadowOf(getMainLooper()).idle() ;
        assertWithMessage(""Broadcast receiver did not execute"")
        .that(broadcastReceiver.broadcastExecuted.await(1, SECONDS))
        .isTrue();
        assertThat(broadcastReceiver.extraValue.get()).isEqualTo(value);
        assertThat(broadcastReceiver.job.get().isCancelled).isTrue();
    }
}"
"public void test_sqlDate() throws Exception {
    java.util.Date date=new java.util.Date();
    long millis=date.getTime();
    long millis2=(millis / 1000) * 1000;
    SimpleDateFormat dateFormat=new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss.SSS"",JSON.defaultLocale);
    dateFormat.setTimeZone(JSON.defaultTimeZone);
    String text=dateFormat.format(millis);
    text=text.replace(' ','T');
    SimpleDateFormat dateFormat2=new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"",JSON.defaultLocale);
    dateFormat2.setTimeZone(JSON.defaultTimeZone);
    String text2=dateFormat2.format(millis2);
    text2=text2.replace(' ','T');
    Assert.assertNull(JSON.parseObject(""null"",Date.class));
    Assert.assertNull(JSON.parseObject(""\""\"""",Date.class));
    Assert.assertNull(JSON.parseArray(""null"",Date.class));
    Assert.assertNull(JSON.parseArray(""[null]"",Date.class).get(0));
    Assert.assertNull(JSON.parseObject(""{\""value\"":null}"",VO.class).getValue());
    Assert.assertEquals(new Date(millis),JSON.parseObject("""" + millis,Date.class));
    Assert.assertEquals(new Date(millis),JSON.parseObject(""{\""@type\"":\""java.sql.Date\"",\""val\"":"" + millis + ""}"",Date.class));
    Assert.assertEquals(new Date(millis),JSON.parseObject(""\"""" + millis + ""\"""",Date.class));
    Assert.assertEquals(new Date(millis2),JSON.parseObject(""\"""" + text2 + ""\"""",Date.class));
    Assert.assertEquals(new Date(millis),JSON.parseObject(""\"""" + text + ""\"""",Date.class));
}"
"@Test
public void TestSimpleDiamond() {
    Node x = new Node(4);
    Node n = new Node(1).addkid(new Node(2).addkid(x)).addkid(new Node(3).addkid(x));
    Graph g = new Graph(n);
    MHGDominatorsFinder<Node> finder = new MHGDominatorsFinder<Node>(g);
    DominatorTree<Node> tree = new DominatorTree<Node>(finder);
    assertThat(tree.getHeads().size(), is(1));
    DominatorNode<Node> head = tree.getHeads().get(0);
    assertThat(head.getGode().id, is(1));
    Set<Integer> kids = kid_ids(head);
    assertThat(kids.size(), is(3));
    assertThat(kids, contains(2, 3, 4));
}"
"@Test public void wrapperIntegers() throws Exception {
    assertThat(testResult(WrapperIntegers.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperIntegers.iterations);
    assertEquals(new HashSet<>(asList(4,5)),new HashSet<>(WrapperIntegers.values.subList(0,2)));
    WrapperIntegers.iterations=0;
}"
"@Test
public void testAddLocation() throws Exception {
    DataSize maxResponseSize = DataSize.of(10, MEGABYTE);
    MockExchangeRequestProcessor processor = new MockExchangeRequestProcessor(maxResponseSize);
    TaskId task1 = new TaskId(new StageId(""query"", 1), 0, 0);
    TaskId task2 = new TaskId(new StageId(""query"", 1), 1, 0);
    TaskId task3 = new TaskId(new StageId(""query"", 1), 2, 0);
    URI location1 = URI.create(""http:www.example1.com"");
    URI location2 = URI.create(""http:www.example2.com"");
    URI location3 = URI.create(""http:www.example3.com"");
    processor.addPage(location1, createSerializedPage(1));
    processor.addPage(location1, createSerializedPage(2));
    TestingExchangeClientBuffer buffer = new TestingExchangeClientBuffer(DataSize.of(1, MEGABYTE));
    @SuppressWarnings(""resource"")
    ExchangeClient exchangeClient = new ExchangeClient(""localhost"", DataIntegrityVerification.ABORT, buffer, maxResponseSize, 1, new Duration(1, TimeUnit.MINUTES), true, new TestingHttpClient(processor, scheduler), scheduler, new SimpleLocalMemoryContext(newSimpleAggregatedMemoryContext(), ""test""), pageBufferClientCallbackExecutor, ( taskId, failure) -> {
    });
    assertThat(buffer.getAllTasks()).isEmpty();
    assertThat(buffer.getPages().asMap()).isEmpty();
    assertThat(buffer.getFinishedTasks()).isEmpty();
    assertThat(buffer.getFailedTasks().asMap()).isEmpty();
    assertFalse(buffer.isNoMoreTasks());
    exchangeClient.addLocation(task1, location1);
    assertThat(buffer.getAllTasks()).containsExactly(task1);
    assertTaskIsNotFinished(buffer, task1);
    processor.setComplete(location1);
    buffer.whenTaskFinished(task1).get(10, SECONDS);
    assertThat(buffer.getPages().get(task1)).hasSize(2);
    assertThat(buffer.getFinishedTasks()).containsExactly(task1);
    exchangeClient.addLocation(task2, location2);
    assertThat(buffer.getAllTasks()).containsExactlyInAnyOrder(task1, task2);
    assertTaskIsNotFinished(buffer, task2);
    processor.setComplete(location2);
    buffer.whenTaskFinished(task2).get(10, SECONDS);
    assertThat(buffer.getFinishedTasks()).containsExactlyInAnyOrder(task1, task2);
    assertThat(buffer.getPages().get(task2)).hasSize(0);
    exchangeClient.addLocation(task3, location3);
    assertThat(buffer.getAllTasks()).containsExactlyInAnyOrder(task1, task2, task3);
    assertTaskIsNotFinished(buffer, task3);
    exchangeClient.noMoreLocations();
    assertTrue(buffer.isNoMoreTasks());
    assertThat(buffer.getAllTasks()).containsExactlyInAnyOrder(task1, task2, task3);
    assertTaskIsNotFinished(buffer, task3);
    exchangeClient.close();
    assertEventually(() -> assertEquals(exchangeClient.getStatus().getPageBufferClientStatuses().get(0).getHttpRequestState(), ""not scheduled"", ""httpRequestState""));
    assertEventually(() -> assertEquals(exchangeClient.getStatus().getPageBufferClientStatuses().get(1).getHttpRequestState(), ""not scheduled"", ""httpRequestState""));
    assertEventually(() -> assertEquals(exchangeClient.getStatus().getPageBufferClientStatuses().get(2).getHttpRequestState(), ""not scheduled"", ""httpRequestState""));
    assertThat(buffer.getFinishedTasks()).containsExactlyInAnyOrder(task1, task2, task3);
    assertThat(buffer.getFailedTasks().asMap()).isEmpty();
    assertTrue(exchangeClient.isFinished());
}"
"@Test
public void recurringJobWithExceptionShouldKeepRunning() throws Exception
{
    RobustJobSchedulerWrapper robustWrapper = new RobustJobSchedulerWrapper( actualScheduler, log );
    AtomicInteger count = new AtomicInteger();
    IllegalStateException e = new IllegalStateException();
    int nRuns = 100;
    JobHandle jobHandle = robustWrapper.scheduleRecurring( ""JobName"", 1, () -> {
        if ( count.get() < nRuns )
        {
            count.incrementAndGet();
            throw e;
        }
    }
    );
    assertEventually( ""run count"", count::get, Matchers.equalTo( nRuns ), DEFAULT_TIMEOUT_MS , MILLISECONDS );
    robustWrapper.cancelAndWaitTermination( jobHandle );
    verify( log, timeout( DEFAULT_TIMEOUT_MS ).times( nRuns ) ).warn( ""Uncaught exception"", e );
}"
"@Test public void test_alter() throws Exception {
    String sql=""ALTER RESOURCE GROUP sql_thread TYPE = USER VCPU = 1,3 THREAD_PRIORITY = -20"";
    List<SQLStatement> stmtList=SQLUtils.toStatementList(sql,JdbcConstants.HIVE);
    SQLStatement stmt=stmtList.get(0);
    MySqlSchemaStatVisitor visitor=new MySqlSchemaStatVisitor();
    stmt.accept(visitor);
    String output=SQLUtils.toMySqlString(stmt);
    Set<String> allPossibleRes=generateAllPossibleRes(""ALTER RESOURCE GROUP sql_thread "");
    assertTrue(allPossibleRes.contains(output));
}"
"@Test
public void notifyAboutChangesConcurrently() {
    final int numberOfThreads = 100;
    final TestSubscriber<Changes> testSubscriber = new TestSubscriber<Changes>();
    final Set<String> tables = new HashSet<String>();
    final List<Changes> expectedChanges = new ArrayList<Changes>();
    for (int i = 0; i < numberOfThreads; i++) {
        final String table = ""test_table"" + i;
        tables.add(table);
        expectedChanges.add(Changes.newInstance(table));
    }
    storIOSQLite.observeChanges(LATEST).subscribe(testSubscriber);
    final CountDownLatch startAllThreadsLock = new CountDownLatch(1);
    for (int i = 0; i < numberOfThreads; i++) {
        final int finalI = i;
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    startAllThreadsLock.await();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                storIOSQLite.lowLevel().notifyAboutChanges(Changes.newInstance(""test_table"" + finalI));
            }
        }).start();
    }
    startAllThreadsLock.countDown();
    final long startTime = SystemClock.elapsedRealtime();
    while ((testSubscriber.valueCount() != tables.size()) && ((SystemClock.elapsedRealtime() - startTime) < 20000)) {
        Thread.yield();
    }
    testSubscriber.assertNoErrors();
    testSubscriber.assertValueCount(expectedChanges.size());
    assertThat(expectedChanges.containsAll(testSubscriber.values())).isTrue();
}"
"/**
* Test destory registry, exporter can be normal by destroyed
*/
@Test public void testDestoryRegistry(){
    URL newRegistryUrl=registryUrl.addParameter(Constants.EXPORT_KEY,serviceUrl);
    Invoker<RegistryProtocolTest> invoker=new MockInvoker<RegistryProtocolTest>(RegistryProtocolTest.class,newRegistryUrl);
    Exporter<?> exporter=protocol.export(invoker);
    destroyRegistryProtocol();
    try {
        Thread.sleep(ConfigurationUtils.getServerShutdownTimeout() + 100);
    }
    catch (  InterruptedException e) {
        e.printStackTrace();
    }
    assertEquals(false,exporter.getInvoker().isAvailable());
}"
"@Test public void strings(){
    assertThat(testResult(Strings.class),isSuccessful());
    assertEquals(2,Strings.iterations);
    assertEquals(new HashSet<>(asList(""some"",""values"")),Strings.testCases);
    Strings.iterations=0;
    Strings.testCases.clear();
}"
"@Test
public void testBind() throws Exception {
    final Name name = new CompositeName(""test"");
    final Object value = new Object();
    WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);
    try {
        store.bind(name, value);
    } finally {
        WritableServiceBasedNamingStore.popOwner();
    }
    assertEquals(value, store.lookup(name));
}"
"@Test
public void testDelegationTokenSecretManager() throws Exception {
    DelegationTokenSecretManager dtSecretManager = cluster.getNameNode().getNamesystem().getDelegationTokenSecretManager();
    Token<DelegationTokenIdentifier> token = generateDelegationToken(""SomeUser"", ""JobTracker"");
    try {
        dtSecretManager.renewToken(token, ""FakeRenewer"");
        Assert.fail(""should have failed"");
    } catch (AccessControlException ace) {
    }
    dtSecretManager.renewToken(token, ""JobTracker"");
    DelegationTokenIdentifier identifier = new DelegationTokenIdentifier();
    byte[] tokenId = token.getIdentifier();
    identifier.readFields(new DataInputStream(new ByteArrayInputStream(tokenId)));
    Assert.assertTrue(null != dtSecretManager.retrievePassword(identifier));
    LOG.info(""Sleep to expire the token"");
    Thread.sleep(6000);
    try {
        dtSecretManager.retrievePassword(identifier);
        Assert.fail(""Token should have expired"");
    } catch (InvalidToken e) {
    }
    dtSecretManager.renewToken(token, ""JobTracker"");
    LOG.info(""Sleep beyond the max lifetime"");
    Thread.sleep(5000);
    try {
        dtSecretManager.renewToken(token, ""JobTracker"");
        Assert.fail(""should have been expired"");
    } catch (InvalidToken it) {
    }
}"
"@Test public void testGetAuths() throws Exception {
    Collection<Authorizations> auths=AuthCache.getAuthorizations(cookie);
    Assert.assertEquals(1,auths.size());
    Authorizations a=auths.iterator().next();
    String[] authStrings=a.toString().split("","");
    Arrays.sort(authStrings);
    Assert.assertEquals(""[A, B, C]"",Arrays.toString(authStrings));
}"
"@Test public void testAdditionalModelTypeAnnotationsNoDuplicate() throws Exception {
    OpenAPI openAPI=TestUtils.createOpenAPI();
    final AbstractJavaCodegen codegen=new P_AbstractJavaCodegen();
    codegen.additionalProperties().put(AbstractJavaCodegen.ADDITIONAL_MODEL_TYPE_ANNOTATIONS,""@Foo;@Bar;@Foo"");
    codegen.processOpts();
    codegen.preprocessOpenAPI(openAPI);
    final List<String> additionalModelTypeAnnotations=new ArrayList<String>();
    additionalModelTypeAnnotations.add(""@Foo"");
    additionalModelTypeAnnotations.add(""@Bar"");
    final List<String> sortedCodegenAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    final List<String> sortedAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    Collections.sort(sortedCodegenAdditionalModelTypeAnnotations);
    Collections.sort(sortedAdditionalModelTypeAnnotations);
    Assert.assertEquals(sortedCodegenAdditionalModelTypeAnnotations,sortedAdditionalModelTypeAnnotations);
}"
"@Test
public void testLogbackStatusPrinterPrintStreamIsRestoredToSystemOut() throws Exception {
    Field field = StatusPrinter.class.getDeclaredField(""ps"");
    field.setAccessible(true);
    PrintStream out = (PrintStream) field.get(null);
    assertThat(out).isSameAs(System.out);
}"
"@Test public void boolArray(){
    final WithArrays wa=new WithArrays();
    wa.boolArray=new boolean[]{true,false,true};
    final String exp=getClassPrefix(wa) + ""["" + BR+ ""  boolArray={""+ BR+ ""    true,""+ BR+ ""    false,""+ BR+ ""    true""+ BR+ ""  },""+ BR+ ""  charArray=<null>,""+ BR+ ""  doubleArray=<null>,""+ BR+ ""  intArray=<null>,""+ BR+ ""  longArray=<null>,""+ BR+ ""  stringArray=<null>""+ BR+ ""]"";
    assertEquals(exp,toString(wa));
}"
"/**
* Tests ReflectionToStringBuilder.toString() for statics.
*/
@Test public void testReflectionStatics(){
    final ReflectionStaticFieldsFixture instance1=new ReflectionStaticFieldsFixture();
    assertEquals(this.toBaseString(instance1) + ""[instanceInt=67890,instanceString=instanceString,staticInt=12345,staticString=staticString]"",ReflectionToStringBuilder.toString(instance1,null,false,true,ReflectionStaticFieldsFixture.class));
    assertEquals(this.toBaseString(instance1) + ""[instanceInt=67890,instanceString=instanceString,staticInt=12345,staticString=staticString,staticTransientInt=54321,staticTransientString=staticTransientString,transientInt=98765,transientString=transientString]"",ReflectionToStringBuilder.toString(instance1,null,true,true,ReflectionStaticFieldsFixture.class));
    assertEquals(this.toBaseString(instance1) + ""[instanceInt=67890,instanceString=instanceString,staticInt=12345,staticString=staticString]"",this.toStringWithStatics(instance1,null,ReflectionStaticFieldsFixture.class));
    assertEquals(this.toBaseString(instance1) + ""[instanceInt=67890,instanceString=instanceString,staticInt=12345,staticString=staticString]"",this.toStringWithStatics(instance1,null,ReflectionStaticFieldsFixture.class));
}"
"@Test
public void journalBlockDeletion() throws Exception {
    FileSystem fs = mCluster.getClient();
    BlockMaster blockMaster = mCluster.getLocalAlluxioMaster().getMasterProcess().getMaster(BlockMaster.class);
    AlluxioURI file = new AlluxioURI(""/test"");
    FileSystemTestUtils.createByteFile(fs, file, MUST_CACHE, 10);
    URIStatus status = fs.getStatus(file);
    Long blockId = status.getBlockIds().get(0);
    assertNotNull(blockMaster.getBlockInfo(blockId));
    fs.delete(file);
    WorkerNetAddress workerAddress = mCluster.getWorkerAddress();
    try {
        blockMaster.getBlockInfo(blockId);
        fail(""Expected the block to be deleted"");
    } catch (BlockInfoException e) {
    }
    mCluster.stopMasters();
    mCluster.startMasters();
    AlluxioMasterProcess masterProcess = mCluster.getLocalAlluxioMaster().getMasterProcess();
    try {
        masterProcess.getMaster(BlockMaster.class).getBlockInfo(blockId);
        fail(""Expected the block to be deleted after restart"");
    } catch (BlockInfoException e) {
    }
}"
"@Test public void test_number_formt_tojson(){
    NumBean num=new NumBean();
    num.setNum1(1);
    String a=""{\n"" + ""   \""num1\"": \""01.00\"",\n"" + ""   \""num2\"": \""02.00\""\n""+ ""}"";
    String str=Json.toJson(num);
    assertJsonEqualsNonStrict(a,str);
    System.out.println(str);
}"
"@Test public void primitiveBytes() throws Exception {
    assertThat(testResult(PrimitiveBytes.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveBytes.iterations);
    assertEquals(new HashSet<>(asList((byte)12,(byte)-13)),new HashSet<>(PrimitiveBytes.values.subList(0,2)));
    PrimitiveBytes.iterations=0;
}"
"@Test
public void testCloseReason() throws Exception {
    MessageEndpoint.reset();
    Session session = deployment.connectToServer(AnnotatedClientEndpoint.class, new URI(""ws://"" + DefaultServer.getHostAddress(""default"") + "":"" + DefaultServer.getHostPort(""default"") + ""/ws/chat/Bob""));
    Assert.assertEquals(""hi Bob (protocol=foo)"", AnnotatedClientEndpoint.message());
    session.close(new CloseReason(CloseReason.CloseCodes.VIOLATED_POLICY, ""Foo!""));
    Assert.assertEquals(""CLOSED"", AnnotatedClientEndpoint.message());
    CloseReason cr = MessageEndpoint.getReason();
    Assert.assertEquals(CloseReason.CloseCodes.VIOLATED_POLICY.getCode(), cr.getCloseCode().getCode());
    Assert.assertEquals(""Foo!"", cr.getReasonPhrase());
}"
"@Test
public void testListTaskWithCriteria() throws Exception {
    requireDockerApiVersionAtLeast(""1.24"", ""swarm support"");
    final ServiceSpec spec = createServiceSpec(randomName());
    assertThat(sut.listTasks().size(), is(0));
    sut.createService(spec);
    await().until(numberOfTasks(sut), is(greaterThan(0)));
    final Task task = sut.listTasks().get(1);
    final List<Task> tasksWithId = sut.listTasks(Task.find().taskId(task.id()).build());
    assertThat(tasksWithId.size(), is(1));
    assertThat(tasksWithId.get(0), equalTo(task));
    final List<Task> tasksWithServiceName = sut.listTasks(Task.find().serviceName(spec.name()).build());
    assertThat(tasksWithServiceName.size(), is(greaterThanOrEqualTo(1)));
    final Set<String> taskIds = Sets.newHashSet(Lists.transform(tasksWithServiceName, new Function<Task, String>()));
    assertThat(task.id(), isIn(taskIds));
}"
"@Test public void unboxingAFoo() throws Exception {
    assertThat(testResult(UnboxingAFoo.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),UnboxingAFoo.iterations);
    UnboxingAFoo.iterations=0;
}"
"@Test public void explicitConversion() throws Exception {
    assertThat(testResult(ExplicitConversion.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ExplicitConversion.iterations);
    assertEquals(new HashSet<>(asList(LocalDate.of(2017,1,1),LocalDate.of(2001,12,25))),new HashSet<>(ExplicitConversion.values.subList(0,2)));
    ExplicitConversion.iterations=0;
}"
"@Test
public void testMonitor() throws IOException, InterruptedException {
    monitor.setScanInterval(5);
    assertTrue(monitor.getEntries().isEmpty());
    File fooFile = touchFile(""foo"", ""foo1"");
    Thread.sleep(MONITOR_CHECK_DELAY);
    Collection<TestInstance> entries = monitor.getEntries();
    assertEquals(1, entries.size());
    TestInstance[] entryArray = new TestInstance[1];
    entryArray = entries.toArray(entryArray);
    TestInstance fooInst = entryArray[0];
    assertEquals(""foo1"", fooInst.getMessage());
    touchFile(""bar"", ""bar1"");
    Thread.sleep(MONITOR_CHECK_DELAY);
    entries = monitor.getEntries();
    assertEquals(2, entries.size());
    TestInstance fooCheck = monitor.get(""foo"");
    TestUtil.testArray(entryNames(entries), new String[]{ ""foo1"", ""bar1"" });
    assertEquals(fooCheck, fooInst);
    touchFile(""foo"", ""foo2"");
    Thread.sleep(MONITOR_CHECK_DELAY);
    entries = monitor.getEntries();
    assertEquals(2, entries.size());
    TestUtil.testArray(entryNames(entries), new String[]{ ""foo2"", ""bar1"" });
    fooCheck = monitor.get(""foo"");
    assertNotSame(fooInst, fooCheck);
    assertEquals(""foo2"", fooCheck.getMessage());
    fooFile.delete();
    Thread.sleep(MONITOR_CHECK_DELAY);
    entries = monitor.getEntries();
    assertEquals(1, entries.size());
    TestUtil.testArray(entryNames(entries), new String[]{ ""bar1"" });
}"
"@Test public void testDubboProtocolWithMina() throws Exception {
    DemoService service=new DemoServiceImpl();
    protocol.export(proxy.getInvoker(service,DemoService.class,URL.valueOf(""dubbo://127.0.0.1:9011/"" + DemoService.class.getName()).addParameter(Constants.SERVER_KEY,""mina"")));
    service=proxy.getProxy(protocol.refer(DemoService.class,URL.valueOf(""dubbo://127.0.0.1:9011/"" + DemoService.class.getName()).addParameter(Constants.CLIENT_KEY,""mina"").addParameter(""timeout"",3000l)));
    for (int i=0; i < 10; i++) {
        assertEquals(service.enumlength(new Type[]{}),Type.Lower);
        assertEquals(service.getSize(null),-1);
        assertEquals(service.getSize(new String[]{"""","""",""""}),3);
    }
    Map<String,String> map=new HashMap<String,String>();
    map.put(""aa"",""bb"");
    for (int i=0; i < 10; i++) {
        Set<String> set=service.keys(map);
        assertEquals(set.size(),1);
        assertEquals(set.iterator().next(),""aa"");
        service.invoke(""dubbo://127.0.0.1:9010/"" + DemoService.class.getName() + """",""invoke"");
    }
    service=proxy.getProxy(protocol.refer(DemoService.class,URL.valueOf(""dubbo://127.0.0.1:9011/"" + DemoService.class.getName() + ""?client=mina"").addParameter(""timeout"",3000l)));
    StringBuffer buf=new StringBuffer();
    for (int i=0; i < 1024 * 32 + 32; i++)   buf.append('A');
    System.out.println(service.stringLength(buf.toString()));
    EchoService echo=proxy.getProxy(protocol.refer(EchoService.class,URL.valueOf(""dubbo://127.0.0.1:9011/"" + DemoService.class.getName() + ""?client=mina"").addParameter(""timeout"",3000l)));
    for (int i=0; i < 10; i++) {
        assertEquals(echo.$echo(buf.toString()),buf.toString());
        assertEquals(echo.$echo(""test""),""test"");
        assertEquals(echo.$echo(""abcdefg""),""abcdefg"");
        assertEquals(echo.$echo(1234),1234);
    }
}"
"@Test
public void testRejectionsEAP6() throws Exception {
    testTransformer(""subsystem.xml"", ModelTestControllerVersion.EAP_6_4_0, ModelVersion.create(1, 3),""jboss-as-naming"");
}"
"public void testForIssue(){
    ArrayListMultimap<String,String> multimap=ArrayListMultimap.create();
    multimap.put(""a"",""1"");
    multimap.put(""a"",""2"");
    multimap.put(""a"",""3"");
    multimap.put(""b"",""1"");
    VO vo=new VO();
    vo.setMap(multimap);
    vo.setName(""zhangsan"");
    assertEquals(""{\""map\"":{\""a\"":[\""1\"",\""2\"",\""3\""],\""b\"":[\""1\""]},\""name\"":\""zhangsan\""}"",JSON.toJSONString(vo,SerializerFeature.MapSortField));
}"
"@Test
public void testReplicaThreadedThroughputDegradationAndRejection() throws Exception {
    Settings settings = Settings.builder().put(IndexingPressure.MAX_INDEXING_BYTES.getKey(), ""10KB"")
    .put(ShardIndexingPressureSettings.SHARD_INDEXING_PRESSURE_ENABLED.getKey(), true)
    .put(ShardIndexingPressureSettings.SHARD_INDEXING_PRESSURE_ENFORCED.getKey(), true)
    .put(ShardIndexingPressureMemoryManager.THROUGHPUT_DEGRADATION_LIMITS.getKey(), 1)
    .put(ShardIndexingPressureSettings.REQUEST_SIZE_WINDOW.getKey(), 100)
    .build();
    final int NUM_THREADS = scaledRandomIntBetween(100, 120);
    ShardIndexingPressure shardIndexingPressure = new ShardIndexingPressure(settings, clusterService);
    Index index = new Index(""IndexName"", ""UUID"");
    ShardId shardId1 = new ShardId(index, 0);
    fireConcurrentAndParallelRequestsForUniformThroughPut(NUM_THREADS, shardIndexingPressure, shardId1, 100, 100,
    OperationType.REPLICA);
    fireAllThenCompleteConcurrentRequestsWithUniformDelay(ShardIndexingPressureSettings.REQUEST_SIZE_WINDOW.get(settings),
    shardIndexingPressure, shardId1, 100, 200, OperationType.REPLICA);
    expectThrows(OpenSearchRejectedExecutionException.class,
    () -> shardIndexingPressure.markReplicaOperationStarted(shardId1, 11 * 1024, false));
    assertEquals(0, shardIndexingPressure.coldStats().getIndexingPressureShardStats(shardId1).getCurrentReplicaBytes());
    assertEquals(15, shardIndexingPressure.coldStats().getIndexingPressureShardStats(shardId1).getCurrentReplicaLimits());
}"
"@Test public void wrapperFloats(){
    assertThat(testResult(WrapperFloats.class),isSuccessful());
    assertEquals(2,WrapperFloats.iterations);
    assertEquals(new HashSet<>(asList(1.7F,-4.14F)),WrapperFloats.testCases);
    WrapperFloats.iterations=0;
}"
"@Test
public void testReplicatorProducerName() throws Exception {
    log.info(""--- Starting ReplicatorTest::testReplicatorProducerName ---"");
    final String topicName = BrokerTestUtil.newUniqueName(""persistent"");
    final TopicName dest = TopicName.get(topicName);
    @Cleanup
    MessageProducer producer1 = new MessageProducer(url1, dest);
    Awaitility.await().untilAsserted(() -> {
        assertTrue(pulsar2.getBrokerService().getTopicReference(topicName).isPresent());
    });
    Optional<Topic> topic = pulsar2.getBrokerService().getTopicReference(topicName);
    assertTrue(topic.isPresent());
    Set<String> remoteClusters = topic.get().getProducers().values().stream().map(Producer::getRemoteCluster).collect(Collectors.toSet());
    assertTrue(remoteClusters.contains(""r1""));
}"
"@Test public void manyParametersWithBooleanAndEnum(){
    assertThat(testResult(ManyParametersWithBooleanAndEnum.class),isSuccessful());
    int expectedCount=4 * 4 * 2* RoundingMode.values().length;
    assertEquals(expectedCount,ManyParametersWithBooleanAndEnum.iterations);
    for (int i=0; i < expectedCount / 4; ++i) {
        assertEquals(String.valueOf(i),asList(3,7),ManyParametersWithBooleanAndEnum.firstTestCases.subList(i * 4,i * 4 + 2));
    }
    for (int i=0; i < expectedCount / 16; ++i) {
        assertEquals(String.valueOf(i),asList('a','a','a','a','b','b','b','b','c','c','c','c'),ManyParametersWithBooleanAndEnum.secondTestCases.subList(i * 16,i * 16 + 12));
    }
    for (int i=0; i < expectedCount / 32; ++i) {
        assertEquals(asList(false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false),ManyParametersWithBooleanAndEnum.thirdTestCases.subList(i * 32,i * 32 + 16));
        assertEquals(asList(true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true),ManyParametersWithBooleanAndEnum.thirdTestCases.subList(i * 32 + 16,i * 32 + 32));
    }
    assertEquals(expectedCount,ManyParametersWithBooleanAndEnum.fourthTestCases.size());
    assertEquals(EnumSet.allOf(RoundingMode.class),new HashSet<>(ManyParametersWithBooleanAndEnum.fourthTestCases));
    ManyParametersWithBooleanAndEnum.iterations=0;
    ManyParametersWithBooleanAndEnum.fourthTestCases.clear();
}"
"@Test
public void testRemoveFirstConsumer() throws Exception {
    this.conf.setSubscriptionKeySharedEnable(true);
    String topic = ""testReadAheadWhenAddingConsumers-"" + UUID.randomUUID();
    @Cleanup
    Producer<Integer> producer = createProducer(topic, false);
    @Cleanup
    Consumer<Integer> c1 = pulsarClient.newConsumer(INT32).topic(topic).subscriptionName(""key_shared"").subscriptionType(Key_Shared).receiverQueueSize(10).consumerName(""c1"").subscribe();
    for (int i = 0; i < 10; i++) {
        producer.newMessage().key(String.valueOf(random.nextInt(NUMBER_OF_KEYS))).value(i).send();
    }
    @Cleanup
    Consumer<Integer> c2 = pulsarClient.newConsumer(INT32).topic(topic).subscriptionName(""key_shared"").subscriptionType(Key_Shared).receiverQueueSize(10).consumerName(""c2"").subscribe();
    for (int i = 10; i < 20; i++) {
        producer.newMessage().key(String.valueOf(random.nextInt(NUMBER_OF_KEYS))).value(i).send();
    }
    assertNull(c2.receive(100, TimeUnit.MILLISECONDS));
    c1.close();
    for (int i = 0; i < 20; i++) {
        Message<Integer> msg = c2.receive();
        assertEquals(msg.getValue().intValue(), i);
        c2.acknowledge(msg);
    }
}"
"@Test
public void testCorrectRebalancingCurrentlyRentingPartitions() throws Exception {
    IgniteEx ignite = ((IgniteEx) (startGrids(3)));
    ignite.cluster().active(true);
    final int keysCnt = SF.applyLB(300000, 10000);
    try (final IgniteDataStreamer<Integer, Integer> ds = ignite.dataStreamer(CACHE_NAME)) {
        log.info(""Writing initial data..."");
        ds.allowOverwrite(true);
        for (int k = 1; k <= keysCnt; k++) {
            ds.addData(k, k);
            if ((k % 10000) == 0) {
                log.info((""Written "" + k) + "" entities."");
            }
        }
        log.info(""Writing initial data finished."");
    }
    startGrid(3);
    resetBaselineTopology();
    stopGrid(3);
    resetBaselineTopology();
    stopGrid(1);
    startGrid(1);
    awaitPartitionMapExchange();
    for (int k = 1; k <= keysCnt; k++) {
        Integer val = ((Integer) (ignite.cache(CACHE_NAME).get(k)));
        Assert.assertNotNull((""Value for "" + k) + "" is null"", val);
        Assert.assertEquals(((""Check failed for "" + k) + "" = "") + val, k, ((int) (val)));
    }
}"
"public void test_for_issue() throws Exception {
    DubboResponse resp=new DubboResponse();
    JSONObject obj=new JSONObject();
    obj.put(""key1"",""value1"");
    obj.put(""key2"",""value2"");
    resp.setData(obj);
    String str=JSON.toJSONString(resp,SerializerFeature.MapSortField);
    System.out.println(str);
    DubboResponse resp1=JSON.parseObject(str,DubboResponse.class);
    assertEquals(str,JSON.toJSONString(resp1,SerializerFeature.MapSortField));
    JSONArray arr=new JSONArray();
    arr.add(""key1"");
    arr.add(""key2"");
    resp.setData(arr);
    String str2=JSON.toJSONString(resp,SerializerFeature.MapSortField);
    System.out.println(str2);
    DubboResponse resp2=JSON.parseObject(str2,DubboResponse.class);
    assertEquals(str2,JSON.toJSONString(resp2,SerializerFeature.MapSortField));
}"
"@Test public void primitiveFloats() throws Exception {
    assertThat(testResult(PrimitiveFloats.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveFloats.iterations);
    assertEquals(new HashSet<>(asList(3.3F,-5F)),new HashSet<>(PrimitiveFloats.values.subList(0,2)));
    PrimitiveFloats.iterations=0;
}"
"@Test
public void outerInnerErrorRace() {
    for (int i = 0; i < 500; i++) {
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final PublishSubject<Integer> ps1 = PublishSubject.create();
            final PublishSubject<Integer> ps2 = PublishSubject.create();
            ps1.switchMap(new Function<Integer, ObservableSource<Integer>>() {
                @Override
                public ObservableSource<Integer> apply(Integer v) throws Exception {
                    if (v == 1) {
                        return ps2;
                    }
                    return Observable.never();
                }
            })
            .test();
            final TestException ex1 = new TestException();
            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps1.onError(ex1);
                }
            };
            final TestException ex2 = new TestException();
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps2.onError(ex2);
                }
            };
            TestHelper.race(r1, r2);
            for (Throwable e : errors) {
                assertTrue(e.toString(), e instanceof TestException);
            }
        } finally {
            RxJavaPlugins.reset();
        }
    }
}"
"@Test public void onlyTrumpsAlso() throws Exception {
    assertThat(testResult(OnlyTrumpsAlso.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),OnlyTrumpsAlso.iterations);
    OnlyTrumpsAlso.iterations=0;
}"
"@Test
public void testWriteGaps() throws Exception {
    final Object notifyObject = new Object();
    byte[] passwd = new byte[20];
    Arrays.fill(passwd, ((byte) ('a')));
    InetSocketAddress addr = new InetSocketAddress(""127.0.0.1"", port);
    ResultStruct arc = new ResultStruct();
    BookieClient bc = new BookieClient(new ClientConfiguration(), channelFactory, executor);
    ChannelBuffer bb;
    bb = createByteBuffer(1, 1, 1);
    bc.addEntry(addr, 1, passwd, 1, bb, wrcb, null, FLAG_NONE);
    synchronized(arc) {
        bc.readEntry(addr, 1, 1, recb, arc, FLAG_NONE);
        arc.wait(1000);
        assertEquals(0, arc.rc);
        assertEquals(1, arc.entry.getInt());
    }
    bb = createByteBuffer(2, 1, 2);
    bc.addEntry(addr, 1, passwd, 2, bb, wrcb, null, FLAG_NONE);
    bb = createByteBuffer(3, 1, 3);
    bc.addEntry(addr, 1, passwd, 3, bb, wrcb, null, FLAG_NONE);
    bb = createByteBuffer(5, 1, 5);
    bc.addEntry(addr, 1, passwd, 5, bb, wrcb, null, FLAG_NONE);
    bb = createByteBuffer(7, 1, 7);
    bc.addEntry(addr, 1, passwd, 7, bb, wrcb, null, FLAG_NONE);
    synchronized(notifyObject) {
        bb = createByteBuffer(11, 1, 11);
        bc.addEntry(addr, 1, passwd, 11, bb, wrcb, notifyObject, FLAG_NONE);
        notifyObject.wait();
    }
    synchronized(arc) {
        bc.readEntry(addr, 1, 6, recb, arc, FLAG_NONE);
        arc.wait(1000);
        assertEquals(NoSuchEntryException, arc.rc);
    }
    synchronized(arc) {
        bc.readEntry(addr, 1, 7, recb, arc, FLAG_NONE);
        arc.wait(1000);
        assertEquals(0, arc.rc);
        assertEquals(7, arc.entry.getInt());
    }
    synchronized(arc) {
        bc.readEntry(addr, 1, 1, recb, arc, FLAG_NONE);
        arc.wait(1000);
        assertEquals(0, arc.rc);
        assertEquals(1, arc.entry.getInt());
    }
    synchronized(arc) {
        bc.readEntry(addr, 1, 2, recb, arc, FLAG_NONE);
        arc.wait(1000);
        assertEquals(0, arc.rc);
        assertEquals(2, arc.entry.getInt());
    }
    synchronized(arc) {
        bc.readEntry(addr, 1, 3, recb, arc, FLAG_NONE);
        arc.wait(1000);
        assertEquals(0, arc.rc);
        assertEquals(3, arc.entry.getInt());
    }
    synchronized(arc) {
        bc.readEntry(addr, 1, 4, recb, arc, FLAG_NONE);
        arc.wait(1000);
        assertEquals(NoSuchEntryException, arc.rc);
    }
    synchronized(arc) {
        bc.readEntry(addr, 1, 11, recb, arc, FLAG_NONE);
        arc.wait(1000);
        assertEquals(0, arc.rc);
        assertEquals(11, arc.entry.getInt());
    }
    synchronized(arc) {
        bc.readEntry(addr, 1, 5, recb, arc, FLAG_NONE);
        arc.wait(1000);
        assertEquals(0, arc.rc);
        assertEquals(5, arc.entry.getInt());
    }
    synchronized(arc) {
        bc.readEntry(addr, 1, 10, recb, arc, FLAG_NONE);
        arc.wait(1000);
        assertEquals(NoSuchEntryException, arc.rc);
    }
    synchronized(arc) {
        bc.readEntry(addr, 1, 12, recb, arc, FLAG_NONE);
        arc.wait(1000);
        assertEquals(NoSuchEntryException, arc.rc);
    }
    synchronized(arc) {
        bc.readEntry(addr, 1, 13, recb, arc, FLAG_NONE);
        arc.wait(1000);
        assertEquals(NoSuchEntryException, arc.rc);
    }
}"
"@Test public void longArray(){
    final WithArrays wa=new WithArrays();
    wa.longArray=new long[]{1L,2L};
    final String exp=getClassPrefix(wa) + ""["" + BR+ ""  boolArray=<null>,""+ BR+ ""  charArray=<null>,""+ BR+ ""  doubleArray=<null>,""+ BR+ ""  intArray=<null>,""+ BR+ ""  longArray={""+ BR+ ""    1,""+ BR+ ""    2""+ BR+ ""  },""+ BR+ ""  stringArray=<null>""+ BR+ ""]"";
    assertEquals(exp,toString(wa));
}"
"@Test public void serializeParameter() throws IOException {
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.createParameter(""Test"")),""{\""@type\"":\""parameter\"",\""@value\"":\""Test\""}"");
}"
"@Test public void acrossParametersOfSameParameterizedType() throws Exception {
    assertThat(testResult(ParametersOfSameParameterizedType.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ParametersOfSameParameterizedType.iterations);
    ParametersOfSameParameterizedType.iterations=0;
}"
"@Test
public void earlyUnstableStatusShouldReportPunStateAsRunningAndResultAsUnknown() throws Exception {
    WorkflowJob p = j.createProject(WorkflowJob.class, ""project"");
    URL resource = Resources.getResource(getClass(), ""earlyUnstableStatusShouldReportPunStateAsRunningAndResultAsUnknown.jenkinsfile"");
    String jenkinsFile = Resources.toString(resource, Charsets.UTF_8);
    p.setDefinition(new CpsFlowDefinition(jenkinsFile, true));
    p.save();
    Run r = p.scheduleBuild2(0).waitForStart();
    String url = ""/organizations/jenkins/pipelines/project/runs/"" + r.getId() + ""/"";
    Map m = request().get(url).build(Map.class);
    j.waitForMessage(""Running on master"", r);
    while (!""FINISHED"".equals(m.get(""state"").toString())) {
        Assert.assertEquals(""RUNNING"", m.get(""state""));
        Assert.assertEquals(""UNKNOWN"", m.get(""result""));
        Thread.sleep(1000);
        m = request().get(url).build(Map.class);
    }
    Assert.assertEquals(""FINISHED"", m.get(""state""));
    Assert.assertEquals(""UNSTABLE"", m.get(""result""));
}"
"@Test
public void testWsSubprotocols() throws Exception {
    Tomcat tomcat = getTomcatInstance();
    Context ctx = tomcat.addContext("""", System.getProperty(""java.io.tmpdir""));
    ctx.addApplicationListener(new ApplicationListener(Config.class.getName(), false));
    Tomcat.addServlet(ctx, ""default"", new DefaultServlet());
    ctx.addServletMapping(""/"", ""default"");
    tomcat.start();
    WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer();
    tomcat.start();
    Session wsSession = wsContainer.connectToServer(TesterProgrammaticEndpoint.class, Builder.create().preferredSubprotocols(Arrays.asList(""sp3"")).build(), new URI((""ws"")));
    Assert.assertTrue(wsSession.isOpen());
    if (wsSession.getNegotiatedSubprotocol() != null) {
        Assert.assertTrue(wsSession.getNegotiatedSubprotocol().isEmpty());
    }
    wsSession.close();
    wsSession = wsContainer.connectToServer(TesterProgrammaticEndpoint.class, Builder.create().preferredSubprotocols(Arrays.asList(""sp2"")).build(), new URI((""ws"")));
    Assert.assertTrue(wsSession.isOpen());
    Assert.assertEquals(""sp2"", wsSession.getNegotiatedSubprotocol());
    Assert.assertArrayEquals(new String[]{ ""sp1"", ""sp2"" }, SubProtocolsEndpoint.subprotocols.toArray(new String[2]));
    wsSession.close();
}"
"@Test
public void createdWorkerThreadsShouldContainConnectorName() throws Exception
{
    AtomicInteger processNextBatchCount = new AtomicInteger();
    AtomicReference<Thread> poolThread = new AtomicReference<>();
    AtomicReference<String> poolThreadName = new AtomicReference<>();
    String id = UUID.randomUUID().toString();
    BoltConnection connection = newConnection( id );
    when( connection.processNextBatch() ).thenAnswer( inv ->
    {
        poolThread.set( Thread.currentThread() );
        poolThreadName.set( Thread.currentThread().getName() );
        processNextBatchCount.incrementAndGet();
        return true;
    } );
    boltScheduler.start();
    boltScheduler.created( connection );
    boltScheduler.enqueued( connection, Jobs.noop() );
    Predicates.await( () -> processNextBatchCount.get() > 0, 1, MINUTES );
    assertThat( poolThread.get().getName(), not( equalTo( poolThreadName.get() ) ) );
    assertThat( poolThread.get().getName(), containsString( String.format( ""[%s]"", CONNECTOR_KEY ) ) );
    assertThat( poolThread.get().getName(), not( containsString( String.format( ""[%s]"", connection.remoteAddress() ) ) ) );
}"
"public void test_1() throws Exception {
    V1 entity=new V1();
    String text=JSON.toJSONString(entity,SerializerFeature.SortField);
    Assert.assertEquals(""{\""f1\"":0,\""f2\"":0,\""f3\"":0,\""f4\"":0,\""f5\"":0}"",text);
    JSONObject object=JSON.parseObject(text);
    text=JSON.toJSONString(object,SerializerFeature.MapSortField);
    Assert.assertEquals(""{\""f1\"":0,\""f2\"":0,\""f3\"":0,\""f4\"":0,\""f5\"":0}"",text);
}"
"@Test public void wrapperDoubles() throws Exception {
    assertThat(testResult(WrapperDoubles.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperDoubles.iterations);
    assertEquals(new HashSet<>(asList(2.7,-3.14)),new HashSet<>(WrapperDoubles.values.subList(0,2)));
    WrapperDoubles.iterations=0;
}"
"@Test
public void testStartProgramWithDisabledRuntimeArgs() throws Exception {
    ProfileId profileId = new NamespaceId(TEST_NAMESPACE1).profile(""MyProfile"");
    Profile profile = new Profile(""MyProfile"", Profile.NATIVE.getLabel(), Profile.NATIVE.getDescription(),Profile.NATIVE.getScope(), Profile.NATIVE.getProvisioner());
    putProfile(profileId, profile, 200);
    disableProfile(profileId, 200);
    deploy(AppWithWorkflow.class, 200, Constants.Gateway.API_VERSION_3_TOKEN,TEST_NAMESPACE1);
    ProgramId programId = new NamespaceId(TEST_NAMESPACE1).app(APP_WITH_WORKFLOW_APP_ID).workflow(APP_WITH_WORKFLOW_WORKFLOW_NAME);
    Assert.assertEquals(STOPPED, getProgramStatus(programId));
    startProgram(programId, Collections.singletonMap(SystemArguments.PROFILE_NAME, profileId.getScopedName()), 409);
    Assert.assertEquals(STOPPED, getProgramStatus(programId));
    startProgram(programId, Collections.singletonMap(SystemArguments.PROFILE_NAME, ProfileId.NATIVE.getScopedName()),200);
    waitState(programId, STOPPED);
}"
"@Test public void test_2() throws Exception {
    String sql=""create database test_cascade for 'ALIYUN$test@aliyun.com' options(resourceType=ecu ecu_type=c1 ecu_count=2)"";
    MySqlStatementParser parser=new MySqlStatementParser(sql);
    SQLStatement stmt=parser.parseStatement();
    String output=SQLUtils.toMySqlString(stmt);
    Set<String> allPossibleRes=generateAllPossibleRes();
    assertTrue(allPossibleRes.contains(output));
}"
"@Test
public void testSimpleConsumerEventsWithoutPartition() throws Exception {
    final String topicName = ""persistent"";
    final String subName = ""sub1"";
    final int numMsgs = 100;
    TestConsumerStateEventListener listener1 = new TestConsumerStateEventListener();
    TestConsumerStateEventListener listener2 = new TestConsumerStateEventListener();
    ConsumerBuilder<byte[]> consumerBuilder = pulsarClient.newConsumer().topic(topicName).subscriptionName(subName).acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscriptionType(Failover);
    ConsumerBuilder<byte[]> consumerBulder1 = consumerBuilder.clone().consumerName(""1"").consumerEventListener(listener1).acknowledgmentGroupTime(0, TimeUnit.SECONDS);
    Consumer<byte[]> consumer1 = consumerBulder1.subscribe();
    Consumer<byte[]> consumer2 = consumerBuilder.clone().consumerName(""2"").consumerEventListener(listener2).subscribe();
    verifyConsumerActive(listener1, -1);
    verifyConsumerInactive(listener2, -1);
    PersistentTopic topicRef = ((PersistentTopic) (pulsar.getBrokerService().getTopicReference(topicName).get()));
    PersistentSubscription subRef = topicRef.getSubscription(subName);
    assertNotNull(topicRef);
    assertNotNull(subRef);
    assertTrue(subRef.getDispatcher().isConsumerConnected());
    assertEquals(subRef.getDispatcher().getType(), Failover);
    List<CompletableFuture<MessageId>> futures = Lists.newArrayListWithCapacity(numMsgs);
    Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName).enableBatching(false).messageRoutingMode(SinglePartition).create();
    for (int i = 0; i < numMsgs; i++) {
        String message = ""my-message-"" + i;
        futures.add(producer.sendAsync(message.getBytes()));
    }
    FutureUtil.waitForAll(futures).get();
    futures.clear();
    rolloverPerIntervalStats();
    assertEquals(subRef.getNumberOfEntriesInBacklog(), numMsgs);
    Thread.sleep(ASYNC_EVENT_COMPLETION_WAIT);
    Message<byte[]> msg = null;
    Assert.assertNull(consumer2.receive(1, TimeUnit.SECONDS));
    for (int i = 0; i < numMsgs; i++) {
        msg = consumer1.receive(1, TimeUnit.SECONDS);
        Assert.assertNotNull(msg);
        Assert.assertEquals(new String(msg.getData()), ""my-message-"" + i);
        consumer1.acknowledge(msg);
    }
    rolloverPerIntervalStats();
    Thread.sleep(ASYNC_EVENT_COMPLETION_WAIT);
    assertEquals(subRef.getNumberOfEntriesInBacklog(), 0);
    for (int i = 0; i < numMsgs; i++) {
        String message = ""my-message-"" + i;
        futures.add(producer.sendAsync(message.getBytes()));
    }
    FutureUtil.waitForAll(futures).get();
    futures.clear();
    for (int i = 0; i < 5; i++) {
        msg = consumer1.receive(1, TimeUnit.SECONDS);
        Assert.assertNotNull(msg);
        Assert.assertEquals(new String(msg.getData()), ""my-message-"" + i);
        consumer1.acknowledge(msg);
    }
    for (int i = 5; i < 10; i++) {
        msg = consumer1.receive(1, TimeUnit.SECONDS);
        Assert.assertNotNull(msg);
        Assert.assertEquals(new String(msg.getData()), ""my-message-"" + i);
    }
    consumer1.close();
    Thread.sleep(CONSUMER_ADD_OR_REMOVE_WAIT_TIME);
    verifyConsumerActive(listener2, -1);
    verifyConsumerNotReceiveAnyStateChanges(listener1);
    for (int i = 5; i < numMsgs; i++) {
        msg = consumer2.receive(1, TimeUnit.SECONDS);
        Assert.assertNotNull(msg);
        Assert.assertEquals(new String(msg.getData()), ""my-message-"" + i);
        consumer2.acknowledge(msg);
    }
    Assert.assertNull(consumer2.receive(1, TimeUnit.SECONDS));
    rolloverPerIntervalStats();
    Thread.sleep(ASYNC_EVENT_COMPLETION_WAIT);
    assertEquals(subRef.getNumberOfEntriesInBacklog(), 0);
    for (int i = 0; i < numMsgs; i++) {
        String message = ""my-message-"" + i;
        futures.add(producer.sendAsync(message.getBytes()));
    }
    FutureUtil.waitForAll(futures).get();
    futures.clear();
    for (int i = 0; i < 5; i++) {
        msg = consumer2.receive(1, TimeUnit.SECONDS);
        Assert.assertNotNull(msg);
        Assert.assertEquals(new String(msg.getData()), ""my-message-"" + i);
        consumer2.acknowledge(msg);
    }
    consumer1 = consumerBulder1.subscribe();
    Thread.sleep(CONSUMER_ADD_OR_REMOVE_WAIT_TIME);
    for (int i = 5; i < numMsgs; i++) {
        msg = consumer1.receive(1, TimeUnit.SECONDS);
        Assert.assertNotNull(msg);
        Assert.assertEquals(new String(msg.getData()), ""my-message-"" + i);
        consumer1.acknowledge(msg);
    }
    Assert.assertNull(consumer1.receive(1, TimeUnit.SECONDS));
    rolloverPerIntervalStats();
    Thread.sleep(ASYNC_EVENT_COMPLETION_WAIT);
    assertEquals(subRef.getNumberOfEntriesInBacklog(), 0);
    for (int i = 0; i < numMsgs; i++) {
        String message = ""my-message-"" + i;
        futures.add(producer.sendAsync(message.getBytes()));
    }
    FutureUtil.waitForAll(futures).get();
    futures.clear();
    for (int i = 0; i < 5; i++) {
        msg = consumer1.receive(1, TimeUnit.SECONDS);
        Assert.assertNotNull(msg);
        Assert.assertEquals(new String(msg.getData()), ""my-message-"" + i);
        consumer1.acknowledge(msg);
    }
    TestConsumerStateEventListener listener3 = new TestConsumerStateEventListener();
    Consumer<byte[]> consumer3 = consumerBuilder.clone().consumerName(""3"").consumerEventListener(listener3).subscribe();
    Thread.sleep(CONSUMER_ADD_OR_REMOVE_WAIT_TIME);
    verifyConsumerInactive(listener3, -1);
    Assert.assertNull(consumer3.receive(1, TimeUnit.SECONDS));
    for (int i = 5; i < numMsgs; i++) {
        msg = consumer1.receive(1, TimeUnit.SECONDS);
        Assert.assertNotNull(msg);
        Assert.assertEquals(new String(msg.getData()), ""my-message-"" + i);
        consumer1.acknowledge(msg);
    }
    rolloverPerIntervalStats();
    Thread.sleep(ASYNC_EVENT_COMPLETION_WAIT);
    assertEquals(subRef.getNumberOfEntriesInBacklog(), 0);
    try {
        consumer1.unsubscribe();
        fail(""should fail"");
    } catch (PulsarClientException e) {
    }
    consumer1.close();
    Thread.sleep(CONSUMER_ADD_OR_REMOVE_WAIT_TIME);
    consumer2.close();
    Thread.sleep(CONSUMER_ADD_OR_REMOVE_WAIT_TIME);
    try {
        consumer3.unsubscribe();
    } catch (PulsarClientException e) {
        fail(""Should not fail"", e);
    }
    Thread.sleep(ASYNC_EVENT_COMPLETION_WAIT);
    subRef = topicRef.getSubscription(subName);
    assertNull(subRef);
    producer.close();
    consumer3.close();
    admin.topics().delete(topicName);
}"
"@Test
void writesAndReadsCustomFieldsConvertedClass() {
    List<Object> converters = new ArrayList<>();
    converters.add(BigDecimalToStringConverter.INSTANCE);
    converters.add(StringToBigDecimalConverter.INSTANCE);
    CustomConversions customConversions = new CouchbaseCustomConversions(converters);
    converter.setCustomConversions(customConversions);
    converter.afterPropertiesSet();
    ((CouchbaseMappingContext) (converter.getMappingContext())).setSimpleTypeHolder(customConversions.getSimpleTypeHolder());
    CouchbaseDocument converted = new CouchbaseDocument();
    final String valueStr = ""12.345"";
    final BigDecimal value = new BigDecimal(valueStr);
    final String value2Str = ""0.6789"";
    final BigDecimal value2 = new BigDecimal(value2Str);
    List<BigDecimal> listOfValues = new ArrayList<>();
    listOfValues.add(value);
    listOfValues.add(value2);
    Map<String, BigDecimal> mapOfValues = new HashMap<>();
    mapOfValues.put(""val1"", value);
    mapOfValues.put(""val2"", value2);
    CustomFieldsEntity entity = new CustomFieldsEntity(value, listOfValues, mapOfValues);
    converter.write(entity, converted);
    CouchbaseDocument source = new CouchbaseDocument();
    source.put(""_class"", CustomFieldsEntity.class.getName());
    source.put(""decimalValue"", valueStr);
    CouchbaseList listOfValuesDoc = new CouchbaseList();
    listOfValuesDoc.put(valueStr);
    listOfValuesDoc.put(value2Str);
    source.put(""listOfDecimalValues"", listOfValuesDoc);
    CouchbaseDocument mapOfValuesDoc = new CouchbaseDocument();
    mapOfValuesDoc.put(""val1"", valueStr);
    mapOfValuesDoc.put(""val2"", value2Str);
    source.put(""mapOfDecimalValues"", mapOfValuesDoc);
    assertThat(valueStr).isEqualTo(((CouchbaseList) (converted.getContent().get(""listOfDecimalValues""))).get(0));
    assertThat(value2Str).isEqualTo(((CouchbaseList) (converted.getContent().get(""listOfDecimalValues""))).get(1));
    assertThat(converted.export().toString()).isEqualTo(source.export().toString());
    CustomFieldsEntity readConverted = converter.read(CustomFieldsEntity.class, source);
    assertThat(readConverted.value).isEqualTo(value);
    assertThat(readConverted.listOfValues.get(0)).isEqualTo(listOfValues.get(0));
    assertThat(readConverted.listOfValues.get(1)).isEqualTo(listOfValues.get(1));
    assertThat(readConverted.mapOfValues.get(""val1"")).isEqualTo(mapOfValues.get(""val1""));
    assertThat(readConverted.mapOfValues.get(""val2"")).isEqualTo(mapOfValues.get(""val2""));
}"
"@Test public void testDoNotPurgeRPCTask() throws Exception {
    int RPCTaskNums=10;
    TaskMonitor tm=TaskMonitor.get();
    for (int i=0; i < RPCTaskNums; i++) {
        tm.createRPCStatus(""PRCTask"" + i);
    }
    for (int i=0; i < TaskMonitor.DEFAULT_MAX_TASKS; i++) {
        tm.createStatus(""otherTask"" + i);
    }
    int remainRPCTask=0;
    for (  MonitoredTask task : tm.getTasks()) {
        if (task instanceof MonitoredRPCHandler) {
            remainRPCTask++;
        }
    }
    assertEquals(""RPC Tasks have been purged!"",RPCTaskNums,remainRPCTask);
    tm.shutdown();
    tm.purgeAllTasks();
}"
"@Test public void boxOfFoo() throws Exception {
    assertThat(testResult(BoxOfFoo.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),BoxOfFoo.iterations);
    BoxOfFoo.iterations=0;
}"
"@Test
public void testValidate_badXml() throws IOException, CoreException {
    XmlValidator validator = new XmlValidator();
    validator.setHelper(new AppEngineWebXmlValidator());
    IFile file = createBogusProjectFile();
    byte[] badXml = BAD_XML.getBytes(StandardCharsets.UTF_8);
    validator.validate(file, badXml);
    IMarker[] emptyMarkers =
    ProjectUtils.waitUntilNoMarkersFound(file, PROBLEM, true, DEPTH_ZERO);
    ArrayAssertions.assertIsEmpty(emptyMarkers);
}"
"@Test
public void testExpiry() throws Exception {
    final int CAPACITY = 3;
    final int EXPIRY_PERIOD = 10;
    PeerCache cache = PeerCache.getInstance(CAPACITY, EXPIRY_PERIOD);
    DatanodeID dnIds[] = new DatanodeID[CAPACITY];
    FakePeer peers[] = new FakePeer[CAPACITY];
    for (int i = 0; i < CAPACITY; ++i) {
        dnIds[i] = new DatanodeID(""192.168.0.1"",
        ""fakehostname_"" + i, ""fake_storage_id"",
        100, 101, 102);
        peers[i] = new FakePeer(dnIds[i], false);
    }
    for (int i = 0; i < CAPACITY; ++i) {
        cache.put(dnIds[i], peers[i]);
    }
    Thread.sleep(EXPIRY_PERIOD * 50);
    assertEquals(0, cache.size());
    for (int i = 0; i < CAPACITY; ++i) {
        assertTrue(peers[i].isClosed());
    }
    Thread.sleep(EXPIRY_PERIOD * 50);
    cache.close();
}"
"@Test
public void testTimerThreadLeak() throws Exception {
    Tomcat tomcat = getTomcatInstance();
    Context ctx = tomcat.addContext("""", System.getProperty(""java.io.tmpdir""));
    if (ctx instanceof StandardContext) {
        ((StandardContext) (ctx)).setClearReferencesStopThreads(true);
    }
    ExecutorServlet executorServlet = new ExecutorServlet();
    Tomcat.addServlet(ctx, ""taskServlet"", executorServlet);
    ctx.addServletMapping(""/"", ""taskServlet"");
    tomcat.start();
    getUrl((""http://google.com""));
    ctx.stop();
    try {
        Thread.sleep(1000);
    } catch (InterruptedException ie) {
    }
    Assert.assertTrue(executorServlet.tpe.isShutdown());
    Assert.assertTrue(executorServlet.tpe.isTerminated());
}"
"@Test public void wrapperBooleans() throws Exception {
    assertThat(testResult(WrapperBooleans.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperBooleans.iterations);
    assertEquals(singletonList(false),WrapperBooleans.values.subList(0,1));
    WrapperBooleans.iterations=0;
}"
"@Test public void testNotAllowNullSchema() throws JSONException {
    JSONSchema<Foo> jsonSchema=JSONSchema.of(SchemaDefinition.<Foo>builder().withPojo(Foo.class).withAlwaysAllowNull(false).build());
    Assert.assertEquals(jsonSchema.getSchemaInfo().getType(),SchemaType.JSON);
    Schema.Parser parser=new Schema.Parser();
    String schemaJson=new String(jsonSchema.getSchemaInfo().getSchema());
    assertJSONEqual(schemaJson,SCHEMA_JSON_NOT_ALLOW_NULL);
    Schema schema=parser.parse(schemaJson);
    for (  String fieldName : FOO_FIELDS) {
        Schema.Field field=schema.getField(fieldName);
        Assert.assertNotNull(field);
        if (field.name().equals(""field4"")) {
            Assert.assertNotNull(field.schema().getTypes().get(1).getField(""field1""));
        }
        if (field.name().equals(""fieldUnableNull"")) {
            Assert.assertNotNull(field.schema().getType());
        }
    }
}"
"@Test
public void testProxy() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
    Queue<String> output = ExamplesTestUtil.runClientInMockedEnvironment(ProxyClient.class);
    HttpResponse expectedHeader = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
    expectedHeader.headers().add(((CharSequence) (""X-Proxied-By"")), ""RxNetty"");
    expectedHeader.headers().add(TRANSFER_ENCODING, CHUNKED);
    String expectedHeaderString = HttpMessageFormatter.formatResponse(expectedHeader.protocolVersion(), expectedHeader.status(), expectedHeader.headers().iteratorCharSequence());
    assertThat(""Unexpected number of messages echoed"", output, hasSize(2));
    assertThat(""Unexpected response."", output, contains(expectedHeaderString, ""HelloWorld!""));
}"
"@Test public void serializeEnum() throws IOException {
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of(TestEnum.A)),""{\""@type\"":\""string\"",\""@value\"":\""A\""}"");
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of(TestEnum.B)),""{\""@type\"":\""string\"",\""@value\"":\""B\""}"");
}"
"@Test
public void testOverdueStateIfNoPaymentMethod() throws Exception {
    clock.setTime(new DateTime(2012, 5, 1, 0, 3, 42, 0));
    setupAccount();
    accountInternalApi.removePaymentMethod(account.getId(), internalCallContext);
    final DefaultEntitlement baseEntitlement = createBaseEntitlementAndCheckForCompletion(account.getId(), ""externalKey"", productName, BASE, term, CREATE, BLOCK, INVOICE);
    bundle = subscriptionApi.getSubscriptionBundle(baseEntitlement.getBundleId(), callContext);
    invoiceChecker.checkInvoice(account.getId(), 1, callContext, new ExpectedInvoiceItemCheck(new LocalDate(2012, 5, 1), null, InvoiceItemType.FIXED, new BigDecimal(""0"")));
    invoiceChecker.checkChargedThroughDate(baseEntitlement.getId(), new LocalDate(2012, 5, 1), callContext);
    addDaysAndCheckForCompletion(30, PHASE, INVOICE, INVOICE_PAYMENT_ERROR);
    invoiceChecker.checkInvoice(account.getId(), 2, callContext, new ExpectedInvoiceItemCheck(new LocalDate(2012, 5, 31), new LocalDate(2012, 6, 30), InvoiceItemType.RECURRING, new BigDecimal(""249.95"")));
    invoiceChecker.checkChargedThroughDate(baseEntitlement.getId(), new LocalDate(2012, 6, 30), callContext);
    checkODState(CLEAR_STATE_NAME);
    addDaysAndCheckForCompletion(15);
    checkODState(CLEAR_STATE_NAME);
    addDaysAndCheckForCompletion(20, BLOCK, INVOICE, INVOICE_PAYMENT_ERROR);
    invoiceChecker.checkInvoice(account.getId(), 3, callContext, new ExpectedInvoiceItemCheck(new LocalDate(2012, 6, 30), new LocalDate(2012, 7, 31), InvoiceItemType.RECURRING, new BigDecimal(""249.95"")));
    invoiceChecker.checkChargedThroughDate(baseEntitlement.getId(), new LocalDate(2012, 7, 31), callContext);
    checkODState(""OD1"");
    checkChangePlanWithOverdueState(baseEntitlement, true, true);
    addDaysAndCheckForCompletion(2);
    checkODState(""OD1"");
    checkChangePlanWithOverdueState(baseEntitlement, true, true);
    addDaysAndCheckForCompletion(8, BLOCK, TAG);
    checkODState(""OD2"");
    checkChangePlanWithOverdueState(baseEntitlement, true, true);
    addDaysAndCheckForCompletion(10, BLOCK);
    checkODState(""OD3"");
    checkChangePlanWithOverdueState(baseEntitlement, true, true);
    paymentApi.addPaymentMethod(account, UUID.randomUUID().toString(), NON_OSGI_PLUGIN_NAME, true, paymentMethodPlugin, PLUGIN_PROPERTIES, callContext);
    allowPaymentsAndResetOverdueToClearByPayingAllUnpaidInvoices(false);
    invoiceChecker.checkInvoice(account.getId(), 3, callContext, new ExpectedInvoiceItemCheck(new LocalDate(2012, 6, 30), new LocalDate(2012, 7, 31), InvoiceItemType.RECURRING, new BigDecimal(""249.95"")));
    invoiceChecker.checkInvoice(account.getId(), 4, callContext, new ExpectedInvoiceItemCheck(new LocalDate(2012, 7, 15), new LocalDate(2012, 7, 25), InvoiceItemType.REPAIR_ADJ, new BigDecimal(""-80.63"")), new ExpectedInvoiceItemCheck(new LocalDate(2012, 7, 25), new LocalDate(2012, 7, 25), InvoiceItemType.CBA_ADJ, new BigDecimal(""80.63"")));
    invoiceChecker.checkChargedThroughDate(baseEntitlement.getId(), new LocalDate(2012, 7, 31), callContext);
    checkChangePlanWithOverdueState(baseEntitlement, false, false);
    invoiceChecker.checkInvoice(account.getId(), 4, callContext, new ExpectedInvoiceItemCheck(new LocalDate(2012, 7, 15), new LocalDate(2012, 7, 25), InvoiceItemType.REPAIR_ADJ, new BigDecimal(""-80.63"")), new ExpectedInvoiceItemCheck(new LocalDate(2012, 7, 25), new LocalDate(2012, 7, 25), InvoiceItemType.CBA_ADJ, new BigDecimal(""80.63"")));
    invoiceChecker.checkInvoice(account.getId(), 5, callContext, new ExpectedInvoiceItemCheck(new LocalDate(2012, 7, 25), new LocalDate(2012, 7, 31), InvoiceItemType.RECURRING, new BigDecimal(""116.12"")), new ExpectedInvoiceItemCheck(new LocalDate(2012, 7, 25), new LocalDate(2012, 7, 31), InvoiceItemType.REPAIR_ADJ, new BigDecimal(""-48.38"")), new ExpectedInvoiceItemCheck(new LocalDate(2012, 7, 25), new LocalDate(2012, 7, 25), InvoiceItemType.CBA_ADJ, new BigDecimal(""-67.74"")));
    invoiceChecker.checkChargedThroughDate(baseEntitlement.getId(), new LocalDate(2012, 7, 31), callContext);
    assertEquals(invoiceUserApi.getAccountBalance(account.getId(), callContext).compareTo(new BigDecimal(""-12.89"")), 0);
}"
"@Test public void testExecuteLimitInvokeWitException() throws Exception {
    Invoker invoker=Mockito.mock(Invoker.class);
    doThrow(new RpcException()).when(invoker).invoke(any(Invocation.class));
    URL url=URL.valueOf(""test://test:11/test?accesslog=true&group=dubbo&version=1.1&executes=10"");
    when(invoker.getUrl()).thenReturn(url);
    Invocation invocation=Mockito.mock(Invocation.class);
    when(invocation.getMethodName()).thenReturn(""testExecuteLimitInvokeWitException"");
    try {
        executeLimitFilter.invoke(invoker,invocation);
    }
    catch (  Exception e) {
        Assertions.assertTrue(e instanceof RpcException);
        executeLimitFilter.onError(e,invoker,invocation);
    }
    Assertions.assertEquals(1,RpcStatus.getStatus(url,invocation.getMethodName()).getFailed());
    RpcStatus.removeStatus(url,invocation.getMethodName());
}"
"@Test
public void testLookupEmptyName() throws Exception {
    Object result = namingContext.lookup(new CompositeName());
    assertTrue(result instanceof NamingContext);
    result = namingContext.lookup(new CompositeName(""""));
    assertTrue(result instanceof NamingContext);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, null);
    assertTrue(result instanceof NamingContext);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, """");
    assertTrue(result instanceof NamingContext);
}"
"@Test
public void testProducerConsumerTopic() throws Exception {
    final CountDownLatch consumerStarted = new CountDownLatch(1);
    Thread producerThread = new Thread(new Runnable());
    final TopicWithDuplicateMessages consumer = new TopicWithDuplicateMessages();
    Thread consumerThread = new Thread(new Runnable() );
    consumerThread.start();
    LOG.info(""Started Consumer"");
    assertTrue(""consumer started eventually"", consumerStarted.await(10, TimeUnit.SECONDS));
    Thread.sleep(2000);
    producerThread.start();
    LOG.info(""Started Producer"");
    producerThread.join();
    consumerThread.join();
    int duplicateCount = 0;
    Map<String, String> map = new HashMap<String, String>();
    for (String msg : consumer.getMessageStrings()) {
        if (map.containsKey(msg)) {
            LOG.info(""got duplicate: "" + msg);
            duplicateCount++;
        }
        map.put(msg, msg);
    }
    if (suppressDuplicateTopicSubs || (dispatchPolicy instanceof PriorityNetworkDispatchPolicy)) {
        assertEquals(""no duplicates"", 0, duplicateCount);
        assertEquals(""got all required messages: "" + map.size(), consumer.getNumMessages(), map.size());
    } else {
        assertTrue(""we got some duplicates"", duplicateCount > 0);
    }
}"
"public void test_0() throws Exception {
    JSONSerializer serializer=new JSONSerializer();
    serializer.getMapping().clearSerializers();
    int size=JSONSerializerMapTest.size(serializer.getMapping());
    serializer.config(SerializerFeature.WriteEnumUsingToString,false);
    serializer.config(SerializerFeature.WriteEnumUsingName,false);
    serializer.write(Type.A);
    Assert.assertTrue(size < JSONSerializerMapTest.size(serializer.getMapping()));
    Assert.assertEquals(Integer.toString(Type.A.ordinal()),serializer.getWriter().toString());
}"
"@Test
public void testGenerateNewDayPairs() {
    PairCombinations pairs = getPairsList();
    List<Developer> devs = getStandardDevs();
    List<String> tracks = Arrays.asList(""track1"", ""track2"", ""track3"");
    Map<Pair, Integer> pairsWeight = subject.buildPairsWeightFromPastPairing(pairs, devs);
    subject.buildDevelopersPairingDays(pairs, devs);
    DayPairs dayPairs = subject.generateNewDayPairs(tracks, devs, pairs, pairsWeight, getStandardCompanies());
    assertThat(dayPairs.getTracks().size(), is(2));
    assertThat(dayPairs.getTracks(), contains(""track1"", ""track2""));
    assertThat(dayPairs.getPairByTrack(""track1""),
    is(not(new Pair(Arrays.asList(new Developer(""dev1""), new Developer(""dev2""))))));
    assertThat(dayPairs.getPairByTrack(""track2""),
    is(not(new Pair(Arrays.asList(new Developer(""dev3""), new Developer(""dev4""))))));
    boolean trackOneHasContext = dayPairs.getPairByTrack(""track1"").getFirstDev().hasContext() || dayPairs.getPairByTrack(""track1"").getSecondDev().hasContext();
    boolean trackTwoHasContext = dayPairs.getPairByTrack(""track2"").getFirstDev().hasContext() || dayPairs.getPairByTrack(""track2"").getSecondDev().hasContext();
    assertThat(trackOneHasContext, is(true));
    assertThat(trackTwoHasContext, is(true));
}"
"@Test
public void testUnbind() throws Exception {
    final Name name = new CompositeName(""test"");
    final Object value = new Object();
    namingStore.bind(name, value);
    namingContext.unbind(name);
    try {
        namingStore.lookup(name);
        fail(""Should have thrown name not found"");
    } catch (NameNotFoundException expect) {}
    testActionPermission(JndiPermission.ACTION_BIND, namingContext, ""test"", value);
    testActionPermission(JndiPermission.ACTION_UNBIND, namingContext, ""test"");
    try {
        namingStore.lookup(name);
        fail(""Should have thrown name not found"");
    } catch (NameNotFoundException expect) {}
}"
"@Test
void syncWithError_ShouldCallErrorCallback() {
    final TestLogger syncerTestLogger = TestLoggerFactory.getTestLogger(InventoryEntrySyncer.class);
    final SphereClient sourceClient = mock(SphereClient.class);
    final SphereClient targetClient = mock(SphereClient.class);
    when(sourceClient.getConfig()).thenReturn(SphereApiConfig.of(""source-project""));
    when(targetClient.getConfig()).thenReturn(SphereApiConfig.of(""target-project""));
    final List<InventoryEntry> inventoryEntries = Collections.singletonList(readObjectFromResource(""inventory-no-sku.json"", InventoryEntry.class));
    final PagedQueryResult<InventoryEntry> pagedQueryResult = mock(PagedQueryResult.class);
    when(pagedQueryResult.getResults()).thenReturn(inventoryEntries);
    when(sourceClient.execute(any(InventoryEntryQuery.class))).thenReturn(CompletableFuture.completedFuture(pagedQueryResult));
    final InventoryEntrySyncer inventoryEntrySyncer = InventoryEntrySyncer.of(sourceClient, targetClient, mock(Clock.class));
    inventoryEntrySyncer.sync(null, true).toCompletableFuture().join();
    final LoggingEvent errorLog = syncerTestLogger.getAllLoggingEvents().get(1);
    assertThat(errorLog.getMessage()).isEqualTo(""Error when trying to sync inventory entry. Existing key: <<not present>>. Update actions: []"");
    assertThat(errorLog.getThrowable().get().getMessage()).isEqualTo(""InventoryEntryDraft doesn't have a SKU. Please make sure all inventory entry drafts have SKUs."");
}"
"@Test
public void testDeadlockTimeout() throws SQLException, InterruptedException {
    setAutoCommit(false);
    Statement s = createStatement();
    assertUpdateCount(s, 1, ""update t set text='xxx' where id=1"");
    Connection c2 = openDefaultConnection();
    c2.setAutoCommit(false);
    Statement s2 = c2.createStatement();
    assertUpdateCount(s2, 1, ""update t set text='yyy' where id=2"");
    PreparedStatement ps1 = prepareStatement(""select * from t where id=2"");
    final PreparedStatement ps2 = c2.prepareStatement(""select * from t where id=1"");
    final Barrier barrier = new Barrier(2);
    final SQLException[] holder = new SQLException[2];
    final Throwable[] unexpected = new Throwable[1];
    Thread t = new Thread(new Runnable() {
        public void run() {
            try {
                barrier.await();
                JDBC.assertDrainResults(ps2.executeQuery());
            } catch (SQLException e) {
                holder[0] = e;
            } catch (Throwable t) {
                unexpected[0] = t;
            }
        }
    });
    t.start();
    barrier.await();
    try {
        JDBC.assertDrainResults(ps1.executeQuery());
    } catch (SQLException e) {
        holder[1] = e;
    }
    t.join();
    if (unexpected[0] != null) {
        fail(""Helper thread failed unexpectedly"", unexpected[0]);
    }
    assertFalse(""No deadlock"", (holder[0] == null) && (holder[1] == null));
    if ((holder[0] != null) && (holder[1] != null)) {
        printStackTrace(holder[0]);
        printStackTrace(holder[1]);
        fail(""Only one of the waiters should be aborted"");
    }
    SQLException deadlock = (holder[0] == null) ? holder[1] : holder[0];
    assertSQLState(""Not a deadlock"", ""40001"", deadlock);
    String[] lines = deadlock.getMessage().split(""\n"");
    assertEquals(""Unexpected number of lines in message"", 8, lines.length);
    Pattern[] patterns = new Pattern[]{ Pattern.compile(""Lock : ROW, T, \\(\\d+,\\d+\\)""), Pattern.compile("" *Waiting XID : \\{\\d+, S\\} , APP, "" + ""select \\* from t where id=(1|2)""), Pattern.compile("" *Granted XID : \\{\\d+, X\\} *"") };
    for (int i = 0; i < (patterns.length * 2); i++) {
        String line = lines[i + 1];
        Matcher m = patterns[i % patterns.length].matcher(line);
        assertTrue(""mismatch: "" + line, m.matches());
    }
    s.close();
    s2.close();
    c2.rollback();
    c2.close();
}"
"@Test
public void testWithRevisions() {
    Country de = new Country();
    de.code = ""de"";
    de.name = ""Deutschland"";
    countryRepository.save(de);
    de.name = ""Germany"";
    countryRepository.save(de);
    Revisions<Integer, Country> revisions = countryRepository.findRevisions(de.id);
    assertThat(revisions).hasSize(2);
    Iterator<Revision<Integer, Country>> iterator = revisions.iterator();
    Integer firstRevisionNumber = iterator.next().getRevisionNumber().get();
    Integer secondRevisionNumber = iterator.next().getRevisionNumber().get();
    assertThat(countryRepository.findRevision(de.id, firstRevisionNumber).get().getEntity().name)
    .isEqualTo(""Deutschland"");
    assertThat(countryRepository.findRevision(de.id, secondRevisionNumber).get().getEntity().name).isEqualTo(""Germany"");
}"
"@Test public void test1_2() throws Exception {
    JSONObject json=new JSONObject();
    json.put(""id"",123);
    json.put(""name"",""哈哈哈"");
    ResultActions actions=mockMvc.perform((post(""/fastjson/test1?callback=fnUpdateSome"").characterEncoding(""UTF-8"").content(json.toJSONString()).contentType(MediaType.APPLICATION_JSON)));
    actions.andDo(print());
    actions.andExpect(status().isOk()).andExpect(content().contentType(APPLICATION_JAVASCRIPT));
    String content=actions.andReturn().getResponse().getContentAsString();
    assertTrue(content.equals(""/**/fnUpdateSome({\""name\"":\""哈哈哈\"",\""id\"":123})"") || content.equals(""/**/fnUpdateSome({\""id\"":123,\""name\"":\""哈哈哈\""})""));
}"
"@Test public void test_AddExtension() throws Exception {
    try {
        getExtensionLoader(AddExt1.class).getExtension(""Manual1"");
        fail();
    }
    catch (  IllegalStateException expected) {
        assertThat(expected.getMessage(),containsString(""No such extension org.apache.dubbo.common.extension.ext8_add.AddExt1 by name Manual""));
    }
    getExtensionLoader(AddExt1.class).addExtension(""Manual1"",AddExt1_ManualAdd1.class);
    AddExt1 ext=getExtensionLoader(AddExt1.class).getExtension(""Manual1"");
    assertThat(ext,instanceOf(AddExt1_ManualAdd1.class));
    assertEquals(""Manual1"",getExtensionLoader(AddExt1.class).getExtensionName(AddExt1_ManualAdd1.class));
    ExtensionLoader.resetExtensionLoader(AddExt1.class);
}"
"@Test public void usesRegularTrialCount() throws Exception {
    assertThat(testResult(EnumTester.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),EnumTester.iterations);
    EnumTester.iterations=0;
}"
"@Test public void primitiveDoubles() throws Exception {
    assertThat(testResult(PrimitiveDoubles.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveDoubles.iterations);
    assertEquals(new HashSet<>(asList(3.2,-4D)),new HashSet<>(PrimitiveDoubles.values.subList(0,2)));
    PrimitiveDoubles.iterations=0;
}"
"@Test public void summarizeUsersReturnsListOfUsersWithoutTheCurrent(){
    when(currentUser.getName()).thenReturn(""peter"");
    final User user1=mock(User.class);
    when(user1.getName()).thenReturn(""franz"");
    when(user1.getFullName()).thenReturn(""Franz Josef Strauss"");
    final User user2=mock(User.class);
    when(user2.getName()).thenReturn(""friedrich"");
    when(user2.getFullName()).thenReturn(""Friedrich Merz"");
    final User peter=mock(User.class);
    when(peter.getName()).thenReturn(""peter"");
    when(userService.loadAll()).thenReturn(ImmutableList.of(user1,user2,peter));
    final Set<UserShortSummary> users=this.viewSharingResource.summarizeUsers(""viewId"");
    assertThat(users).containsExactlyInAnyOrder(UserShortSummary.create(""franz"",""Franz Josef Strauss""),UserShortSummary.create(""friedrich"",""Friedrich Merz""));
}"
"@Test
public void recoverFromCancelReusesConnection() throws Exception {
    CountDownLatch responseDequeuedLatch = new CountDownLatch(1);
    CountDownLatch requestCanceledLatch = new CountDownLatch(1);
    QueueDispatcher dispatcher = new QueueDispatcher() {
        @Override
        public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
            MockResponse response = super.dispatch(request);
            responseDequeuedLatch.countDown();
            requestCanceledLatch.await();
            return response;
        }
    };
    server.setDispatcher(dispatcher);
    dispatcher.enqueueResponse(new MockResponse().setBodyDelay(10, TimeUnit.SECONDS).setBody(""abc""));
    dispatcher.enqueueResponse(new MockResponse().setBody(""def""));
    client = client.newBuilder().dns(new DoubleInetAddressDns()).build();
    callAndCancel(0, responseDequeuedLatch, requestCanceledLatch);
    Call call = client.newCall(new Request.Builder().url(server.url(""/"")).build());
    Response response = call.execute();
    assertThat(response.body().string()).isEqualTo(""def"");
    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
}"
"@Test
public void testNodeMetricsDb() {
    ManualClock clock = new ManualClock();
    NodeMetricsDb db = new NodeMetricsDb();
    List<NodeMetrics.MetricValue> values = new ArrayList<>();
    for (int i = 0; i < 40; i++) {
        values.add(new NodeMetrics.MetricValue(""host0"", ""cpu.util"", clock.instant().getEpochSecond(), 0.9f));
        clock.advance(Duration.ofHours(1));
    }
    db.add(values);
    assertEquals(29, db.getWindow(clock.instant().minus(Duration.ofHours(30)), Resource.cpu,    List.of(""host0"")).measurementCount());
    assertEquals( 0, db.getWindow(clock.instant().minus(Duration.ofHours(30)), Resource.memory, List.of(""host0"")).measurementCount());
    db.gc(clock);
    assertEquals(23, db.getWindow(clock.instant().minus(Duration.ofHours(30)), Resource.cpu,    List.of(""host0"")).measurementCount());
    assertEquals( 0, db.getWindow(clock.instant().minus(Duration.ofHours(30)), Resource.memory, List.of(""host0"")).measurementCount());
}"
"@Test
public void testBindAndRetrieveObjectFactoryFromInitialContext() throws Exception {
    final Reference reference = new Reference(""java.util.String"", TestObjectFactory.class.getName(), null);
    namingStore.bind(new CompositeName(""test""), reference);
    final InitialContext initialContext = new InitialContext();
    final Object result = initialContext.lookup(""test"");
    assertTrue(result instanceof String);
    assertEquals(""Test ParsedResult"", result);
}"
"@Test
public void testBlueprintCompNamespaceWorks() throws Exception {
    Bundle bBiz = getInstalledBundle(""org.apache.aries.jndi.url.itest.biz"");
    assertNotNull(bBiz);
    Bundle bweb = getInstalledBundle(""org.apache.aries.jndi.url.itest.web"");
    assertNotNull(bweb);
    printBundleStatus(""Before first request"");
    try {
        getTestServletResponse();
    } catch (IOException iox) {
    }
    try {
        Thread.sleep(5000);
    } catch (InterruptedException iox) {
    }
    printBundleStatus(""After workaround, before test proper"");
    System.out.println(""In test and trying to get connection...."");
    String response = getTestServletResponse();
    assertEquals(""ITest servlet response wrong"", ""Mark.2.0.three"", response);
}"
"@Test
public void testWritesWhileGetting() throws IOException, InterruptedException {
    byte[] tableName = Bytes.toBytes(""testWritesWhileScanning"");
    int testCount = 100;
    int numRows = 1;
    int numFamilies = 10;
    int numQualifiers = 100;
    int flushInterval = 10;
    int compactInterval = 10 * flushInterval;
    byte[][] families = new byte[numFamilies][];
    for (int i = 0; i < numFamilies; i++) {
        families[i] = Bytes.toBytes(""family"" + i);
    }
    byte[][] qualifiers = new byte[numQualifiers][];
    for (int i = 0; i < numQualifiers; i++) {
        qualifiers[i] = Bytes.toBytes(""qual"" + i);
    }
    String method = ""testWritesWhileScanning"";
    initHRegion(tableName, method, families);
    PutThread putThread = new PutThread(numRows, families, qualifiers);
    putThread.start();
    FlushThread flushThread = new FlushThread();
    flushThread.start();
    Get get = new Get(Bytes.toBytes(""row0""));
    Result result = null;
    int expectedCount = numFamilies * numQualifiers;
    long prevTimestamp = 0L;
    for (int i = 0; i < testCount; i++) {
        if ((i != 0) && ((i % compactInterval) == 0)) {
            region.compactStores(true);
        }
        if ((i != 0) && ((i % flushInterval) == 0)) {
            flushThread.flush();
        }
        boolean previousEmpty = (result == null) || result.isEmpty();
        result = region.get(get, null);
        if (((!result.isEmpty()) || (!previousEmpty)) || (i > compactInterval)) {
            assertEquals(""i="" + i, expectedCount, result.size());
            long timestamp = 0;
            for (KeyValue kv : result.sorted()) {
                if (Bytes.equals(kv.getFamily(), families[0]) && Bytes.equals(kv.getQualifier(), qualifiers[0])) {
                    timestamp = kv.getTimestamp();
                }
            }
            assertTrue(timestamp >= prevTimestamp);
            prevTimestamp = timestamp;
            byte[] gotValue = null;
            for (KeyValue kv : result.raw()) {
                byte[] thisValue = kv.getValue();
                if (gotValue != null) {
                    assertEquals(gotValue, thisValue);
                }
                gotValue = thisValue;
            }
        }
    }
    putThread.done();
    region.flushcache();
    putThread.join();
    putThread.checkNoError();
    flushThread.done();
    flushThread.join();
    flushThread.checkNoError();
}"
"@Test
public void testConnectedComponents() {
    System.out.println(""graph is "" + graph.toString());
    List<Set<Integer>> ccs = graph.getConnectedComponents();
    for (Set<Integer> cc : ccs) {
        System.out.println(""Connected component: "" + cc);
    }
    assertEquals(ccs.size(), 4);
    assertEquals(CollectionUtils.sorted(ccs.get(0)), Arrays.asList(1, 2, 3, 4));
}"
"@Test
public void testWorkerInstances() throws Exception {
    ApplicationManager applicationManager = deployApplication(testSpace, AppUsingGetServiceURL.class);
    WorkerManager workerManager = applicationManager.getWorkerManager(PINGING_WORKER).start();
    workerManager.waitForStatus(true);
    workerInstancesCheck(workerManager, 5);
    workerManager.setInstances(10);
    workerInstancesCheck(workerManager, 10);
    workerManager.setInstances(2);
    workerInstancesCheck(workerManager, 2);
    workerManager.setInstances(2);
    workerInstancesCheck(workerManager, 2);
    WorkerManager lifecycleWorkerManager = applicationManager.getWorkerManager(LIFECYCLE_WORKER).start();
    lifecycleWorkerManager.waitForStatus(true);
    lifecycleWorkerManager.setInstances(5);
    workerInstancesCheck(lifecycleWorkerManager, 5);
    for (int i = 0; i < 5; i++) {
        kvTableKeyCheck(testSpace, WORKER_INSTANCES_DATASET, Bytes.toBytes(String.format(""init.%d"", i)));
    }
    lifecycleWorkerManager.stop();
    lifecycleWorkerManager.waitForStatus(false);
    if (workerManager.isRunning()) {
        workerManager.stop();
    }
    workerManager.waitForStatus(false);
    workerInstancesCheck(lifecycleWorkerManager, 5);
    workerInstancesCheck(workerManager, 2);
    assertWorkerDatasetWrites(Bytes.toBytes(""init""), Bytes.stopKeyForPrefix(Bytes.toBytes(""init.2"")), 3, 3);
    assertWorkerDatasetWrites(Bytes.toBytes(""init.3""), Bytes.stopKeyForPrefix(Bytes.toBytes(""init"")), 2, 5);
    byte[] startRow = Bytes.toBytes(""stop"");
    assertWorkerDatasetWrites(startRow, Bytes.stopKeyForPrefix(startRow), 5, 5);
}"
"@Test
public void testWorkflowTokenPut() throws Exception {
    Assert.assertEquals(200, deploy(WorkflowTokenTestPutApp.class).getStatusLine().getStatusCode());
    Id.Application appId = Id.Application.from(Id.Namespace.DEFAULT, WorkflowTokenTestPutApp.NAME);
    Id.Workflow workflowId = Id.Workflow.from(appId, WorkflowTokenTestPutApp.WorkflowTokenTestPut.NAME);
    Id.Program mapReduceId = Id.Program.from(appId, ProgramType.MAPREDUCE, WorkflowTokenTestPutApp.RecordCounter.NAME);
    Id.Program sparkId = Id.Program.from(appId, ProgramType.SPARK, WorkflowTokenTestPutApp.SparkTestApp.NAME);
    String outputPath = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
    startProgram(workflowId, ImmutableMap.of(""inputPath"", createInputForRecordVerification(""firstInput""),
    ""outputPath"", outputPath, ""put.in.mapper.initialize"", ""true""));
    waitState(workflowId, ProgramRunStatus.RUNNING.name());
    waitState(workflowId, ""STOPPED"");
    List<RunRecord> workflowProgramRuns = getProgramRuns(workflowId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(1, workflowProgramRuns.size());
    List<RunRecord> mapReduceProgramRuns = getProgramRuns(mapReduceId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(1, mapReduceProgramRuns.size());
    outputPath = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
    startProgram(workflowId, ImmutableMap.of(""inputPath"", createInputForRecordVerification(""secondInput""),
    ""outputPath"", outputPath, ""put.in.map"", ""true""));
    waitState(workflowId, ProgramRunStatus.RUNNING.name());
    waitState(workflowId, ""STOPPED"");
    workflowProgramRuns = getProgramRuns(workflowId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(2, workflowProgramRuns.size());
    mapReduceProgramRuns = getProgramRuns(mapReduceId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(2, mapReduceProgramRuns.size());
    outputPath = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
    startProgram(workflowId, ImmutableMap.of(""inputPath"", createInputForRecordVerification(""thirdInput""),
    ""outputPath"", outputPath, ""put.in.reducer.initialize"", ""true""));
    waitState(workflowId, ProgramRunStatus.RUNNING.name());
    waitState(workflowId, ""STOPPED"");
    workflowProgramRuns = getProgramRuns(workflowId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(3, workflowProgramRuns.size());
    mapReduceProgramRuns = getProgramRuns(mapReduceId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(3, mapReduceProgramRuns.size());
    outputPath = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
    startProgram(workflowId, ImmutableMap.of(""inputPath"", createInputForRecordVerification(""fourthInput""),
    ""outputPath"", outputPath, ""put.in.reduce"", ""true""));
    waitState(workflowId, ProgramRunStatus.RUNNING.name());
    waitState(workflowId, ""STOPPED"");
    workflowProgramRuns = getProgramRuns(workflowId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(4, workflowProgramRuns.size());
    mapReduceProgramRuns = getProgramRuns(mapReduceId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(4, mapReduceProgramRuns.size());
    outputPath = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
    startProgram(workflowId, ImmutableMap.of(""inputPath"", createInputForRecordVerification(""fifthInput""),
    ""outputPath"", outputPath, ""closurePutToken"", ""true""));
    waitState(workflowId, ProgramRunStatus.RUNNING.name());
    waitState(workflowId, ""STOPPED"");
    workflowProgramRuns = getProgramRuns(workflowId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(5, workflowProgramRuns.size());
    mapReduceProgramRuns = getProgramRuns(mapReduceId, ProgramRunStatus.COMPLETED.name());
    Assert.assertEquals(1, mapReduceProgramRuns.size());
    List<RunRecord> sparkProgramRuns = getProgramRuns(sparkId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(1, sparkProgramRuns.size());
    outputPath = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
    startProgram(workflowId, ImmutableMap.of(""inputPath"", createInputForRecordVerification(""sixthInput""),
    ""outputPath"", outputPath));
    waitState(workflowId, ProgramRunStatus.RUNNING.name());
    waitState(workflowId, ""STOPPED"");
    workflowProgramRuns = getProgramRuns(workflowId, ProgramRunStatus.COMPLETED.name());
    Assert.assertEquals(1, workflowProgramRuns.size());
    workflowProgramRuns = getProgramRuns(sparkId, ProgramRunStatus.COMPLETED.name());
    Assert.assertEquals(1, workflowProgramRuns.size());
}"
"@Test
public void giteeSample() throws Exception {
    Map<String, Object> value = new ObjectMapper().readValue(new ClassPathResource(""pathsamples/gitee.json"").getInputStream(), new TypeReference<Map<String, Object>>() {});
    this.headers.set(""x-git-oschina-event"", ""Push Hook"");
    PropertyPathNotification extracted = this.extractor.extract(this.headers, value);
    assertThat(extracted).isNotNull();
    assertThat(extracted.getPaths()[0]).isEqualTo(""d.txt"");
}"
"@Test
public void testBrokerDiscoveryRoundRobin() throws Exception {
    addBrokerToZk(5);
    String prevUrl = null;
    for (int i = 0; i < 10; i++) {
        String current = service.getDiscoveryProvider().nextBroker().getPulsarServiceUrl();
        assertNotEquals(prevUrl, current);
        prevUrl = current;
    }
}"
"public void test_for_issue() throws Exception {
    String text=""{\""a\"":{\""x\"":\""y\""},\""b\"":{\""x\"":\""y\""}}"";
    JSONObject jsonObject=JSONObject.parseObject(text);
    System.out.println(jsonObject);
    String jsonpath=""$..x"";
    String value=""y2"";
    JSONPath.set(jsonObject,jsonpath,value);
    assertEquals(""{\""a\"":{\""x\"":\""y2\""},\""b\"":{\""x\"":\""y2\""}}"",JSON.toJSONString(jsonObject,SerializerFeature.MapSortField));
}"
"@Test
public void testPartialRepair() throws InterruptedException {
    Collection<LongTokenRange> ranges = new ArrayList<>();
    LongTokenRange range1 = new LongTokenRange(1, 2);
    LongTokenRange range2 = new LongTokenRange(3, 4);
    ranges.add(range1);
    ranges.add(range2);
    final RepairTask repairTask = new RepairTask.Builder().withJMXProxyFactory(jmxProxyFactory).withTableReference(myTableReference).withTokenRanges(ranges).withTableRepairMetrics(myTableRepairMetrics).withRepairHistory(repairHistory).withJobId(jobId).withReplicas(participants).build();
    CountDownLatch cdl = startRepair(repairTask, false);
    Notification notification = new Notification(""progress"", ""repair:1"", 0, getRepairMessage(range1));
    notification.setUserData(getNotificationData(PROGRESS.ordinal(), 1, 2));
    proxy.notify(notification);
    notification = new Notification(""progress"", ""repair:1"", 1, getRepairMessage(range2));
    notification.setUserData(getNotificationData(PROGRESS.ordinal(), 2, 2));
    proxy.notify(notification);
    notification = new Notification(""progress"", ""repair:1"", 2, ""Done with repair"");
    notification.setUserData(getNotificationData(COMPLETE.ordinal(), 2, 2));
    proxy.notify(notification);
    cdl.await();
    assertThat(repairTask.getUnknownRanges()).isNull();
    assertThat(repairTask.getCompletedRanges()).containsExactlyElementsOf(ranges);
    assertThat(proxy.myOptions.get(RANGES_KEY)).isNotEmpty();
    verify(myTableRepairMetrics).repairTiming(eq(TABLE_REFERENCE), anyLong(), any(TimeUnit.class), eq(true));
    verify(repairSessions.get(range1)).start();
    verify(repairSessions.get(range2)).start();
    verify(repairSessions.get(range1)).finish(eq(SUCCESS));
    verify(repairSessions.get(range2)).finish(eq(SUCCESS));
}"
"@Test public void testMRAppMasterShutDownJob() throws Exception, InterruptedException {
    ExitUtil.resetFirstExitException();
    String applicationAttemptIdStr=""appattempt_1317529182569_0004_000002"";
    String containerIdStr=""container_1317529182569_0004_000002_1"";
    String userName=""TestAppMasterUser"";
    ApplicationAttemptId applicationAttemptId=ApplicationAttemptId.fromString(applicationAttemptIdStr);
    ContainerId containerId=ContainerId.fromString(containerIdStr);
    JobConf conf=new JobConf();
    conf.set(MRJobConfig.MR_AM_STAGING_DIR,stagingDir);
    File stagingDir=new File(MRApps.getStagingAreaDir(conf,userName).toString());
    stagingDir.mkdirs();
    MRAppMasterTest appMaster=spy(new MRAppMasterTest(applicationAttemptId,containerId,""host"",-1,-1,System.currentTimeMillis(),false,true));
    MRAppMaster.initAndStartAppMaster(appMaster,conf,userName);
    doReturn(conf).when(appMaster).getConfig();
    appMaster.isLastAMRetry=true;
    doNothing().when(appMaster).serviceStop();
    appMaster.shutDownJob();
    Assert.assertTrue(""Expected shutDownJob to terminate."",ExitUtil.terminateCalled());
    Assert.assertEquals(""Expected shutDownJob to exit with status code of 0."",0,ExitUtil.getFirstExitException().status);
    ExitUtil.resetFirstExitException();
    String msg=""Injected Exception"";
    doThrow(new RuntimeException(msg)).when(appMaster).notifyIsLastAMRetry(anyBoolean());
    appMaster.shutDownJob();
    assertTrue(""Expected message from ExitUtil.ExitException to be "" + msg,ExitUtil.getFirstExitException().getMessage().contains(msg));
    Assert.assertEquals(""Expected shutDownJob to exit with status code of 1."",1,ExitUtil.getFirstExitException().status);
}"
"@Test
public void testRITAssignmentManagerMetrics() throws Exception {
    final TableName TABLENAME = TableName.valueOf(name.getMethodName());
    final byte[] FAMILY = Bytes.toBytes(""family"");
    Table table = null;
    try {
        table = TEST_UTIL.createTable(TABLENAME, FAMILY);
        final byte[] row = Bytes.toBytes(""row"");
        final byte[] qualifier = Bytes.toBytes(""qualifier"");
        final byte[] value = Bytes.toBytes(""value"");
        Put put = new Put(row);
        put.addColumn(FAMILY, qualifier, value);
        table.put(put);
        Thread.sleep(msgInterval * 3);
        MetricsAssignmentManagerSource amSource =
        master.getAssignmentManager().getAssignmentManagerMetrics().getMetricsProcSource();
        metricsHelper.assertGauge(MetricsAssignmentManagerSource.RIT_COUNT_NAME, 0, amSource);
        metricsHelper.assertGauge(MetricsAssignmentManagerSource.RIT_COUNT_OVER_THRESHOLD_NAME, 0,
        amSource);
        ColumnFamilyDescriptor hcd = ColumnFamilyDescriptorBuilder.newBuilder(FAMILY).build();
        TableDescriptor htd = TableDescriptorBuilder.newBuilder(TABLENAME).addColumnFamily(hcd).
        addCoprocessorWithSpec(""hdfs:///foo.jar|com.foo.FooRegionObserver|1001|arg1=1,arg2=2"").
        build();
        try {
            TEST_UTIL.getAdmin().modifyTable(htd);
            fail(""Expected region failed to open"");
        } catch (IOException e) {
            LOG.info(""Expected exception"", e);
        }
        Thread.sleep(msgInterval * 3);
        metricsHelper.assertGauge(MetricsAssignmentManagerSource.RIT_COUNT_NAME, 2, amSource);
        metricsHelper.assertGauge(MetricsAssignmentManagerSource.RIT_COUNT_OVER_THRESHOLD_NAME, 2,
        amSource);
    } finally {
        if (table != null) {
            table.close();
        }
    }
}"
"@Test public void manyParameters() throws Exception {
    assertThat(testResult(ManyParameters.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ManyParameters.iterations);
    ManyParameters.iterations=0;
}"
"@Test public void callable() throws Exception {
    assertThat(testResult(CallableOfInt.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),CallableOfInt.iterations);
    CallableOfInt.iterations=0;
}"
"@Test
public void testStreamingPrevValue() throws Exception {
    Process corfuServer = runSinglePersistentServer(corfuSingleNodeHost, corfuStringNodePort);
    runtime = createRuntime(singleNodeEndpoint);
    CorfuStore store = new CorfuStore(runtime);
    String ns = ""test_namespace"";
    String tn = ""tableA"";
    Table<Uuid, SampleTableAMsg, Uuid> table = store.openTable(ns, tn, Uuid.class, SampleTableAMsg.class, Uuid.class, TableOptions.builder().build());
    PrevValueStreamer listenerCommon = new PrevValueStreamer<Uuid, SampleTableAMsg, Uuid>(store, ns, tn);
    store.subscribeListener(listenerCommon, ns, ""sample_streamer_1"", Collections.singletonList(tn));
    final int numRecords = PARAMETERS.NUM_ITERATIONS_LOW;
    for (int i = 0; i < numRecords; i++) {
        try (final TxnContext tx = store.txn(namespace)) {
            Uuid key = Uuid.newBuilder().setLsb(0).setMsb(0).build();
            SampleTableAMsg val = SampleTableAMsg.newBuilder().setPayload(""val"" + i).build();
            tx.putRecord(table, key, val, key);
            tx.commit();
        }
    }
    TimeUnit.MILLISECONDS.sleep(sleepTime);
    assertThat(listenerCommon.getRecordCount()).isEqualTo(numRecords);
    assertThat(shutdownCorfuServer(corfuServer)).isTrue();
}"
"@Test public void wrapperChars() throws Exception {
    assertThat(testResult(WrapperChars.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperChars.iterations);
    assertEquals(new HashSet<>(asList('@','#')),new HashSet<>(WrapperChars.values.subList(0,2)));
    WrapperChars.iterations=0;
}"
"@Test
public void testWithStringAndConfForBuggyPath() throws Exception {
    dirString = ""file"" ;
    testDir = new Path(dirString);
    item = new PathData(dirString, conf);
    assertEquals(""file:/tmp"", testDir.toString());
    checkPathData();
}"
"@Test
public void testDelegationTokenWithRealUser() throws IOException {
    UserGroupInformation ugi = UserGroupInformation.createRemoteUser(REAL_USER);
    final UserGroupInformation proxyUgi = UserGroupInformation.createProxyUserForTesting(PROXY_USER, ugi, GROUP_NAMES);
    try {
        Token<?>[] tokens = proxyUgi.doAs(new PrivilegedExceptionAction<Token<?>[]>() {
            @Override
            public Token<?>[] run() throws IOException {
                return cluster.getFileSystem().addDelegationTokens(""RenewerUser"", null);
            }
        });
        DelegationTokenIdentifier identifier = new DelegationTokenIdentifier();
        byte[] tokenId = tokens[0].getIdentifier();
        identifier.readFields(new DataInputStream(new ByteArrayInputStream(tokenId)));
        Assert.assertEquals(identifier.getUser().getUserName(), PROXY_USER);
        Assert.assertEquals(identifier.getUser().getRealUser().getUserName(), REAL_USER);
    } catch (InterruptedException e) {
    }
}"
"@Test
public void testWorkflowClient() throws Exception {
    String outputPath = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
    Map<String, String> runtimeArgs = ImmutableMap.of(""inputPath"", createInput(""input""),
    ""outputPath"", outputPath);
    Id.Workflow workflowId = Id.Workflow.from(appId, AppWithWorkflow.SampleWorkflow.NAME);
    programClient.start(workflowId, false, runtimeArgs);
    programClient.waitForStatus(workflowId, ""STOPPED"", 60, TimeUnit.SECONDS);
    List<RunRecord> workflowRuns = programClient.getProgramRuns(workflowId, ProgramRunStatus.COMPLETED.name(), 0,
    Long.MAX_VALUE, 10);
    Assert.assertEquals(1, workflowRuns.size());
    Id.Run workflowRunId = new Id.Run(workflowId, workflowRuns.get(0).getPid());
    try {
        workflowClient.getWorkflowToken(new Id.Run(Id.Workflow.from(appId, ""random""), workflowRunId.getId()));
        Assert.fail(""Should not find a workflow token for a non-existing workflow"");
    } catch (NotFoundException expected) {
    }
    try {
        workflowClient.getWorkflowToken(new Id.Run(workflowId, RunIds.generate().getId()));
        Assert.fail(""Should not find a workflow token for a random run id"");
    } catch (NotFoundException expected) {
    }
    WorkflowTokenDetail workflowToken = workflowClient.getWorkflowToken(workflowRunId);
    Assert.assertEquals(3, workflowToken.getTokenData().size());
    workflowToken = workflowClient.getWorkflowToken(workflowRunId, WorkflowToken.Scope.SYSTEM);
    Assert.assertTrue(workflowToken.getTokenData().size() > 0);
    workflowToken = workflowClient.getWorkflowToken(workflowRunId, ""start_time"");
    Map<String, List<WorkflowTokenDetail.NodeValueDetail>> tokenData = workflowToken.getTokenData();
    Assert.assertEquals(AppWithWorkflow.WordCountMapReduce.NAME, tokenData.get(""start_time"").get(0).getNode());
    Assert.assertTrue(Long.parseLong(tokenData.get(""start_time"").get(0).getValue()) < System.currentTimeMillis());
    workflowToken = workflowClient.getWorkflowToken(workflowRunId, WorkflowToken.Scope.USER, ""action_type"");
    tokenData = workflowToken.getTokenData();
    Assert.assertEquals(AppWithWorkflow.WordCountMapReduce.NAME, tokenData.get(""action_type"").get(0).getNode());
    Assert.assertEquals(""MapReduce"", tokenData.get(""action_type"").get(0).getValue());
    String nodeName = AppWithWorkflow.SampleWorkflow.firstActionName;
    WorkflowTokenNodeDetail workflowTokenAtNode =
    workflowClient.getWorkflowTokenAtNode(workflowRunId, nodeName);
    Assert.assertEquals(AppWithWorkflow.DummyAction.TOKEN_VALUE,
    workflowTokenAtNode.getTokenDataAtNode().get(AppWithWorkflow.DummyAction.TOKEN_KEY));
    workflowTokenAtNode = workflowClient.getWorkflowTokenAtNode(workflowRunId, nodeName, WorkflowToken.Scope.SYSTEM);
    Assert.assertEquals(0, workflowTokenAtNode.getTokenDataAtNode().size());
    workflowTokenAtNode = workflowClient.getWorkflowTokenAtNode(workflowRunId, nodeName,
    AppWithWorkflow.DummyAction.TOKEN_KEY);
    Assert.assertEquals(AppWithWorkflow.DummyAction.TOKEN_VALUE,
    workflowTokenAtNode.getTokenDataAtNode().get(AppWithWorkflow.DummyAction.TOKEN_KEY));
    String reduceOutputRecordsCounter = ""org.apache.hadoop.mapreduce.TaskCounter.REDUCE_OUTPUT_RECORDS"";
    workflowTokenAtNode = workflowClient.getWorkflowTokenAtNode(workflowRunId, AppWithWorkflow.WordCountMapReduce.NAME,
    WorkflowToken.Scope.SYSTEM, reduceOutputRecordsCounter);
    Assert.assertEquals(6, Integer.parseInt(workflowTokenAtNode.getTokenDataAtNode().get(reduceOutputRecordsCounter)));
}"
"/**
* Tests add/remove (again).
*/
@Test public void testAddRemove(){
    CollectionValuedMap<Integer,Integer> fooMap=new CollectionValuedMap<>();
    CollectionValuedMap<Integer,Integer> expectedMap=new CollectionValuedMap<>();
    for (int i=0; i < 4; i++) {
        for (int j=0; j < 4; j++) {
            fooMap.add(new Integer(i),new Integer(j));
            if (i != 2) {
                expectedMap.add(new Integer(i),new Integer(j));
            }
        }
    }
    fooMap.remove(new Integer(2));
    Assert.assertEquals(expectedMap,fooMap);
}"
"@Test
public void testAddAndRetrieve() throws Exception {
    PeerCache cache = PeerCache.getInstance(3, 100000);
    DatanodeID dnId = new DatanodeID(""192.168.0.1"",
    ""fakehostname"", ""fake_storage_id"",
    100, 101, 102);
    FakePeer peer = new FakePeer(dnId, false);
    cache.put(dnId, peer);
    assertTrue(!peer.isClosed());
    assertEquals(1, cache.size());
    assertEquals(peer, cache.get(dnId, false));
    assertEquals(0, cache.size());
    cache.close();
}"
"@Test public void primitiveIntegers() throws Exception {
    assertThat(testResult(PrimitiveIntegers.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveIntegers.iterations);
    PrimitiveIntegers.iterations=0;
}"
"@Test public void summarizeUsersReturnsListOfUsersIfCurrentUserIsNull(){
    this.currentUser=null;
    final User user1=mock(User.class);
    when(user1.getName()).thenReturn(""franz"");
    when(user1.getFullName()).thenReturn(""Franz Josef Strauss"");
    final User user2=mock(User.class);
    when(user2.getName()).thenReturn(""friedrich"");
    when(user2.getFullName()).thenReturn(""Friedrich Merz"");
    final User peter=mock(User.class);
    when(peter.getName()).thenReturn(""peter"");
    when(peter.getFullName()).thenReturn(""Peter Altmaier"");
    when(userService.loadAll()).thenReturn(ImmutableList.of(user1,user2,peter));
    final Set<UserShortSummary> users=this.viewSharingResource.summarizeUsers(""viewId"");
    assertThat(users).containsExactlyInAnyOrder(UserShortSummary.create(""franz"",""Franz Josef Strauss""),UserShortSummary.create(""friedrich"",""Friedrich Merz""),UserShortSummary.create(""peter"",""Peter Altmaier""));
}"
"/**
* Tests ReflectionToStringBuilder.toString() for statics.
*/
@Test public void testInheritedReflectionStatics(){
    final InheritedReflectionStaticFieldsFixture instance1=new InheritedReflectionStaticFieldsFixture();
    assertEquals(this.toBaseString(instance1) + ""[staticInt2=67890,staticString2=staticString2]"",ReflectionToStringBuilder.toString(instance1,null,false,true,InheritedReflectionStaticFieldsFixture.class));
    assertEquals(this.toBaseString(instance1) + ""[staticInt2=67890,staticString2=staticString2,staticInt=12345,staticString=staticString]"",ReflectionToStringBuilder.toString(instance1,null,false,true,SimpleReflectionStaticFieldsFixture.class));
    assertEquals(this.toBaseString(instance1) + ""[staticInt2=67890,staticString2=staticString2,staticInt=12345,staticString=staticString]"",this.toStringWithStatics(instance1,null,SimpleReflectionStaticFieldsFixture.class));
    assertEquals(this.toBaseString(instance1) + ""[staticInt2=67890,staticString2=staticString2,staticInt=12345,staticString=staticString]"",this.toStringWithStatics(instance1,null,SimpleReflectionStaticFieldsFixture.class));
}"
"@Test
public void testQualifiedUriContents() throws Exception {
    dirString = fs.makeQualified(new Path(""d1"")).toString();
    item = new PathData(dirString, conf);
    PathData[] items = item.getDirectoryContents();
    assertEquals(sortedString(dirString + ""/f1"", dirString + ""/f1.1"", dirString + ""/f2""), sortedString(items));
}"
"@Test public void testToString() throws Exception {
    PMML model=buildDummyModel();
    model.getHeader().setTimestamp(null);
    assertThat(PMMLUtils.toString(model),anyOf(is(""<?xml version=\""1.0\"" encoding=\""UTF-8\"" standalone=\""yes\""?>"" + ""<PMML version=\""4.3\"" xmlns=\""http://www.dmg.org/PMML-4_3\"" "" + ""xmlns:data=\""http://jpmml.org/jpmml-model/InlineTable\"">""+ ""<Header>""+ ""<Application name=\""Oryx\""/>""+ ""</Header>""+ ""<TreeModel functionName=\""classification\"">""+ ""<Node recordCount=\""123.0\""/>""+ ""</TreeModel>""+ ""</PMML>""),is(""<?xml version=\""1.0\"" encoding=\""UTF-8\"" standalone=\""yes\""?>"" + ""<PMML version=\""4.3\"" xmlns:data=\""http://jpmml.org/jpmml-model/InlineTable\"" "" + ""xmlns=\""http://www.dmg.org/PMML-4_3\"">""+ ""<Header>""+ ""<Application name=\""Oryx\""/>""+ ""</Header>""+ ""<TreeModel functionName=\""classification\"">""+ ""<Node recordCount=\""123.0\""/>""+ ""</TreeModel>""+ ""</PMML>"")));
}"
"@Test public void testGetAllMetaAnnotations(){
    List<Annotation> metaAnnotations=getAllMetaAnnotations(Service5.class);
    int offset=0;
    HashSet<Object> set1=new HashSet<>();
    metaAnnotations.forEach(t -> set1.add(t.annotationType()));
    HashSet<Object> set2=new HashSet<>();
    set2.add(Inherited.class);
    set2.add(DubboService.class);
    set2.add(Service4.class);
    set2.add(Service3.class);
    set2.add(Service2.class);
    assertEquals(9,metaAnnotations.size());
    assertEquals(set1,set2);
    metaAnnotations=getAllMetaAnnotations(MyAdaptive.class);
    HashSet<Object> set3=new HashSet<>();
    metaAnnotations.forEach(t -> set3.add(t.annotationType()));
    HashSet<Object> set4=new HashSet<>();
    metaAnnotations.forEach(t -> set3.add(t.annotationType()));
    set4.add(Inherited.class);
    set4.add(Adaptive.class);
    assertEquals(2,metaAnnotations.size());
    assertEquals(set3,set4);
}"
"public void test_dupType2() throws Exception {
    DianDianCart cart=new DianDianCart();
    cart.setId(1001);
    LinkedHashMap<String,HashMap<String,Object>> cartMap=new LinkedHashMap<String,HashMap<String,Object>>();
    HashMap<String,Object> obj=new LinkedHashMap<String,Object>();
    obj.put(""id"",1001);
    obj.put(JSON.DEFAULT_TYPE_KEY,""com.alibaba.json.bvt.writeClassName.WriteDuplicateType$DianDianCart"");
    cartMap.put(""1001"",obj);
    String text1=JSON.toJSONString(cartMap,SerializerFeature.WriteClassName);
    Assert.assertEquals(""{\""@type\"":\""java.util.LinkedHashMap\"",\""1001\"":{\""id\"":1001,\""@type\"":\""com.alibaba.json.bvt.writeClassName.WriteDuplicateType$DianDianCart\""}}"",text1);
}"
"@Test
public void testLeaseRelease() throws Exception {
    HttpConnection conn1 = Mockito.mock(HttpConnection.class);
    HttpConnection conn2 = Mockito.mock(HttpConnection.class);
    LocalConnFactory connFactory = Mockito.mock(LocalConnFactory.class);
    Mockito.when(connFactory.create(Mockito.eq(""somehost""))).thenReturn(conn1);
    Mockito.when(connFactory.create(Mockito.eq(""otherhost""))).thenReturn(conn2);
    LocalConnPool pool = new LocalConnPool(connFactory, 2, 10);
    Future<LocalPoolEntry> future1 = pool.lease(""somehost"", null);
    LocalPoolEntry entry1 = future1.get(1, TimeUnit.SECONDS);
    Assert.assertNotNull(entry1);
    Future<LocalPoolEntry> future2 = pool.lease(""somehost"", null);
    LocalPoolEntry entry2 = future2.get(1, TimeUnit.SECONDS);
    Assert.assertNotNull(entry2);
    Future<LocalPoolEntry> future3 = pool.lease(""otherhost"", null);
    LocalPoolEntry entry3 = future3.get(1, TimeUnit.SECONDS);
    Assert.assertNotNull(entry3);
    PoolStats totals = pool.getTotalStats();
    Assert.assertEquals(0, totals.getAvailable());
    Assert.assertEquals(3, totals.getLeased());
    LocalPoolEntry entry = future1.get();
    Assert.assertSame(entry1, entry);
    pool.release(entry1, true);
    pool.release(entry2, true);
    pool.release(entry3, false);
    Mockito.verify(conn1, Mockito.never()).close();
    Mockito.verify(conn2, Mockito.times(1)).close();
    totals = pool.getTotalStats();
    Assert.assertEquals(2, totals.getAvailable());
    Assert.assertEquals(0, totals.getLeased());
}"
"@Test
public void runProducerWithHungConsumer() throws Exception {
    final long origTempUsage = broker.getSystemUsage().getTempUsage().getUsage();
    ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(""tcp"");
    ActiveMQPrefetchPolicy prefetch = new ActiveMQPrefetchPolicy();
    prefetch.setTopicPrefetch(10);
    factory.setPrefetchPolicy(prefetch);
    Connection consumerConnection = factory.createConnection();
    consumerConnection.start();
    Session consumerSession = consumerConnection.createSession(false, AUTO_ACKNOWLEDGE);
    MessageConsumer consumer = consumerSession.createConsumer(destination);
    final Connection producerConnection = factory.createConnection();
    producerConnection.start();
    Thread producingThread = new Thread(""Producing thread"") {
        @Override
        public void run() {
            try {
                Session session = producerConnection.createSession(false, AUTO_ACKNOWLEDGE);
                MessageProducer producer = session.createProducer(destination);
                producer.setDeliveryMode(deliveryMode);
                for (int idx = 0; idx < MESSAGES_COUNT; ++idx) {
                    Message message = session.createTextMessage(new String(buf) + idx);
                    producer.send(message);
                    messagesSent.incrementAndGet();
                    Thread.sleep(10);
                    LOG.info(""Sent Message "" + idx);
                    LOG.info(""Temp Store Usage "" + broker.getSystemUsage().getTempUsage().getUsage());
                }
                producer.close();
                session.close();
            } catch (Throwable ex) {
                ex.printStackTrace();
            }
        }
    };
    producingThread.start();
    int count = 0;
    Message m = null;
    while ((m = consumer.receive(messageReceiveTimeout)) != null) {
        count++;
        LOG.info(((""Recieved Message ("" + count) + ""):"") + m);
        messagesConsumed.incrementAndGet();
        try {
            Thread.sleep(100);
        } catch (Exception e) {
            LOG.info(""error sleeping"");
        }
    }
    LOG.info(""Connection Timeout: Retrying"");
    while ((m = consumer.receive(messageReceiveTimeout)) != null) {
        count++;
        LOG.info(((""Recieved Message ("" + count) + ""):"") + m);
        messagesConsumed.incrementAndGet();
        try {
            Thread.sleep(100);
        } catch (Exception e) {
            LOG.info(""error sleeping"");
        }
    }
    LOG.info(""consumer session closing: consumed count: "" + count);
    consumerSession.close();
    producingThread.join();
    final long tempUsageBySubscription = broker.getSystemUsage().getTempUsage().getUsage();
    LOG.info(((""Orig Usage: "" + origTempUsage) + "", currentUsage: "") + tempUsageBySubscription);
    producerConnection.close();
    consumerConnection.close();
    LOG.info(((""Subscrition Usage: "" + tempUsageBySubscription) + "", endUsage: "") + broker.getSystemUsage().getTempUsage().getUsage());
    assertEquals(""Incorrect number of Messages Sent: "" + messagesSent.get(), messagesSent.get(), MESSAGES_COUNT);
    assertEquals(""Incorrect number of Messages Consumed: "" + messagesConsumed.get(), messagesConsumed.get(), MESSAGES_COUNT);
}"
"public void testDefaultShapeOverride() throws Exception {
    ObjectMapper mapper=jsonMapperBuilder().withConfigOverride(Map.Entry.class,o -> o.setFormat(JsonFormat.Value.forShape(JsonFormat.Shape.POJO))).configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY,true).build();
    Map.Entry<String,String> input=new BeanWithMapEntry(""foo"",""bar"").entry;
    assertEquals(aposToQuotes(""{'key':'foo','value':'bar'}""),mapper.writeValueAsString(input));
}"
"@Test @SuppressWarnings(""unchecked"") public void iterableOfIterator(){
    Iterator<Object> mockIterator=mock(Iterator.class,""MockIterator"");
    when(mockIterator.hasNext()).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(false);
    when(mockIterator.next()).thenReturn(1).thenReturn(2).thenReturn(3).thenThrow(new NoSuchElementException(""Iterator exhausted""));
    Iterable<Object> iterable=CollectionUtils.iterable(mockIterator);
    assertThat(iterable).isNotNull();
    Set<Object> set=new LinkedHashSet<>();
    iterable.forEach(set::add);
    assertThat(set).hasSize(3);
    assertThat(set).containsExactly(1,2,3);
    verify(mockIterator,times(4)).hasNext();
    verify(mockIterator,times(3)).next();
}"
"public void test_for_issue() throws Exception {
    String test=""{\""distinct\"":false,\""oredCriteria\"":[{\""allCriteria\"":[{\""betweenValue\"":false,\""condition\"":\""area_id =\"",\""listValue\"":false,\""noValue\"":false,\""singleValue\"":true,\""value\"":917477670000000000},{\""betweenValue\"":false,\""condition\"":\""cabinet_id =\"",\""listValue\"":false,\""noValue\"":false,\""singleValue\"":true,\""value\"":500036},{\""betweenValue\"":false,\""condition\"":\""status =\"",\""listValue\"":false,\""noValue\"":false,\""singleValue\"":true,\""value\"":0}],\""criteria\"":[{\""$ref\"":\""$.oredCriteria[0].allCriteria[0]\""},{\""$ref\"":\""$.oredCriteria[0].allCriteria[1]\""},{\""$ref\"":\""$.oredCriteria[0].allCriteria[2]\""}],\""valid\"":true}],\""page\"":true,\""pageIndex\"":0,\""pageSize\"":1,\""pageStart\"":1}"";
    System.out.println(test);
    CabinetAuthCodeParam cabinetAuthCodeParam=JSONObject.toJavaObject(JSON.parseObject(test),CabinetAuthCodeParam.class);
    System.out.println(JSON.toJSONString(cabinetAuthCodeParam));
    final String jsonString=JSON.toJSONString(cabinetAuthCodeParam,SerializerFeature.MapSortField);
    assertEquals(""{\""distinct\"":false,\""oredCriteria\"":[{\""allCriteria\"":[{\""betweenValue\"":false,\""condition\"":\""area_id =\"",\""listValue\"":false,\""noValue\"":false,\""singleValue\"":true,\""value\"":917477670000000000},{\""betweenValue\"":false,\""condition\"":\""cabinet_id =\"",\""listValue\"":false,\""noValue\"":false,\""singleValue\"":true,\""value\"":500036},{\""betweenValue\"":false,\""condition\"":\""status =\"",\""listValue\"":false,\""noValue\"":false,\""singleValue\"":true,\""value\"":0}],\""criteria\"":[{\""$ref\"":\""$.oredCriteria[0].allCriteria[0]\""},{\""$ref\"":\""$.oredCriteria[0].allCriteria[1]\""},{\""$ref\"":\""$.oredCriteria[0].allCriteria[2]\""}],\""valid\"":true}],\""page\"":true,\""pageIndex\"":0,\""pageSize\"":1,\""pageStart\"":1}"",jsonString);
}"
"@Test public void primitiveIntegers(){
    assertThat(testResult(PrimitiveIntegers.class),isSuccessful());
    assertEquals(3,PrimitiveIntegers.iterations);
    assertEquals(new HashSet<>(asList(1,2,3)),PrimitiveIntegers.testCases);
    PrimitiveIntegers.iterations=0;
    PrimitiveIntegers.testCases.clear();
}"
"@Test public void primitiveShorts() throws Exception {
    assertThat(testResult(PrimitiveShorts.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveShorts.iterations);
    assertEquals(new HashSet<>(asList(Short.valueOf(""9""),Short.valueOf(""8""))),new HashSet<>(PrimitiveShorts.values.subList(0,2)));
    PrimitiveShorts.iterations=0;
}"
"@Test public void testMwMostRecentFullDumpFileProcessing() throws IOException {
    Path dmPath=Paths.get(System.getProperty(""user.dir""));
    MockDirectoryManager dm=new MockDirectoryManager(dmPath,true,true);
    mockLocalDumpFile(""20140418"",2,DumpContentType.FULL,dm);
    DumpProcessingController dpc=new DumpProcessingController(""wikidatawiki"");
    dpc.downloadDirectoryManager=dm;
    dpc.setOfflineMode(true);
    StatisticsMwRevisionProcessor mwrpStats=new StatisticsMwRevisionProcessor(""stats"",2);
    dpc.registerMwRevisionProcessor(mwrpStats,null,false);
    dpc.processMostRecentMainDump();
    assertEquals(9,mwrpStats.getTotalRevisionCount());
    assertEquals(9,mwrpStats.getCurrentRevisionCount());
}"
"@Test
public void testConsumerBacklogEvictionTimeQuotaWithEmptyLedger() throws Exception {
    assertEquals(admin.namespaces().getBacklogQuotaMap(""prop/ns-quota""), Maps.newHashMap());
    admin.namespaces().setBacklogQuota(""prop/ns-quota"", BacklogQuota.builder().limitTime(TIME_TO_CHECK_BACKLOG_QUOTA).retentionPolicy(consumer_backlog_eviction).build(), message_age);
    PulsarClient client = PulsarClient.builder().serviceUrl(adminUrl.toString()).statsInterval(0, TimeUnit.SECONDS).build();
    final String topic = ""persistent"";
    final String subName = ""c1"";
    Consumer<byte[]> consumer = client.newConsumer().topic(topic).subscriptionName(subName).subscribe();
    Producer<byte[]> producer = createProducer(client, topic);
    producer.send(new byte[1024]);
    consumer.receive();
    admin.topics().unload(topic);
    PersistentTopicInternalStats internalStats = admin.topics().getInternalStats(topic);
    assertEquals(internalStats.ledgers.size(), 2);
    assertEquals(internalStats.ledgers.get(1).entries, 0);
    TopicStats stats = admin.topics().getStats(topic);
    assertEquals(stats.getSubscriptions().get(subName).getMsgBacklog(), 1);
    TimeUnit.SECONDS.sleep(TIME_TO_CHECK_BACKLOG_QUOTA);
    Awaitility.await().pollInterval(Duration.ofSeconds(1)).atMost(Duration.ofSeconds(TIME_TO_CHECK_BACKLOG_QUOTA)).untilAsserted(() -> {
        rolloverStats();
        PersistentTopicInternalStats latestInternalStats = admin.topics().getInternalStats(topic);
        assertEquals(latestInternalStats.ledgers.size(), 2);
        assertEquals(latestInternalStats.ledgers.get(1).entries, 0);
        TopicStats latestStats = admin.topics().getStats(topic);
        assertEquals(latestStats.getSubscriptions().get(subName).getMsgBacklog(), 0);
    });
    client.close();
}"
"@Test
public void findingAnnotationsRecursively() {
    Method method = findMethod(this.getClass(), ""withMarker"", String.class);
    List<Annotation> annotations = allAnnotations(method.getParameters()[0]);
    assertEquals(4, annotations.size());
    assertEquals(X.class, annotations.get(0).annotationType());
    assertEquals(Y.class, annotations.get(1).annotationType());
    assertEquals(Z.class, annotations.get(2).annotationType());
    assertEquals(W.class, annotations.get(3).annotationType());
}"
"@Test
public void testWrite() throws Exception {
    FileSystem fs = cluster.getFileSystem();
    long tStart = System.currentTimeMillis();
    bench.writeTest(fs);
    long execTime = System.currentTimeMillis() - tStart;
    bench.analyzeResult(fs, TestType.TEST_TYPE_WRITE, execTime);
}"
"@Test
public void testWorkflowForkFailure() throws Exception {
    Assert.assertEquals(200, deploy(WorkflowFailureInForkApp.class).getStatusLine().getStatusCode());
    Id.Application appId = Application.from(DEFAULT, NAME);
    Id.Workflow workflowId = Workflow.from(appId, NAME);
    Id.Program firstMRId = Program.from(appId, MAPREDUCE, FIRST_MAPREDUCE_NAME);
    Id.Program secondMRId = Program.from(appId, MAPREDUCE, SECOND_MAPREDUCE_NAME);
    String outputPath = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
    File fileToSync = new File(tmpFolder.newFolder() + ""/sync.file"");
    File fileToWait = new File(tmpFolder.newFolder() + ""/wait.file"");
    startProgram(workflowId, ImmutableMap.of(""inputPath"", createInput(""testWorkflowForkFailureInput""), ""outputPath"", outputPath, ""sync.file"", fileToSync.getAbsolutePath(), ""wait.file"", fileToWait.getAbsolutePath(), (""mapreduce."" + WorkflowFailureInForkApp.SECOND_MAPREDUCE_NAME) + "".throw.exception"", ""true""));
    waitState(workflowId, RUNNING.name());
    waitState(workflowId, STOPPED.name());
    verifyProgramRuns(workflowId, ""failed"");
    List<RunRecord> mapReduceProgramRuns = getProgramRuns(firstMRId, KILLED.name());
    Assert.assertEquals(1, mapReduceProgramRuns.size());
    mapReduceProgramRuns = getProgramRuns(secondMRId, FAILED.name());
    Assert.assertEquals(1, mapReduceProgramRuns.size());
}"
"@Test
public void testAddRemoveRenewAction() throws IOException, InterruptedException {
    TestFileSystem tfs = new TestFileSystem();
    renewer.addRenewAction(tfs);
    for (int i = 0; i < 60; i++) {
        Thread.sleep(RENEW_CYCLE);
        if (tfs.testToken.renewCount > 0) {
            renewer.removeRenewAction(tfs);
            break;
        }
    }
    assertTrue(""Token not renewed even after 1 minute"", tfs.testToken.renewCount > 0);
    assertTrue(""Token not removed"", tfs.testToken.renewCount < MAX_RENEWALS);
    assertTrue(""Token not cancelled"", tfs.testToken.cancelled);
}"
"@Test
public void testChangeServiceNotExport() throws RemotingException {
    String result = change.telnet(mockChannel, ""demo"");
    assertEquals(""No such service demo"", result);
}"
"@Test
public void testSubscribeRate() throws Exception {
    SubscribeRate subscribeRate = new SubscribeRate(1, 5);
    String namespace = ""my-tenants/my-namespace"";
    admin.tenants().createTenant(""my-tenants"", new TenantInfoImpl(Sets.newHashSet(), Sets.newHashSet(testLocalCluster)));
    admin.namespaces().createNamespace(namespace, Sets.newHashSet(testLocalCluster));
    admin.namespaces().setSubscribeRate(namespace, subscribeRate);
    assertEquals(subscribeRate, admin.namespaces().getSubscribeRate(namespace));
    String topicName = ((""persistent""));
    admin.topics().createPartitionedTopic(topicName, 2);
    pulsar.getConfiguration().setAuthorizationEnabled(false);
    Consumer<?> consumer = pulsarClient.newConsumer().topic(topicName).subscriptionType(Shared).subscriptionName(""subscribe-rate"").subscribe();
    assertTrue(consumer.isConnected());
    pulsarClient.updateServiceUrl(lookupUrl.toString());
    Awaitility.await().untilAsserted(() -> assertFalse(consumer.isConnected()));
    Thread.sleep(6000L);
    pulsarClient.updateServiceUrl(lookupUrl.toString());
    assertTrue(consumer.isConnected());
    subscribeRate = new SubscribeRate(0, 10);
    admin.namespaces().setSubscribeRate(namespace, subscribeRate);
    pulsarClient.updateServiceUrl(lookupUrl.toString());
    Awaitility.await().untilAsserted(() -> assertTrue(consumer.isConnected()));
    pulsar.getConfiguration().setAuthorizationEnabled(true);
    admin.topics().deletePartitionedTopic(topicName, true);
    admin.namespaces().deleteNamespace(namespace);
    admin.tenants().deleteTenant(""my-tenants"");
}"
"public void testConnectedComponents(){
    System.out.println(""graph is "" + graph.toString());
    Set<Set<Integer>> ccs=new HashSet<>(graph.getConnectedComponents());
    for (  Set<Integer> cc : ccs) {
        System.out.println(""Connected component: "" + cc);
    }
    Set<Integer> edge1=new HashSet<>(Arrays.asList(1,2,3,4));
    Set<Integer> edge2=new HashSet<>(Arrays.asList(5,6,7));
    Set<Integer> edge3=new HashSet<>(Arrays.asList(8));
    Set<Integer> edge4=new HashSet<>(Arrays.asList(9,10));
    Set<Set<Integer>> expectedCcs=new HashSet<>(Arrays.asList(edge1,edge2,edge3,edge4));
    assertEquals(expectedCcs,ccs);
}"
"@Test
public void canHandleUnfragmentedMessageReceived() {
    NMEAMessage unfragmentedNMEAMessage = NMEAMessage.fromString(""!AIVDM,1,1,,B,15MqdBP000G@qoLEi69PVGaN0D0=,0*3A"");
    final ArgumentCaptor<AISMessage> aisMessage = new ArgumentCaptor<>();
    context.checking(new Expectations() {{
        oneOf(aisMessageHandler).accept(with(aisMessage.getMatcher()));
    }});
    aisMessageReceiver.accept(unfragmentedNMEAMessage);
    assertEquals(AISMessageType.PositionReportClassAScheduled, aisMessage.getCapturedObject().getMessageType());
}"
"@Test
public void testCursorBatch() throws Exception {
    ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(""vm://localhost?jms.prefetchPolicy.all=10"");
    factory.setOptimizeAcknowledge(true);
    Connection conn = factory.createConnection();
    conn.start();
    Session sess = conn.createSession(false, CLIENT_ACKNOWLEDGE);
    Queue queue = sess.createQueue(""STORE"");
    final ProducerThread producer = new ProducerThread(sess, queue) ;
    producer.setMessageCount(2000);
    producer.start();
    producer.join();
    Thread.sleep(1000);
    Destination dest = broker.getDestination(((ActiveMQQueue) (queue)));
    LOG.info(""Destination usage: "" + dest.getMemoryUsage());
    int percentUsage = dest.getMemoryUsage().getPercentUsage();
    assertTrue(""Should be less than 70% of limit but was: "" + percentUsage, percentUsage <= 71);
    LOG.info(""Broker usage: "" + broker.getSystemUsage().getMemoryUsage());
    assertTrue(broker.getSystemUsage().getMemoryUsage().getPercentUsage() <= 71);
    MessageConsumer consumer = sess.createConsumer(queue);
    Message msg = consumer.receive();
    msg.acknowledge();
    Thread.sleep(1000);
    LOG.info(""Destination usage: "" + dest.getMemoryUsage());
    assertTrue(dest.getMemoryUsage().getPercentUsage() >= 478);
    LOG.info(""Broker usage: "" + broker.getSystemUsage().getMemoryUsage());
    assertTrue(broker.getSystemUsage().getMemoryUsage().getPercentUsage() >= 478);
    for (int i = 1; i < 2000; i++) {
        msg = consumer.receive(1000);
        assertNotNull(""Didn't receive message "" + i, msg);
        msg.acknowledge();
    }
}"
"@Test
public void basicSwipeTest(int dir, int swipeDirs, int targetX) throws Throwable {
    final RecyclerView recyclerView = setup(0, swipeDirs);
    mLayoutManager.expectLayouts(1);
    setRecyclerView(recyclerView);
    mLayoutManager.waitForLayout(1);
    final RecyclerView.ViewHolder target = mRecyclerView
    .findViewHolderForAdapterPosition(1);
    TouchUtils.dragViewToX(getInstrumentation(), target.itemView, Gravity.CENTER, targetX);
    Thread.sleep(100);
    final SwipeRecord swipe = mCalback.getSwipe(target);
    assertNotNull(swipe);
    assertEquals(dir, swipe.dir);
    assertEquals(1, mItemTouchHelper.mRecoverAnimations.size());
    assertEquals(1, mItemTouchHelper.mPendingCleanup.size());
    mLayoutManager.expectLayouts(1);
    mAdapter.deleteAndNotify(1, 1);
    mLayoutManager.waitForLayout(1);
    waitForAnimations();
    assertEquals(0, mItemTouchHelper.mRecoverAnimations.size());
    assertEquals(0, mItemTouchHelper.mPendingCleanup.size());
    assertTrue(mCalback.isCleared(target));
}"
"@Test
public void testFireAllEvent() throws Exception {
    final NamingEventCoordinator coordinator = new NamingEventCoordinator();
    final CollectingListener objectListener = new CollectingListener(1);
    coordinator.addListener(""test/path"", EventContext.OBJECT_SCOPE, objectListener);
    final CollectingListener subtreeListener = new CollectingListener(1);
    coordinator.addListener(""test"", EventContext.SUBTREE_SCOPE, subtreeListener);
    final CollectingListener oneLevelListener = new CollectingListener(1);
    coordinator.addListener(""test"", EventContext.ONELEVEL_SCOPE, oneLevelListener);
    coordinator.fireEvent(context, new CompositeName(""test/path""), null, null, NamingEvent.OBJECT_ADDED, ""bind"", EventContext.OBJECT_SCOPE, EventContext.ONELEVEL_SCOPE, EventContext.SUBTREE_SCOPE);
    objectListener.latch.await(1, TimeUnit.SECONDS);
    oneLevelListener.latch.await(1, TimeUnit.SECONDS);
    subtreeListener.latch.await(1, TimeUnit.SECONDS);
    assertEquals(1, objectListener.capturedEvents.size());
    assertEquals(1, subtreeListener.capturedEvents.size());
    assertEquals(1, oneLevelListener.capturedEvents.size());
}"
"@Test
public void testCancelDeprovision() throws Exception {
    ProvisionerInfo provisionerInfo = new MockProvisioner.PropertyBuilder().waitDelete(1, TimeUnit.MINUTES).build();
    TaskFields taskFields = testProvision(ProvisioningOp.Status.CREATED, provisionerInfo);
    Runnable task = Transactionals.execute(transactional, dsContext -> {
        return provisioningService.deprovision(taskFields.programRunId, dsContext);
    });
    task.run();
    Assert.assertTrue(provisioningService.cancelDeprovisionTask(taskFields.programRunId).isPresent());
    ProvisioningTaskKey taskKey = new ProvisioningTaskKey(taskFields.programRunId, ProvisioningOp.Type.DEPROVISION);
    waitForExpectedProvisioningState(taskKey, ProvisioningOp.Status.CANCELLED);
}"
"@Test
public void testClientHang() throws Exception {
    clientTransport = new TcpTransport(new OpenWireFormat(), SocketFactory.getDefault(), new URI(""tcp://localhost:61616""), null) ;
    clientTransport.setTransportListener(new TransportListener() {
        public void onCommand(Object command) {
            clientReceiveCount.incrementAndGet();
            if (clientRunOnCommand != null) {
                clientRunOnCommand.run();
            }
        }
        clientTransport.start();
        WireFormatInfo info = new WireFormatInfo();
        info.setMaxInactivityDuration(1000);
        clientTransport.oneway(info);
        assertEquals(0, serverErrorCount.get());
        assertEquals(0, clientErrorCount.get());
        Thread.sleep(3000);
        assertEquals(0, clientErrorCount.get());
        assertTrue(serverErrorCount.get() > 0);
    }"
"@Test
public void testExcludeInclude() throws Exception {
    checkoutDir.mkdirs();
    CheckoutMojo mojo = ((CheckoutMojo) (lookupMojo(""checkout"", getTestFile(""src/test/resources/mojos/checkout/checkoutWithExcludesIncludes.xml""))));
    mojo.setCheckoutDirectory(checkoutDir);
    mojo.execute();
    assertTrue(checkoutDir.listFiles().length > 0);
    assertTrue(new File(checkoutDir, "".svn"").exists());
    assertTrue(new File(checkoutDir, ""pom.xml"").exists());
    assertFalse(new File(checkoutDir, ""readme.txt"").exists());
    assertFalse(new File(checkoutDir, ""src/test"").exists());
    assertTrue(new File(checkoutDir, ""src/main/java"").exists());
    assertTrue(new File(checkoutDir, ""src/main/java/.svn"").exists());
    assertTrue(new File(checkoutDir, ""src/main/.svn"").exists());
}"
"@Test public void testObject(){
    RpcContext context=RpcContext.getContext();
    Map<String,Object> map=new HashMap<String,Object>();
    map.put(""_11"",""1111"");
    map.put(""_22"",""2222"");
    map.put("".33"",""3333"");
    map.forEach(context::set);
    Assertions.assertEquals(map,context.get());
    Assertions.assertEquals(""1111"",context.get(""_11""));
    context.set(""_11"",""11.11"");
    Assertions.assertEquals(""11.11"",context.get(""_11""));
    context.set(null,""22222"");
    context.set(""_22"",null);
    Assertions.assertEquals(""22222"",context.get(null));
    Assertions.assertNull(context.get(""_22""));
    Assertions.assertNull(context.get(""_33""));
    Assertions.assertEquals(""3333"",context.get("".33""));
    map.keySet().forEach(context::remove);
    Assertions.assertNull(context.get(""_11""));
    RpcContext.removeContext();
}"
"@Test public void canSerializeAdditionalProperties() throws Exception {
    Foo foo=new Foo();
    foo.bar=""hello.world"";
    foo.baz=new ArrayList<>();
    foo.baz.add(""hello"");
    foo.baz.add(""hello.world"");
    foo.qux=new HashMap<>();
    foo.qux.put(""hello"",""world"");
    foo.qux.put(""a.b"",""c.d"");
    foo.qux.put(""bar.a"",""ttyy"");
    foo.qux.put(""bar.b"",""uuzz"");
    foo.additionalProperties=new HashMap<>();
    foo.additionalProperties.put(""bar"",""baz"");
    foo.additionalProperties.put(""a.b"",""c.d"");
    foo.additionalProperties.put(""properties.bar"",""barbar"");
    String serialized=new JacksonAdapter().serialize(foo);
    String expected=""{\""$type\"":\""foo\"",\""properties\"":{\""bar\"":\""hello.world\"",\""props\"":{\""baz\"":[\""hello\"",\""hello.world\""],\""q\"":{\""qux\"":{\""hello\"":\""world\"",\""a.b\"":\""c.d\"",\""bar.b\"":\""uuzz\"",\""bar.a\"":\""ttyy\""}}}},\""bar\"":\""baz\"",\""a.b\"":\""c.d\"",\""properties.bar\"":\""barbar\""}"";
    assertJsonEqualsNonStrict(expected,serialized);
}"
"@Test
public void testDuplicateConcurrentSubscribeCommand() throws Exception {
    resetChannel();
    setChannelConnected();
    CompletableFuture<Topic> delayFuture = new CompletableFuture<>();
    doReturn(delayFuture).when(brokerService).getOrCreateTopic(any(String.class));
    ByteBuf clientCommand =
    Commands.newSubscribe(successTopicName, successSubName, 1, 1, Exclusive, 0, ""test"", 0);
    channel.writeInbound(clientCommand);
    clientCommand =
    Commands.newSubscribe(successTopicName, successSubName, 1, 1, Exclusive, 0, ""test"", 0);
    channel.writeInbound(clientCommand);
    Object response = getResponse();
    assertTrue(response instanceof CommandError, ""Response is not CommandError but "" + response);
    CommandError error = ((CommandError) (response));
    assertEquals(error.getError(), ServiceNotReady);
    channel.finish();
}"
"@Test
public void testRepairSuccessfully() throws InterruptedException {
    Collection<LongTokenRange> ranges = new ArrayList<>();
    LongTokenRange range1 = new LongTokenRange(1, 2);
    LongTokenRange range2 = new LongTokenRange(3, 4);
    ranges.add(range1);
    ranges.add(range2);
    final RepairTask repairTask = new RepairTask.Builder().withJMXProxyFactory(jmxProxyFactory).withTableReference(myTableReference).withTokenRanges(ranges).withTableRepairMetrics(myTableRepairMetrics).withRepairHistory(repairHistory).withJobId(jobId).withReplicas(participants).build();
    CountDownLatch cdl = startRepair(repairTask, false);
    Notification notification = new Notification(""progress"", ""repair:1"", 0, getRepairMessage(range1));
    notification.setUserData(getNotificationData(PROGRESS.ordinal(), 1, 2));
    proxy.notify(notification);
    notification = new Notification(""progress"", ""repair:1"", 1, getRepairMessage(range2));
    notification.setUserData(getNotificationData(PROGRESS.ordinal(), 2, 2));
    proxy.notify(notification);
    notification = new Notification(""progress"", ""repair:1"", 2, ""Done with repair"");
    notification.setUserData(getNotificationData(COMPLETE.ordinal(), 2, 2));
    proxy.notify(notification);
    cdl.await();
    assertThat(repairTask.getUnknownRanges()).isNull();
    assertThat(repairTask.getCompletedRanges()).containsExactlyElementsOf(ranges);
    assertThat(proxy.myOptions.get(RANGES_KEY)).isNotEmpty();
    verify(myTableRepairMetrics).repairTiming(eq(TABLE_REFERENCE), anyLong(), any(TimeUnit.class), eq(true));
    verify(repairSessions.get(range1)).start();
    verify(repairSessions.get(range2)).start();
    verify(repairSessions.get(range1)).finish(eq(SUCCESS));
    verify(repairSessions.get(range2)).finish(eq(SUCCESS));
}"
"@Test public void mergesResultsFromMultipleChecks(){
    final Map<String,PluginMetadataSummary> result=new ViewRequirements(ImmutableSet.of(view -> Collections.singletonMap(""aioverlord"",plugin),view -> Collections.emptyMap(),view -> Collections.singletonMap(""parameters"",new EnterpriseMetadataSummary())),view);
    assertThat(result).containsOnly(Maps.immutableEntry(""aioverlord"",plugin),Maps.immutableEntry(""parameters"",new EnterpriseMetadataSummary()));
}"
"@Test
public void testHftpCustomUriPortWithDefaultPorts() throws IOException {
    resetFileSystem();
    Configuration conf = new Configuration();
    URI uri = URI.create() ;
    HftpFileSystem fs = ((HftpFileSystem) (FileSystem.get(uri, conf)));
    assertEquals(DFS_NAMENODE_HTTP_PORT_DEFAULT, fs.getDefaultPort());
    assertEquals(DFS_NAMENODE_HTTPS_PORT_DEFAULT, fs.getDefaultSecurePort());
    assertEquals(uri, fs.getUri());
    assertEquals(""127.0.0.1:"" + DFSConfigKeys.DFS_NAMENODE_HTTPS_PORT_DEFAULT, fs.getCanonicalServiceName());
}"
"@Test
public void excerpt() throws Exception {
    Session session = getAdminSession();
    QueryManager qm = session.getWorkspace().getQueryManager();
    Node testRootNode = session.getRootNode().addNode(""testroot"");
    Node n1 = testRootNode.addNode(""node1"");
    n1.setProperty(""text"", ""hello world"");
    n1.setProperty(""desc"", ""description"");
    Node n2 = testRootNode.addNode(""node2"");
    n2.setProperty(""text"", ""Hello World"");
    n2.setProperty(""desc"", ""Description"");
    session.save();
    Query q;
    RowIterator it;
    Row row;
    String s;
    String xpath = """";
    q = qm.createQuery(xpath, ""xpath"");
    it = q.execute().getRows();
    row = it.nextRow();
    s = row.getValue(""rep:excerpt(.)"").getString();
    assertTrue(s, s.indexOf(""<strong>hello</strong> world"") >= 0);
    assertTrue(s, s.indexOf(""description"") >= 0);
    row = it.nextRow();
    s = row.getValue(""rep:excerpt(.)"").getString();
    assertTrue(s, s.indexOf(""Hello World"") >= 0);
    assertTrue(s, s.indexOf(""Description"") >= 0);
    xpath = """";
    q = qm.createQuery(xpath, ""xpath"");
    it = q.execute().getRows();
    row = it.nextRow();
    s = row.getValue(""rep:excerpt(text)"").getString();
    assertTrue(s, s.indexOf(""<strong>hello</strong> world"") >= 0);
    assertTrue(s, s.indexOf(""description"") < 0);
    row = it.nextRow();
    s = row.getValue(""rep:excerpt(text)"").getString();
    assertTrue(s, s.indexOf(""Hello World"") >= 0);
    assertTrue(s, s.indexOf(""Description"") < 0);
}"
"@Test public void wrapperBooleans() throws Exception {
    assertThat(testResult(WrapperBooleans.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperBooleans.iterations);
    assertEquals(false,WrapperBooleans.values.get(0));
    assertEquals(new HashSet<>(asList(true,false)),new HashSet<>(WrapperBooleans.values));
    WrapperBooleans.iterations=0;
}"
"@Test
public void testCompositeBindingOps() throws Exception {
    final KernelServices services = createKernelServicesBuilder(createAdditionalInitialization()).setSubsystemXml(getSubsystemXml()).build();
    final ModelNode addr = Operations.createAddress(ModelDescriptionConstants.SUBSYSTEM, NamingExtension.SUBSYSTEM_NAME, NamingSubsystemModel.BINDING, ""java:global/alookup"");
    final ModelNode addOp = Operations.createAddOperation(addr);
    addOp.get(NamingSubsystemModel.BINDING_TYPE).set(NamingSubsystemModel.LOOKUP);
    final ModelNode compositeOp = Operations.CompositeOperationBuilder.create().addStep(addOp).addStep(Operations.createWriteAttributeOperation(addr, NamingSubsystemModel.LOOKUP, ""java:global/a"")).build().getOperation();
    ModelTestUtils.checkOutcome(services.executeOperation(compositeOp));
}"
"@Test
public void shouldTogglePrepareForBulkLoadDuringRestoreCalls() throws Exception {
    final List<KeyValue<byte[], byte[]>> entries = new ArrayList<>();
    entries.add(new KeyValue<>(""1"".getBytes(""UTF-8""), ""a"".getBytes(""UTF-8"")));
    entries.add(new KeyValue<>(""2"".getBytes(""UTF-8""), ""b"".getBytes(""UTF-8"")));
    entries.add(new KeyValue<>(""3"".getBytes(""UTF-8""), ""c"".getBytes(""UTF-8"")));
    final AtomicReference<Exception> conditionNotMet = new AtomicReference<>();
    final AtomicInteger conditionCheckCount = new AtomicInteger();
    Thread conditionCheckThread = new Thread(new Runnable() {
        @Override
        public void run() {
            assertRocksDBTurnsOnBulkLoading(conditionCheckCount, conditionNotMet);
            assertRockDBTurnsOffBulkLoad(conditionCheckCount, conditionNotMet);
        }
    });
    subject.init(context, subject);
    conditionCheckThread.start();
    context.restore(subject.name(), entries);
    conditionCheckThread.join(2000);
    assertTrue(conditionNotMet.get() == null);
    assertTrue(conditionCheckCount.get() == 2);
}"
"public void test_cast_to_Timestamp_1970_01_01_00_00_00() throws Exception {
    JSON.defaultTimeZone=TimeZone.getTimeZone(""Asia/Shanghai"");
    Assert.assertEquals(new Timestamp(0),TypeUtils.castToTimestamp(""1970-01-01 08:00:00""));
}"
"@Test public void testSimpleReflectionStatics(){
    final SimpleReflectionStaticFieldsFixture instance1=new SimpleReflectionStaticFieldsFixture();
    assertEquals(this.toBaseString(instance1) + ""[staticInt=12345,staticString=staticString]"",ReflectionToStringBuilder.toString(instance1,null,false,true,SimpleReflectionStaticFieldsFixture.class));
    assertEquals(this.toBaseString(instance1) + ""[staticInt=12345,staticString=staticString]"",ReflectionToStringBuilder.toString(instance1,null,true,true,SimpleReflectionStaticFieldsFixture.class));
    assertEquals(this.toBaseString(instance1) + ""[staticInt=12345,staticString=staticString]"",this.toStringWithStatics(instance1,null,SimpleReflectionStaticFieldsFixture.class));
    assertEquals(this.toBaseString(instance1) + ""[staticInt=12345,staticString=staticString]"",this.toStringWithStatics(instance1,null,SimpleReflectionStaticFieldsFixture.class));
}"
"@Test
public void testAutomaticStartStop() throws Exception {
    final TestRunnable task = new TestRunnable(500);
    e.execute(task);
    Thread thread = e.thread;
    assertThat(thread, is(not(nullValue())));
    assertThat(thread.isAlive(), is(true));
    Thread.sleep(1500);
    assertThat(thread.isAlive(), is(false));
    assertThat(task.ran.get(), is(true));
    task.ran.set(false);
    e.execute(task);
    assertThat(e.thread, not(sameInstance(thread)));
    thread = e.thread;
    Thread.sleep(1500);
    assertThat(thread.isAlive(), is(false));
    assertThat(task.ran.get(), is(true));
}"
"@Test
public void testFormatMultipleUTF8() {
    HashMap<String, String> params = new HashMap<String, String>();
    params.put(""a "", ""b, "");
    params.put(""c"", ""32626&"");
    Assert.assertTrue(""a =b%2C+&c=32626%26"".equals(KeyValueFormatter.format(params, true)) || ""c=32626%26&a =b%2C+"".equals(KeyValueFormatter.format(params, true)));
}"
"@Test public void enumsUnmarked(){
    assertThat(testResult(EnumsUnmarked.class),isSuccessful());
    assertEquals(EnumSet.allOf(RoundingMode.class).size(),EnumsUnmarked.iterations);
    assertEquals(EnumSet.allOf(RoundingMode.class),EnumsUnmarked.testCases);
    EnumsUnmarked.iterations=0;
}"
"@Test
public void shouldPickANewServerToWriteToOnLeaderSwitch() throws Throwable
{
    cluster = clusterRule.withNumberOfEdgeMembers( 0 ).startCluster();
    CoreClusterMember leader = cluster.awaitLeader();
    CountDownLatch startTheLeaderSwitching = new CountDownLatch( 1 );
    Thread thread = new Thread( () ->
    {
        try
        {
            startTheLeaderSwitching.await();
            CoreClusterMember theLeader = cluster.awaitLeader();
            switchLeader( theLeader );
        }
        catch ( TimeoutException | InterruptedException e )
        {
        }
    } );
    thread.start();
    Config config = Config.build().withLogging( new JULogging( Level.OFF ) ).toConfig();
    try ( Driver driver = GraphDatabase
    .driver( leader.routingURI(), AuthTokens.basic( ""neo4j"", ""neo4j"" ), config ) )
    {
        boolean success = false;
        Set<BoltServerAddress> seenAddresses = new HashSet<>();
        long deadline = System.currentTimeMillis() + (30 * 1000);
        while ( !success )
        {
            if ( System.currentTimeMillis() > deadline )
            {
                fail( ""Failed to write to the new leader in time"" );
            }
            try ( Session session = driver.session( AccessMode.WRITE ) )
            {
                startTheLeaderSwitching.countDown();
                BoltServerAddress boltServerAddress = ((RoutingNetworkSession) session).address();
                seenAddresses.add( boltServerAddress );
                session.run( ""CREATE (p:Person)"" );
                success = seenAddresses.size() >= 2;
            }
            catch ( Exception e )
            {
                Thread.sleep( 100 );
            }
        }
    }
    finally
    {
        thread.join();
    }
}"
"@Test
public void testListBindingsNameNotFound() throws Exception {
    try {
        namingContext.listBindings(new CompositeName(""test""));
        fail(""Should have thrown and NameNotFoundException"");
    } catch (NameNotFoundException expected) {
    }
    try {
        testActionPermission(JndiPermission.ACTION_LIST_BINDINGS, namingContext, ""test"");
        fail(""Should have thrown and NameNotFoundException with appropriate permissions"");
    } catch (NameNotFoundException expected) {
    }
}"
"@Test public void test_inherit_from_abstract_class_2(){
    issue3655_c c=new issue3655_c(null,null,null,null,null,null,null,null,null);
    String result=JSON.toJSONString(c,filter,SerializerFeature.WriteNullStringAsEmpty);
    System.out.println(result);
    Assert.assertEquals(jsonStr,result);
}"
"@Test
public void testRequestMetaForSuccessfulRequest() throws Exception {
    ListenerMeta listenerMeta = listenerMetaIndexProvider.get().getListenerMetas().get(0);
    OnlineServerMetaIndexProvider onlineServerMetaIndexProvider = listenerMeta.getOnlineServerMetaIndexProvider();
    await().until(() -> {
        assertThat(onlineServerMetaIndexProvider.get().getBalancer().size(), equalTo(3));
    });
    String content = fetch(""http://example.com/request-meta"");
    RequestMeta requestMeta = RequestMeta.fromJSON(content);
    requestMeta.getHeaders().remove(""Via"");
    requestMeta.getHeaders().remove(""Cache-Control"");
    requestMeta.getHeaders().remove(""Accept"");
    requestMeta.getHeaders().remove(""Pragma"");
    assertEquals(""foo"", requestMeta.getHeaders().get(""X-foo""));
    content = requestMeta.toJSON();
    corporaAsserter.assertEquals(""testRequestMetaForSuccessfulRequest"", content);
}"
"@Test
public void testBus() throws Exception {
    final ToBreakRunner runner = new ToBreakRunner(""dig/circuitBuilder/busTest.dig"", false);
    TruthTable tt = new ModelAnalyser(runner.getModel()).analyse();
    assertEquals(8, tt.getVars().size());
    assertEquals(8, tt.getResultCount());
    ExpressionListenerStore expr = new ExpressionListenerStore(null);
    new ExpressionCreator(tt).create(expr);
    CircuitBuilder circuitBuilder = new CircuitBuilder(runner.getLibrary().getShapeFactory(), tt.getVars()).setModelAnalyzerInfo(tt.getModelAnalyzerInfo());
    new BuilderExpressionCreator(circuitBuilder).create(expr);
    Circuit circuit = circuitBuilder.createCircuit();
    List<VisualElement> in = circuit.getElements(( v) -> v.equalsDescription(In.DESCRIPTION));
    assertEquals(2, in.size());
    checkPin(in.get(0), ""A"", ""1,2,3,4"");
    checkPin(in.get(1), ""B"", ""5,6,7,8"");
    List<VisualElement> out = circuit.getElements(( v) -> v.equalsDescription(Out.DESCRIPTION));
    assertEquals(2, out.size());
    checkPin(out.get(0), ""S"", ""9,10,11,12"");
    checkPin(out.get(1), ""U"", ""13,14,15,16"");
}"
"@Test
public void testWatch() throws Exception {
    final JsonArray operationTypes = new JsonArray(Arrays.asList(""insert"", ""update"", ""replace"", ""delete""));
    final JsonObject match = new JsonObject().put(""operationType"", new JsonObject().put(""$in"", operationTypes));
    final JsonArray pipeline = new JsonArray().add(new JsonObject().put(""$match"", match));
    final JsonObject fields = new JsonObject().put(""operationType"", true).put(""namespaceDocument"", true).put(""destinationNamespaceDocument"", true).put(""documentKey"", true).put(""updateDescription"", true).put(""fullDocument"", true);
    pipeline.add(new JsonObject().put(""$project"", fields));
    final String collection = randomCollection();
    final JsonObject doc = createDoc();
    final CountDownLatch latch = new CountDownLatch(4);
    final AtomicReference<ReadStream<ChangeStreamDocument<JsonObject>>> streamReference = new AtomicReference<>();
    mongoClient.createCollection(collection, onSuccess(( res) -> {
        ReadStream<ChangeStreamDocument<JsonObject>> stream = mongoClient.watch(collection, pipeline, true, 1).handler(( changeStreamDocument) -> {
            OperationType operationType = changeStreamDocument.getOperationType();
            assertNotNull(operationType);
            JsonObject fullDocument = changeStreamDocument.getFullDocument();
            switch (operationType.getValue()) {
                case ""insert"" :
                assertNotNull(fullDocument);
                assertNotNull(fullDocument.getString(MongoClientUpdateResult.ID_FIELD));
                assertEquals(""bar"", fullDocument.getString(""foo""));
                break;
                case ""update"" :
                assertNotNull(fullDocument);
                assertEquals(""updatedValue"", fullDocument.getString(""fieldToUpdate""));
                break;
                case ""replace"" :
                assertNotNull(fullDocument);
                assertEquals(""replacedValue"", fullDocument.getString(""fieldToReplace""));
                break;
                case ""delete"" :
                assertNull(fullDocument);
                break;
                default :
            }
            latch.countDown();
            if (latch.getCount() == 1) {
                mongoClient.removeDocuments(collection, new JsonObject());
            }
        }).endHandler(( v) -> assertEquals(0, latch.getCount())).exceptionHandler(this::fail).fetch(1);
        streamReference.set(stream);
        vertx.setTimer(50, ( v) -> {
            mongoClient.insert(collection, doc).compose(( idString) -> {
                doc.put(MongoClientUpdateResult.ID_FIELD, idString);
                doc.put(""fieldToUpdate"", ""updatedValue"");
                final JsonObject query = new JsonObject().put(MongoClientUpdateResult.ID_FIELD, idString);
                final JsonObject updateField = new JsonObject().put(""fieldToUpdate"", ""updatedValue"");
                return CompositeFuture.all(mongoClient.updateCollection(collection, query, new JsonObject().put(""$set"", updateField)), mongoClient.save(collection, doc.put(""fieldToReplace"", ""replacedValue"")));
            });
        });
    }));
    awaitLatch(latch);
    streamReference.get().handler(null);
}"
"@Test
public void testRsReportsWrongServerName() throws Exception {
    MiniHBaseCluster cluster = TEST_UTIL.getHBaseCluster();
    MiniHBaseClusterRegionServer firstServer = ((MiniHBaseClusterRegionServer) (cluster.getRegionServer(0)));
    HRegionServer secondServer = cluster.getRegionServer(1);
    HServerInfo hsi = firstServer.getServerInfo();
    firstServer.setHServerInfo(new HServerInfo(hsi.getServerAddress(), hsi.getInfoPort(), hsi.getHostname()));
    Thread.sleep(2000);
    assertTrue(firstServer.isOnline());
    assertEquals(2, cluster.getLiveRegionServerThreads().size());
    secondServer.getHServerInfo().setServerAddress(new HServerAddress(""0.0.0.0"", 60010));
    Thread.sleep(2000);
    assertTrue(secondServer.isOnline());
    assertEquals(1, cluster.getLiveRegionServerThreads().size());
}"
"@Test
public void testSimple() throws Exception {
    Configuration conf = new Configuration();
    MyResourceManager rm = new MyResourceManager(conf);
    rm.start();
    DrainDispatcher dispatcher = ((DrainDispatcher) (rm.getRMContext().getDispatcher()));
    RMApp app = rm.submitApp(1024);
    dispatcher.await();
    MockNM amNodeManager = rm.registerNode(""amNM:1234"", 2048);
    amNodeManager.nodeHeartbeat(true);
    dispatcher.await();
    ApplicationAttemptId appAttemptId = app.getCurrentAppAttempt().getAppAttemptId();
    rm.sendAMLaunched(appAttemptId);
    dispatcher.await();
    JobId jobId = MRBuilderUtils.newJobId(appAttemptId.getApplicationId(), 0);
    Job mockJob = mock(Job.class);
    when(mockJob.getReport()).thenReturn(MRBuilderUtils.newJobReport(jobId, ""job"", ""user"", RUNNING, 0, 0, 0, 0, 0, 0, ""jobfile""));
    MyContainerAllocator allocator = new MyContainerAllocator(rm, conf, appAttemptId, mockJob);
    MockNM nodeManager1 = rm.registerNode(""h1:1234"", 10240);
    MockNM nodeManager2 = rm.registerNode(""h2:1234"", 10240);
    MockNM nodeManager3 = rm.registerNode(""h3:1234"", 10240);
    dispatcher.await();
    ContainerRequestEvent event1 = createReq(jobId, 1, 1024, new String[]{ ""h1"" });
    allocator.sendRequest(event1);
    ContainerRequestEvent event2 = createReq(jobId, 2, 1024, new String[]{ ""h2"" });
    allocator.sendRequest(event2);
    List<TaskAttemptContainerAssignedEvent> assigned = allocator.schedule();
    dispatcher.await();
    Assert.assertEquals(""No of assignments must be 0"", 0, assigned.size());
    ContainerRequestEvent event3 = createReq(jobId, 3, 1024, new String[]{ ""h3"" });
    allocator.sendRequest(event3);
    assigned = allocator.schedule();
    dispatcher.await();
    Assert.assertEquals(""No of assignments must be 0"", 0, assigned.size());
    nodeManager1.nodeHeartbeat(true);
    nodeManager2.nodeHeartbeat(true);
    nodeManager3.nodeHeartbeat(true);
    dispatcher.await();
    assigned = allocator.schedule();
    dispatcher.await();
    checkAssignments(new ContainerRequestEvent[]{ event1, event2, event3 }, assigned, false);
}"
"@Test
public void testCreateSubcontext() throws Exception {
    assertTrue(namingContext.createSubcontext(new CompositeName(""test"")) instanceof NamingContext);
    assertTrue(testActionPermission(JndiPermission.ACTION_CREATE_SUBCONTEXT, namingContext, ""securitytest"") instanceof NamingContext);
}"
"@Test
public void testLookupLink() throws Exception {
    final Name name = new CompositeName(""test"");
    namingStore.bind(name, ""testValue"", String.class);
    final Name linkName = new CompositeName(""link"");
    namingStore.bind(linkName, new LinkRef(""./test""));
    Object result = namingContext.lookup(linkName);
    assertEquals(""testValue"", result);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, Arrays.asList(new JndiPermission(""test"", ""lookup"")), namingContext, ""link"");
    assertEquals(""testValue"", result);
    System.setProperty(Context.INITIAL_CONTEXT_FACTORY, InitialContextFactory.class.getName());
    namingStore.rebind(linkName, new LinkRef(name));
    result = namingContext.lookup(linkName);
    assertEquals(""testValue"", result);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, Arrays.asList(new JndiPermission(""test"", ""lookup"")), namingContext, ""link"");
    assertEquals(""testValue"", result);
}"
"@Test public void primitiveChars() throws Exception {
    assertThat(testResult(PrimitiveChars.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveChars.iterations);
    assertEquals(new HashSet<>(asList('Z','z')),new HashSet<>(PrimitiveChars.values.subList(0,2)));
    PrimitiveChars.iterations=0;
}"
"@Test
public void waitAddProject(String title) throws Exception {
    String condition = ""selenium.browserbot.getCurrentWindow().document.title.replace(/^\\s*/, \""\"").replace(/\\s*$/, \""\"") != \'\' && selenium.browserbot.getCurrentWindow().document.getElementById(\'footer\') != null"";
    getSelenium().waitForCondition(condition, maxWaitTimeInMs);
    Assert.assertEquals(getTitle(), title);
}"
"@Test public void test2_2() throws Exception {
    String jsonStr=""[{\""name\"":\""p1\"",\""sonList\"":[{\""name\"":\""s1\""}]},{\""name\"":\""p2\"",\""sonList\"":[{\""name\"":\""s2\""},{\""name\"":\""s3\""}]}]"";
    ResultActions actions=mockMvc.perform((post(""/fastjson/test2?jsonp=fnUpdateSome"").characterEncoding(""UTF-8"").content(jsonStr).contentType(MediaType.APPLICATION_JSON)));
    actions.andDo(print());
    actions.andExpect(status().isOk()).andExpect(content().contentType(APPLICATION_JAVASCRIPT));
    String content=actions.andReturn().getResponse().getContentAsString();
    assertTrue(content.equals(""/**/fnUpdateSome({\""p1\"":1,\""p2\"":2})"") || content.equals(""/**/fnUpdateSome({\""p2\"":2,\""p1\"":1})""));
}"
"@Test public void primitiveFloats(){
    assertThat(testResult(PrimitiveFloats.class),isSuccessful());
    assertEquals(2,PrimitiveFloats.iterations);
    assertEquals(new HashSet<>(asList(3.3F,-5F)),PrimitiveFloats.testCases);
    PrimitiveFloats.iterations=0;
    PrimitiveFloats.testCases.clear();
}"
"@Test public void noArray(){
    final WithArrays wa=new WithArrays();
    final String exp=getClassPrefix(wa) + ""["" + BR+ ""  boolArray=<null>,""+ BR+ ""  charArray=<null>,""+ BR+ ""  doubleArray=<null>,""+ BR+ ""  intArray=<null>,""+ BR+ ""  longArray=<null>,""+ BR+ ""  stringArray=<null>""+ BR+ ""]"";
    assertEquals(exp,toString(wa));
}"
"@Test(expected=ClusterStateException.class) public void testReassignFailOnStartNew() throws IOException {
    ReceiverAdminClient receiverAdminClient=mockReceiverClientFailOnStartNewComsumer();
    coordinator=new Coordinator(metadataStore,receiverAdminClient);
    Map<Integer,List<Partition>> preAssignMap=metadataStore.getAssignmentsByCube(cubeName).getAssignments();
    Map<Integer,List<Partition>> newAssignMap=new LinkedHashMap<>();
    newAssignMap.put(1,Lists.newArrayList(p1,p2,p3));
    newAssignMap.put(2,Lists.newArrayList(p4,p5));
    newAssignMap.put(3,Lists.newArrayList(p6));
    CubeAssignment preAssigment=new CubeAssignment(cube.getName(),preAssignMap);
    CubeAssignment newAssigment=new CubeAssignment(cube.getName(),newAssignMap);
    try {
        coordinator.doReassign(cube,preAssigment,newAssigment);
    }
    catch (  ClusterStateException rune) {
        assertSame(ClusterStateException.ClusterState.ROLLBACK_FAILED,rune.getClusterState());
        assertSame(ClusterStateException.TransactionStep.START_NEW,rune.getTransactionStep());
        System.out.println(rune.getMessage());
        throw rune;
    }
}"
"@Test
@Test(timeOut = 10000)
public void producerSendAsync() throws PulsarClientException {
    String key = ""producerSendAsync"";
    final String topicName = ""persistent://prop/cluster/namespace/topic-"" + key;
    final String subscriptionName = ""my-subscription-"" + key;
    final String messagePredicate = ""my-message-"" + key + ""-"";
    final int numberOfMessages = 30;
    Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)
    .enableBatching(false)
    .messageRoutingMode(MessageRoutingMode.SinglePartition)
    .create();
    Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(topicName).subscriptionName(subscriptionName)
    .subscribe();
    Set<MessageId> messageIds = new HashSet<>();
    List<Future<MessageId>> futures = new ArrayList<>();
    for (int i = 0; i < numberOfMessages; i++) {
        String message = messagePredicate + i;
        futures.add(producer.sendAsync(message.getBytes()));
    }
    MessageIdImpl previousMessageId = null;
    for (Future<MessageId> f : futures) {
        try {
            MessageIdImpl currentMessageId = (MessageIdImpl) f.get();
            if (previousMessageId != null) {
                Assert.assertTrue(currentMessageId.compareTo(previousMessageId) > 0,
                ""Message Ids should be in ascending order"");
            }
            messageIds.add(currentMessageId);
            previousMessageId = currentMessageId;
        } catch (Exception e) {
            Assert.fail(""Failed to publish message, Exception: "" + e.getMessage());
        }
    }
    log.info(""Message IDs = "" + messageIds);
    Assert.assertEquals(messageIds.size(), numberOfMessages, ""Not all messages published successfully"");
    for (int i = 0; i < numberOfMessages; i++) {
        Message<byte[]> message = consumer.receive();
        Assert.assertEquals(new String(message.getData()), messagePredicate + i);
        MessageId messageId = message.getMessageId();
        Assert.assertTrue(messageIds.remove(messageId), ""Failed to receive message"");
    }
    log.info(""Message IDs = "" + messageIds);
    Assert.assertEquals(messageIds.size(), 0, ""Not all messages received successfully"");
    consumer.unsubscribe();
}"
"@Test public void nestedElements(){
    final Customer customer=new Customer(""Douglas Adams"");
    final Bank bank=new Bank(""ASF Bank"");
    customer.bank=bank;
    final String exp=getClassPrefix(customer) + ""["" + BR+ ""  accounts=<null>,""+ BR+ ""  bank=""+ getClassPrefix(bank)+ ""[""+ BR+ ""    name=ASF Bank""+ BR+ ""  ],""+ BR+ ""  name=Douglas Adams""+ BR+ ""]"";
    assertEquals(exp,toString(customer));
}"
"@Test public void test_alter() throws Exception {
    String sql=""ALTER RESOURCE GROUP sql_thread TYPE = USER VCPU = 1,3 THREAD_PRIORITY = -20"";
    List<SQLStatement> stmtList=SQLUtils.toStatementList(sql,JdbcConstants.MYSQL);
    SQLStatement stmt=stmtList.get(0);
    MySqlSchemaStatVisitor visitor=new MySqlSchemaStatVisitor();
    stmt.accept(visitor);
    String output=SQLUtils.toMySqlString(stmt);
    Set<String> allPossibleRes=generateAllPossibleRes(""ALTER RESOURCE GROUP sql_thread "","""");
    assertTrue(allPossibleRes.contains(output));
}"
"@Test public void canSerializeAdditionalPropertiesThroughInheritance() throws Exception {
    Foo foo=new FooChild();
    foo.bar=""hello.world"";
    foo.baz=new ArrayList<>();
    foo.baz.add(""hello"");
    foo.baz.add(""hello.world"");
    foo.qux=new HashMap<>();
    foo.qux.put(""hello"",""world"");
    foo.qux.put(""a.b"",""c.d"");
    foo.qux.put(""bar.a"",""ttyy"");
    foo.qux.put(""bar.b"",""uuzz"");
    foo.additionalProperties=new HashMap<>();
    foo.additionalProperties.put(""bar"",""baz"");
    foo.additionalProperties.put(""a.b"",""c.d"");
    foo.additionalProperties.put(""properties.bar"",""barbar"");
    String serialized=new JacksonAdapter().serialize(foo);
    String expected=""{\""$type\"":\""foochild\"",\""properties\"":{\""bar\"":\""hello.world\"",\""props\"":{\""baz\"":[\""hello\"",\""hello.world\""],\""q\"":{\""qux\"":{\""hello\"":\""world\"",\""a.b\"":\""c.d\"",\""bar.b\"":\""uuzz\"",\""bar.a\"":\""ttyy\""}}}},\""bar\"":\""baz\"",\""a.b\"":\""c.d\"",\""properties.bar\"":\""barbar\""}"";
    assertJsonEqualsNonStrict(expected,serialized);
}"
"@Test public void handleArchiveFileLocation() throws Exception {
    File cacheSnapshotZipDirectory=null;
    try {
        File cacheSnapshotZip=new ClassPathResource(""/cache_snapshot.zip"").getFile();
        File[] actualSnapshots=snapshotService.handleFileLocation(cacheSnapshotZip);
        assertThat(actualSnapshots,is(notNullValue()));
        assertThat(actualSnapshots.length,is(equalTo(3)));
        assertThat(toFilenames(actualSnapshots).containsAll(Arrays.asList(""accounts.snapshot"",""address.snapshot"",""people.snapshot"")),is(true));
        cacheSnapshotZipDirectory=new File(System.getProperty(""java.io.tmpdir""),cacheSnapshotZip.getName().replaceAll(""\\."",""-""));
        assertThat(cacheSnapshotZipDirectory.isDirectory(),is(true));
        File[] expectedSnapshots=cacheSnapshotZipDirectory.listFiles(FileSystemUtils.FileOnlyFilter.INSTANCE);
        Arrays.sort(expectedSnapshots,(f1,f2) -> (f1.compareTo(f2)));
        Arrays.sort(actualSnapshots,(f1,f2) -> (f1.compareTo(f2)));
        assertThat(expectedSnapshots,is(equalTo(actualSnapshots)));
    }
    finally {
        if (cacheSnapshotZipDirectory != null && cacheSnapshotZipDirectory.isDirectory()) {
            FileSystemUtils.deleteRecursive(cacheSnapshotZipDirectory);
        }
    }
}"
"@Test public void test_empty_obj_toJson(){
    String j=Json.toJson(new Person(),JsonFormat.compact().setQuoteName(true));
    assertJsonEqualsNonStrict(""{\""age\"":0,\""num\"":0}"",j);
}"
"@Test
public void testSubscriber() throws InterruptedException, ExecutionException, TimeoutException {
    LineageWriter lineageWriter = getInjector().getInstance(MessagingLineageWriter.class);
    ProgramRunId run1 = service1.run(RunIds.generate());
    lineageWriter.addAccess(run1, dataset1, AccessType.READ);
    lineageWriter.addAccess(run1, dataset2, AccessType.WRITE);
    LineageStoreReader lineageReader = getInjector().getInstance(LineageStoreReader.class);
    ProgramRunId run1 = service1.run(RunIds.generate());
    Set<NamespacedEntityId> entities = lineageReader.getEntitiesForRun(run1);
    Assert.assertTrue(entities.isEmpty());
    LineageWriter lineageWriter = getInjector().getInstance(MessagingLineageWriter.class);
    lineageWriter.addAccess(run1, dataset1, AccessType.READ);
    lineageWriter.addAccess(run1, dataset2, AccessType.WRITE);
    FieldLineageWriter fieldLineageWriter = getInjector().getInstance(MessagingLineageWriter.class);
    ProgramRunId spark1Run1 = spark1.run(RunIds.generate(100));
    ReadOperation read = new ReadOperation(""read"", ""some read"", EndPoint.of(""ns"", ""endpoint1""), ""offset"", ""body"");
    TransformOperation parse = new TransformOperation(""parse"", ""parse body"",
    Collections.singletonList(InputField.of(""read"", ""body"")),
    ""name"", ""address"");
    WriteOperation write = new WriteOperation(""write"", ""write data"", EndPoint.of(""ns"", ""endpoint2""),
    Arrays.asList(InputField.of(""read"", ""offset""),
    InputField.of(""parse"", ""name""),
    InputField.of(""parse"", ""address"")));
    List<Operation> operations = new ArrayList<>();
    operations.add(read);
    operations.add(write);
    operations.add(parse);
    FieldLineageInfo info1 = new FieldLineageInfo(operations);
    fieldLineageWriter.write(spark1Run1, info1);
    ProgramRunId spark1Run2 = spark1.run(RunIds.generate(200));
    fieldLineageWriter.write(spark1Run2, info1);
    List<Operation> operations2 = new ArrayList<>();
    operations2.add(read);
    operations2.add(parse);
    TransformOperation normalize = new TransformOperation(""normalize"", ""normalize address"",
    Collections.singletonList(InputField.of(""parse"", ""address"")),
    ""address"");
    operations2.add(normalize);
    WriteOperation anotherWrite = new WriteOperation(""anotherwrite"", ""write data"", EndPoint.of(""ns"", ""endpoint2""),
    Arrays.asList(InputField.of(""read"", ""offset""),
    InputField.of(""parse"", ""name""),
    InputField.of(""normalize"", ""address"")));
    operations2.add(anotherWrite);
    FieldLineageInfo info2 = new FieldLineageInfo(operations2);
    ProgramRunId spark1Run3 = spark1.run(RunIds.generate(300));
    fieldLineageWriter.write(spark1Run3, info2);
    UsageWriter usageWriter = getInjector().getInstance(MessagingUsageWriter.class);
    usageWriter.register(spark1, dataset1);
    usageWriter.registerAll(Collections.singleton(spark1), dataset3);
    Set<NamespacedEntityId> expectedLineage = new HashSet<>(Arrays.asList(run1.getParent(), dataset1, dataset2));
    Tasks.waitFor(true, () -> expectedLineage.equals(lineageReader.getEntitiesForRun(run1)),
    10, TimeUnit.SECONDS, 100, TimeUnit.MILLISECONDS);
    Assert.assertTrue(lineageReader.getRelations(spark1, 0L, Long.MAX_VALUE, x -> true).isEmpty());
    FieldLineageReader fieldLineageReader = getInjector().getInstance(FieldLineageReader.class);
    Set<Operation> expectedOperations = new HashSet<>();
    expectedOperations.add(read);
    expectedOperations.add(anotherWrite);
    List<ProgramRunOperations> expected = new ArrayList<>();
    expected.add(new ProgramRunOperations(Collections.singleton(spark1Run3), expectedOperations));
    expectedOperations = new HashSet<>();
    expectedOperations.add(read);
    expectedOperations.add(write);
    expected.add(new ProgramRunOperations(new HashSet<>(Arrays.asList(spark1Run1, spark1Run2)),
    expectedOperations));
    EndPointField endPointField = new EndPointField(EndPoint.of(""ns"", ""endpoint2""), ""offset"");
    Tasks.waitFor(expected, () -> fieldLineageReader.getIncomingOperations(endPointField, 1L, Long.MAX_VALUE - 1),
    10, TimeUnit.SECONDS, 100, TimeUnit.MILLISECONDS);
    Set<EntityId> expectedUsage = new HashSet<>(Arrays.asList(dataset1, dataset3));
    UsageRegistry usageRegistry = getInjector().getInstance(UsageRegistry.class);
    Tasks.waitFor(true, () -> expectedUsage.equals(usageRegistry.getDatasets(spark1)),
    10, TimeUnit.SECONDS, 100, TimeUnit.MILLISECONDS);
}"
"@Test public void testAddMultipleColumnsMySql(){
    AddColumnStatement columns=new AddColumnStatement(new AddColumnStatement(null,null,TABLE_NAME,""column1"",""INT"",null,new NotNullConstraint()),new AddColumnStatement(null,null,TABLE_NAME,""column2"",""INT"",null,new NotNullConstraint()));
    assertFalse(generatorUnderTest.validate(columns,new MySQLDatabase(),new MockSqlGeneratorChain()).hasErrors());
    Sql[] sql=generatorUnderTest.generateSql(columns,new MySQLDatabase(),new MockSqlGeneratorChain());
    assertEquals(1,sql.length);
    assertEquals(""ALTER TABLE "" + TABLE_NAME + "" ADD column1 INT NOT NULL, ADD column2 INT NOT NULL"",sql[0].toSql());
    List<String> actualNames=sql[0].getAffectedDatabaseObjects().stream().map(o -> o.toString()).collect(Collectors.toList());
    List<String> expectedNames=Arrays.asList(new String[]{""table_name.column1"",""table_name.column2"",""table_name"",""DEFAULT""});
    assertTrue(actualNames.containsAll(expectedNames));
    assertTrue(expectedNames.containsAll(actualNames));
}"
"@Test
public void assertDurationIsInRange(long expectedMillis) {
    long minimum = (long) ((double) expectedMillis * 0.90);
    long maximum =
    Math.max((long) ((double) expectedMillis * 1.10), 10);
    long waitMillis = Math.max(expectedMillis * 10, 10);
    long duration = getDurationMillis(waitMillis);
    if (duration < minimum) {
        Assert.fail(""expected duration: "" + expectedMillis +
        "" minimum duration: "" + minimum +
        "" actual duration too short: "" + duration);
    } else if (duration > maximum) {
        Assert.fail(""expected duration: "" + expectedMillis +
        "" maximum duration: "" + maximum +
        "" actual duration too long: "" + duration);
    }
}"
"public void test_0() throws Exception {
    String sql=""CREATE EXTERNAL CATALOG shanghao_test.oss_catalog_0\n"" + ""PROPERTIES\n"" + ""(\n""+ ""  connector.name='oss'\n""+ ""  'connection-url'='http://oss-cn-hangzhou-zmf.aliyuncs.com'\n""+ ""  'bucket-name'='oss_test'\n""+ ""  'connection-user' = 'access_id'\n""+ ""  'connection-password' = 'access_key'\n""+ "" )\n""+ ""COMMENT 'This is a sample to create an oss connector catalog';"";
    MySqlStatementParser parser=new MySqlStatementParser(sql);
    List<SQLStatement> stmtList=parser.parseStatementList();
    assertEquals(1,stmtList.size());
    SQLStatement stmt=stmtList.get(0);
    Set<String> allPossibleRes=generateAllPossibleRes();
    assertTrue(allPossibleRes.contains(stmt.toString()));
}"
"@Test public void mergesMultipleResultsFromMultipleChecksWithConflictingKeys(){
    final Map<String,PluginMetadataSummary> result=new ViewRequirements(ImmutableSet.of(view -> ImmutableMap.of(""parameters"",plugin,""aioverlord"",plugin),view -> Collections.emptyMap(),view -> ImmutableMap.of(""parameters"",new EnterpriseMetadataSummary(),""aioverlord"",new EnterpriseMetadataSummary())),view);
    assertThat(result).contains(Maps.immutableEntry(""aioverlord"",plugin),Maps.immutableEntry(""parameters"",plugin));
}"
"@Test public void expectedOrderingOfMethods() throws Exception {
    assertThat(testResult(Leaf.class),isSuccessful());
    assertEquals(resourceAsString(""subclass-property-test-expected.txt""),bytesOut.toString().replaceAll(System.lineSeparator(),""\r\n""));
}"
"@Test public void BuilderAndGettersWithMultipleValuesTest(){
    List<String> emails=Arrays.asList(""email0"",""email1"");
    List<String> phones=Arrays.asList(""1234567890"",""2062062006"");
    List<GenderEnum> genders=Arrays.asList(GenderEnum.MALE,GenderEnum.FEMALE);
    List<String> datesOfBirth=Arrays.asList(""20000101"",""20000102"");
    List<String> lastNames=Arrays.asList(""lastname-1"",""lastname-2"");
    List<String> firstNames=Arrays.asList(""firstname-2"",""firstname-3"");
    List<String> cities=Arrays.asList(""Seattle"",""Portland"");
    List<String> states=Arrays.asList(""WA"",""CA"");
    List<String> zipcodes=Arrays.asList(""98123"",""98122"");
    List<String> countryCodes=Arrays.asList(""USA"",""CA"");
    List<String> externalIds=Arrays.asList(""external-1"",""external-2"",""external-2"");
    UserData userData=new UserData();
    userData.emails(emails).phones(phones).genders(genders).datesOfBirth(datesOfBirth).lastNames(lastNames).firstNames(firstNames).cities(cities).states(states).zipcodes(zipcodes).countryCodes(countryCodes).externalIds(externalIds);
    assertEquals(userData.getEmails(),emails);
    assertEquals(userData.getPhones(),phones);
    assertEquals(userData.getGenders(),genders);
    assertEquals(userData.getDatesOfBirth(),datesOfBirth);
    assertEquals(userData.getLastNames(),lastNames);
    assertEquals(userData.getFirstNames(),firstNames);
    assertEquals(userData.getCities(),cities);
    assertEquals(userData.getStates(),states);
    assertEquals(userData.getZipcodes(),zipcodes);
    assertEquals(userData.getCountryCodes(),countryCodes);
    List<String> sortedActualExternalIds=userData.getExternalIds();
    Collections.sort(sortedActualExternalIds);
    assertEquals(sortedActualExternalIds,externalIds.subList(0,2));
}"
"@Test
public void testConcurrentDurableConsumer() throws Exception {
    broker.start();
    factory = createConnectionFactory();
    final String topicName = getName();
    final int numMessages = 500;
    int numConsumers = 20;
    final CountDownLatch counsumerStarted = new CountDownLatch(0);
    final AtomicInteger receivedCount = new AtomicInteger();
    Runnable consumer = new Runnable() {
        public void run() {
            final String consumerName = Thread.currentThread().getName();
            int acked = 0;
            int received = 0;
            try {
                while (acked < (numMessages / 2)) {
                    Connection consumerConnection = factory.createConnection();
                    ((ActiveMQConnection) (consumerConnection)).setWatchTopicAdvisories(false);
                    consumerConnection.setClientID(consumerName);
                    Session consumerSession = consumerConnection.createSession(false, CLIENT_ACKNOWLEDGE);
                    Topic topic = consumerSession.createTopic(topicName);
                    consumerConnection.start();
                    MessageConsumer consumer = consumerSession.createDurableSubscriber(topic, consumerName);
                    counsumerStarted.countDown();
                    Message msg = null;
                    do {
                        msg = consumer.receive(5000);
                        if (msg != null) {
                            receivedCount.incrementAndGet();
                            if (((received++) % 2) == 0) {
                                msg.acknowledge();
                                acked++;
                            }
                        }
                    } while (msg == null );
                    consumerConnection.close();
                }
                assertTrue(received >= acked);
            } catch (Exception e) {
                e.printStackTrace();
                exceptions.add(e);
            }
        }
    };
    ExecutorService executor = Executors.newCachedThreadPool();
    for (int i = 0; i < numConsumers; i++) {
        executor.execute(consumer);
    }
    assertTrue(counsumerStarted.await(30, TimeUnit.SECONDS));
    Connection producerConnection = factory.createConnection();
    ((ActiveMQConnection) (producerConnection)).setWatchTopicAdvisories(false);
    Session producerSession = producerConnection.createSession(false, AUTO_ACKNOWLEDGE);
    Topic topic = producerSession.createTopic(topicName);
    MessageProducer producer = producerSession.createProducer(topic);
    producerConnection.start();
    for (int i = 0; i < numMessages; i++) {
        BytesMessage msg = producerSession.createBytesMessage();
        msg.writeBytes(payload);
        producer.send(msg);
        if ((i != 0) && ((i % 100) == 0)) {
            LOG.info(""Sent msg "" + i);
        }
    }
    Thread.sleep(2000);
    executor.shutdown();
    executor.awaitTermination(30, TimeUnit.SECONDS);
    assertTrue(""got some messages: "" + receivedCount.get(), receivedCount.get() > numMessages);
    assertTrue(""no exceptions, but: "" + exceptions, exceptions.isEmpty());
}"
"@Test
public void testMatchesSpeedTest() throws Exception {
    int iterations = 15;
    String password = new RandomValueStringGenerator().generate();
    String encodedBcrypt = cachingPasswordEncoder.encode(password);
    long nanoStart = System.nanoTime();
    for (int i = 0; i < iterations; i++) {
        assertTrue(cachingPasswordEncoder.getPasswordEncoder().matches(password, encodedBcrypt));
        long nanoStop = System.nanoTime();
        long bcryptTime = nanoStop - nanoStart;
        nanoStart = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            nanoStop = System.nanoTime();
            long cacheTime = nanoStop - nanoStart;
            assertTrue(bcryptTime > (10 * cacheTime));
        }
    }
}"
"@Test public void stringArray(){
    final WithArrays wa=new WithArrays();
    wa.stringArray=new String[]{""a"",""A""};
    final String exp=getClassPrefix(wa) + ""["" + BR+ ""  boolArray=<null>,""+ BR+ ""  charArray=<null>,""+ BR+ ""  doubleArray=<null>,""+ BR+ ""  intArray=<null>,""+ BR+ ""  longArray=<null>,""+ BR+ ""  stringArray={""+ BR+ ""    a,""+ BR+ ""    A""+ BR+ ""  }""+ BR+ ""]"";
    assertEquals(exp,toString(wa));
}"
"@Test public void test_create() throws Exception {
    String sql=""CREATE RESOURCE GROUP sql_thread TYPE = USER VCPU = 1,3 THREAD_PRIORITY = -20"";
    List<SQLStatement> stmtList=SQLUtils.toStatementList(sql,JdbcConstants.HIVE);
    SQLStatement stmt=stmtList.get(0);
    MySqlSchemaStatVisitor visitor=new MySqlSchemaStatVisitor();
    stmt.accept(visitor);
    String output=SQLUtils.toMySqlString(stmt);
    Set<String> allPossibleRes=generateAllPossibleRes(""CREATE RESOURCE GROUP sql_thread "");
    assertTrue(allPossibleRes.contains(output));
}"
"@Test
public void shouldReturnBodyWhenEnabledAndNoMax() {
    String body = ""{\n"" +
    ""  \""error\"": \""not found\""\n"" +
    ""}"";
    HttpResponseFacade mock = mock(HttpResponseFacade.class);
    when(mock.response()).thenReturn(generateResponse(
    ""application/json"",
    404,
    body.getBytes()));
    ((HttpAssertionFacadeImpl) facade).facade = mock;
    world.put(ASSERTS_STATUS_CODE_DISPLAY_BODY, ""true"");
    validateException(
    200,
    ""1 expectation failed.\n"" +
    ""Expected status code \""200\"" but was \""404\"" with body:\n"" +
    ""\""\""\""\n"" +
    body +
    ""\n\""\""\"".\n"");
}"
"@Test public void manyParameters(){
    assertThat(testResult(ManyParameters.class),isSuccessful());
    assertEquals(16,ManyParameters.iterations);
    assertEquals(asList(-4,-2,-1),ManyParameters.firstTestCases.subList(0,3));
    assertEquals(asList(-4,-2,-1),ManyParameters.firstTestCases.subList(4,7));
    assertEquals(asList(-4,-2,-1),ManyParameters.firstTestCases.subList(8,11));
    assertEquals(asList(-4,-2,-1),ManyParameters.firstTestCases.subList(12,15));
    assertEquals(asList('r','r','r','r','y','y','y','y'),ManyParameters.secondTestCases.subList(0,8));
    ManyParameters.iterations=0;
}"
"@Test
public void testRateLimitingMax() {
    int n = 10;
    double rate = 10.0;
    long duration = runWithRate(n, rate, new IdentityFn<Integer>());
    long perElementPause = (long) (1000L / rate);
    long minDuration = (n - 1) * perElementPause;
    Assert.assertThat(duration, greaterThan(minDuration));
}"
"@Test
public void testIndependentBranchesCase() {
    graph.add(""a"", ""b"");
    graph.add(""b"", ""c1"");
    graph.add(""b"", ""c2"");
    graph.add(""o"", ""p1"");
    graph.add(""p1"", ""r1"");
    graph.add(""r1"", ""s"");
    graph.add(""o"", ""p2"");
    graph.add(""p2"", ""r2"");
    graph.add(""r2"", ""s2"");
    graph.add(""r2"", ""s3"");
    graph.add(""x"", ""y"");
    graph.computeDependencies();
    List<String> expected =
    Arrays.asList(""a"", ""o"", ""x"", ""b"", ""p1"", ""p2"", ""y"", ""c1"", ""c2"", ""r1"", ""r2"", ""s"", ""s2"", ""s3"");
    Assert.assertEquals(expected, dependencyOrder);
}"
"@Test
public void testMultiReaderIsAbleToSeekWithTimeOnMiddleOfTopic() throws Exception {
    final String topicName = ""persistent"";
    final int numOfMessage = 10;
    final int halfMessages = numOfMessage / 2;
    admin.topics().createPartitionedTopic(topicName, 3);
    Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName).create();
    long l = System.currentTimeMillis();
    for (int i = 0; i < numOfMessage; i++) {
        producer.send(String.format(""msg num %d"", i).getBytes());
    }
    Reader<byte[]> reader = pulsarClient.newReader().topic(topicName).startMessageId(earliest).create();
    int plusTime = (halfMessages + 1) * 100;
    reader.seek(l + plusTime);
    Set<String> messageSet = Sets.newHashSet();
    for (int i = halfMessages + 1; i < numOfMessage; i++) {
        Message<byte[]> message = reader.readNext();
        String receivedMessage = new String(message.getData());
        Assert.assertTrue(messageSet.add(receivedMessage), ""Received duplicate message "" + receivedMessage);
    }
    reader.close();
    producer.close();
}"
"@Test public void wrapperBytes() throws Exception {
    assertThat(testResult(WrapperBytes.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperBytes.iterations);
    assertEquals(new HashSet<>(asList((byte)14,(byte)-15)),new HashSet<>(WrapperBytes.values.subList(0,2)));
    WrapperBytes.iterations=0;
}"
"@Test public void assertPersistSequential() throws Exception {
    assertThat(zkRegCenter.persistSequential(""/sequential/test_sequential"",""test_value""),startsWith(""/sequential/test_sequential""));
    assertThat(zkRegCenter.persistSequential(""/sequential/test_sequential"",""test_value""),startsWith(""/sequential/test_sequential""));
    CuratorFramework client=CuratorFrameworkFactory.newClient(EmbedTestingServer.getConnectionString(),new RetryOneTime(2000));
    client.start();
    client.blockUntilConnected();
    List<String> actual=client.getChildren().forPath(""/"" + ZookeeperRegistryCenterModifyTest.class.getName() + ""/sequential"");
    assertThat(actual.size(),is(2));
    for (  String each : actual) {
        assertThat(each,startsWith(""test_sequential""));
        assertThat(zkRegCenter.get(""/sequential/"" + each),startsWith(""test_value""));
    }
    zkRegCenter.remove(""/sequential"");
    assertFalse(zkRegCenter.isExisted(""/sequential""));
}"
"public void testMarshalObj3(){
    final DataField d1=new DataField(20);
    for (int i=0; i < 11; i++)   d1.setData(i,2);
    final DataField d2=new DataField(20);
    for (int j=0; j < 11; j++)   for (int i=0; i < 11; i++)   d2.setData(i + j * 11,j + 1);
    XStream xs=getxStream();
    String xml=xs.toXML(new Test(d1,d2));
    String d1_str=""<d1>11*2</d1>"";
    String d2_str=""<d2>11*1,11*2,11*3,11*4,11*5,11*6,11*7,11*8,11*9,11*a,11*b</d2>"";
    checkEquals(d1_str,d2_str,xml);
}"
"@Test public void wrapperDoubles(){
    assertThat(testResult(WrapperDoubles.class),isSuccessful());
    assertEquals(2,WrapperDoubles.iterations);
    assertEquals(new HashSet<>(asList(2.7,-3.14)),WrapperDoubles.testCases);
    WrapperDoubles.iterations=0;
}"
"@Test
public void assertGetCurrentShardingTotalCountIfNull() {
    assertThat(JobRegistry.getInstance().getCurrentShardingTotalCount(""exist_job_instance""), is(0));
}"
"@Test
public void testWithDirStringAndConf() throws Exception {
    dirString = ""d1"";
    item = new PathData(dirString, conf);
    checkPathData();
    dirString = ""d1/"";
    item = new PathData(dirString, conf);
    checkPathData();
}"
"@Test
void validUsage() throws Exception {
    assertThat(stopWatch.isRunning()).isFalse();
    stopWatch.start(name1);
    Thread.sleep(duration1);
    assertThat(stopWatch.isRunning()).isTrue();
    assertThat(stopWatch.currentTaskName()).isEqualTo(name1);
    stopWatch.stop();
    assertThat(stopWatch.isRunning()).isFalse();
    assertThat(stopWatch.getLastTaskTimeNanos())
    .as(""last task time in nanoseconds for task #2"")
    .isGreaterThanOrEqualTo(millisToNanos(duration2))
    .isLessThanOrEqualTo(millisToNanos(duration2 + fudgeFactor));
    assertThat(stopWatch.getTotalTimeMillis())
    .as(""total time in milliseconds for tasks #1 and #2"")
    .isGreaterThanOrEqualTo(duration1 + duration2 - fudgeFactor)
    .isLessThanOrEqualTo(duration1 + duration2 + fudgeFactor);
    assertThat(stopWatch.getTotalTimeSeconds())
    .as(""total time in seconds for task #2"")
    .isGreaterThanOrEqualTo((duration1 + duration2 - fudgeFactor) / 1000.0)
    .isLessThanOrEqualTo((duration1 + duration2 + fudgeFactor) / 1000.0);
    assertThat(stopWatch.getTaskCount()).isEqualTo(2);
    assertThat(stopWatch.prettyPrint()).contains(name1, name2);
    assertThat(stopWatch.getTaskInfo()).extracting(TaskInfo::getTaskName).containsExactly(name1, name2);
    assertThat(stopWatch.toString()).contains(ID, name1, name2);
    assertThat(stopWatch.getId()).isEqualTo(ID);
}"
"@Test
public void test_6() throws Exception {
    JSONObject jsonObject = new JSONObject();
    jsonObject.put(""val"", new Character[]{  });
    jsonObject.put(""cls"", Number.class);
    jsonObject.put(""nums"", new Number[]{  });
    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
    ObjectOutputStream objOut = new ObjectOutputStream(bytesOut);
    objOut.writeObject(jsonObject);
    objOut.flush();
    byte[] bytes = bytesOut.toByteArray();
    ByteArrayInputStream bytesIn = new ByteArrayInputStream(bytes);
    ObjectInputStream objIn = new ObjectInputStream(bytesIn);
    Object obj = objIn.readObject();
    assertEquals(JSONObject.class, obj.getClass());
    assertEquals(jsonObject.toJSONString(), JSON.toJSONString(obj));
}"
"@Test public void strings() throws Exception {
    assertThat(testResult(Strings.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),Strings.iterations);
    assertEquals(new HashSet<>(asList(""some"",""values"")),new HashSet<>(Strings.values.subList(0,2)));
    Strings.iterations=0;
}"
"@Test public void primitiveDoubles() throws Exception {
    assertThat(testResult(PrimitiveDoubles.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveDoubles.iterations);
    PrimitiveDoubles.iterations=0;
}"
"@Test
public void testActivateSamples() throws Exception {
    UUID collectionExerciseId = UUID.randomUUID();
    UUID surveyId = UUID.randomUUID();
    UUID sampleSummaryId = UUID.randomUUID();
    SampleLink sampleLink = new SampleLink();
    sampleLink.setSampleSummaryId(sampleSummaryId);
    sampleLink.setCollectionExerciseId(collectionExerciseId);
    List<SampleLink> sampleLinks = new ArrayList<>();
    sampleLinks.add(sampleLink);
    CollectionExercise collectionExercise = new CollectionExercise();
    collectionExercise.setId(collectionExerciseId);
    collectionExercise.setSurveyId(surveyId);
    Event event = new Event();
    event.setTimestamp(new Timestamp(System.currentTimeMillis()));
    when(collectionExerciseRepository.findOneById(collectionExerciseId)).thenReturn(collectionExercise);
    when(sampleLinkRepository.findByCollectionExerciseId(collectionExerciseId)).thenReturn(sampleLinks);
    when(eventRepository.findOneByCollectionExerciseAndTag(collectionExercise, go_live.name())).thenReturn(event);
    sampleSummaryService.activateSamples(collectionExerciseId);
    sampleSummaryService.sampleSummaryValidated(true, collectionExerciseId);
    sampleSummaryService.sampleSummaryDistributed(true, collectionExerciseId);
    verify(collectionExerciseRepository, times(3)).findOneById(collectionExerciseId);
    verify(sampleSummaryActivationPublisher, times(1)).sendSampleSummaryActivation(collectionExerciseId, sampleSummaryId, surveyId);
    verify(collectionExerciseService, times(1)).transitionCollectionExercise(collectionExercise, EXECUTE);
    verify(collectionExerciseService, times(1)).transitionCollectionExercise(collectionExercise, VALIDATE);
    verify(collectionExerciseService, times(1)).transitionCollectionExercise(collectionExercise, EXECUTION_COMPLETE);
    verify(collectionExerciseService, times(1)).transitionCollectionExercise(collectionExercise, GO_LIVE);
}"
"@Test public void enums() throws Exception {
    assertThat(testResult(Enums.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),Enums.iterations);
    assertEquals(EnumSet.of(HALF_UP,HALF_EVEN),new HashSet<>(Enums.values.subList(0,2)));
    Enums.iterations=0;
}"
"@Test public void acrossParametersOfSameTypeWithOneConstant() throws Exception {
    assertThat(testResult(ParametersOfSameTypeWithOneConstant.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ParametersOfSameTypeWithOneConstant.iterations);
    ParametersOfSameTypeWithOneConstant.iterations=0;
}"
"@Test
public void testInitialFactory() throws Exception {
    System.setProperty(Context.INITIAL_CONTEXT_FACTORY, InitialContextFactory.class.getName());
    InitialContext initialContext = new InitialContext();
    Context context = (Context) initialContext.lookup("""");
    assertTrue(context instanceof NamingContext);
    if (!NamingManager.hasInitialContextFactoryBuilder()) {
        NamingManager.setInitialContextFactoryBuilder(new InitialContextFactoryBuilder());
    }
    initialContext = new InitialContext();
    context = (Context) initialContext.lookup("""");
    assertTrue(context instanceof NamingContext);
}"
"@Test
public void test_multimap() throws Exception {
    Map<String, Integer> map = ImmutableMap.of(""a"", 1, ""b"", 1, ""c"", 2);
    SetMultimap<String, Integer> multimap = Multimaps.forMap(map);
    Multimap<Integer, String> inverse = Multimaps.invertFrom(multimap, HashMultimap.<Integer, String>create());
    String json = JSON.toJSONString(inverse);
    assertEquals(""{1:[\""a\"",\""b\""],2:[\""c\""]}"", json);
}"
"@Test void writesAndReadsClassContainingCustomConvertedObjects(){
    List<Object> converters=new ArrayList<>();
    converters.add(BigDecimalToStringConverter.INSTANCE);
    converters.add(StringToBigDecimalConverter.INSTANCE);
    CustomConversions customConversions=new CouchbaseCustomConversions(converters);
    converter.setCustomConversions(customConversions);
    converter.afterPropertiesSet();
    ((CouchbaseMappingContext)converter.getMappingContext()).setSimpleTypeHolder(customConversions.getSimpleTypeHolder());
    CouchbaseDocument converted=new CouchbaseDocument();
    final String weightStr=""12.34"";
    final BigDecimal weight=new BigDecimal(weightStr);
    final CustomObject addy=new CustomObject(weight);
    List<CustomObject> listOfObjects=new ArrayList<>();
    listOfObjects.add(addy);
    Map<String,CustomObject> mapOfObjects=new HashMap<>();
    mapOfObjects.put(""obj0"",addy);
    mapOfObjects.put(""obj1"",addy);
    CustomObjectEntity entity=new CustomObjectEntity(addy,listOfObjects,mapOfObjects);
    converter.write(entity,converted);
    CouchbaseDocument source=new CouchbaseDocument();
    source.put(""_class"",CustomObjectEntity.class.getName());
    CouchbaseDocument objectDoc=new CouchbaseDocument();
    objectDoc.put(""weight"",weightStr);
    source.put(""object"",objectDoc);
    CouchbaseList listOfObjectsDoc=new CouchbaseList();
    listOfObjectsDoc.put(objectDoc);
    source.put(""listOfObjects"",listOfObjectsDoc);
    CouchbaseDocument mapOfObjectsDoc=new CouchbaseDocument();
    mapOfObjectsDoc.put(""obj0"",objectDoc);
    mapOfObjectsDoc.put(""obj1"",objectDoc);
    source.put(""mapOfObjects"",mapOfObjectsDoc);
    assertThat(converted.export()).isEqualTo(source.export());
    CustomObjectEntity readConverted=converter.read(CustomObjectEntity.class,source);
    assertThat(readConverted.object.weight).isEqualTo(addy.weight);
    assertThat(readConverted.listOfObjects.get(0).weight).isEqualTo(listOfObjects.get(0).weight);
    assertThat(readConverted.mapOfObjects.get(""obj0"").weight).isEqualTo(mapOfObjects.get(""obj0"").weight);
    assertThat(readConverted.mapOfObjects.get(""obj1"").weight).isEqualTo(mapOfObjects.get(""obj1"").weight);
}"
"@Test public void testMwRecentCurrentDumpFileProcessing() throws IOException {
    Path dmPath=Paths.get(System.getProperty(""user.dir""));
    MockDirectoryManager dm=new MockDirectoryManager(dmPath,true,true);
    mockLocalDumpFile(""20140420"",4,DumpContentType.DAILY,dm);
    mockLocalDumpFile(""20140419"",3,DumpContentType.DAILY,dm);
    mockLocalDumpFile(""20140418"",2,DumpContentType.DAILY,dm);
    mockLocalDumpFile(""20140417"",1,DumpContentType.DAILY,dm);
    mockLocalDumpFile(""20140418"",2,DumpContentType.CURRENT,dm);
    DumpProcessingController dpc=new DumpProcessingController(""wikidatawiki"");
    dpc.downloadDirectoryManager=dm;
    dpc.setOfflineMode(true);
    StatisticsMwRevisionProcessor mwrpStats=new StatisticsMwRevisionProcessor(""stats"",2);
    dpc.registerMwRevisionProcessor(mwrpStats,null,true);
    dpc.processAllRecentRevisionDumps();
    assertEquals(5,mwrpStats.getTotalRevisionCount());
    assertEquals(1,mwrpStats.getCurrentRevisionCount());
}"
"@Test
public void testCollectorContextWithKeyword() throws Exception {
    ValidationResult validationResult = validate(""{\""test-property1\"":\""sample1\"",\""test-property2\"":\""sample2\""}"");
    Assertions.assertEquals(0, validationResult.getValidationMessages().size());
    List<String> contextValues = ((List<String>) (validationResult.getCollectorContext().get(SAMPLE_COLLECTOR)));
    Assertions.assertEquals(0, validationResult.getValidationMessages().size());
    Assertions.assertEquals(2, contextValues.size());
    Assertions.assertEquals(contextValues.get(0), ""actual_value_added_to_context1"");
    Assertions.assertEquals(contextValues.get(1), ""actual_value_added_to_context2"");
}"
"@Test
public void assertGetLocalFailoverItemsIfShutdown() {
    assertThat(failoverService.getLocalFailoverItems(), is(Collections.<Integer>emptyList()));
    verify(jobNodeStorage, times(0)).getJobNodeChildrenKeys(""sharding"");
}"
"public void test_for_issue2(){
    VO2 vo=new VO2();
    vo.id=123;
    vo.properties.put(""latitude"",37);
    vo.properties.put(""longitude"",127);
    Object obj=JSON.toJSON(vo);
    String text=JSON.toJSONString(obj,SerializerFeature.MapSortField);
    assertEquals(""{\""id\"":123,\""latitude\"":37,\""longitude\"":127}"",text);
}"
"@Test
public void test() throws Exception {
    captureErr();
    new Thread(this::startServer).start();
    Ignite client = startGrid(getConfiguration(""client"").setClientMode(true));
    IgniteServices services = client.services();
    SimpleService srvc = services.serviceProxy(""service"", SimpleService.class, false);
    Thread.sleep(1000);
    srvc.isWorking();
    assertFalse(getErr().contains(""Cache is not configured:""));
}"
"@Test
void close() throws Exception {
    when(webSocketClient.getConnection()).thenReturn(webSocket);
    when(webSocketClient.isOpen()).thenReturn(true);
    webSocketConnection.close();
    Thread.sleep(10);
    verify(webSocket).close();
}"
"public void test_reserve() throws Exception {
    JSONObject object=JSON.parseObject(""{\""id\"":1001,\""name\"":\""ljw\"",\""age\"":50}"");
    assertEquals(""[1001,\""ljw\""]"",JSONPath.reserveToArray(object,""id"",""name"").toString());
    assertEquals(""[\""ljw\"",1001]"",JSONPath.reserveToArray(object,""name"",""id"").toString());
    String text=JSON.toJSONString(JSONPath.reserveToArray(object,""name"",""*""),SerializerFeature.MapSortField);
    assertTrue(text.equals(""[\""ljw\"",[\""ljw\"",1001,50]]"") || text.equals(""[\""ljw\"",[\""ljw\"",50,1001]]"") || text.equals(""[\""ljw\"",[50,1001,\""ljw\""]]"")|| text.equals(""[\""ljw\"",[1001,50,\""ljw\""]]"")|| text.equals(""[\""ljw\"",[1001,\""ljw\"",50]]"")|| text.equals(""[\""ljw\"",[50,\""ljw\"",1001]]""));
}"
"@Test
public synchronized void testLockExpiration() throws RepositoryException, NotExecutableException {
    lockedNode.unlock();
    long hint = 1;
    lock = lockMgr.lock(lockedNode.getPath(), isDeep(), isSessionScoped(), hint, null);
    long remaining = lock.getSecondsRemaining();
    if (remaining <= hint) {
        try {
            wait(remaining * 2000);
        } catch (InterruptedException ignore) {
        }
        long secs = lock.getSecondsRemaining();
        assertTrue(""A released lock must return a negative number of seconds, was: "" + secs, secs < 0);
        String message = ""If the timeout hint is respected the lock"" + "" must be automatically released."";
        assertFalse(message, lock.isLive());
        assertFalse(message, lockedNode.isLocked());
        assertFalse(message, lockMgr.isLocked(lockedNode.getPath()));
        assertFalse(message, lockedNode.hasProperty(JCR_LOCK_IS_DEEP));
        assertFalse(message, lockedNode.hasProperty(JCR_LOCK_OWNER));
    } else {
        throw new NotExecutableException(""timeout hint was ignored."");
    }
}"
"@Test
public void testJavaContext() throws Exception {
    System.setProperty(Context.INITIAL_CONTEXT_FACTORY, InitialContextFactory.class.getName());
    System.setProperty(Context.URL_PKG_PREFIXES, ""org.jboss.as.naming.interfaces"");
    InitialContext initialContext = new InitialContext();
    Context context = (Context) initialContext.lookup(""java:"");
    assertTrue(context instanceof NamingContext);
}"
"@Test public void primitiveBytes(){
    assertThat(testResult(PrimitiveBytes.class),isSuccessful());
    assertEquals(2,PrimitiveBytes.iterations);
    assertEquals(new HashSet<>(asList(Byte.valueOf(""12""),Byte.valueOf(""-13""))),PrimitiveBytes.testCases);
    PrimitiveBytes.iterations=0;
}"
"@Test
public void testPublishFailsForClosedConnection() throws JMSException {
    Connection tempConnection = factory.createConnection();
    Session tempSession = tempConnection.createSession(false, AUTO_ACKNOWLEDGE);
    TemporaryQueue queue = tempSession.createTemporaryQueue();
    Session session = connection.createSession(false, AUTO_ACKNOWLEDGE);
    connection.start();
    MessageProducer producer = session.createProducer(queue);
    producer.setDeliveryMode(NON_PERSISTENT);
    TextMessage message = session.createTextMessage(""First"");
    producer.send(message);
    tempConnection.close();
    try {
        message = session.createTextMessage(""Hello"");
        producer.send(message);
        fail(""Send should fail since temp destination should not exist anymore."");
    } catch (JMSException e) {
        assertTrue(""failed to throw an exception"", true);
    }
}"
"@Test
public void testLookupWithContinuation() throws Exception {
    namingStore.bind(new CompositeName(""comp/nested""), ""test"");
    final Reference reference = new Reference(String.class.getName(), new StringRefAddr(""nns"", ""comp""), TestObjectFactoryWithNameResolution.class.getName(), null);
    namingStore.bind(new CompositeName(""test""), reference);
    Object result = namingContext.lookup(new CompositeName(""test/nested""));
    assertEquals(""test"", result);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, Arrays.asList(new JndiPermission(""comp/nested"", ""lookup"")), namingContext, ""test/nested"");
    assertEquals(""test"", result);
}"
"@Test
public void testSystemMetadataRetrieval() throws Exception {
    appClient.deploy(DEFAULT, createAppJarFile(AllProgramsApp.class));
    Id.Stream streamId = Stream.from(DEFAULT, STREAM_NAME);
    Set<String> streamSystemTags = getTags(streamId, SYSTEM);
    Assert.assertEquals(ImmutableSet.of(STREAM_NAME), streamSystemTags);
    Map<String, String> streamSystemProperties = getProperties(streamId, SYSTEM);
    final String creationTime = ""creation-time"";
    String description = ""description"";
    String schema = ""schema"";
    String ttl = ""ttl"";
    Assert.assertTrue(""Expected creation time to exist but it does not"", streamSystemProperties.containsKey(creationTime));
    long createTime = Long.parseLong(streamSystemProperties.get(creationTime));
    Assert.assertTrue(""Stream create time should be within the last hour - "" + createTime, createTime > (System.currentTimeMillis() - TimeUnit.HOURS.toMillis(1)));
    Assert.assertEquals(ImmutableMap.of(schema, Schema.recordOf(""stringBody"", Field.of(""body"", Schema.of(STRING))).toString(), ttl, String.valueOf(Long.MAX_VALUE), description, ""test stream"", creationTime, String.valueOf(createTime)), streamSystemProperties);
    long newTtl = 100000L;
    streamClient.setStreamProperties(streamId, new StreamProperties(newTtl, null, null));
    streamSystemProperties = getProperties(streamId, SYSTEM);
    Assert.assertEquals(ImmutableMap.of(schema, Schema.recordOf(""stringBody"", Field.of(""body"", Schema.of(STRING))).toString(), ttl, String.valueOf(newTtl * 1000), description, ""test stream"", creationTime, String.valueOf(createTime)), streamSystemProperties);
    Set<MetadataRecord> streamSystemMetadata = getMetadata(streamId, SYSTEM);
    Assert.assertEquals(ImmutableSet.of(new MetadataRecord(streamId, MetadataScope.SYSTEM, streamSystemProperties, streamSystemTags)), streamSystemMetadata);
    Id.Stream.View view = View.from(streamId, ""view"");
    Schema viewSchema = Schema.recordOf(""record"", Field.of(""viewBody"", Schema.nullableOf(Schema.of(BYTES))));
    streamViewClient.createOrUpdate(view, new ViewSpecification(new FormatSpecification(""format"", viewSchema)));
    Set<String> viewSystemTags = getTags(view, SYSTEM);
    Assert.assertEquals(ImmutableSet.of(""view"", STREAM_NAME), viewSystemTags);
    Map<String, String> viewSystemProperties = getProperties(view, SYSTEM);
    Assert.assertEquals(viewSchema.toString(), viewSystemProperties.get(schema));
    ImmutableSet<String> viewUserTags = ImmutableSet.of(""viewTag"");
    addTags(view, viewUserTags);
    Assert.assertEquals(ImmutableSet.of(new MetadataRecord(view, MetadataScope.USER, ImmutableMap.<String, String>of(), viewUserTags), new MetadataRecord(view, MetadataScope.SYSTEM, viewSystemProperties, viewSystemTags)), getMetadata(view));
    Id.DatasetInstance datasetInstance = DatasetInstance.from(DEFAULT, DATASET_NAME);
    Set<String> dsSystemTags = getTags(datasetInstance, SYSTEM);
    Assert.assertEquals(ImmutableSet.of(DATASET_NAME, BATCH_TAG, EXPLORE_TAG), dsSystemTags);
    Map<String, String> dsSystemProperties = getProperties(datasetInstance, SYSTEM);
    Assert.assertTrue(""Expected creation time to exist but it does not"", dsSystemProperties.containsKey(creationTime));
    createTime = Long.parseLong(dsSystemProperties.get(creationTime));
    Assert.assertTrue(""Dataset create time should be within the last hour - "" + createTime, createTime > (System.currentTimeMillis() - TimeUnit.HOURS.toMillis(1)));
    Assert.assertEquals(ImmutableMap.of(""type"", KeyValueTable.class.getName(), description, ""test dataset"", creationTime, String.valueOf(createTime)), dsSystemProperties);
    datasetClient.update(datasetInstance, ImmutableMap.of(PROPERTY_TTL, ""100000""));
    dsSystemProperties = getProperties(datasetInstance, SYSTEM);
    Assert.assertEquals(ImmutableMap.of(""type"", KeyValueTable.class.getName(), description, ""test dataset"", ttl, ""100000"", creationTime, String.valueOf(createTime)), dsSystemProperties);
    Id.Artifact artifactId = getArtifactId();
    Assert.assertEquals(ImmutableSet.of(new MetadataRecord(artifactId, MetadataScope.SYSTEM, ImmutableMap.<String, String>of(), ImmutableSet.of(AllProgramsApp.class.getSimpleName()))), getMetadata(artifactId, SYSTEM));
    Id.Application app = Application.from(DEFAULT, NAME);
    Assert.assertEquals(ImmutableMap.builder().put((FLOW.getPrettyName() + MetadataDataset.KEYVALUE_SEPARATOR) + NoOpFlow.NAME, NAME).put((MAPREDUCE.getPrettyName() + MetadataDataset.KEYVALUE_SEPARATOR) + NoOpMR.NAME, NAME).put((MAPREDUCE.getPrettyName() + MetadataDataset.KEYVALUE_SEPARATOR) + NoOpMR2.NAME, NAME).put((SERVICE.getPrettyName() + MetadataDataset.KEYVALUE_SEPARATOR) + NoOpService.NAME, NAME).put((SPARK.getPrettyName() + MetadataDataset.KEYVALUE_SEPARATOR) + NoOpSpark.NAME, NAME).put((WORKER.getPrettyName() + MetadataDataset.KEYVALUE_SEPARATOR) + NoOpWorker.NAME, NAME).put((WORKFLOW.getPrettyName() + MetadataDataset.KEYVALUE_SEPARATOR) + NoOpWorkflow.NAME, NAME).put((""schedule"" + MetadataDataset.KEYVALUE_SEPARATOR) + AllProgramsApp.SCHEDULE_NAME, (AllProgramsApp.SCHEDULE_NAME + MetadataDataset.KEYVALUE_SEPARATOR) + AllProgramsApp.SCHEDULE_DESCRIPTION).build(), getProperties(app, SYSTEM));
    Assert.assertEquals(ImmutableSet.of(AllProgramsApp.class.getSimpleName(), NAME), getTags(app, SYSTEM));
    assertProgramSystemMetadata(Program.from(app, FLOW, NAME), ""Realtime"");
    assertProgramSystemMetadata(Program.from(app, WORKER, NAME), ""Realtime"");
    assertProgramSystemMetadata(Program.from(app, SERVICE, NAME), ""Realtime"");
    assertProgramSystemMetadata(Program.from(app, MAPREDUCE, NAME), ""Batch"");
    assertProgramSystemMetadata(Program.from(app, SPARK, NAME), ""Batch"");
    assertProgramSystemMetadata(Program.from(app, WORKFLOW, NAME), ""Batch"");
}"
"@Test public void testRepairSuccessfully() throws InterruptedException {
    Collection<LongTokenRange> ranges=new ArrayList<>();
    LongTokenRange range1=new LongTokenRange(1,2);
    LongTokenRange range2=new LongTokenRange(3,4);
    ranges.add(range1);
    ranges.add(range2);
    final RepairTask repairTask=new RepairTask.Builder().withJMXProxyFactory(jmxProxyFactory).withTableReference(myTableReference).withTokenRanges(ranges).withTableRepairMetrics(myTableRepairMetrics).withRepairHistory(repairHistory).withJobId(jobId).withReplicas(participants).build();
    CountDownLatch cdl=startRepair(repairTask,false);
    Notification notification=new Notification(""progress"",""repair:1"",0,getRepairMessage(range1));
    notification.setUserData(getNotificationData(RepairTask.ProgressEventType.PROGRESS.ordinal(),1,2));
    proxy.notify(notification);
    notification=new Notification(""progress"",""repair:1"",1,getRepairMessage(range2));
    notification.setUserData(getNotificationData(RepairTask.ProgressEventType.PROGRESS.ordinal(),2,2));
    proxy.notify(notification);
    notification=new Notification(""progress"",""repair:1"",2,""Done with repair"");
    notification.setUserData(getNotificationData(RepairTask.ProgressEventType.COMPLETE.ordinal(),2,2));
    proxy.notify(notification);
    cdl.await();
    assertThat(repairTask.getUnknownRanges()).isNull();
    assertThat(repairTask.getCompletedRanges()).containsExactlyInAnyOrderElementsOf(ranges);
    assertThat(proxy.myOptions.get(RepairOptions.RANGES_KEY)).isNotEmpty();
    verify(myTableRepairMetrics).repairTiming(eq(TABLE_REFERENCE),anyLong(),any(TimeUnit.class),eq(true));
    verify(repairSessions.get(range1)).start();
    verify(repairSessions.get(range2)).start();
    verify(repairSessions.get(range1)).finish(eq(RepairStatus.SUCCESS));
    verify(repairSessions.get(range2)).finish(eq(RepairStatus.SUCCESS));
}"
"@Test public void toXmlTest(){
    final JSONObject put=JSONUtil.createObj().set(""aaa"",""你好"").set(""键2"",""test"");
    final String s=JSONUtil.toXmlStr(put);
    Assert.assertThat(s,CoreMatchers.anyOf(CoreMatchers.is(""<aaa>你好</aaa><键2>test</键2>""),CoreMatchers.is(""<键2>test</键2><aaa>你好</aaa>"")));
}"
"@Test
public void manyParameters() throws Exception {
    assertThat(testResult(ManyParameters.class), isSuccessful());
    assertEquals(6, ManyParameters.iterations);
    assertEquals(asList(-1, -2, -4, -1, -2, -4), ManyParameters.firstTestCases);
    assertEquals(asList('r', 'r', 'r', 'y', 'y', 'y'), ManyParameters.secondTestCases);
}"
"@Test
public void testReadSkip() throws Exception {
    FileSystem fs = cluster.getFileSystem();
    long tStart = System.currentTimeMillis();
    bench.getConf().setLong(""test.io.skip.size"", 1);
    bench.randomReadTest(fs);
    long execTime = System.currentTimeMillis() - tStart;
    bench.analyzeResult(fs, TestType.TEST_TYPE_READ_SKIP, execTime);
}"
"@Test(expected=ClusterStateException.class) public void testReassignFailOnStopAndSync() throws IOException {
    ReceiverAdminClient receiverAdminClient=mockReceiverClientFailOnStopAndSync();
    coordinator=new Coordinator(metadataStore,receiverAdminClient);
    Map<Integer,List<Partition>> preAssignMap=metadataStore.getAssignmentsByCube(cubeName).getAssignments();
    Map<Integer,List<Partition>> newAssignMap=new LinkedHashMap<>();
    newAssignMap.put(1,Lists.newArrayList(p1,p2,p3));
    newAssignMap.put(2,Lists.newArrayList(p4,p5));
    newAssignMap.put(3,Lists.newArrayList(p6));
    CubeAssignment preAssigment=new CubeAssignment(cube.getName(),preAssignMap);
    CubeAssignment newAssigment=new CubeAssignment(cube.getName(),newAssignMap);
    try {
        coordinator.doReassign(cube,preAssigment,newAssigment);
    }
    catch (  ClusterStateException rune) {
        assertSame(ClusterStateException.ClusterState.ROLLBACK_FAILED,rune.getClusterState());
        assertSame(ClusterStateException.TransactionStep.STOP_AND_SNYC,rune.getTransactionStep());
        System.out.println(rune.getMessage());
        throw rune;
    }
}"
"@Test public void testToQueryUrl(){
    Map<String,String> parameters=new LinkedHashMap<String,String>();
    parameters.put(CommonParams.NAMESPACE_ID,""namespace"");
    parameters.put(CommonParams.SERVICE_NAME,""service"");
    parameters.put(CommonParams.GROUP_NAME,""group"");
    parameters.put(CommonParams.CLUSTER_NAME,null);
    parameters.put(""ip"",""1.1.1.1"");
    parameters.put(""port"",String.valueOf(9999));
    parameters.put(""weight"",String.valueOf(1.0));
    parameters.put(""ephemeral"",String.valueOf(true));
    String excepted=""namespaceId=namespace&serviceName=service&groupName=group&ip=1.1.1.1&port=9999&weight=1.0&ephemeral=true"";
    assertEquals(excepted,Query.newInstance().initParams(parameters).toQueryUrl());
}"
"@Test
public void testFlushThroughputTuning() throws Exception {
    Configuration conf = TEST_UTIL.getConfiguration();
    conf.set(StoreEngine.STORE_ENGINE_CLASS_KEY, DefaultStoreEngine.class.getName());
    conf.setLong(PressureAwareFlushThroughputController.HBASE_HSTORE_FLUSH_MAX_THROUGHPUT_UPPER_BOUND,20L * 1024 * 1024);
    conf.setLong(PressureAwareFlushThroughputController.HBASE_HSTORE_FLUSH_MAX_THROUGHPUT_LOWER_BOUND,10L * 1024 * 1024);
    conf.set(FlushThroughputControllerFactory.HBASE_FLUSH_THROUGHPUT_CONTROLLER_KEY,PressureAwareFlushThroughputController.class.getName());
    conf.setInt(PressureAwareFlushThroughputController.HBASE_HSTORE_FLUSH_THROUGHPUT_TUNE_PERIOD,3000);
    TEST_UTIL.startMiniCluster(1);
    Connection conn = ConnectionFactory.createConnection(conf);
    try {
        HTableDescriptor htd = new HTableDescriptor(tableName);
        htd.addFamily(new HColumnDescriptor(family));
        htd.setCompactionEnabled(false);
        TEST_UTIL.getHBaseAdmin().createTable(htd);
        TEST_UTIL.waitTableAvailable(tableName);
        HRegionServer regionServer = TEST_UTIL.getRSForFirstRegionInTable(tableName);
        PressureAwareFlushThroughputController throughputController = (PressureAwareFlushThroughputController) regionServer.getFlushThroughputController();
        for (Region region : regionServer.getOnlineRegions()) {
            region.flush(true);
        }
        assertEquals(0.0, regionServer.getFlushPressure(), EPSILON);
        Thread.sleep(5000);
        assertEquals(10L * 1024 * 1024, throughputController.getMaxThroughput(), EPSILON);
        Table table = conn.getTable(tableName);
        Random rand = new Random();
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                byte[] value = new byte[256 * 1024];
                rand.nextBytes(value);
                table.put(new Put(Bytes.toBytes(i * 10 + j)).addColumn(family, qualifier, value));
            }
        }
        Thread.sleep(5000);
        double expectedThroughPut = 10L * 1024 * 1024 * (1 + regionServer.getFlushPressure());
        assertEquals(expectedThroughPut, throughputController.getMaxThroughput(), EPSILON);
        conf.set(FlushThroughputControllerFactory.HBASE_FLUSH_THROUGHPUT_CONTROLLER_KEY,NoLimitThroughputController.class.getName());
        regionServer.onConfigurationChange(conf);
        assertTrue(throughputController.isStopped());
        assertTrue(regionServer.getFlushThroughputController() instanceof NoLimitThroughputController);
    } finally {
        conn.close();
        TEST_UTIL.shutdownMiniCluster();
    }"
"@Test
public void servicesCanCallOtherServices() throws InterruptedException {
    ReactorGreeterGrpc.ReactorGreeterStub stub = ReactorGreeterGrpc.newReactorStub(channel);
    Mono<String> chain =
    Mono.just(request(""X"")).compose(stub::sayHello).map(ChainedCallIntegrationTest::bridge).doOnSuccess(System.out::println).as(stub::sayHelloRespStream).map(ChainedCallIntegrationTest::bridge).doOnNext(System.out::println).compose(stub::sayHelloBothStream).map(ChainedCallIntegrationTest::bridge).doOnNext(System.out::println).as(stub::sayHelloReqStream).map(ChainedCallIntegrationTest::bridge).doOnSuccess(System.out::println).compose(stub::sayHello).map(HelloResponse::getMessage).doOnSuccess(System.out::println);
    StepVerifier.create(chain).expectNext(""[<{[X]}> :: </[X]/> :: <\\[X]\\> :: <([X])>]"").expectComplete().verify(Duration.ofSeconds(2));
}"
"@Test public void testFormatMultiple(){
    HashMap<String,String> params=new HashMap<String,String>();
    params.put(""a"",""b"");
    params.put(""a"",""b"");
    params.put(""b"",""c"");
    String s=KeyValueFormatter.format(params,true);
    Assert.assertTrue((""a=b&b=c"").equals(s) || (""b=c&a=b"").equals(s));
}"
"@Test public void whenConstrained() throws Exception {
    assertThat(testResult(EnumWithConstraint.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),EnumWithConstraint.values.size());
    assertThat(EnumWithConstraint.values,not(hasItem(E3)));
    EnumWithConstraint.values.clear();
}"
"@Test public void wrapperBooleans() throws Exception {
    assertThat(testResult(WrapperBooleans.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperBooleans.iterations);
    WrapperBooleans.iterations=0;
}"
"@Test public void serialize(){
    final LookupCacheKey cacheKey=LookupCacheKey.createFromJSON(""prefix"",""key"");
    final JsonNode node=objectMapper.convertValue(cacheKey,JsonNode.class);
    assertThat(node.isObject()).isTrue();
    assertThat(node.fieldNames()).containsExactlyInAnyOrder(""prefix"",""key"");
    assertThat(node.path(""prefix"").isTextual()).isTrue();
    assertThat(node.path(""prefix"").asText()).isEqualTo(""prefix"");
    assertThat(node.path(""key"").isTextual()).isTrue();
    assertThat(node.path(""key"").asText()).isEqualTo(""key"");
}"
"@Test public void wrapperFloats() throws Exception {
    assertThat(testResult(WrapperFloats.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperFloats.iterations);
    WrapperFloats.iterations=0;
}"
"@Test
protected void assertMessageValid(int index, Message message) throws JMSException {
    assertEquals(""localhost"", message.getStringProperty(""BrokerPath""));
    ActiveMQMessage amqMsg = ((ActiveMQMessage) (message));
    if (index == 7) {
        assertEquals(2000, amqMsg.getExpiration() - amqMsg.getTimestamp());
    } else if (index == 9) {
        assertEquals(60000, amqMsg.getExpiration() - amqMsg.getTimestamp());
    } else {
        assertEquals(1000, amqMsg.getExpiration() - amqMsg.getTimestamp());
    }
    super.assertMessageValid(index, message);
}"
"@Test public void testCanBeNull() throws Exception {
    Field[] fields=CanBeNull.class.getDeclaredFields();
    Arrays.sort(fields,new Comparator<Field>(){
        public int compare(    Field a,    Field b){
            return b.getName().compareTo(a.getName());
        }
    }
    );
    assertTrue(fields.length >= 2);
    Field field=fields[1];
    FieldType fieldType=FieldType.createFieldType(databaseType,CanBeNull.class.getSimpleName(),field,CanBeNull.class);
    assertTrue(fieldType.isCanBeNull());
    field=fields[0];
    fieldType=FieldType.createFieldType(databaseType,CanBeNull.class.getSimpleName(),field,CanBeNull.class);
    assertFalse(fieldType.isCanBeNull());
}"
"@Test public void test_create() throws Exception {
    String sql=""CREATE RESOURCE GROUP sql_thread TYPE = USER VCPU = 1,3 THREAD_PRIORITY = -20"";
    List<SQLStatement> stmtList=SQLUtils.toStatementList(sql,JdbcConstants.MYSQL);
    SQLStatement stmt=stmtList.get(0);
    MySqlSchemaStatVisitor visitor=new MySqlSchemaStatVisitor();
    stmt.accept(visitor);
    String output=SQLUtils.toMySqlString(stmt);
    Set<String> allPossibleRes=generateAllPossibleRes(""CREATE RESOURCE GROUP sql_thread "","""");
    assertTrue(allPossibleRes.contains(output));
}"
"@Test public void wrapperLongs(){
    assertThat(testResult(WrapperLongs.class),isSuccessful());
    assertEquals(3,WrapperLongs.iterations);
    assertEquals(new HashSet<>(asList(10L,11L,12L)),WrapperLongs.testCases);
    WrapperLongs.iterations=0;
}"
"@Test
public void testZkNodeChangesUpdateFeatureState() throws Exception {
    setupTestWithEmptyDatastore();
    FeatureState savedFeatureState = new FeatureState(TestFeature.FEATURE);
    savedFeatureState.setStrategyId(ID);
    savedFeatureState.setParameter(PARAM_USERS, ""user1, user2, user3"");
    stateRepository.setFeatureState(savedFeatureState);
    FeatureState loadedFeatureState = stateRepository.getFeatureState(TestFeature.FEATURE);
    assertThat(reflectionEquals(savedFeatureState, loadedFeatureState), is(true));
    FeatureStateStorageWrapper externallySetStateWrapper = new FeatureStateStorageWrapper();
    FeatureState externallySetState = new FeatureState(TestFeature.FEATURE);
    ObjectMapper objectMapper = new ObjectMapper();
    final String json = objectMapper.writeValueAsString(externallySetStateWrapper);
    final CountDownLatch latch = new CountDownLatch(1);
    new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                serverClientPair.client.setData().forPath(TEST_ZNODE + ""/FEATURE"", json.getBytes(""UTF-8""));
                latch.countDown();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }).start();
    latch.await(2, TimeUnit.SECONDS);
    Thread.sleep(25);
    loadedFeatureState = stateRepository.getFeatureState(TestFeature.FEATURE);
    assertThat(reflectionEquals(externallySetState, loadedFeatureState), is(true));
}"
"@Test public void explicitConversion() throws Exception {
    assertThat(testResult(ExplicitConversion.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ExplicitConversion.iterations);
    ExplicitConversion.iterations=0;
}"
"@Test
public void doTestLogicalNodesConcurrentDFOMans(final int threads,
final int events, int timeout) throws IOException, InterruptedException,
FlumeSpecException {
    BenchmarkHarness.setupLocalWriteDir();
    FlumeMaster master = new FlumeMaster();
    FlumeNode node = new FlumeNode(new DirectMasterRPC(master), false, false);
    final Reportable[] dfos = new Reportable[threads];
    for (int i = 0; i < threads; i++) {
        String name = ""test."" + i;
        String report = ""report."" + i;
        int count = events + i;
        String src = ""asciisynth("" + count + "",100)"";
        String snk = ""{ diskFailover => counter(\"""" + report + ""\"") } "";
        node.getLogicalNodeManager().testingSpawn(name, src, snk);
        dfos[i] = node.getLogicalNodeManager().get(name);
    }
    waitForEmptyDFOs(node, timeout);
    boolean success = true;
    for (int i = 0; i < threads; i++) {
        LOG.info(dfos[i].getReport());
    }
    for (int i = 0; i < threads; i++) {
        CounterSink cnt = (CounterSink) ReportManager.get().getReportable(
        ""report."" + i);
        LOG.info(i + "" expected "" + (events + i) + "" and got "" + cnt.getCount());
        success &= ((events + i) == cnt.getCount());
        assertEquals(events + i, cnt.getCount());
    }
    assertTrue(""Counts did not line up"", success);
    BenchmarkHarness.cleanupLocalWriteDir();
}"
"@Test public void shouldRespectTrialCountIfSpecified(){
    assertThat(testResult(ForSpecifiedNumberOfValues.class),isSuccessful());
    assertEquals(5,ForSpecifiedNumberOfValues.iterations);
    ForSpecifiedNumberOfValues.iterations=0;
}"
"@Test public void intArray(){
    final WithArrays wa=new WithArrays();
    wa.intArray=new int[]{1,2};
    final String exp=getClassPrefix(wa) + ""["" + BR+ ""  boolArray=<null>,""+ BR+ ""  charArray=<null>,""+ BR+ ""  doubleArray=<null>,""+ BR+ ""  intArray={""+ BR+ ""    1,""+ BR+ ""    2""+ BR+ ""  },""+ BR+ ""  longArray=<null>,""+ BR+ ""  stringArray=<null>""+ BR+ ""]"";
    assertEquals(exp,toString(wa));
}"
"@Test
public void testProcessAction_ok() {
    final Mock mockResponse = mock(ActionResponse.class);
    PortletMode mode = PortletMode.VIEW;
    Map<String, String> initParams = new HashMap<String, String>();
    initParams.put(""viewNamespace"", ""/view"");
    Map<String, String[]> requestParams = new HashMap<String, String[]>();
    requestParams.put(ACTION_PARAM, new String[] { ""/view/testAction"" });
    requestParams.put(MODE_PARAM, new String[] { mode.toString() });
    initParams.put(StrutsConstants.STRUTS_ALWAYS_SELECT_FULL_NAMESPACE,
    ""true"");
    initPortletConfig(initParams, new HashMap<String, Object>());
    initRequest(requestParams, new HashMap<String, Object>(),
    new HashMap<String, Object>(), PortletMode.VIEW,
    WindowState.NORMAL, true, null);
    setupActionFactory(""/view"", ""testAction"", ""success"",
    EasyMock.createNiceMock(ValueStack.class));
    try {
        dispatcher
        .setActionProxyFactory((ActionProxyFactory) mockActionFactory
        .proxy());
        dispatcher.init((PortletConfig) mockConfig.proxy());
        dispatcher.processAction((ActionRequest) mockRequest.proxy(),
        (ActionResponse) mockResponse.proxy());
    } catch (Exception e) {
        e.printStackTrace();
        fail(""Error occured"");
    }
}"
"@Test
public void testInitFirstVerifyCallBacks() throws Exception {
    DefaultMetricsSystem.shutdown();
    new ConfigBuilder().add(""*.period"", 8).add(""test.sink.test.class"", TestSink.class.getName()).add(""test.*.source.filter.exclude"", ""s0"").add(""test.source.s1.metric.filter.exclude"", ""X*"").add(""test.sink.sink1.metric.filter.exclude"", ""Y*"").add(""test.sink.sink2.metric.filter.exclude"", ""Y*"").save(TestMetricsConfig.getTestFilename(""hadoop-metrics2-test""));
    MetricsSystemImpl ms = new MetricsSystemImpl(""Test"");
    ms.start();
    ms.register(""s0"", ""s0 desc"", new TestSource(""s0rec""));
    TestSource s1 = ms.register(""s1"", ""s1 desc"", new TestSource(""s1rec""));
    s1.c1.incr();
    s1.xxx.incr();
    s1.g1.set(2);
    s1.yyy.incr(2);
    s1.s1.add(0);
    MetricsSink sink1 = mock(MetricsSink.class);
    MetricsSink sink2 = mock(MetricsSink.class);
    ms.registerSink(""sink1"", ""sink1 desc"", sink1);
    ms.registerSink(""sink2"", ""sink2 desc"", sink2);
    ms.publishMetricsNow();
    try {
        verify(sink1, timeout(200).times(2)).putMetrics(r1.capture());
        verify(sink2, timeout(200).times(2)).putMetrics(r2.capture());
    } finally {
        ms.stop();
        ms.shutdown();
    }
    List<MetricsRecord> mr1 = r1.getAllValues();
    List<MetricsRecord> mr2 = r2.getAllValues();
    checkMetricsRecords(mr1);
    assertEquals(""output"", mr1, mr2);
}"
"@Test
public void healthCheckTest() throws Exception {
    RssGetShuffleAssignmentsRequest request = new RssGetShuffleAssignmentsRequest(""1"", 1, 1, 1, 1, Sets.newHashSet(SHUFFLE_SERVER_VERSION));
    Uninterruptibles.sleepUninterruptibly(3, TimeUnit.SECONDS);
    assertEquals(2, coordinatorClient.getShuffleServerList().getServersCount());
    List<ServerNode> nodes = coordinators.get(0).getClusterManager().getServerList(Sets.newHashSet(SHUFFLE_SERVER_VERSION));
    assertEquals(2, coordinatorClient.getShuffleServerList().getServersCount());
    assertEquals(2, nodes.size());
    RssGetShuffleAssignmentsResponse response = coordinatorClient.getShuffleAssignments(request);
    assertFalse(response.getPartitionToServers().isEmpty());
    for (ServerNode node : nodes) {
        assertTrue(node.isHealthy());
    }
    byte[] bytes = new byte[writeDataSize];
    new Random().nextBytes(bytes);
    try (final FileOutputStream out = new FileOutputStream(tempDataFile)) {
        out.write(bytes);
    }
    Uninterruptibles.sleepUninterruptibly(3, TimeUnit.SECONDS);
    CoordinatorTestUtils.waitForRegister(coordinatorClient, 2);
    nodes = coordinators.get(0).getClusterManager().getServerList(Sets.newHashSet(SHUFFLE_SERVER_VERSION));
    for (ServerNode node : nodes) {
        assertFalse(node.isHealthy());
    }
    assertEquals(0, nodes.size());
    response = coordinatorClient.getShuffleAssignments(request);
    assertEquals(INTERNAL_ERROR, response.getStatusCode());
    tempDataFile.delete();
    int i = 0;
    do {
        Uninterruptibles.sleepUninterruptibly(3, TimeUnit.SECONDS);
        nodes = coordinators.get(0).getClusterManager().getServerList(Sets.newHashSet(SHUFFLE_SERVER_VERSION));
        i++;
        if (i == 10) {
            fail();
        }
    } while (nodes.size() != 2 );
    for (ServerNode node : nodes) {
        assertTrue(node.isHealthy());
    }
    assertEquals(2, nodes.size());
    response = coordinatorClient.getShuffleAssignments(request);
    assertFalse(response.getPartitionToServers().isEmpty());
}"
"@Test public void explicitConversion(){
    assertThat(testResult(ExplicitConversion.class),isSuccessful());
    assertEquals(2,ExplicitConversion.iterations);
    assertEquals(new HashSet<>(asList(LocalDate.of(2017,1,1),LocalDate.of(2001,12,25))),ExplicitConversion.testCases);
    ExplicitConversion.iterations=0;
    ExplicitConversion.testCases.clear();
}"
"@Test
public void testShortCircuited() {
    HystrixCommandKey key = Factory.asKey(""CMD-Health-G"");
    stream = HealthCountsStream.getInstance(key, 10, 100);
    final CountDownLatch latch = new CountDownLatch(1);
    stream.observe().take(10).subscribe(getSubscriber(latch));
    CommandStreamTest.Command failure1 = Command.from(groupKey, key, FAILURE, 20);
    CommandStreamTest.Command failure2 = Command.from(groupKey, key, FAILURE, 20);
    CommandStreamTest.Command failure3 = Command.from(groupKey, key, FAILURE, 20);
    CommandStreamTest.Command shortCircuit1 = Command.from(groupKey, key, SUCCESS);
    CommandStreamTest.Command shortCircuit2 = Command.from(groupKey, key, SUCCESS);
    failure1.observe();
    failure2.observe();
    failure3.observe();
    try {
        Thread.sleep(100);
    } catch (InterruptedException ie) {
        fail(ie.getMessage());
    }
    shortCircuit1.observe();
    shortCircuit2.observe();
    try {
        assertTrue(latch.await(10000, TimeUnit.MILLISECONDS));
    } catch (InterruptedException ex) {
        fail(""Interrupted ex"");
    }
    assertTrue(shortCircuit1.isResponseShortCircuited());
    assertTrue(shortCircuit2.isResponseShortCircuited());
    System.out.println(""ReqLog : "" + HystrixRequestLog.getCurrentRequest().getExecutedCommandsAsString());
    assertEquals(3L, stream.getLatest().getErrorCount());
    assertEquals(3L, stream.getLatest().getTotalRequests());
}"
"@Test public void shouldFeedADefaultNumberOfValuesToAProperty() throws Exception {
    assertThat(testResult(ForDefaultNumberOfValues.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ForDefaultNumberOfValues.iterations);
    ForDefaultNumberOfValues.iterations=0;
}"
"@Test
public void testGettersAfterConnected() throws InterruptedException {
    prepareLooper();
    final int state = MediaPlayerBase.PLAYER_STATE_PLAYING;
    final long position = 150000;
    final long bufferedPosition = 900000;
    final float speed = 0.5f;
    mPlayer.mLastPlayerState = state;
    mPlayer.mCurrentPosition = position;
    mPlayer.mBufferedPosition = bufferedPosition;
    mPlayer.mPlaybackSpeed = speed;
    long time = System.currentTimeMillis();
    MediaController2 controller = createController(mSession.getToken());
    assertEquals(state, controller.getPlayerState());
    assertEquals(bufferedPosition, controller.getBufferedPosition());
    assertEquals(speed, controller.getPlaybackSpeed());
    long elapsedTime = System.currentTimeMillis() - time;
    final long tolerance = 10;
    assertEquals(position + speed * elapsedTime, controller.getCurrentPosition(), tolerance);
}"
"@Test
public void testInterruptsOnLFSRead() throws Exception {
    final Ignite ignite = startGrid();
    ignite.active(true);
    final int valLen = 8192;
    final byte[] payload = new byte[valLen];
    final int maxKey = 10000;
    Thread[] workers = new Thread[THREADS_CNT];
    final IgniteCache<Object, Object> cache = ignite.cache(CACHE_NAME);
    for (int i = 0; i < maxKey; i++) {
        cache.put(i, payload);
    }
    final AtomicReference<Throwable> fail = new AtomicReference<>();
    Runnable clo = new Runnable() {
        @Override
        public void run() {
            cache.get(ThreadLocalRandom.current().nextInt(maxKey / 5));
        }
    };
    for (int i = 0; i < workers.length; i++) {
        workers[i] = new Thread(clo);
        workers[i].setName(""reader-"" + i);
        workers[i].setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
            @Override
            public void uncaughtException(Thread t, Throwable e) {
                fail.compareAndSet(null, e);
            }
        });
    }
    for (Thread worker : workers) {
        worker.start();
    }
    for (int i = 0; i < (workers.length / 2); i++) {
        workers[i].interrupt();
    }
    Thread.sleep(3000);
    stop = true;
    for (Thread worker : workers) {
        worker.join();
    }
    Throwable t = fail.get();
    assertNull(t);
    int verifiedKeys = 0;
    for (int i = 0; i < maxKey; i++) {
        byte[] val = ((byte[]) (cache.get(i)));
        if (val != null) {
            assertEquals(""Illegal length"", valLen, val.length);
            verifiedKeys++;
        }
    }
}"
"@Test public void favorValueOf(){
    assertThat(testResult(FavorValueOf.class),isSuccessful());
    assertEquals(2,FavorValueOf.iterations);
    assertEquals(new HashSet<>(asList(FavorValueOf.Target.valueOf(""a""),FavorValueOf.Target.valueOf(""b""))),FavorValueOf.testCases);
    FavorValueOf.iterations=0;
    FavorValueOf.testCases.clear();
}"
"public void test_for_multimap() throws Exception {
    HashMultimap map=HashMultimap.create();
    map.put(""name"",""a"");
    map.put(""name"",""b"");
    String json=JSON.toJSONString(map);
    assertTrue(json.equals(""{\""name\"":[\""a\"",\""b\""]}"") || json.equals(""{\""name\"":[\""b\"",\""a\""]}""));
}"
"@Test
public void testWritesWhileScanning() throws IOException, InterruptedException {
    byte[] tableName = Bytes.toBytes(""testWritesWhileScanning"");
    int testCount = 100;
    int numRows = 1;
    int numFamilies = 10;
    int numQualifiers = 100;
    int flushInterval = 7;
    int compactInterval = 5 * flushInterval;
    byte[][] families = new byte[numFamilies][];
    for (int i = 0; i < numFamilies; i++) {
        families[i] = Bytes.toBytes(""family"" + i);
    }
    byte[][] qualifiers = new byte[numQualifiers][];
    for (int i = 0; i < numQualifiers; i++) {
        qualifiers[i] = Bytes.toBytes(""qual"" + i);
    }
    String method = ""testWritesWhileScanning"";
    initHRegion(tableName, method, families);
    PutThread putThread = new PutThread(numRows, families, qualifiers);
    putThread.start();
    FlushThread flushThread = new FlushThread();
    flushThread.start();
    Scan scan = new Scan(Bytes.toBytes(""row0""), Bytes.toBytes(""row1""));
    int expectedCount = numFamilies * numQualifiers;
    List<KeyValue> res = new ArrayList<KeyValue>();
    long prevTimestamp = 0L;
    for (int i = 0; i < testCount; i++) {
        if ((i != 0) && ((i % compactInterval) == 0)) {
            region.compactStores(true);
        }
        if ((i != 0) && ((i % flushInterval) == 0)) {
            flushThread.flush();
        }
        boolean previousEmpty = res.isEmpty();
        res.clear();
        InternalScanner scanner = region.getScanner(scan);
        while (scanner.next(res));
        if (((!res.isEmpty()) || (!previousEmpty)) || (i > compactInterval)) {
            assertEquals(""i="" + i, expectedCount, res.size());
            long timestamp = res.get(0).getTimestamp();
            assertTrue(((""Timestamps were broke: "" + timestamp) + "" prev: "") + prevTimestamp, timestamp >= prevTimestamp);
            prevTimestamp = timestamp;
        }
    }
    putThread.done();
    region.flushcache();
    putThread.join();
    putThread.checkNoError();
    flushThread.done();
    flushThread.join();
    flushThread.checkNoError();
}"
"public void test_8() throws Exception {
    JSON.defaultTimeZone=TimeZone.getTimeZone(""Asia/Shanghai"");
    DefaultJSONParser parser=new DefaultJSONParser(""\""2011-01-09T13:49:53.254\"""");
    parser.config(Feature.AllowISO8601DateFormat,true);
    Object value=parser.parse();
    Assert.assertEquals(new Date(1294552193254L),value);
}"
"@Test
public void testGetContextTypeLoader() throws Exception {
    SchemaTypeLoader stl = XmlBeans.getContextTypeLoader();
    if (stl == null) {
        fail(""getContextTypeLoader failed"");
    }
    Vector vThreads = new Vector();
    Set STLset = Collections.synchronizedSortedSet(new TreeSet());
    for (int i = 0; i < 10; i++) {
        Thread t = new BogusThread(STLset);
        vThreads.add(t);
        t.start();
    }
    for (int i = 0; i < 10; i++) {
        ((BogusThread) (vThreads.elementAt(i))).join();
    }
    assertEquals(10, STLset.size());
}"
"@Test
public void testRegionCachePreWarm() throws Exception {
    final byte[] TABLENAME = Bytes.toBytes(""testCachePrewarm"");
    Configuration conf = TEST_UTIL.getConfiguration();
    TEST_UTIL.createTable(TABLENAME, FAMILY);
    HTable.setRegionCachePrefetch(conf, TABLENAME, false);
    assertFalse(""The table is disabled for region cache prefetch"", HTable.getRegionCachePrefetch(conf, TABLENAME));
    HTable table = new HTable(conf, TABLENAME);
    TEST_UTIL.createMultiRegions(table, FAMILY);
    Get g = new Get(Bytes.toBytes(""aaa""));
    table.get(g);
    assertEquals(""Number of cached region is incorrect "", 1, HConnectionManager.getCachedRegionCount(conf, TABLENAME));
    HTable.setRegionCachePrefetch(conf, TABLENAME, true);
    assertTrue(""The table is enabled for region cache prefetch"", HTable.getRegionCachePrefetch(conf, TABLENAME));
    HTable.setRegionCachePrefetch(conf, TABLENAME, false);
    assertFalse(""The table is disabled for region cache prefetch"", HTable.getRegionCachePrefetch(conf, TABLENAME));
    HTable.setRegionCachePrefetch(conf, TABLENAME, true);
    assertTrue(""The table is enabled for region cache prefetch"", HTable.getRegionCachePrefetch(conf, TABLENAME));
    table.getConnection().clearRegionCache();
    assertEquals(""Number of cached region is incorrect "", 0, HConnectionManager.getCachedRegionCount(conf, TABLENAME));
    Get g2 = new Get(Bytes.toBytes(""bbb""));
    table.get(g2);
    int prefetchRegionNumber = conf.getInt(""hbase.client.prefetch.limit"", 10) / 2;
    LOG.info(""Testing how many regions cached"");
    assertTrue(prefetchRegionNumber < HConnectionManager.getCachedRegionCount(conf, TABLENAME));
    table.getConnection().clearRegionCache();
    Get g3 = new Get(Bytes.toBytes(""abc""));
    table.get(g3);
    assertTrue(prefetchRegionNumber < HConnectionManager.getCachedRegionCount(conf, TABLENAME));
}"
"@Test
public void testClientConnecting() throws Exception {
    PipelineOptions options = PipelineOptionsFactory.create();
    Endpoints.ApiServiceDescriptor descriptor = findOpenPort();
    BeamFnControlService service =
    new BeamFnControlService(
    descriptor,
    ServerStreamObserverFactory.fromOptions(options)::from,
    GrpcContextHeaderAccessorProvider.getHeaderAccessor());
    Server server =
    ServerFactory.fromOptions(options).create(descriptor, ImmutableList.of(service));
    String url = service.getApiServiceDescriptor().getUrl();
    BeamFnControlGrpc.BeamFnControlStub clientStub =
    BeamFnControlGrpc.newStub(ManagedChannelBuilder.forTarget(url).usePlaintext(true).build());
    clientStub.control(requestObserver);
    try (FnApiControlClient client = service.get()) {
        assertNotNull(client);
    }
    server.shutdown();
    server.awaitTermination(1, TimeUnit.SECONDS);
    server.shutdownNow();
    verify(requestObserver).onCompleted();
    verifyNoMoreInteractions(requestObserver);
}"
"@Test
public void test_date() throws Exception {
    Date date1 = JSON.parseObject(""{\""gmtCreate\"":\""2018-09-12\""}"", VO.class).getGmtCreate();
    assertNotNull(date1);
    Date date2 = JSON.parseObject(""{\""gmtCreate\"":\""2018-09-12T15:10:19+00:00\""}"", VO.class).getGmtCreate();
    Date date3 = JSON.parseObject(""{\""gmtCreate\"":\""2018-09-12T15:10:19Z\""}"", VO.class).getGmtCreate();
    Date date4 = JSON.parseObject(""{\""gmtCreate\"":\""20180912T151019Z\""}"", VO.class).getGmtCreate();
    Date date5 = JSON.parseObject(""{\""gmtCreate\"":\""2018-09-12T15:10:19Z\""}"", VO.class).getGmtCreate();
    Date date6 = JSON.parseObject(""{\""gmtCreate\"":\""20180912\""}"", VO.class).getGmtCreate();
    long delta_2_1 = date2.getTime() - date1.getTime();
    assertEquals(83419000, delta_2_1);
    long delta_3_1 = date3.getTime() - date1.getTime();
    assertEquals(83419000, delta_3_1);
    long delta_4_3 = date4.getTime() - date3.getTime();
    assertEquals(0, delta_4_3);
    long delta_5_4 = date5.getTime() - date4.getTime();
    assertEquals(0, delta_5_4);
    long delta_6_1 = date6.getTime() - date1.getTime();
    assertEquals(0, delta_6_1);
}"
"@Test
public void testSimpleClassloading() throws Exception {
    final AtomicInteger count = new AtomicInteger(0);
    final List<Event> finishedEvents = Collections.synchronizedList(new ArrayList<Event>());
    final ServiceRegistration jcReg = this.registerJobConsumer(TOPIC, new JobConsumer() {
        @Override
        public JobResult process(Job job) {
            count.incrementAndGet();
            return JobResult.OK;
        }
    });
    final ServiceRegistration ehReg = this.registerEventHandler(TOPIC_JOB_FINISHED, new EventHandler() {
        @Override
        public void handleEvent(Event event) {
            finishedEvents.add(event);
        }
    });
    try {
        final JobManager jobManager = this.getJobManager();
        final List<String> list = new ArrayList<String>();
        list.add(""1"");
        list.add(""2"");
        final EventPropertiesMap map = new EventPropertiesMap();
        map.put(""a"", ""a1"");
        map.put(""b"", ""b2"");
        final Map<String, Object> props = new HashMap<String, Object>();
        props.put(""string"", ""Hello"");
        props.put(""int"", new Integer(5));
        props.put(""long"", new Long(7));
        props.put(""list"", list);
        props.put(""map"", map);
        jobManager.addJob(TOPIC, null, props);
        while (finishedEvents.size() < 1) {
            Thread.sleep(100);
        }
        Thread.sleep(100);
        assertEquals(0, jobManager.getStatistics().getNumberOfQueuedJobs());
        assertEquals(1, count.get());
        assertEquals(0, jobManager.findJobs(ALL, TOPIC, -1, ((Map<String, Object>[]) (null))).size());
        final String jobTopic = ((String) (finishedEvents.get(0).getProperty(NOTIFICATION_PROPERTY_JOB_TOPIC)));
        assertNotNull(jobTopic);
        assertEquals(""Hello"", finishedEvents.get(0).getProperty(""string""));
        assertEquals(new Integer(5), Integer.valueOf(finishedEvents.get(0).getProperty(""int"").toString()));
        assertEquals(new Long(7), Long.valueOf(finishedEvents.get(0).getProperty(""long"").toString()));
        assertEquals(list, finishedEvents.get(0).getProperty(""list""));
        assertEquals(map, finishedEvents.get(0).getProperty(""map""));
    } finally {
        jcReg.unregister();
        ehReg.unregister();
    }
}"
"@Test
public void testIsExpiredTimestampYesterday() {
    LocalDateTime yesterday = LocalDateTime.now().minusDays(1);
    String timestamp = getTimestampFormatter().format(yesterday);
    assertTrue(MavenMetadata.isExpiredTimestamp(timestamp), ""Timestamp should be stale: "" + timestamp);
}"
"@Test
public void testReadRandom() throws Exception {
    FileSystem fs = cluster.getFileSystem();
    long tStart = System.currentTimeMillis();
    bench.getConf().setLong(""test.io.skip.size"", 0);
    bench.randomReadTest(fs);
    long execTime = System.currentTimeMillis() - tStart;
    bench.analyzeResult(fs, TestType.TEST_TYPE_READ_RANDOM, execTime);
}"
"@Test
public void testListDetail() throws RemotingException {
    String result = port.telnet(null, ""-l"");
    assertEquals(""dubbo://127.0.0.1:20887"", result);
}"
"@Test
public void testListAllPort() throws RemotingException {
    String result = port.telnet(null, """");
    assertEquals(""20887"", result);
}"
"@Test public void testLogicDeleteSql(){
    String wherePKColumns=SqlHelper.wherePKColumns(User.class);
    Assert.assertEquals(""<where> AND id = #{id} AND is_valid = 1</where>"",wherePKColumns);
    String whereAllIfColumns=SqlHelper.whereAllIfColumns(User.class,false);
    Assert.assertEquals(""<where><if test=\""id != null\""> AND id = #{id}</if><if test=\""username != null\""> AND username = #{username}</if> AND is_valid = 1</where>"",whereAllIfColumns);
    String isLogicDeletedColumn=SqlHelper.whereLogicDelete(User.class,true);
    Assert.assertEquals("" AND is_valid = 0"",isLogicDeletedColumn);
    String notLogicDeletedColumn=SqlHelper.whereLogicDelete(User.class,false);
    Assert.assertEquals("" AND is_valid = 1"",notLogicDeletedColumn);
    String updateSetColumns=SqlHelper.updateSetColumns(User.class,null,false,false);
    Assert.assertEquals(""<set>is_valid = 1,username = #{username},</set>"",updateSetColumns);
}"
"@Test
public void testRecoverExpiredMessages() throws Exception {
    ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory( ) ;
    connection = factory.createConnection();
    connection.start();
    session = connection.createSession(false, AUTO_ACKNOWLEDGE);
    producer = session.createProducer(destination);
    producer.setTimeToLive(2000);
    producer.setDeliveryMode(PERSISTENT);
    Thread producingThread = new Thread(""Producing Thread"") {
        public void run() {
            try {
                int i = 0;
                while ((i++) < 1000) {
                    Message message = (useTextMessage) ? session.createTextMessage(""test"") : session.createObjectMessage(""test"");
                    producer.send(message);
                }
                producer.close();
            } catch (Throwable ex) {
                ex.printStackTrace();
            }
        }
    };
    producingThread.start();
    producingThread.join();
    DestinationViewMBean view = createView(destination);
    LOG.info(((((((((((""Stats: size: "" + view.getQueueSize()) + "", enqueues: "") + view.getDequeueCount()) + "", dequeues: "") + view.getDequeueCount()) + "", dispatched: "") + view.getDispatchCount()) + "", inflight: "") + view.getInFlightCount()) + "", expiries: "") + view.getExpiredCount());
    LOG.info(""stopping broker"");
    broker.stop();
    broker.waitUntilStopped();
    Thread.sleep(5000);
    LOG.info(""recovering broker"");
    final boolean deleteAllMessages = false;
    broker = createBroker(deleteAllMessages, 5000);
    Wait.waitFor(new Wait.Condition() {
        public boolean isSatisified() throws Exception {
            boolean result = false;
            try {
                DestinationViewMBean view = createView(destination);
                LOG.info(((((((((((""Stats: size: "" + view.getQueueSize()) + "", enqueues: "") + view.getDequeueCount()) + "", dequeues: "") + view.getDequeueCount()) + "", dispatched: "") + view.getDispatchCount()) + "", inflight: "") + view.getInFlightCount()) + "", expiries: "") + view.getExpiredCount());
                result = view.getQueueSize() == 0;
            } catch (Exception notFoundExpectedOnSlowMachines) {
            }
            return result;
        }
    });
    view = createView(destination);
    assertEquals(""Expect empty queue, QueueSize: "", 0, view.getQueueSize());
    assertEquals(""all dequeues were expired"", view.getDequeueCount(), view.getExpiredCount());
}"
"@Test public void primitiveChars() throws Exception {
    assertThat(testResult(PrimitiveChars.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveChars.iterations);
    assertEquals(new HashSet<>(asList('Z','z')),new HashSet<>(PrimitiveChars.values.subList(0,2)));
    PrimitiveChars.iterations=0;
}"
"@Test
public class Test {
    public void testPendingAndInvalidate() throws Exception {
        final Configuration CONF = new HdfsConfiguration();
        MiniDFSCluster cluster = new MiniDFSCluster.Builder(CONF).numDataNodes(DATANODE_COUNT).build();
        cluster.waitActive();
        FSNamesystem namesystem = cluster.getNamesystem();
        BlockManager bm = namesystem.getBlockManager();
        DistributedFileSystem fs = cluster.getFileSystem();
        try {
            Path filePath = new Path(""/tmp.txt"");
            DFSTestUtil.createFile(fs, filePath, 1024, (short) 3, 0L);
            for (DataNode dn : cluster.getDataNodes()) {
                DataNodeTestUtils.setHeartbeatsDisabledForTests(dn, true);
            }
            LocatedBlock block = NameNodeAdapter.getBlockLocations(
            cluster.getNameNode(), filePath.toString(), 0, 1).get(0);
            cluster.getNamesystem().writeLock();
            try {
                bm.findAndMarkBlockAsCorrupt(block.getBlock(), block.getLocations()[0],
                ""STORAGE_ID"", ""TEST"");
            } finally {
                cluster.getNamesystem().writeUnlock();
            }
            BlockManagerTestUtil.computeAllPendingWork(bm);
            BlockManagerTestUtil.updateState(bm);
            assertEquals(bm.getPendingReconstructionBlocksCount(), 1L);
            BlockInfo storedBlock = bm.getStoredBlock(block.getBlock().getLocalBlock());
            assertEquals(bm.pendingReconstruction.getNumReplicas(storedBlock), 2);
            fs.delete(filePath, true);
            int retries = 10;
            long pendingNum = bm.getPendingReconstructionBlocksCount();
            while (pendingNum != 0 && retries-- > 0) {
                Thread.sleep(1000);
                BlockManagerTestUtil.updateState(bm);
                pendingNum = bm.getPendingReconstructionBlocksCount();
            }
            assertEquals(pendingNum, 0L);
        } finally {
            cluster.shutdown();
        }
    }
}"
"@Test
public void testPerson() {
    final Person p = new Person();
    p.name = ""John Doe"";
    p.age = 33;
    p.smoker = false;
    p.job = new Job();
    p.job.title = ""Manager"";
    final String pBaseStr = (p.getClass().getName() + ""@"") + Integer.toHexString(System.identityHashCode(p));
    final String pJobStr = (p.job.getClass().getName() + ""@"") + Integer.toHexString(System.identityHashCode(p.job));
    assertEquals(((pBaseStr + ""[name=John Doe,age=33,smoker=false,job="") + pJobStr) + ""[title=Manager]]"", new ReflectionToStringBuilder(p, new RecursiveToStringStyle()).toString());
}"
"@Test
public void testInterruption() throws InterruptedException {
    OneTimeWorkRequest work = new OneTimeWorkRequest.Builder(TestWorker.class).build();
    insertWork(work);
    WorkerWrapper workerWrapper =
    createBuilder(work.getStringId())
    .withSchedulers(Collections.singletonList(mMockScheduler))
    .build();
    FutureListener listener = createAndAddFutureListener(workerWrapper);
    Executors.newSingleThreadExecutor().submit(workerWrapper);
    workerWrapper.interrupt();
    Thread.sleep(6000L);
    assertThat(listener.mResult, is(true));
}"
"@Test public void onlyTrumpsGenerators() throws Exception {
    assertThat(testResult(OnlyTrumpsGenerators.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),OnlyTrumpsGenerators.iterations);
    OnlyTrumpsGenerators.iterations=0;
}"
"@Test
public void testSkipCheckoutWhenCheckoutDirectoryExistsAndSkip() throws Exception {
    checkoutDir.mkdirs();
    CheckoutMojo mojo = ((CheckoutMojo) (lookupMojo(""checkout"", getTestFile(""src/test/resources/mojos/checkout/checkoutWhenCheckoutDirectoryExistsAndSkip.xml""))));
    mojo.setCheckoutDirectory(checkoutDir);
    mojo.execute();
    assertEquals(0, checkoutDir.listFiles().length);
}"
"@Test
public void testListenerFailures() throws InterruptedException {
    int iters = iterations(10, 100);
    for (int i = 0; i < iters; i++) {
        try (TestIteration iteration = new TestIteration()) {
            iteration.transport.endConnectMode();
            final CountDownLatch latch = new CountDownLatch(1);
            final AtomicInteger finalFailures = new AtomicInteger();
            final AtomicReference<Throwable> finalFailure = new AtomicReference<>();
            final AtomicReference<TestResponse> response = new AtomicReference<>();
            ActionListener<TestResponse> actionListener = new ActionListener<TestResponse>();
            final AtomicInteger preSendFailures = new AtomicInteger();
            iteration.transportClientNodesService.execute((node, retryListener) -> {
                if (rarely()) {
                    preSendFailures.incrementAndGet();
                    throw new IllegalArgumentException();
                }
                iteration.transportService.sendRequest(node, ""action"", new TestRequest(),
                TransportRequestOptions.EMPTY, new TransportResponseHandler<TestResponse>() {
                }, actionListener);
                assertThat(latch.await(1, TimeUnit.SECONDS), equalTo(true));
                assertThat(preSendFailures.get() + iteration.transport.failures() + iteration.transport.successes(), lessThanOrEqualTo(1));
                if (iteration.transport.successes() == 1) {
                    assertThat(finalFailures.get(), equalTo(0));
                    assertThat(finalFailure.get(), nullValue());
                    assertThat(response.get(), notNullValue());
                } else {
                    assertThat(finalFailures.get(), equalTo(1));
                    assertThat(finalFailure.get(), notNullValue());
                    assertThat(response.get(), nullValue());
                    if (preSendFailures.get() == 0 && iteration.transport.failures() == 0) {
                        assertThat(finalFailure.get(), instanceOf(NoNodeAvailableException.class));
                    }
                }
                assertThat(iteration.transport.triedNodes().size(), lessThanOrEqualTo(iteration.listNodesCount));
                assertThat(iteration.transport.triedNodes().size(), equalTo(iteration.transport.connectTransportExceptions() + iteration.transport.failures() + iteration.transport.successes()));
            });
        }
    }
}"
"@Test public void testResponse1() throws Exception {
    SearchLookupResponse response=new SearchLookupResponse();
    response.setType(""LOOKUP"");
    response.setMetric(""sys.cpu.user"");
    response.putTag(""host"",""localhost"");
    response.putTag(""rack"",""r1"");
    response.setTime(1500);
    List<Result> results=new ArrayList<>();
    Result r1=new Result();
    r1.setMetric(""sys.cpu.idle"");
    r1.setTsuid(""000011000008203D00"");
    r1.putTag(""host"",""localhost"");
    r1.putTag(""rack"",""r1"");
    Result r2=new Result();
    r2.setMetric(""sys.cpu.user"");
    r2.setTsuid(""000011000008203D01"");
    r2.putTag(""host"",""localhost"");
    r2.putTag(""rack"",""r1"");
    results.add(r1);
    results.add(r2);
    response.setResults(results);
    response.setTotalResults(results.size());
    String r=JsonUtil.getObjectMapper().writeValueAsString(response);
    String expected=""{\""type\"":\""LOOKUP\"",\""metric\"":\""sys.cpu.user\"",\""tags\"":{\""host\"":\""localhost\"",\""rack\"":\""r1\""},\""limit\"":0,\""time\"":1500,\""totalResults\"":2,\""results\"":[{\""tags\"":{\""host\"":\""localhost\"",\""rack\"":\""r1\""},\""metric\"":\""sys.cpu.idle\"",\""tsuid\"":\""000011000008203D00\""},{\""tags\"":{\""host\"":\""localhost\"",\""rack\"":\""r1\""},\""metric\"":\""sys.cpu.user\"",\""tsuid\"":\""000011000008203D01\""}]}"";
    Assert.assertEquals(expected,r);
    SearchLookupResponse slr=JsonUtil.getObjectMapper().readValue(r,SearchLookupResponse.class);
    Assert.assertEquals(response,slr);
}"
"@Test public void testClassFinderDefaultsToOwnPackage() throws Exception {
    ClassFinder allClassesFinder=new ClassFinder(classLoader);
    Set<Class<?>> pkgClasses=allClassesFinder.findClasses(ClassFinder.class.getPackage().getName(),false);
    Set<Class<?>> defaultClasses=allClassesFinder.findClasses(false);
    Object[] pkgClassesArray=pkgClasses.toArray();
    Object[] defaultClassesArray=defaultClasses.toArray();
    assertEquals(pkgClassesArray.length,defaultClassesArray.length);
    assertThat(pkgClassesArray,arrayContainingInAnyOrder(defaultClassesArray));
}"
"@Test
public void getFieldNamesTest() {
    List<String> names = EnumUtil.getFieldNames(TestEnum.class);
    Assert.assertEquals(CollUtil.newArrayList(""type"", ""name""), names);
}"
"@Test
public void testBulkUpdateOnTimestampedVersion() {
    TimestampedEntity pc = new TimestampedEntity();
    pc.setName(""Original"");
    EntityManager em = emf.createEntityManager();
    em.getTransaction().begin();
    em.persist(pc);
    em.getTransaction().commit();
    em.getTransaction().begin();
    Timestamp oldVersion = pc.getVersion();
    String jpql = ""UPDATE TimestampedEntity t SET t.name=:newname WHERE t.name=:oldname"";
    em.createQuery(jpql).setParameter(""newname"", ""Updated"").setParameter(""oldname"", ""Original"").executeUpdate();
    em.getTransaction().commit();
    em.getTransaction().begin();
    em.refresh(pc);
    Timestamp newVersion = pc.getVersion();
    assertTrue(newVersion.after(oldVersion));
}"
"@Test
public void testConduitBridge() throws Exception {
    MessageConsumer consumer1 = remoteSession.createConsumer(included);
    MessageConsumer consumer2 = remoteSession.createConsumer(included);
    MessageProducer producer = localSession.createProducer(included);
    producer.setDeliveryMode(NON_PERSISTENT);
    Thread.sleep(2000);
    for (int i = 0; i < MESSAGE_COUNT; i++) {
        Message test = localSession.createTextMessage(""test-"" + i);
        producer.send(test);
        assertNotNull(consumer1.receive(1000));
        assertNotNull(consumer2.receive(1000));
    }
    assertNull(consumer1.receive(1000));
    assertNull(consumer2.receive(1000));
}"
"@Test
public void testOnlyExternalContextAllowsCache() throws Exception {
    KernelServices services = createKernelServicesBuilder(AdditionalInitialization.MANAGEMENT)
    .build();
    Assert.assertTrue(services.isSuccessfulBoot());
    List<ModelNode> list = parse(ModelTestUtils.readResource(this.getClass(), ""subsystem.xml""));
    for (ModelNode addOp : list) {
        PathAddress addr = PathAddress.pathAddress(addOp.require(ModelDescriptionConstants.OP_ADDR));
        if (addr.size() == 2 && addr.getLastElement().getKey().equals(NamingSubsystemModel.BINDING) && BindingType.forName(addOp.get(NamingBindingResourceDefinition.BINDING_TYPE.getName()).asString()) != BindingType.EXTERNAL_CONTEXT) {
            addOp.get(NamingBindingResourceDefinition.CACHE.getName()).set(true);
            services.executeForFailure(addOp);
            addOp.remove(NamingBindingResourceDefinition.CACHE.getName());
            ModelTestUtils.checkOutcome(services.executeOperation(addOp));
            ModelTestUtils.checkFailed(services.executeOperation(Util.getWriteAttributeOperation(addr, NamingBindingResourceDefinition.CACHE.getName(), new ModelNode(true))));
        } else {
            ModelTestUtils.checkOutcome(services.executeOperation(addOp));
        }
    }"
"@Test public void acrossParametersOfSameType() throws Exception {
    assertThat(testResult(ParametersOfSameType.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ParametersOfSameType.iterations);
    ParametersOfSameType.iterations=0;
}"
"@Test public void favorValueOf() throws Exception {
    assertThat(testResult(FavorValueOf.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),FavorValueOf.iterations);
    assertEquals(new HashSet<>(asList(FavorValueOf.Target.valueOf(""a""),FavorValueOf.Target.valueOf(""b""))),new HashSet<>(FavorValueOf.values.subList(0,2)));
    FavorValueOf.iterations=0;
}"
"@Test
public void testReacquireLocksAfterSessionLost() throws Exception {
    @Cleanup
    MetadataStoreExtended store = MetadataStoreExtended.create(zks.getConnectionString(), MetadataStoreConfig.builder().sessionTimeoutMillis(2000).build());
    BlockingQueue<SessionEvent> sessionEvents = new LinkedBlockingQueue<>();
    store.registerSessionListener(sessionEvents::add);
    @Cleanup
    CoordinationService coordinationService = new CoordinationServiceImpl(store);
    @Cleanup
    LockManager<String> lm1 = coordinationService.getLockManager(String.class);
    String path = newKey();
    ResourceLock<String> lock = lm1.acquireLock(path, ""value-1"").join();
    zks.expireSession(((ZKMetadataStore) (store)).getZkSessionId());
    SessionEvent e = sessionEvents.poll(5, TimeUnit.SECONDS);
    assertEquals(e, ConnectionLost);
    e = sessionEvents.poll(10, TimeUnit.SECONDS);
    assertEquals(e, SessionLost);
    e = sessionEvents.poll(10, TimeUnit.SECONDS);
    assertEquals(e, Reconnected);
    e = sessionEvents.poll(10, TimeUnit.SECONDS);
    assertEquals(e, SessionReestablished);
    Awaitility.await().untilAsserted(() -> {
        assertFalse(lock.getLockExpiredFuture().isDone());
    });
    assertTrue(store.get(path).join().isPresent());
}"
"@Test public void testProxy() throws Exception {
    service2.export();
    assertThat(service2.getExportedUrls(),hasSize(1));
    assertEquals(2,TestProxyFactory.count);
    TestProxyFactory.count=0;
}"
"@Test public void primitiveBooleans() throws Exception {
    assertThat(testResult(PrimitiveBooleans.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveBooleans.iterations);
    assertEquals(singletonList(true),PrimitiveBooleans.values.subList(0,1));
    PrimitiveBooleans.iterations=0;
}"
"@Test void nullAndObjectValuesInMap(){
    Map<String,Object> queryParams=new LinkedHashMap<>();
    queryParams.put(""foo"",null);
    queryParams.put(""baz"",""qux"");
    Unirest.get(MockServer.GET).queryString(queryParams).asObject(RequestCapture.class).getBody().assertParam(""foo"","""").assertParam(""baz"",""qux"").assertQueryString(""foo&baz=qux"");
}"
"@Test
public void testCheckoutPrepareBuildMultiModuleProject() throws Exception {
    PrepareBuildProjectsTask task = createTask(""src/test-projects/multi-module/pom.xml"", false, false);
    this.prepareBuildQueue.put(task);
    List<Project> projects = getProjectDao().getProjectsInGroup(task.getProjectGroupId());
    assertEquals(""failed to add all projects"", 3, projects.size());
    Project rootProject = getProjectDao().getProjectByName(""multi-module-parent"");
    Project moduleA = getProjectDao().getProjectByName(""module-A"");
    Project moduleB = getProjectDao().getProjectByName(""module-B"");
    while ((!prepareBuildQueue.getQueueSnapshot().isEmpty()) || (prepareBuildTaskQueueExecutor.getCurrentTask() != null)) {
        Thread.sleep(10);
    }
    ProjectScmRoot scmRoot = projectScmRootDao.getProjectScmRoot(task.getProjectScmRootId());
    assertEquals(""Failed to update multi-module project"", UPDATED, scmRoot.getState());
    File workingDir = configurationService.getWorkingDirectory();
    assertTrue(""checkout directory of project 'multi-module-parent' does not exist."", new File(workingDir, Integer.toString(rootProject.getId())).exists());
    assertTrue(""checkout directory of project 'module-A' does not exist."", new File(workingDir, Integer.toString(moduleA.getId())).exists());
    assertTrue(""checkout directory of project 'module-B' does not exist."", new File(workingDir, Integer.toString(moduleB.getId())).exists());
}"
"public void test_for_issue_1() throws Exception {
    DataSimpleVO a=new DataSimpleVO(""a"",1);
    DataSimpleVO b=new DataSimpleVO(""b"",2);
    b.value1=a;
    Map<String,Object> map=new HashMap<String,Object>();
    map.put(a.name,a);
    b.value=map;
    String jsonStr=JSON.toJSONString(b,SerializerFeature.MapSortField);
    System.out.println(jsonStr);
    DataSimpleVO obj=JSON.parseObject(jsonStr,DataSimpleVO.class);
    System.out.println(obj.toString());
    assertNotNull(obj.value1);
    assertEquals(jsonStr,JSON.toJSONString(obj,SerializerFeature.MapSortField));
}"
"@Test
public void testEviction() throws Exception {
    final int CAPACITY = 3;
    PeerCache cache = PeerCache.getInstance(CAPACITY, 100000);
    DatanodeID dnIds[] = new DatanodeID[CAPACITY + 1];
    FakePeer peers[] = new FakePeer[CAPACITY + 1];
    for (int i = 0; i < dnIds.length; ++i) {
        dnIds[i] = new DatanodeID(""192.168.0.1"",
        ""fakehostname_"" + i, ""fake_storage_id_"" + i,
        100, 101, 102);
        peers[i] = new FakePeer(dnIds[i], false);
    }
    for (int i = 0; i < CAPACITY; ++i) {
        cache.put(dnIds[i], peers[i]);
    }
    assertEquals(CAPACITY, cache.size());
    cache.put(dnIds[CAPACITY], peers[CAPACITY]);
    assertEquals(CAPACITY, cache.size());
    assertSame(null, cache.get(dnIds[0], false));
    for (int i = 1; i < CAPACITY; ++i) {
        Peer peer = cache.get(dnIds[i], false);
        assertSame(peers[i], peer);
        assertTrue(!peer.isClosed());
        peer.close();
    }
    assertEquals(1, cache.size());
    cache.close();
}"
"@Test
public void testTimeWindows()
{
    Long tstamp1 = 1451001601000L;
    Long tstamp2 = 1451088001000L;
    Long lowHour = 1451001600000L;
    assertTrue(getWindowBoundsInMillis(TimeUnit.HOURS, 1, tstamp1).left.compareTo(lowHour) == 0);
    assertTrue(getWindowBoundsInMillis(TimeUnit.MINUTES, 1, tstamp1).left.compareTo(lowHour) == 0);
    assertTrue(getWindowBoundsInMillis(TimeUnit.DAYS, 1, tstamp1).left.compareTo(lowHour) == 0 );
    assertTrue(getWindowBoundsInMillis(TimeUnit.DAYS, 2, tstamp2).left.compareTo(lowHour) == 0);
    return;
}"
"@Test
public void testRemoveContext() throws IOException {
    String dir = buildBufferDir(ROOT, 0);
    String contextCfgItemName = ""application_1340842292563_0004.app.cache.dirs"";
    conf.set(contextCfgItemName, dir);
    LocalDirAllocator localDirAllocator = new LocalDirAllocator(contextCfgItemName);
    localDirAllocator.getLocalPathForWrite(""p1/x"", SMALL_FILE_SIZE, conf);
    assertTrue(LocalDirAllocator.isContextValid(contextCfgItemName));
    LocalDirAllocator.removeContext(contextCfgItemName);
    assertFalse(LocalDirAllocator.isContextValid(contextCfgItemName));
}"
"@Test
public void testTrackMetadata_rowTombstone() throws Throwable
{
    createTable(""CREATE TABLE %s (a int, b int, c text, PRIMARY KEY (a, b))"");
    ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(currentTable());
    execute(""DELETE FROM %s USING TIMESTAMP 9999 WHERE a = 1"");
    cfs.forceBlockingFlush();
    assertEquals(1, cfs.getLiveSSTables().size());
    StatsMetadata metadata = cfs.getLiveSSTables().iterator().next().getSSTableMetadata();
    assertEquals(9999, metadata.minTimestamp);
    assertEquals(9999, metadata.maxTimestamp);
    assertEquals(System.currentTimeMillis()/1000, metadata.maxLocalDeletionTime, 5);
    assertEquals(nowInSec(), metadata.maxLocalDeletionTime, DELTA);
    cfs.forceMajorCompaction();
    StatsMetadata metadata2 = cfs.getLiveSSTables().iterator().next().getSSTableMetadata();
    assertEquals(metadata.maxLocalDeletionTime, metadata2.maxLocalDeletionTime);
    assertEquals(metadata.minTimestamp, metadata2.minTimestamp);
    assertEquals(metadata.maxTimestamp, metadata2.maxTimestamp);
}"
"@Test public void testAsync(){
    RpcContext rpcContext=RpcContext.getContext();
    Assertions.assertFalse(rpcContext.isAsyncStarted());
    AsyncContext asyncContext=RpcContext.startAsync();
    Assertions.assertTrue(rpcContext.isAsyncStarted());
    asyncContext.write(new Object());
    Assertions.assertTrue(((AsyncContextImpl)asyncContext).getInternalFuture().isDone());
    rpcContext.stopAsync();
    Assertions.assertTrue(rpcContext.isAsyncStarted());
    RpcContext.removeContext();
}"
"@Test
public void shouldBuildUpGracefullyUntilReachedMinPoolSize() throws InterruptedException
{
    StatefulMonitor stateMonitor = new StatefulMonitor();
    FakeClock clock = new FakeClock();
    final LinkedQueuePool<Object> pool = getLinkedQueuePool( stateMonitor, clock, 5 );
    ExecutorService executor = Executors.newCachedThreadPool();
    List<FlyweightHolder<Object>> flyweightHolders = acquireFromPool( pool, 5, executor );
    executor.shutdown();
    for ( FlyweightHolder<Object> flyweightHolder : flyweightHolders )
    {
        flyweightHolder.release();
    }
    executor.awaitTermination( 10, TimeUnit.SECONDS );
    assertEquals( -1, stateMonitor.currentPeakSize.get() );
    assertEquals( -1, stateMonitor.targetSize.get() );
    assertEquals( 0, stateMonitor.disposed.get() );
}"
"@Test public void testSerialize() throws SerializationException {
    GetUserIdSerializableRequest request=new GetUserIdSerializableRequest();
    request.setOperation(InstantAccessOperationValue.GETUSERID);
    request.setInfoField1(""nobody@amazon.com"");
    request.setInfoField2(""AMZN"");
    String requestString=serializer.encode(request);
    requestString=requestString.replace(""{"","""").replace(""}"","""").replace(""\"""","""");
    HashMap<String,String> requestMap=new HashMap<String,String>();
    String[] pairs=requestString.split("","");
    for (int i=0; i < pairs.length; i++) {
        String pair=pairs[i];
        String[] keyValue=pair.split("":"");
        requestMap.put(keyValue[0],keyValue[1]);
    }
    HashMap<String,String> expected=new HashMap<String,String>();
    expected.put(""operation"",""GetUserId"");
    expected.put(""infoField1"",""nobody@amazon.com"");
    expected.put(""infoField2"",""AMZN"");
    assertEquals(requestMap,expected);
}"
"@Test public void testAdditionalModelTypeAnnotationsMixed() throws Exception {
    OpenAPI openAPI=TestUtils.createOpenAPI();
    final AbstractJavaCodegen codegen=new P_AbstractJavaCodegen();
    codegen.additionalProperties().put(AbstractJavaCodegen.ADDITIONAL_MODEL_TYPE_ANNOTATIONS,"" \t @Foo;\r\n@Bar  ;\n @Foobar  "");
    codegen.processOpts();
    codegen.preprocessOpenAPI(openAPI);
    final List<String> additionalModelTypeAnnotations=new ArrayList<String>();
    additionalModelTypeAnnotations.add(""@Foo"");
    additionalModelTypeAnnotations.add(""@Bar"");
    additionalModelTypeAnnotations.add(""@Foobar"");
    final List<String> sortedCodegenAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    final List<String> sortedAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    Collections.sort(sortedCodegenAdditionalModelTypeAnnotations);
    Collections.sort(sortedAdditionalModelTypeAnnotations);
    Assert.assertEquals(sortedCodegenAdditionalModelTypeAnnotations,sortedAdditionalModelTypeAnnotations);
}"
"@Test
public void test_1() throws Exception {
    V1 entity = new V1();
    String text = JSON.toJSONString(entity, SortField);
    System.out.println(text);
    Assert.assertEquals(""{\""f1\"":0,\""f2\"":0,\""f3\"":0,\""f4\"":0,\""f5\"":0}"", text);
    JSONObject object = JSON.parseObject(text);
    text = JSON.toJSONString(object, SortField);
    Assert.assertEquals(""{\""f1\"":0,\""f2\"":0,\""f3\"":0,\""f4\"":0,\""f5\"":0}"", text);
}"
"@Test
public void testingUserServiceGaugeMetrics() throws Exception {
    MetricsCollector collector =
    collectionService.getCollector(getUserServiceContext(Constants.DEFAULT_NAMESPACE, ""WordCount"", ""CounterService"",
    ""CountRunnable""));
    collector.increment(""gmetric"", 1);
    collector.gauge(""gmetric"", 10);
    collector.increment(""gmetric"", 1);
    TimeUnit.SECONDS.sleep(1);
    collector.gauge(""gmetric"", 10);
    TimeUnit.SECONDS.sleep(2);
    String runnableRequest =
    ""/system/apps/WordCount/services/CounterService/runnables/CountRunnable/gmetric?aggregate=true"";
    String serviceRequest =
    ""/system/apps/WordCount/services/CounterService/gmetric?aggregate=true"";
    testSingleMetric(runnableRequest, 10);
    testSingleMetric(serviceRequest, 10);
}"
"@Test
public void testPrematureTimeout() throws Exception {
    final AtomicBoolean failed = new AtomicBoolean(false);
    MockVolt volt = new MockVolt(20000);
    volt.start();
    Distributer dist = new Distributer(false,
    ClientConfig.DEFAULT_PROCEDURE_TIMOUT_NANOS,
    2000,
    false, null);
    dist.addClientStatusListener(new TimeoutMonitorCSL());
    dist.createConnection(""localhost"", """", """", 20000);
    assertTrue(volt.handler != null);
    long start = System.currentTimeMillis();
    while ((System.currentTimeMillis() - start) < 3000) {
        Thread.yield();
    }
    volt.handler.sendResponses.set(false);
    start = System.currentTimeMillis();
    while (!failed.get()) {
        if ((System.currentTimeMillis() - start) > 2000) {
            break;
        } else {
            Thread.yield();
        }
    }
    if ((System.currentTimeMillis() - start) < 2000) {
    fail(""Premature timeout occurred""); }
    dist.shutdown();
    volt.shutdown();
}"
"@Test public void explicitConversion() throws Exception {
    assertThat(testResult(ExplicitConversion.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ExplicitConversion.iterations);
    assertEquals(new HashSet<>(asList(LocalDate.of(2017,1,1),LocalDate.of(2001,12,25))),new HashSet<>(ExplicitConversion.values.subList(0,2)));
    ExplicitConversion.iterations=0;
}"
"public void test_6() throws Exception {
    JSONObject jsonObject=new JSONObject();
    jsonObject.put(""val"",new Character[]{});
    jsonObject.put(""cls"",java.lang.Number.class);
    jsonObject.put(""nums"",new java.lang.Number[]{});
    ByteArrayOutputStream bytesOut=new ByteArrayOutputStream();
    ObjectOutputStream objOut=new ObjectOutputStream(bytesOut);
    objOut.writeObject(jsonObject);
    objOut.flush();
    byte[] bytes=bytesOut.toByteArray();
    ByteArrayInputStream bytesIn=new ByteArrayInputStream(bytes);
    ObjectInputStream objIn=new ObjectInputStream(bytesIn);
    Object obj=objIn.readObject();
    assertEquals(JSONObject.class,obj.getClass());
    assertEquals(JSON.toJSONString(jsonObject,SerializerFeature.MapSortField),JSON.toJSONString(obj,SerializerFeature.MapSortField));
}"
"@Test public void testFormatMultipleUTF8(){
    HashMap<String,String> params=new HashMap<String,String>();
    params.put(""a "",""b, "");
    params.put(""c"",""32626&"");
    String s=KeyValueFormatter.format(params,true);
    Assert.assertTrue((""a =b%2C+&c=32626%26"").equals(s) || (""c=32626%26&a =b%2C+"").equals(s));
}"
