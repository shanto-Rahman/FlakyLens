full_code
"@Test public void serializePrefixOnly(){
    final LookupCacheKey cacheKey=LookupCacheKey.createFromJSON(""prefix"",null);
    final JsonNode node=objectMapper.convertValue(cacheKey,JsonNode.class);
    assertThat(node.isObject()).isTrue();
    assertThat(node.fieldNames()).containsExactlyInAnyOrder(""prefix"",""key"");
    assertThat(node.path(""prefix"").isTextual()).isTrue();
    assertThat(node.path(""prefix"").asText()).isEqualTo(""prefix"");
    assertThat(node.path(""key"").isNull()).isTrue();
}"
"/**
* Fruits - serialization tests for simple property on sub-classes
*/
public void testExistingPropertySerializationFruits() throws Exception {
    Map<String,Object> result=writeAndMap(MAPPER,pinguo);
    assertEquals(3,result.size());
    assertEquals(pinguo.name,result.get(""name""));
    assertEquals(pinguo.seedCount,result.get(""seedCount""));
    assertEquals(pinguo.type,result.get(""type""));
    result=writeAndMap(MAPPER,mandarin);
    assertEquals(3,result.size());
    assertEquals(mandarin.name,result.get(""name""));
    assertEquals(mandarin.color,result.get(""color""));
    assertEquals(mandarin.type,result.get(""type""));
    String pinguoSerialized=MAPPER.writeValueAsString(pinguo);
    assertEquals(pinguoSerialized,pinguoJson);
    String mandarinSerialized=MAPPER.writeValueAsString(mandarin);
    assertEquals(mandarinSerialized,mandarinJson);
    String fruitWrapperSerialized=MAPPER.writeValueAsString(pinguoWrapper);
    assertEquals(fruitWrapperSerialized,pinguoWrapperJson);
    String fruitListSerialized=MAPPER.writeValueAsString(fruitList);
    assertEquals(fruitListSerialized,fruitListJson);
}"
"@Test
public void shouldHighPriorityNodeStartElectionFirst() {
    final AtomicBoolean highPrioElectionTriggered = spy(new AtomicBoolean());
    final AtomicBoolean lowPrioElectionTriggered = spy(new AtomicBoolean());
    final int targetPriority = 4;
    final PriorityElectionTimer timerHighPrio = new PriorityElectionTimer(Duration.ofMillis(100), threadContext, () -> highPrioElectionTriggered.set(true), log, targetPriority, targetPriority);
    final PriorityElectionTimer timerLowPrio = new PriorityElectionTimer(Duration.ofMillis(100), threadContext, () -> lowPrioElectionTriggered.set(true), log, targetPriority, 1);
    timerLowPrio.reset();
    timerHighPrio.reset();
    Awaitility.await().until(highPrioElectionTriggered::get);
    Awaitility.await().until(lowPrioElectionTriggered::get);
    final var inorder = Mockito.inOrder(highPrioElectionTriggered, lowPrioElectionTriggered);
    inorder.verify(highPrioElectionTriggered).set(true);
    inorder.verify(lowPrioElectionTriggered).set(true);
}"
"public void test_dupType() throws Exception {
    DianDianCart cart=new DianDianCart();
    cart.setId(1001);
    LinkedHashMap<String,JSONObject> cartMap=new LinkedHashMap<String,JSONObject>();
    JSONObject obj=new JSONObject();
    obj.put(""id"",1001);
    obj.put(JSON.DEFAULT_TYPE_KEY,""com.alibaba.json.bvt.writeClassName.WriteDuplicateType$DianDianCart"");
    cartMap.put(""1001"",obj);
    String text1=JSON.toJSONString(cartMap,SerializerFeature.WriteClassName);
    assertTrue(text1.equals(""{\""@type\"":\""java.util.LinkedHashMap\"",\""1001\"":{\""@type\"":\""com.alibaba.json.bvt.writeClassName.WriteDuplicateType$DianDianCart\"",\""id\"":1001}}"") || text1.equals(""{\""@type\"":\""java.util.LinkedHashMap\"",\""1001\"":{\""id\"":1001,\""@type\"":\""com.alibaba.json.bvt.writeClassName.WriteDuplicateType$DianDianCart\""}}""));
}"
"public void test_7() throws Exception {
    JSON.defaultTimeZone=TimeZone.getTimeZone(""Asia/Shanghai"");
    DefaultJSONParser parser=new DefaultJSONParser(""[\""2011-01-09T13:49:53.254\"", \""xxx\"", true, false, null, {}]"");
    parser.config(Feature.AllowISO8601DateFormat,true);
    ArrayList list=new ArrayList();
    parser.parseArray(list);
    Assert.assertEquals(new Date(1294552193254L),list.get(0));
    Assert.assertEquals(""xxx"",list.get(1));
    Assert.assertEquals(Boolean.TRUE,list.get(2));
    Assert.assertEquals(Boolean.FALSE,list.get(3));
    Assert.assertEquals(null,list.get(4));
    Assert.assertEquals(new JSONObject(),list.get(5));
}"
"@Test
public void testBindAndRetrieveObjectFactoryFromNamingContext() throws Exception {
    final Reference reference = new Reference(""java.util.String"", TestObjectFactory.class.getName(), null);
    namingStore.bind(new CompositeName(""test""), reference);
    final Object result = namingContext.lookup(""test"");
    assertTrue(result instanceof String);
    assertEquals(""Test ParsedResult"", result);
}"
"@Test public void serializeInteger() throws IOException {
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of(1)),""{\""@type\"":\""integer\"",\""@value\"":1}"");
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of(42)),""{\""@type\"":\""integer\"",\""@value\"":42}"");
}"
"@Test public void test1_2() throws Exception {
    JSONObject json=new JSONObject();
    json.put(""id"",123);
    json.put(""name"",""哈哈哈"");
    ResultActions actions=mockMvc.perform((post(""/fastjson/test1?callback=fnUpdateSome"").characterEncoding(""UTF-8"").content(json.toJSONString()).contentType(MediaType.APPLICATION_JSON)));
    actions.andDo(print());
    actions.andExpect(status().isOk()).andExpect(content().contentType(APPLICATION_JAVASCRIPT));
    String content=actions.andReturn().getResponse().getContentAsString();
    assertTrue(content.equals(""/**/fnUpdateSome({\""name\"":\""哈哈哈\"",\""id\"":123})"") || content.equals(""/**/fnUpdateSome({\""id\"":123,\""name\"":\""哈哈哈\""})""));
}"
"@Test public void charArray(){
    final WithArrays wa=new WithArrays();
    wa.charArray=new char[]{'a','A'};
    final String exp=getClassPrefix(wa) + ""["" + BR+ ""  boolArray=<null>,""+ BR+ ""  charArray={""+ BR+ ""    a,""+ BR+ ""    A""+ BR+ ""  },""+ BR+ ""  doubleArray=<null>,""+ BR+ ""  intArray=<null>,""+ BR+ ""  longArray=<null>,""+ BR+ ""  stringArray=<null>""+ BR+ ""]"";
    assertEquals(exp,toString(wa));
}"
"@Test
public void testRecursingTrace() throws Exception {
    TracePluginConfiguration conf = new TracePluginConfiguration();
    conf.traceProb = 1.0;
    conf.port = 51010;
    conf.clientPort = 12346;
    TracePlugin aPlugin = new TracePlugin(conf);
    conf.port = 51011;
    conf.clientPort = 12347;
    TracePlugin bPlugin = new TracePlugin(conf);
    conf.port = 51012;
    conf.clientPort = 12348;
    TracePlugin cPlugin = new TracePlugin(conf);
    conf.port = 51013;
    conf.clientPort = 12349;
    TracePlugin dPlugin = new TracePlugin(conf);
    Responder bRes = new RecursingResponder(TestBasicTracing.advancedProtocol, bPlugin);
    bRes.addRPCPlugin(bPlugin);
    HttpServer server1 = new HttpServer(bRes, 21005);
    server1.start();
    Responder cRes = new EndpointResponder(TestBasicTracing.advancedProtocol);
    cRes.addRPCPlugin(cPlugin);
    HttpServer server2 = new HttpServer(cRes, 21006);
    server2.start();
    Responder dRes = new EndpointResponder(TestBasicTracing.advancedProtocol);
    dRes.addRPCPlugin(dPlugin);
    HttpServer server3 = new HttpServer(dRes, 21007);
    server3.start();
    HttpTransceiver trans = new HttpTransceiver(new URL(""http:www.example.com""));
    GenericRequestor r = new GenericRequestor(TestBasicTracing.advancedProtocol, trans);
    r.addRPCPlugin(aPlugin);
    GenericRecord params = new GenericData.Record(advancedProtocol.getMessages().get(""w"").getRequest());
    params.put(""req"", 1);
    for (int i = 0; i < 40; i++) {
        r.request(""w"", params);
    }
    List<Span> allSpans = new ArrayList<Span>();
    allSpans.addAll(aPlugin.storage.getAllSpans());
    allSpans.addAll(bPlugin.storage.getAllSpans());
    allSpans.addAll(cPlugin.storage.getAllSpans());
    allSpans.addAll(dPlugin.storage.getAllSpans());
    SpanAggregationResults results = SpanAggregator.getFullSpans(allSpans);
    assertEquals(0, results.incompleteSpans.size());
    List<Span> merged = results.completeSpans;
    List<Trace> traces = SpanAggregator.getTraces(merged).traces;
    assertEquals(40, traces.size());
    TraceCollection collection = new TraceCollection(traces.get(0));
    for (Trace t : traces) {
        collection.addTrace(t);
    }
    server1.close();
    server2.close();
    server3.close();
    aPlugin.httpServer.close();
    aPlugin.clientFacingServer.stop();
    bPlugin.httpServer.close();
    bPlugin.clientFacingServer.stop();
    cPlugin.httpServer.close();
    cPlugin.clientFacingServer.stop();
    dPlugin.httpServer.close();
    dPlugin.clientFacingServer.stop();
}"
"@Test public void TestAcyclicCFG(){
    Node n1=new Node(1);
    Node n2=new Node(2);
    Node n3=new Node(3);
    Node n4=new Node(4);
    Node n5=new Node(5);
    Node n6=new Node(6);
    Node n7=new Node(7);
    Node n8=new Node(8);
    Node n9=new Node(9);
    Node n10=new Node(10);
    Node n11=new Node(11);
    n1.addkid(n2).addkid(n3);
    n2.addkid(n9);
    n3.addkid(n4).addkid(n5);
    n4.addkid(n9);
    n5.addkid(n6).addkid(n10);
    n6.addkid(n7).addkid(n8);
    n7.addkid(n10);
    n8.addkid(n10);
    n9.addkid(n11);
    n10.addkid(n11);
    Graph g=new Graph(n1);
    MHGDominatorsFinder<Node> finder=new MHGDominatorsFinder<Node>(g);
    DominatorTree<Node> tree=new DominatorTree<Node>(finder);
    assertThat(tree.getHeads().size(),is(1));
    DominatorNode<Node> n=tree.getHeads().get(0);
    assertThat(n.getGode().id,is(1));
    Set<Integer> kids=kid_ids(n);
    assertThat(kids.size(),is(4));
    assertThat(kids,containsInAnyOrder(2,3,9,11));
    Map<Integer,DominatorNode<Node>> KM=kid_map(n);
    DominatorNode<Node> m=KM.get(2);
    kids=kid_ids(m);
    assertThat(kids.size(),is(0));
    m=KM.get(9);
    kids=kid_ids(m);
    assertThat(kids.size(),is(0));
    m=KM.get(11);
    kids=kid_ids(m);
    assertThat(kids.size(),is(0));
    n=KM.get(3);
    kids=kid_ids(n);
    assertThat(kids.size(),is(2));
    assertThat(kids,containsInAnyOrder(4,5));
    KM=kid_map(n);
    m=KM.get(4);
    kids=kid_ids(m);
    assertThat(kids.size(),is(0));
    n=KM.get(5);
    kids=kid_ids(n);
    assertThat(kids.size(),is(2));
    assertThat(kids,containsInAnyOrder(6,10));
    KM=kid_map(n);
    m=KM.get(10);
    kids=kid_ids(m);
    assertThat(kids.size(),is(0));
    n=KM.get(6);
    kids=kid_ids(n);
    assertThat(kids.size(),is(2));
    assertThat(kids,containsInAnyOrder(7,8));
    KM=kid_map(n);
    m=KM.get(7);
    kids=kid_ids(m);
    assertThat(kids.size(),is(0));
    m=KM.get(8);
    kids=kid_ids(m);
    assertThat(kids.size(),is(0));
}"
"@Test public void wrapperChars() throws Exception {
    assertThat(testResult(WrapperChars.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperChars.iterations);
    WrapperChars.iterations=0;
}"
"@Test
public void testPull() throws Exception {
    PullPoint pullPoint = wsnCreatePullPoint.createPullPoint();
    wsnBroker.subscribe(pullPoint.getEndpoint(), ""myTopic"", null);
    wsnBroker.notify(""myTopic"", new Notify());
    Thread.sleep(500);
    List<NotificationMessageHolderType> msgs = pullPoint.getMessages(0);
    assertNotNull(msgs);
    assertEquals(1, msgs.size());
    Thread.sleep(500);
}"
"@Test public void wrapperLongs() throws Exception {
    assertThat(testResult(WrapperLongs.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperLongs.iterations);
    WrapperLongs.iterations=0;
}"
"@Test
public void testMinAllowedValue() {
    long millis = _validMinTime;
    DateTime dateTime = new DateTime(millis, DateTimeZone.UTC);
    LocalDateTime localDateTime = dateTime.toLocalDateTime();
    int year = localDateTime.getYear();
    int month = localDateTime.getMonthOfYear();
    int day = localDateTime.getDayOfMonth();
    Assert.assertEquals(year, 1971);
    Assert.assertEquals(month, 1);
    Assert.assertEquals(day, 1);
}"
"@Test
public void testReassignFailOnStartNew() throws IOException {
    ReceiverAdminClient receiverAdminClient = mockReceiverClientFailOnStartNewComsumer();
    coordinator = new Coordinator(metadataStore, receiverAdminClient);
    Map<Integer, List<Partition>> preAssignMap = metadataStore.getAssignmentsByCube(cubeName).getAssignments();
    Map<Integer, List<Partition>> newAssignMap = new HashMap<>();
    newAssignMap.put(1, Lists.newArrayList(p1, p2, p3));
    newAssignMap.put(2, Lists.newArrayList(p4, p5));
    newAssignMap.put(3, Lists.newArrayList(p6));
    CubeAssignment preAssigment = new CubeAssignment(cube.getName(), preAssignMap);
    CubeAssignment newAssigment = new CubeAssignment(cube.getName(), newAssignMap);
    try {
        coordinator.doReassign(cube, preAssigment, newAssigment);
    } catch (ClusterStateException rune) {
        assertSame(ROLLBACK_FAILED, rune.getClusterState());
        assertSame(START_NEW, rune.getTransactionStep());
        System.out.println(rune.getMessage());
        throw rune;
    }
}"
"@Test
public void test_empty_obj_toJson() {
    String j = Json.toJson(new Person(), JsonFormat.compact().setQuoteName(true));
    assertEquals(""{\""age\"":0,\""num\"":0}"", j);
}"
"@Test
public void test_parseLString() throws Exception {
    DateFormat format = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL, Locale.US);
    try {
        Date date = format.parse(format.format(current).toString());
        assertEquals(current.getDate(), date.getDate());
        assertEquals(current.getDay(), date.getDay());
        assertEquals(current.getMonth(), date.getMonth());
        assertEquals(current.getYear(), date.getYear());
        assertEquals(current.getHours(), date.getHours());
        assertEquals(current.getMinutes(), date.getMinutes());
    } catch(ParseException pe) {
    fail(""ParseException was thrown for current Date.""); }
    try {
        format.parse(""January 16, 1970 8:03:52 PM CET"");
        fail(""ParseException was not thrown."");
    } catch(ParseException pe) { }
}"
"@Test
public void testBuildTokenServiceSockAddr() {
    assertEquals(""127.0.0.1:123"", SecurityUtil.buildTokenService(new InetSocketAddress(""LocalHost"", 123)).toString());
    assertEquals(""127.0.0.1:123"", SecurityUtil.buildTokenService(new InetSocketAddress(""127.0.0.1"", 123)).toString());
    assertEquals(""127.0.0.1:123"", SecurityUtil.buildTokenService(NetUtils.createSocketAddr(""127.0.0.1"", 123)).toString());
}"
"@Test
public void testHeartbeatExpiry() throws Exception {
    Clusters fsm = mock(Clusters.class);
    ActionQueue aq = new ActionQueue();
    ActionManager am = mock(ActionManager.class);
    HostState hs = HostState.WAITING_FOR_HOST_STATUS_UPDATES;
    List<Host> allHosts = new ArrayList<Host>();
    Host hostObj = mock(Host.class);
    allHosts.add(hostObj);
    when(fsm.getHosts()).thenReturn(allHosts);
    when(fsm.getHost(""host1"")).thenReturn(hostObj);
    when(hostObj.getState()).thenReturn(hs);
    when(hostObj.getHostName()).thenReturn(""host1"");
    aq.enqueue(""host1"", new ExecutionCommand());
    HeartbeatMonitor hm = new HeartbeatMonitor(fsm, aq, am, 100);
    hm.start();
    Thread.sleep(120);
    assertEquals(0, aq.dequeueAll(""host1"").size());
    verify(am, times(1)).handleLostHost(""host1"");
    verify(hostObj, times(1)).handleEvent(any(HostEvent.class));
    verify(hostObj, times(1)).setState(INIT);
    hm.shutdown();
}"
"@Test public void test_enum(){
    assertEquals(""\""K\"""",Json.toJson(K.K));
    String expected=""{\n"" + ""   \""name\"": \""t\"",\n"" + ""   \""index\"": 1\n""+ ""}"";
    assertJsonEqualsNonStrict(expected,Json.toJson(TT.T));
    assertEquals(""\""T\"""",Json.toJson(TT.T,JsonFormat.full().ignoreJsonShape()));
}"
"@Test public void wrapperDoubles() throws Exception {
    assertThat(testResult(WrapperDoubles.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperDoubles.iterations);
    assertEquals(new HashSet<>(asList(2.7,-3.14)),new HashSet<>(WrapperDoubles.values.subList(0,2)));
    WrapperDoubles.iterations=0;
}"
"@Test public void trialCountHoldsForEntirePropertyRatherThanIndividualParameters(){
    assertThat(testResult(ForValuesOfMultipleParameters.class),isSuccessful());
    assertEquals(4,ForValuesOfMultipleParameters.iterations);
    List<Foo> foos=ForValuesOfMultipleParameters.foos;
    assertEquals(8,foos.size());
    assertEquals(foos.get(0),foos.get(4));
    assertEquals(foos.get(1),foos.get(3));
    assertEquals(foos.get(2),foos.get(6));
    assertEquals(foos.get(5),foos.get(7));
    ForValuesOfMultipleParameters.iterations=0;
    ForValuesOfMultipleParameters.foos.clear();
}"
"@Test
public void legalToExecuteTwiceCloning_Async() throws Exception {
    server.enqueue(new MockResponse().setBody(""abc""));
    server.enqueue(new MockResponse().setBody(""def""));
    Request request = new Request.Builder().url(server.url(""/"")).build();
    Call call = client.newCall(request);
    call.enqueue(callback);
    Call cloned = call.clone();
    cloned.enqueue(callback);
    callback.await(request.url()).assertBody(""abc"");
    callback.await(request.url()).assertBody(""def"");
}"
"@Test
public void recurringJobWithErrorShouldStop() throws Exception
{
    RobustJobSchedulerWrapper robustWrapper = new RobustJobSchedulerWrapper( actualScheduler, log );
    AtomicInteger count = new AtomicInteger();
    Error e = new Error();
    JobHandle jobHandle = robustWrapper.scheduleRecurring( ""JobName"", 1, () ->{
        count.incrementAndGet();
        throw e;
    }
    );
    Thread.sleep( 50 );
    assertEventually( ""run count"", count::get, Matchers.equalTo( 1 ), DEFAULT_TIMEOUT_MS , MILLISECONDS );
    robustWrapper.cancelAndWaitTermination( jobHandle );
    verify( log, timeout( DEFAULT_TIMEOUT_MS ).times( 1 ) ).error( ""Uncaught error rethrown"", e );
}"
"@Test void writesAndReadsCustomFieldsConvertedClass(){
    List<Object> converters=new ArrayList<>();
    converters.add(BigDecimalToStringConverter.INSTANCE);
    converters.add(StringToBigDecimalConverter.INSTANCE);
    CustomConversions customConversions=new CouchbaseCustomConversions(converters);
    converter.setCustomConversions(customConversions);
    converter.afterPropertiesSet();
    ((CouchbaseMappingContext)converter.getMappingContext()).setSimpleTypeHolder(customConversions.getSimpleTypeHolder());
    CouchbaseDocument converted=new CouchbaseDocument();
    final String valueStr=""12.345"";
    final BigDecimal value=new BigDecimal(valueStr);
    final String value2Str=""0.6789"";
    final BigDecimal value2=new BigDecimal(value2Str);
    List<BigDecimal> listOfValues=new ArrayList<>();
    listOfValues.add(value);
    listOfValues.add(value2);
    Map<String,BigDecimal> mapOfValues=new HashMap<>();
    mapOfValues.put(""val1"",value);
    mapOfValues.put(""val2"",value2);
    CustomFieldsEntity entity=new CustomFieldsEntity(value,listOfValues,mapOfValues);
    converter.write(entity,converted);
    CouchbaseDocument source=new CouchbaseDocument();
    source.put(""_class"",CustomFieldsEntity.class.getName());
    source.put(""decimalValue"",valueStr);
    CouchbaseList listOfValuesDoc=new CouchbaseList();
    listOfValuesDoc.put(valueStr);
    listOfValuesDoc.put(value2Str);
    source.put(""listOfDecimalValues"",listOfValuesDoc);
    CouchbaseDocument mapOfValuesDoc=new CouchbaseDocument();
    mapOfValuesDoc.put(""val1"",valueStr);
    mapOfValuesDoc.put(""val2"",value2Str);
    source.put(""mapOfDecimalValues"",mapOfValuesDoc);
    assertThat(valueStr).isEqualTo(((CouchbaseList)converted.getContent().get(""listOfDecimalValues"")).get(0));
    assertThat(value2Str).isEqualTo(((CouchbaseList)converted.getContent().get(""listOfDecimalValues"")).get(1));
    assertThat(converted.export().toString()).isEqualTo(source.export().toString());
    CustomFieldsEntity readConverted=converter.read(CustomFieldsEntity.class,source);
    assertThat(readConverted.value).isEqualTo(value);
    assertThat(readConverted.listOfValues.get(0)).isEqualTo(listOfValues.get(0));
    assertThat(readConverted.listOfValues.get(1)).isEqualTo(listOfValues.get(1));
    assertThat(readConverted.mapOfValues.get(""val1"")).isEqualTo(mapOfValues.get(""val1""));
    assertThat(readConverted.mapOfValues.get(""val2"")).isEqualTo(mapOfValues.get(""val2""));
}"
"@Test
public void testTrackMetadata_rowMarkerDelete() throws Throwable
{
    createTable(""CREATE TABLE %s (a int, PRIMARY KEY (a))"");
    ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(currentTable());
    execute(""DELETE FROM %s USING TIMESTAMP 9999 WHERE a=1"");
    cfs.forceBlockingFlush();
    assertEquals(1, cfs.getLiveSSTables().size());
    StatsMetadata metadata = cfs.getLiveSSTables().iterator().next().getSSTableMetadata();
    assertEquals(9999, metadata.minTimestamp);
    assertEquals(9999, metadata.maxTimestamp);
    assertEquals(System.currentTimeMillis()/1000, metadata.maxLocalDeletionTime, 5);
    cfs.forceMajorCompaction();
    StatsMetadata metadata2 = cfs.getLiveSSTables().iterator().next().getSSTableMetadata();
    assertEquals(metadata.maxLocalDeletionTime, metadata2.maxLocalDeletionTime);
    assertEquals(metadata.minTimestamp, metadata2.minTimestamp);
    assertEquals(metadata.maxTimestamp, metadata2.maxTimestamp);
}"
"@Test
public void testListBindings() throws Exception {
    bindList();
    NamingEnumeration<Binding> results = namingContext.listBindings(new CompositeName());
    checkListResults(results);
    results = (NamingEnumeration<Binding>) testActionPermission(JndiPermission.ACTION_LIST_BINDINGS, namingContext, null);
    checkListResults(results);
}"
"@Test public void primitiveChars(){
    assertThat(testResult(PrimitiveChars.class),isSuccessful());
    assertEquals(2,PrimitiveChars.iterations);
    assertEquals(new HashSet<>(asList('Z','z')),PrimitiveChars.testCases);
    PrimitiveChars.iterations=0;
}"
"@Test
public void testToFile() throws Exception {
    item = new PathData(""."", conf);
    assertEquals(new File(testDir.toString()), item.toFile());
    item = new PathData(""d1/f1"", conf);
    assertEquals(new File(testDir + ""/d1/f1""), item.toFile());
    item = new PathData(testDir + ""/d1/f1"", conf);
    assertEquals(new File(testDir + ""/d1/f1""), item.toFile());
}"
"@Test
void shouldExitBeforeGivenWaitTime_WhenWaitingThreadInterrupted() {
    var executorService = Executors.newFixedThreadPool(2);
    var executionStrategy = new ExecutionStrategies.ExitFlaggingExecutionStrategy();
    var executioner = new SystemExecutioner(executionStrategy);
    var startTime = new AtomicLong();
    var executionFuture = executorService.submit(() -> {
        LOG.info(""Calling executioner with 5 second wait"");
        startTime.set(System.nanoTime());
        executioner.exit(5, TimeUnit.SECONDS);
    });
    var killerSleepTimeMillis = 100;
    var killerFuture = executorService.submit(() -> {
        LOG.info(""Sleeping for {} milliseconds..."", killerSleepTimeMillis);
        new DefaultEnvironment().sleepQuietly(killerSleepTimeMillis, TimeUnit.MILLISECONDS);
        LOG.info(""I'm awake and will now interrupt executionThread"");
        var canceled = executionFuture.cancel(true);
        LOG.info(""executionFuture was canceled? {}"", canceled);
    });
    await().atMost(ONE_SECOND).until(() -> executionFuture.isDone() && killerFuture.isDone());
    long elapsedNanos = System.nanoTime() - startTime.get();
    assertThat(executionStrategy.didExit()).describedAs(""Execution strategy exit() should have been called"").isTrue();
    assertThat(TimeUnit.NANOSECONDS.toMillis(elapsedNanos)).describedAs(""Elapsed millis must be greater than %d"", killerSleepTimeMillis).isGreaterThan(killerSleepTimeMillis);
    executorService.shutdown();
    await().atMost(ONE_SECOND).until(executorService::isShutdown);
}"
"@Test
public void runCollectiveChokeTest() throws InterruptedException, IOException {
    int numChokes = 5;
    for (int i = 0; i < numChokes; i++) {
        chokeMap.put(Integer.toString(i),
        rateFloor + rand.nextInt(rateCeil - rateFloor));
    }
    testChokeMan.updateChokeLimitMap(chokeMap);
    TestChoke[] tchokeArray = new TestChoke[numChokes];
    for (int i = 0; i < numChokes; i++) {
        tchokeArray[i] = new TestChoke<EventSink>(null, Integer.toString(i));
    }
    Set<TestChoke<EventSink>> chokesUsed = new HashSet<TestChoke<EventSink>>();
    DirectDriver[] directDriverArray = new DirectDriver[numDrivers];
    int randChokeIndex = 0;
    for (int i = 0; i < numDrivers; i++) {
        randChokeIndex = rand.nextInt(numChokes);
        directDriverArray[i] = new DirectDriver(new SynthSourceRndSize(0,minMsgSize, maxMsgSize), tchokeArray[randChokeIndex]);
        chokesUsed.add(tchokeArray[randChokeIndex]);
    }
    LOG.info(""Running the Collective Test Now!"");
    for (TestChoke<EventSink> t : chokesUsed) {
        if (!testChokeMan.isChokeId(t.getChokeId())) {
            LOG.error(""ChokeID "" + t.getChokeId() + ""not present"");
            fail();
        }
    }
    testChokeMan.start();
    for (DirectDriver f : directDriverArray) {
        f.start();
    }
    Thread.sleep(testTime);
    for (DirectDriver f : directDriverArray) {
        f.stop();
    }
    testChokeMan.halt();
    for (TestChoke<EventSink> t : chokesUsed) {
        double maxRate = chokeMap.get(t.getChokeId());
        errorRatio = ((double) (chokeMap.get(t.getChokeId()) * testTime)) / (double) (t.getReport().getLongMetric(""number of bytes""));
        assertFalse((errorRatio > this.highErrorLimit || errorRatio < this.lowErrorLimit));
    }
}"
"@Test public void test_create2() throws Exception {
    String sql=""CREATE RESOURCE GROUP sql_thread TYPE = USER VCPU = 1,3 THREAD_PRIORITY = -20 disable"";
    List<SQLStatement> stmtList=SQLUtils.toStatementList(sql,JdbcConstants.MYSQL);
    SQLStatement stmt=stmtList.get(0);
    MySqlSchemaStatVisitor visitor=new MySqlSchemaStatVisitor();
    stmt.accept(visitor);
    String output=SQLUtils.toMySqlString(stmt);
    Set<String> allPossibleRes=generateAllPossibleRes(""CREATE RESOURCE GROUP sql_thread "","" DISABLE"");
    assertTrue(allPossibleRes.contains(output));
}"
"@Test public void testPerson(){
    final Person p=new Person();
    p.name=""John Doe"";
    p.age=33;
    p.smoker=false;
    p.job=new Job();
    p.job.title=""Manager"";
    final String pBaseStr=p.getClass().getName() + ""@"" + Integer.toHexString(System.identityHashCode(p));
    final String pJobStr=p.job.getClass().getName() + ""@"" + Integer.toHexString(System.identityHashCode(p.job));
    assertEquals(pBaseStr + ""[age=33,job="" + pJobStr+ ""[title=Manager],name=John Doe,smoker=false]"",new ReflectionToStringBuilder(p,new RecursiveToStringStyle()).toString());
}"
"@Test public void wrapperBytes(){
    assertThat(testResult(WrapperBytes.class),isSuccessful());
    assertEquals(2,WrapperBytes.iterations);
    assertEquals(new HashSet<>(asList(Byte.valueOf(""14""),Byte.valueOf(""-15""))),WrapperBytes.testCases);
    WrapperBytes.iterations=0;
}"
"public void test_0() throws Exception {
    String sql=""CREATE EXTERNAL CATALOG IF NOT EXISTS kafka_1 PROPERTIES ("" + ""'connector.name'='kafka' "" + ""'kafka.table-names'='table1,table2' ""+ ""'kafka.nodes'='1.1.1.1:10000,1.1.1.2:10000') COMMENT 'this is a kafka connector test.'"";
    MySqlStatementParser parser=new MySqlStatementParser(sql);
    List<SQLStatement> stmtList=parser.parseStatementList();
    assertEquals(1,stmtList.size());
    SQLStatement stmt=stmtList.get(0);
    Set<String> allPossibleRes=generateAllPossibleRes4test0();
    assertTrue(allPossibleRes.contains(stmt.toString()));
}"
"@Test public void disablingShrinking(){
    assertThat(testResult(DisablingShrinking.class),failureCountIs(1));
    assertEquals(1,DisablingShrinking.attempts.size());
    DisablingShrinking.attempts.clear();
}"
"@Test
public void testList() throws Exception {
    bindList();
    NamingEnumeration<NameClassPair> results = namingContext.list(new CompositeName());
    checkListResults(results);
    results = (NamingEnumeration<NameClassPair>) testActionPermission(JndiPermission.ACTION_LIST, namingContext, null);
    checkListResults(results);
}"
"@Test public void enums() throws Exception {
    assertThat(testResult(Enums.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),Enums.iterations);
    Enums.iterations=0;
}"
"@Test public void wrapperIntegers(){
    assertThat(testResult(WrapperIntegers.class),isSuccessful());
    assertEquals(2,WrapperIntegers.iterations);
    assertEquals(new HashSet<>(asList(4,5)),WrapperIntegers.testCases);
    WrapperIntegers.iterations=0;
    WrapperIntegers.testCases.clear();
}"
"@Test
public void canSerializeAdditionalProperties() throws Exception {
    Foo foo = new Foo();
    foo.bar = ""hello.world"";
    foo.baz = new ArrayList<>();
    foo.baz.add(""hello"");
    foo.baz.add(""hello.world"");
    foo.qux = new HashMap<>();
    foo.qux.put(""hello"", ""world"");
    foo.qux.put(""a.b"", ""c.d"");
    foo.qux.put(""bar.a"", ""ttyy"");
    foo.qux.put(""bar.b"", ""uuzz"");
    foo.additionalProperties = new HashMap<>();
    foo.additionalProperties.put(""bar"", ""baz"");
    foo.additionalProperties.put(""a.b"", ""c.d"");
    foo.additionalProperties.put(""properties.bar"", ""barbar"");
    String serialized = new JacksonAdapter().serialize(foo);
    Assert.assertEquals(""{\""$type\"":\""foo\"",\""properties\"":{\""bar\"":\""hello.world\"",\""props\"":{\""baz\"":[\""hello\"",\""hello.world\""],\""q\"":{\""qux\"":{\""hello\"":\""world\"",\""a.b\"":\""c.d\"",\""bar.b\"":\""uuzz\"",\""bar.a\"":\""ttyy\""}}}},\""bar\"":\""baz\"",\""a.b\"":\""c.d\"",\""properties.bar\"":\""barbar\""}"", serialized);
}"
"@Test
public void testLookupNameNotFound() throws Exception {
    try {
        namingContext.lookup(new CompositeName(""test""));
        fail(""Should have thrown and NameNotFoundException"");
    } catch (NameNotFoundException expected) {
    }
    try {
        testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, ""test"");
        fail(""Should have thrown and NameNotFoundException with appropriate permissions"");
    } catch (NameNotFoundException expected) {
    }
}"
"@Test public void TestSimpleDiamond(){
    Node x=new Node(4);
    Node n=new Node(1).addkid((new Node(2)).addkid(x)).addkid((new Node(3)).addkid(x));
    Graph g=new Graph(n);
    MHGDominatorsFinder<Node> finder=new MHGDominatorsFinder<Node>(g);
    DominatorTree<Node> tree=new DominatorTree<Node>(finder);
    assertThat(tree.getHeads().size(),is(1));
    DominatorNode<Node> head=tree.getHeads().get(0);
    assertThat(head.getGode().id,is(1));
    Set<Integer> kids=kid_ids(head);
    assertThat(kids.size(),is(3));
    assertThat(kids,containsInAnyOrder(2,3,4));
}"
"@Test
public void extraSweepersGiveUpAfterFailingToAcquireEnoughTimes() throws InterruptedException {
    int shards = 16;
    int sweepers = 4;
    int threads = shards / (sweepers / 2);
    TimelockService stickyLockService = createStickyLockService();
    createAndInitializeSweepersAndWaitForOneBackgroundIteration(sweepers, shards, threads, stickyLockService);
    ArgumentCaptor<LockRequest> captor = ArgumentCaptor.forClass(LockRequest.class);
    verify(stickyLockService, atLeast(shards * (shards / threads + 1) / 2 + shards * (threads * sweepers - shards)));
    verify(stickyLockService, atMost(shards * ((threads + 1) * sweepers - shards) - sweepers * (sweepers - 1) / 2));
    Set<String> requestedLockIds = captor.getAllValues().stream()
    .map(LockRequest::getLockDescriptors)
    .map(Iterables::getOnlyElement)
    .map(LockDescriptor::getLockIdAsString)
    .collect(Collectors.toSet());
    Set<String> expectedLockIds = IntStream.range(0, shards).boxed()
    .map(ShardAndStrategy::conservative)
    .map(ShardAndStrategy::toText)
    .collect(Collectors.toSet());
    assertThat(requestedLockIds).hasSameElementsAs(expectedLockIds);
}"
"@Test
public void manyParameters() throws Exception {
    assertThat(testResult(ManyParameters.class), isSuccessful());
    assertEquals(16, ManyParameters.iterations);
    assertEquals(asList(-1, -2, -4), ManyParameters.firstTestCases.subList(0, 3));
    assertEquals(asList(-1, -2, -4), ManyParameters.firstTestCases.subList(4, 7));
    assertEquals(asList(-1, -2, -4), ManyParameters.firstTestCases.subList(8, 11));
    assertEquals(asList(-1, -2, -4), ManyParameters.firstTestCases.subList(12, 15));
    assertEquals(asList('r', 'r', 'r', 'r', 'y', 'y', 'y', 'y'), ManyParameters.secondTestCases.subList(0, 8));
}"
"@Test public void wrapperFloats() throws Exception {
    assertThat(testResult(WrapperFloats.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperFloats.iterations);
    assertEquals(new HashSet<>(asList(1.7F,-4.14F)),new HashSet<>(WrapperFloats.values.subList(0,2)));
    WrapperFloats.iterations=0;
}"
"@Test
public void testResourceGroupConcurrencyThreshold()
throws Exception
{
    String dbConfigUrl1 = getDbConfigUrl();
    H2ResourceGroupsDao dao = getDao(dbConfigUrl1);
    DistributedQueryRunner queryRunner = createQueryRunner(dbConfigUrl1, dao, ImmutableMap.of(""concurrency-threshold-to-enable-resource-group-refresh"", ""0.1"", ""resource-group-runtimeinfo-refresh-interval"", ""10s""));
    MILLISECONDS.sleep(500);
    QueryId firstAdhocQuery = createQuery(queryRunner, adhocSession(), LONG_LASTING_QUERY);
    waitForQueryState(queryRunner, firstAdhocQuery, RUNNING);
    waitForRunningQueryCount(queryRunner, 1);
    QueryId secondAdhocQuery = createQuery(queryRunner, adhocSession(), LONG_LASTING_QUERY);
    waitForQueryState(queryRunner, secondAdhocQuery, QUEUED);
    MILLISECONDS.sleep(500);
    waitForQueryState(queryRunner, secondAdhocQuery, RUNNING);
    waitForRunningQueryCount(queryRunner, 2);
    closeQuietly(queryRunner);
}"
"@Test
public void testCreateWithTwo() {
    AISMessage msg = amf.create(split1, split2);
    assertTrue(msg instanceof AISMessage05);
    assertEquals(5, msg.getMessageType());
}"
"@Test
public void shouldTerminateWhenFutureIsCancelled() throws InterruptedException {
    GracefulExecutorServicesShutdown shutdown = GracefulExecutorServicesShutdown.initiate();
    shutdown.timeout(Duration.ofMillis(15000));
    ExecutorService executorService = mock(ExecutorService.class);
    when(executorService.isShutdown()).thenReturn(true);
    AtomicBoolean terminated = new AtomicBoolean();
    AtomicBoolean awaitTerminationInterrupted = new AtomicBoolean();
    when(executorService.isTerminated()).thenAnswer(invocation -> terminated.get());
    when(executorService.awaitTermination(anyLong(), any())).thenAnswer(invocation  -> {
        long timeout = invocation.getArgument(0);
        TimeUnit unit = invocation.getArgument(1);
        try {
            Thread.sleep(unit.toMillis(timeout));
        } catch (InterruptedException e) {
            awaitTerminationInterrupted.set(true);
            Thread.currentThread().interrupt();
            throw e;
        }
        throw new IllegalStateException(""Thread.sleep should have been interrupted"");
    });
    when(executorService.shutdownNow()).thenAnswer(invocation -> {
        terminated.set(true);
        return null;
    });
    shutdown.shutdown(executorService);
    CompletableFuture<Void> future = shutdown.handle();
    future.cancel(false);
    Awaitility.await().untilAsserted(() -> assertTrue(awaitTerminationInterrupted.get(),
    ""awaitTermination should have been interrupted""));
    verify(executorService, times(1)).awaitTermination(anyLong(), any());
    verify(executorService, times(1)).shutdownNow();
}"
"@Test
public void testHftpDefaultPorts() throws IOException {
    resetFileSystem();
    Configuration conf = new Configuration();
    URI uri = URI.create();
    HftpFileSystem fs = ((HftpFileSystem) (FileSystem.get(uri, conf)));
    assertEquals(DFS_NAMENODE_HTTP_PORT_DEFAULT, fs.getDefaultPort());
    assertEquals(DFS_NAMENODE_HTTPS_PORT_DEFAULT, fs.getDefaultSecurePort());
    assertEquals(uri, fs.getUri());
    assertEquals(""127.0.0.1:"" + DFSConfigKeys.DFS_NAMENODE_HTTPS_PORT_DEFAULT, fs.getCanonicalServiceName());
}"
"@Test
public void shouldOnlyHandleRequestsOfSubscribedTypes() {
    serverTransport.subscribe(0, COMMAND, new DirectlyResponder());
    serverTransport.subscribe(0, UNKNOWN, new FailingResponder());
    final var requestFuture = clientTransport.sendRequest(() -> AtomixTransportTest.serverAddress, new Request(""messageABC""), REQUEST_TIMEOUT);
    final var response = requestFuture.join();
    assertThat(response.byteArray()).isEqualTo(""messageABC"".getBytes());
}"
"@Test
public void testCommit() throws Exception {
    producer2.send(session.createTextMessage(""X""));
    producer2.send(session.createTextMessage(""Y""));
    producer2.send(session.createTextMessage(""Z""));
    expect(""A"", consumer1.receive(1000));
    expect(""B"", consumer1.receive(1000));
    expect(""C"", consumer1.receive(1000));
    session.commit();
    expect(""X"", testConsumer2.receive(1000));
    expect(""Y"", testConsumer2.receive(1000));
    expect(""Z"", testConsumer2.receive(1000));
    assertTrue(null == testConsumer1.receive(1000));
    assertTrue(null == testConsumer2.receive(1000));
}"
"@Test
public void testConcurrentOperations() throws InterruptedException {
    ActionQueue aq = new ActionQueue();
    String[] hosts = new String[]{ ""h0"", ""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"", ""h7"", ""h8"", ""h9"" };
    ActionQueueOperation[] enqueOperators = new ActionQueueOperation[threadCount];
    ActionQueueOperation[] dequeOperators = new ActionQueueOperation[threadCount];
    ActionQueueOperation[] dequeAllOperators = new ActionQueueOperation[threadCount];
    for (int i = 0; i < threadCount; i++) {
        dequeOperators[i] = new ActionQueueOperation(aq, hosts, ActionQueueOperation.OpType.DEQUEUE);
        Thread t = new Thread(dequeOperators[i]);
        t.start();
    }
    for (int i = 0; i < threadCount; i++) {
        enqueOperators[i] = new ActionQueueOperation(aq, hosts, ActionQueueOperation.OpType.ENQUEUE);
        Thread t = new Thread(enqueOperators[i]);
        t.start();
    }
    for (int i = 0; i < threadCount; i++) {
        dequeAllOperators[i] = new ActionQueueOperation(aq, hosts, ActionQueueOperation.OpType.DEQUEUEALL);
        Thread t = new Thread(dequeAllOperators[i]);
        t.start();
    }
    Thread.sleep(100);
    for (int i = 0; i < threadCount; i++) {
        enqueOperators[i].stop();
    }
    boolean allDequeued = false;
    while (!allDequeued) {
        Thread.sleep(10);
        allDequeued = true;
        for (String host : hosts) {
            if (aq.size(host) > 0) {
                allDequeued = false;
                break;
            }
        }
    }
    for (int i = 0; i < threadCount; i++) {
        dequeOperators[i].stop();
        dequeAllOperators[i].stop();
    }
    for (int h = 0; h < hosts.length; h++) {
        long opsEnqueued = 0;
        long opsDequeued = 0;
        for (int i = 0; i < threadCount; i++) {
            opsEnqueued += enqueOperators[i].getOpCounts()[h];
            opsDequeued += dequeOperators[i].getOpCounts()[h];
            opsDequeued += dequeAllOperators[i].getOpCounts()[h];
        }
        assertTrue(opsEnqueued != 0);
        assertEquals(0, aq.size(hosts[h]));
        LOG.info(((((""Host: "" + hosts[h]) + "", opsEnqueued: "") + opsEnqueued) + "", opsDequeued: "") + opsDequeued);
        assertEquals(opsDequeued, opsEnqueued);
    }
}"
"@Test
public void testMenuInvalidationAfterDestroy() throws Throwable {
    final A activity = getActivity();
    getInstrumentation().runOnMainSync(new Runnable() {
        @Override
        public void run() {
            activity.reset();
            assertNull(activity.getMenu());
            activity.supportInvalidateOptionsMenu();
            getInstrumentation().callActivityOnDestroy(activity);
        }
    });
    Thread.sleep(100);
    assertNull(activity.getMenu());
}"
