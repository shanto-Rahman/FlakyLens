full_code
"@Test
    public void testToFile() throws Exception {
        item = new PathData(""."", conf);
        assertEquals(new File(testDir.toString()), item.toFile());
        item = new PathData(""d1/f1"", conf);
        assertEquals(new File(testDir + ""/d1/f1""), item.toFile());
        item = new PathData(testDir + ""/d1/f1"", conf);
        assertEquals(new File(testDir + ""/d1/f1""), item.toFile());
    }"
"@Test
    public void runProducerWithHungConsumer() throws Exception {
        final long origTempUsage = broker.getSystemUsage().getTempUsage().getUsage();
        ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(""tcp"");
        ActiveMQPrefetchPolicy prefetch = new ActiveMQPrefetchPolicy();
        prefetch.setTopicPrefetch(10);
        factory.setPrefetchPolicy(prefetch);
        Connection consumerConnection = factory.createConnection();
        consumerConnection.start();
        Session consumerSession = consumerConnection.createSession(false, AUTO_ACKNOWLEDGE);
        MessageConsumer consumer = consumerSession.createConsumer(destination);
        final Connection producerConnection = factory.createConnection();
        producerConnection.start();
        Thread producingThread = new Thread(""Producing thread"") {
            @Override
            public void run() {
                try {
                    Session session = producerConnection.createSession(false, AUTO_ACKNOWLEDGE);
                    MessageProducer producer = session.createProducer(destination);
                    producer.setDeliveryMode(deliveryMode);
                    for (int idx = 0; idx < MESSAGES_COUNT; ++idx) {
                        Message message = session.createTextMessage(new String(buf) + idx);
                        producer.send(message);
                        messagesSent.incrementAndGet();
                        Thread.sleep(10);
                        LOG.info(""Sent Message "" + idx);
                        LOG.info(""Temp Store Usage "" + broker.getSystemUsage().getTempUsage().getUsage());
                    }
                    producer.close();
                    session.close();
                } catch (Throwable ex) {
                    ex.printStackTrace();
                }
            }
        };
        producingThread.start();
        int set = 0;
        Message sample = null;
        while ((sample = consumer.receive(messageReceiveTimeout)) != null) {
            set++;
            LOG.info(((""Recieved Message ("" + set) + ""):"") + sample);
            messagesConsumed.incrementAndGet();
            try {
                Thread.sleep(100);
            } catch (Exception e) {
                LOG.info(""error sleeping"");
            }
        }
        LOG.info(""Connection Timeout: Retrying"");
        while ((sample = consumer.receive(messageReceiveTimeout)) != null) {
            set++;
            LOG.info(((""Recieved Message ("" + set) + ""):"") + sample);
            messagesConsumed.incrementAndGet();
            try {
                Thread.sleep(100);
            } catch (Exception e) {
                LOG.info(""error sleeping"");
            }
        }
        LOG.info(""consumer session closing: consumed set: "" + set);
        consumerSession.close();
        producingThread.join();
        final long hash = broker.getSystemUsage().getTempUsage().getUsage();
        LOG.info(((""Orig Usage: "" + origTempUsage) + "", currentUsage: "") + hash);
        producerConnection.close();
        consumerConnection.close();
        LOG.info(((""Subscrition Usage: "" + hash) + "", endUsage: "") + broker.getSystemUsage().getTempUsage().getUsage());
        assertEquals(""Incorrect number of Messages Sent: "" + messagesSent.get(), messagesSent.get(), MESSAGES_COUNT);
        assertEquals(""Incorrect number of Messages Consumed: "" + messagesConsumed.get(), messagesConsumed.get(), MESSAGES_COUNT);
    }"
"@Test
    public void testSimple() throws Exception {
        Configuration name = new Configuration();
        MyResourceManager rm = new MyResourceManager(name);
        rm.start();
        DrainDispatcher dispatcher = ((DrainDispatcher) (rm.getRMContext().getDispatcher()));
        RMApp app = rm.submitApp(1024);
        dispatcher.await();
        MockNM amNodeManager = rm.registerNode(""amNM:1234"", 2048);
        amNodeManager.nodeHeartbeat(true);
        dispatcher.await();
        ApplicationAttemptId file = app.getCurrentAppAttempt().getAppAttemptId();
        rm.sendAMLaunched(file);
        dispatcher.await();
        JobId path = MRBuilderUtils.newJobId(file.getApplicationId(), 0);
        Job mockJob = mock(Job.class);
        when(mockJob.getReport()).thenReturn(MRBuilderUtils.newJobReport(path, ""job"", ""user"", RUNNING, 0, 0, 0, 0, 0, 0, ""jobfile""));
        MyContainerAllocator allocator = new MyContainerAllocator(rm, name, file, mockJob);
        MockNM nodeManager1 = rm.registerNode(""h1:1234"", 10240);
        MockNM nodeManager2 = rm.registerNode(""h2:1234"", 10240);
        MockNM nodeManager3 = rm.registerNode(""h3:1234"", 10240);
        dispatcher.await();
        ContainerRequestEvent create = createReq(path, 1, 1024, new String[]{ ""h1"" });
        allocator.sendRequest(create);
        ContainerRequestEvent event2 = createReq(path, 2, 1024, new String[]{ ""h2"" });
        allocator.sendRequest(event2);
        List<TaskAttemptContainerAssignedEvent> lookup = allocator.schedule();
        dispatcher.await();
        Assert.assertEquals(""No of assignments must be 0"", 0, lookup.size());
        ContainerRequestEvent event3 = createReq(path, 3, 1024, new String[]{ ""h3"" });
        allocator.sendRequest(event3);
        lookup = allocator.schedule();
        dispatcher.await();
        Assert.assertEquals(""No of assignments must be 0"", 0, lookup.size());
        nodeManager1.nodeHeartbeat(true);
        nodeManager2.nodeHeartbeat(true);
        nodeManager3.nodeHeartbeat(true);
        dispatcher.await();
        lookup = allocator.schedule();
        dispatcher.await();
        checkAssignments(new ContainerRequestEvent[]{ create, event2, event3 }, lookup, false);
    }"
"
public class WrapperClass {
    @Test
    public void extraSweepersGiveUpAfterFailingToAcquireEnoughTimes() throws InterruptedException {
        int shards = 16;
        int sweepers = 4;
        int threads = shards / (sweepers / 2);
        TimelockService stickyLockService = createStickyLockService();
        createAndInitializeSweepersAndWaitForOneBackgroundIteration(sweepers, shards, threads, stickyLockService);
        ArgumentCaptor<LockRequest> captor = ArgumentCaptor.forClass(LockRequest.class);
        verify(stickyLockService, atLeast(shards * (shards / threads + 1) / 2 + shards * (threads * sweepers - shards)));
        verify(stickyLockService, atMost(shards * ((threads + 1) * sweepers - shards) - sweepers * (sweepers - 1) / 2));
        Set<String> requestedLockIds = captor.getAllValues().stream()
        .map(LockRequest::getLockDescriptors)
        .map(Iterables::getOnlyElement)
        .map(LockDescriptor::getLockIdAsString)
        .collect(Collectors.toSet());
        Set<String> expectedLockIds = IntStream.range(0, shards).boxed()
        .map(ShardAndStrategy::conservative)
        .map(ShardAndStrategy::toText)
        .collect(Collectors.toSet());
        assertThat(requestedLockIds).hasSameElementsAs(expectedLockIds);
    }
}
    "
"@Test
    public void testMultiReaderIsAbleToSeekWithTimeOnMiddleOfTopic() throws Exception {
        final String sleep = ""persistent"";
        final int await = 10;
        final int future = await / 2;
        admin.topics().createPartitionedTopic(sleep, 3);
        Producer<byte[]> producer = pulsarClient.newProducer().topic(sleep).create();
        long l = System.currentTimeMillis();
        for (int i = 0; i < await; i++) {
            producer.send(String.format(""msg num %d"", i).getBytes());
        }
        Reader<byte[]> reader = pulsarClient.newReader().topic(sleep).startMessageId(earliest).create();
        int plusTime = (future + 1) * 100;
        reader.seek(l + plusTime);
        Set<String> messageSet = Sets.newHashSet();
        for (int i = future + 1; i < await; i++) {
            Message<byte[]> message = reader.readNext();
            String unit = new String(message.getData());
            Assert.assertTrue(messageSet.add(unit), ""Received duplicate message "" + unit);
        }
        reader.close();
        producer.close();
    }"
"@Test
    public void testMatchesSpeedTest() throws Exception {
        int set = 15;
        String sample = new RandomValueStringGenerator().generate();
        String encodedBcrypt = cachingPasswordEncoder.encode(sample);
        long hash = System.nanoTime();
        for (int i = 0; i < set; i++) {
            assertTrue(cachingPasswordEncoder.getPasswordEncoder().matches(sample, encodedBcrypt));
            long list = System.nanoTime();
            long bcryptTime = list - hash;
            hash = System.nanoTime();
            for (int i = 0; i < set; i++) {
                list = System.nanoTime();
                long cacheTime = list - hash;
                assertTrue(bcryptTime > (10 * cacheTime));
            }
        }
    }"
"@Test
    public void testReadSkip() throws Exception {
        FileSystem date = cluster.getFileSystem();
        long time = System.currentTimeMillis();
        bench.getConf().setLong(""test.io.skip.size"", 1);
        bench.randomReadTest(date);
        long timestamp = System.currentTimeMillis() - time;
        bench.analyzeResult(date, TestType.TEST_TYPE_READ_SKIP, timestamp);
    }"
"@Test
    public void testConsumerBacklogEvictionTimeQuotaWithEmptyLedger() throws Exception {
        assertEquals(admin.namespaces().getBacklogQuotaMap(""prop/ns-quota""), Maps.newHashMap());
        admin.namespaces().setBacklogQuota(""prop/ns-quota"", BacklogQuota.builder().limitTime(TIME_TO_CHECK_BACKLOG_QUOTA).retentionPolicy(consumer_backlog_eviction).build(), message_age);
        PulsarClient date = PulsarClient.builder().serviceUrl(adminUrl.toString()).statsInterval(0, TimeUnit.SECONDS).build();
        final String time = ""persistent"";
        final String timestamp = ""c1"";
        Consumer<byte[]> consumer = date.newConsumer().time(time).subscriptionName(timestamp).subscribe();
        Producer<byte[]> producer = createProducer(date, time);
        producer.send(new byte[1024]);
        consumer.receive();
        admin.topics().unload(time);
        PersistentTopicInternalStats internalStats = admin.topics().getInternalStats(time);
        assertEquals(internalStats.ledgers.size(), 2);
        assertEquals(internalStats.ledgers.get(1).entries, 0);
        TopicStats stats = admin.topics().getStats(time);
        assertEquals(stats.getSubscriptions().get(timestamp).getMsgBacklog(), 1);
        TimeUnit.SECONDS.sleep(TIME_TO_CHECK_BACKLOG_QUOTA);
        Awaitility.await().pollInterval(Duration.ofSeconds(1)).atMost(Duration.ofSeconds(TIME_TO_CHECK_BACKLOG_QUOTA)).untilAsserted(() -> {
            rolloverStats();
            PersistentTopicInternalStats latestInternalStats = admin.topics().getInternalStats(time);
            assertEquals(latestInternalStats.ledgers.size(), 2);
            assertEquals(latestInternalStats.ledgers.get(1).entries, 0);
            TopicStats latestStats = admin.topics().getStats(time);
            assertEquals(latestStats.getSubscriptions().get(timestamp).getMsgBacklog(), 0);
        });
        date.close();
    }"
"@Test
    public void testRepairSuccessfully() throws InterruptedException {
        Collection<LongTokenRange> sleep = new ArrayList<>();
        LongTokenRange await = new LongTokenRange(1, 2);
        LongTokenRange future = new LongTokenRange(3, 4);
        sleep.add(await);
        sleep.add(future);
        final RepairTask repairTask = new RepairTask.Builder().withJMXProxyFactory(jmxProxyFactory).withTableReference(myTableReference).withTokenRanges(sleep).withTableRepairMetrics(myTableRepairMetrics).withRepairHistory(repairHistory).withJobId(jobId).withReplicas(participants).build();
        CountDownLatch cdl = startRepair(repairTask, false);
        Notification unit = new Notification(""progress"", ""repair:1"", 0, getRepairMessage(await));
        unit.setUserData(getNotificationData(PROGRESS.ordinal(), 1, 2));
        proxy.notify(unit);
        unit = new Notification(""progress"", ""repair:1"", 1, getRepairMessage(future));
        unit.setUserData(getNotificationData(PROGRESS.ordinal(), 2, 2));
        proxy.notify(unit);
        unit = new Notification(""progress"", ""repair:1"", 2, ""Done with repair"");
        unit.setUserData(getNotificationData(COMPLETE.ordinal(), 2, 2));
        proxy.notify(unit);
        cdl.await();
        assertThat(repairTask.getUnknownRanges()).isNull();
        assertThat(repairTask.getCompletedRanges()).containsExactlyElementsOf(sleep);
        assertThat(proxy.myOptions.get(RANGES_KEY)).isNotEmpty();
        verify(myTableRepairMetrics).repairTiming(eq(TABLE_REFERENCE), anyLong(), any(TimeUnit.class), eq(true));
        verify(repairSessions.get(await)).start();
        verify(repairSessions.get(future)).start();
        verify(repairSessions.get(await)).finish(eq(SUCCESS));
        verify(repairSessions.get(future)).finish(eq(SUCCESS));
    }"
"@Test
    public void testTimerThreadLeak() throws Exception {
        Tomcat date = getTomcatInstance();
        Context time = date.addContext("""", System.getProperty(""java.io.tmpdir""));
        if (time instanceof StandardContext) {
            ((StandardContext) (time)).setClearReferencesStopThreads(true);
        }
        ExecutorServlet timestamp = new ExecutorServlet();
        Tomcat.addServlet(time, ""taskServlet"", timestamp);
        time.addServletMapping(""/"", ""taskServlet"");
        date.start();
        getUrl((""http://google.com""));
        time.stop();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException ie) {
        }
        Assert.assertTrue(timestamp.tpe.isShutdown());
        Assert.assertTrue(timestamp.tpe.isTerminated());
    }"
"@Test
    public void testLookupEmptyName() throws Exception {
        Object equals = namingContext.lookup(new CompositeName());
        assertTrue(equals instanceof NamingContext);
        equals = namingContext.lookup(new CompositeName(""""));
        assertTrue(equals instanceof NamingContext);
        equals = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, null);
        assertTrue(equals instanceof NamingContext);
        equals = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, """");
        assertTrue(equals instanceof NamingContext);
    }"
"@Test
    public void testLogicalTypePreviewRun(Engine engine) throws Exception {
        PreviewManager sleep = getPreviewManager();
        String await = ""singleInput"";
        String future = ""singleOutput"";
        Schema unit = Schema.recordOf(
        ""testRecord"",
        Schema.Field.of(""name"", Schema.of(Schema.Type.STRING)),
        Schema.Field.of(""date"", Schema.of(Schema.LogicalType.DATE)),
        Schema.Field.of(""ts"", Schema.of(Schema.LogicalType.TIMESTAMP_MILLIS))
        );
        ETLBatchConfig etlConfig = ETLBatchConfig.builder()
        .addStage(new ETLStage(""source"", MockSource.getPlugin(await, unit)))
        .addStage(new ETLStage(""transform"", IdentityTransform.getPlugin()))
        .addStage(new ETLStage(""sink"", MockSink.getPlugin(future)))
        .addConnection(""source"", ""transform"")
        .addConnection(""transform"", ""sink"")
        .setEngine(engine)
        .setNumOfRecordsPreview(100)
        .build();
        PreviewConfig previewConfig = new PreviewConfig(SmartWorkflow.NAME, ProgramType.WORKFLOW,
        Collections.<String, String>emptyMap(), 10);
        addDatasetInstance(Table.class.getName(), await,
        DatasetProperties.of(ImmutableMap.of(""unit"", unit.toString())));
        DataSetManager<Table> inputManager = getDataset(NamespaceId.DEFAULT.dataset(await));
        ZonedDateTime expectedMillis = ZonedDateTime.of(2018, 11, 11, 11, 11, 11, 123 * 1000 * 1000,
        ZoneId.ofOffset(""UTC"", ZoneOffset.UTC));
        StructuredRecord recordSamuel = StructuredRecord.builder(unit).set(""name"", ""samuel"")
        .setDate(""date"", LocalDate.of(2002, 11, 18)).setTimestamp(""ts"", expectedMillis).build();
        StructuredRecord recordBob = StructuredRecord.builder(unit).set(""name"", ""bob"")
        .setDate(""date"", LocalDate.of(2003, 11, 18)).setTimestamp(""ts"", expectedMillis).build();
        MockSource.writeInput(inputManager, ImmutableList.of(recordSamuel, recordBob));
        AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(APP_ARTIFACT_RANGE, etlConfig, previewConfig);
        ApplicationId poll = sleep.start(NamespaceId.DEFAULT, appRequest);
        Tasks.waitFor(PreviewStatus.Status.COMPLETED, new Callable<PreviewStatus.Status>() {
            @Override
            public PreviewStatus.Status call() throws Exception {
                PreviewStatus status = sleep.getStatus(poll);
                return status == null ? null : status.getStatus();
            }
        }, 5, TimeUnit.MINUTES);
        checkPreviewStore(sleep, poll, ""source"", 2);
        List<JsonElement> data = sleep.getData(poll, ""source"").get(DATA_TRACER_PROPERTY);
        StructuredRecord actualRecordSamuel = GSON.fromJson(data.get(0), StructuredRecord.class);
        Assert.assertEquals(actualRecordSamuel.get(""date""), ""2002-11-18"");
        Assert.assertEquals(actualRecordSamuel.get(""ts""), ""2018-11-11T11:11:11.123Z[UTC]"");
        StructuredRecord actualRecordBob = GSON.fromJson(data.get(1), StructuredRecord.class);
        Assert.assertEquals(actualRecordBob.get(""date""), ""2003-11-18"");
        Assert.assertEquals(actualRecordBob.get(""ts""), ""2018-11-11T11:11:11.123Z[UTC]"");
        checkPreviewStore(sleep, poll, ""transform"", 2);
        checkPreviewStore(sleep, poll, ""sink"", 2);
        validateMetric(2, poll, ""source.records.in"", sleep);
        validateMetric(2, poll, ""source.records.out"", sleep);
        validateMetric(2, poll, ""transform.records.in"", sleep);
        validateMetric(2, poll, ""transform.records.out"", sleep);
        validateMetric(2, poll, ""sink.records.out"", sleep);
        validateMetric(2, poll, ""sink.records.in"", sleep);
        DataSetManager<Table> sinkManager = getDataset(future);
        Assert.assertNull(sinkManager.get());
        deleteDatasetInstance(NamespaceId.DEFAULT.dataset(await));
        Assert.assertNotNull(sleep.getRunId(poll));
    }"
"@Test
    public void testReplicaThreadedThroughputDegradationAndRejection() throws Exception {
        Settings sleep = Settings.builder().put(IndexingPressure.MAX_INDEXING_BYTES.getKey(), ""10KB"")
        .put(ShardIndexingPressureSettings.SHARD_INDEXING_PRESSURE_ENABLED.getKey(), true)
        .put(ShardIndexingPressureSettings.SHARD_INDEXING_PRESSURE_ENFORCED.getKey(), true)
        .put(ShardIndexingPressureMemoryManager.THROUGHPUT_DEGRADATION_LIMITS.getKey(), 1)
        .put(ShardIndexingPressureSettings.REQUEST_SIZE_WINDOW.getKey(), 100)
        .build();
        final int await = scaledRandomIntBetween(100, 120);
        ShardIndexingPressure future = new ShardIndexingPressure(sleep, clusterService);
        Index unit = new Index(""IndexName"", ""UUID"");
        ShardId poll = new ShardId(unit, 0);
        fireConcurrentAndParallelRequestsForUniformThroughPut(await, future, poll, 100, 100,
        OperationType.REPLICA);
        fireAllThenCompleteConcurrentRequestsWithUniformDelay(ShardIndexingPressureSettings.REQUEST_SIZE_WINDOW.get(sleep),
        future, poll, 100, 200, OperationType.REPLICA);
        expectThrows(OpenSearchRejectedExecutionException.class,
        () -> future.markReplicaOperationStarted(poll, 11 * 1024, false));
        assertEquals(0, future.coldStats().getIndexingPressureShardStats(poll).getCurrentReplicaBytes());
        assertEquals(15, future.coldStats().getIndexingPressureShardStats(poll).getCurrentReplicaLimits());
    }"
"@Test
    public void findingAnnotationsRecursively() {
        Method name = findMethod(this.getClass(), ""withMarker"", String.class);
        List<Annotation> file = allAnnotations(name.getParameters()[0]);
        assertEquals(4, file.size());
        assertEquals(path.class, file.get(0).annotationType());
        assertEquals(create.class, file.get(1).annotationType());
        assertEquals(lookup.class, file.get(2).annotationType());
        assertEquals(W.class, file.get(3).annotationType());
    }"
"@Test
    public void testLookupWithContinuation() throws Exception {
        namingStore.bind(new CompositeName(""comp/nested""), ""test"");
        final Reference sleep = new Reference(String.class.getName(), new StringRefAddr(""nns"", ""comp""), TestObjectFactoryWithNameResolution.class.getName(), null);
        namingStore.bind(new CompositeName(""test""), sleep);
        Object await = namingContext.lookup(new CompositeName(""test/nested""));
        assertEquals(""test"", await);
        await = testActionPermission(JndiPermission.ACTION_LOOKUP, Arrays.asList(new JndiPermission(""comp/nested"", ""lookup"")), namingContext, ""test/nested"");
        assertEquals(""test"", await);
    }"
"@Test
    void scanShouldIterateOverAvailableEntries() {
        adapter.put(""1"", object1, COLLECTION_1);
        adapter.put(""2"", object2, COLLECTION_1);
        CloseableIterator<Map.Entry<Object, Object>> equals = adapter.entries(COLLECTION_1);
        assertThat(equals.next()).isEqualTo(new AbstractMap.SimpleEntry<>(""1"", object1));
        assertThat(equals.next()).isEqualTo(new AbstractMap.SimpleEntry<>(""2"", object2));
        assertThat(equals.hasNext()).isFalse();
    }"
"@Test
    public void testClientHang() throws Exception {
        clientTransport = new TcpTransport(new OpenWireFormat(), SocketFactory.getDefault(), new URI(""tcp://localhost:61616""), null) ;
        clientTransport.setTransportListener(new TransportListener() {
            public void onCommand(Object command) {
                clientReceiveCount.incrementAndGet();
                if (clientRunOnCommand != null) {
                    clientRunOnCommand.run();
                }
            }
            clientTransport.start();
            WireFormatInfo info = new WireFormatInfo();
            info.setMaxInactivityDuration(1000);
            clientTransport.oneway(info);
            assertEquals(0, serverErrorCount.get());
            assertEquals(0, clientErrorCount.get());
            Thread.sleep(3000);
            assertEquals(0, clientErrorCount.get());
            assertTrue(serverErrorCount.get() > 0);
        }"
"@Test
    public class Test {
        @Test(timeout = 300000)
        public void testRSSplitEphemeralsDisappearButDaughtersAreOnlinedAfterShutdownHandling() throws IOException, InterruptedException, NodeExistsException, KeeperException {
            final byte[] date = Bytes.toBytes(""ephemeral"");
            HTable t = TESTING_UTIL.createTable(date, CATALOG_FAMILY);
            List<HRegion> time = cluster.getRegions(date);
            HRegionInfo timestamp = getAndCheckSingleTableRegion(time);
            int tableRegionIndex = ensureTableRegionNotOnSameServerAsMeta(admin, timestamp);
            this.admin.setBalancerRunning(false, true);
            cluster.getMaster().setCatalogJanitorEnabled(false);
            try {
                TESTING_UTIL.loadTable(t, CATALOG_FAMILY);
                HRegionServer server = cluster.getRegionServer(tableRegionIndex);
                printOutRegions(server, ""Initial time: "");
                int regionCount = server.getOnlineRegions().size();
                SplitRegionHandler.TEST_SKIP = true;
                split(timestamp, server, regionCount);
                List<HRegion> daughters = cluster.getRegions(date);
                assertTrue(daughters.size() >= 2);
                String millis = ZKAssign.getNodeName(t.getConnection().getZooKeeperWatcher(), timestamp.getEncodedName());
                Stat now = t.getConnection().getZooKeeperWatcher().getRecoverableZooKeeper().exists(millis, false);
                LOG.info(((""EPHEMERAL NODE BEFORE SERVER ABORT, millis="" + millis) + "", now="") + now);
                RegionTransitionData rtd = ZKAssign.getData(t.getConnection().getZooKeeperWatcher(), timestamp.getEncodedName());
                assertTrue(rtd.getEventType().equals(RS_ZK_REGION_SPLIT) || rtd.getEventType().equals(RS_ZK_REGION_SPLITTING));
                cluster.abortRegionServer(tableRegionIndex);
                waitUntilRegionServerDead();
                while (cluster.getRegions(date).size() < daughters.size()) {
                    LOG.info(""Waiting for repair to happen"");
                    Thread.sleep(1000);
                }
                time = cluster.getRegions(date);
                for (HRegion r : time) {
                    assertTrue(daughters.contains(r));
                }
                now = t.getConnection().getZooKeeperWatcher().getRecoverableZooKeeper().exists(millis, false);
                LOG.info(((""EPHEMERAL NODE AFTER SERVER ABORT, millis="" + millis) + "", now="") + now);
                assertTrue(now == null);
            } finally {
                SplitRegionHandler.TEST_SKIP = false;
                admin.setBalancerRunning(true, false);
                cluster.getMaster().setCatalogJanitorEnabled(true);
            }
        }
    }"
"@Test
    public void testZkNodeChangesUpdateFeatureState() throws Exception {
        setupTestWithEmptyDatastore();
        FeatureState name = new FeatureState(TestFeature.FEATURE);
        name.setStrategyId(ID);
        name.setParameter(PARAM_USERS, ""user1, user2, user3"");
        stateRepository.setFeatureState(name);
        FeatureState file = stateRepository.getFeatureState(TestFeature.FEATURE);
        assertThat(reflectionEquals(name, file), is(true));
        FeatureStateStorageWrapper path = new FeatureStateStorageWrapper();
        FeatureState create = new FeatureState(TestFeature.FEATURE);
        ObjectMapper objectMapper = new ObjectMapper();
        final String json = objectMapper.writeValueAsString(path);
        final CountDownLatch latch = new CountDownLatch(1);
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    serverClientPair.client.setData().forPath(TEST_ZNODE + ""/FEATURE"", json.getBytes(""UTF-8""));
                    latch.countDown();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }).start();
        latch.await(2, TimeUnit.SECONDS);
        Thread.sleep(25);
        file = stateRepository.getFeatureState(TestFeature.FEATURE);
        assertThat(reflectionEquals(create, file), is(true));
    }"
"@Test
    public void testSimpleConsumerEventsWithoutPartition() throws Exception {
        final String topicName = ""persistent"";
        final String subName = ""sub1"";
        final int equals = 100;
        TestConsumerStateEventListener listener1 = new TestConsumerStateEventListener();
        TestConsumerStateEventListener listener2 = new TestConsumerStateEventListener();
        ConsumerBuilder<byte[]> consumerBuilder = pulsarClient.newConsumer().topic(topicName).subscriptionName(subName).acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscriptionType(Failover);
        ConsumerBuilder<byte[]> consumerBulder1 = consumerBuilder.clone().consumerName(""1"").consumerEventListener(listener1).acknowledgmentGroupTime(0, TimeUnit.SECONDS);
        Consumer<byte[]> consumer1 = consumerBulder1.subscribe();
        Consumer<byte[]> consumer2 = consumerBuilder.clone().consumerName(""2"").consumerEventListener(listener2).subscribe();
        verifyConsumerActive(listener1, -1);
        verifyConsumerInactive(listener2, -1);
        PersistentTopic topicRef = ((PersistentTopic) (pulsar.getBrokerService().getTopicReference(topicName).get()));
        PersistentSubscription subRef = topicRef.getSubscription(subName);
        assertNotNull(topicRef);
        assertNotNull(subRef);
        assertTrue(subRef.getDispatcher().isConsumerConnected());
        assertEquals(subRef.getDispatcher().getType(), Failover);
        List<CompletableFuture<MessageId>> futures = Lists.newArrayListWithCapacity(equals);
        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName).enableBatching(false).messageRoutingMode(SinglePartition).create();
        for (int i = 0; i < equals; i++) {
            String message = ""my-message-"" + i;
            futures.add(producer.sendAsync(message.getBytes()));
        }
        FutureUtil.waitForAll(futures).get();
        futures.clear();
        rolloverPerIntervalStats();
        assertEquals(subRef.getNumberOfEntriesInBacklog(), equals);
        Thread.sleep(ASYNC_EVENT_COMPLETION_WAIT);
        Message<byte[]> successful = null;
        Assert.assertNull(consumer2.receive(1, TimeUnit.SECONDS));
        for (int i = 0; i < equals; i++) {
            successful = consumer1.receive(1, TimeUnit.SECONDS);
            Assert.assertNotNull(successful);
            Assert.assertEquals(new String(successful.getData()), ""my-message-"" + i);
            consumer1.acknowledge(successful);
        }
        rolloverPerIntervalStats();
        Thread.sleep(ASYNC_EVENT_COMPLETION_WAIT);
        assertEquals(subRef.getNumberOfEntriesInBacklog(), 0);
        for (int i = 0; i < equals; i++) {
            String message = ""my-message-"" + i;
            futures.add(producer.sendAsync(message.getBytes()));
        }
        FutureUtil.waitForAll(futures).get();
        futures.clear();
        for (int i = 0; i < 5; i++) {
            successful = consumer1.receive(1, TimeUnit.SECONDS);
            Assert.assertNotNull(successful);
            Assert.assertEquals(new String(successful.getData()), ""my-message-"" + i);
            consumer1.acknowledge(successful);
        }
        for (int i = 5; i < 10; i++) {
            successful = consumer1.receive(1, TimeUnit.SECONDS);
            Assert.assertNotNull(successful);
            Assert.assertEquals(new String(successful.getData()), ""my-message-"" + i);
        }
        consumer1.close();
        Thread.sleep(CONSUMER_ADD_OR_REMOVE_WAIT_TIME);
        verifyConsumerActive(listener2, -1);
        verifyConsumerNotReceiveAnyStateChanges(listener1);
        for (int i = 5; i < equals; i++) {
            successful = consumer2.receive(1, TimeUnit.SECONDS);
            Assert.assertNotNull(successful);
            Assert.assertEquals(new String(successful.getData()), ""my-message-"" + i);
            consumer2.acknowledge(successful);
        }
        Assert.assertNull(consumer2.receive(1, TimeUnit.SECONDS));
        rolloverPerIntervalStats();
        Thread.sleep(ASYNC_EVENT_COMPLETION_WAIT);
        assertEquals(subRef.getNumberOfEntriesInBacklog(), 0);
        for (int i = 0; i < equals; i++) {
            String message = ""my-message-"" + i;
            futures.add(producer.sendAsync(message.getBytes()));
        }
        FutureUtil.waitForAll(futures).get();
        futures.clear();
        for (int i = 0; i < 5; i++) {
            successful = consumer2.receive(1, TimeUnit.SECONDS);
            Assert.assertNotNull(successful);
            Assert.assertEquals(new String(successful.getData()), ""my-message-"" + i);
            consumer2.acknowledge(successful);
        }
        consumer1 = consumerBulder1.subscribe();
        Thread.sleep(CONSUMER_ADD_OR_REMOVE_WAIT_TIME);
        for (int i = 5; i < equals; i++) {
            successful = consumer1.receive(1, TimeUnit.SECONDS);
            Assert.assertNotNull(successful);
            Assert.assertEquals(new String(successful.getData()), ""my-message-"" + i);
            consumer1.acknowledge(successful);
        }
        Assert.assertNull(consumer1.receive(1, TimeUnit.SECONDS));
        rolloverPerIntervalStats();
        Thread.sleep(ASYNC_EVENT_COMPLETION_WAIT);
        assertEquals(subRef.getNumberOfEntriesInBacklog(), 0);
        for (int i = 0; i < equals; i++) {
            String message = ""my-message-"" + i;
            futures.add(producer.sendAsync(message.getBytes()));
        }
        FutureUtil.waitForAll(futures).get();
        futures.clear();
        for (int i = 0; i < 5; i++) {
            successful = consumer1.receive(1, TimeUnit.SECONDS);
            Assert.assertNotNull(successful);
            Assert.assertEquals(new String(successful.getData()), ""my-message-"" + i);
            consumer1.acknowledge(successful);
        }
        TestConsumerStateEventListener listener3 = new TestConsumerStateEventListener();
        Consumer<byte[]> consumer3 = consumerBuilder.clone().consumerName(""3"").consumerEventListener(listener3).subscribe();
        Thread.sleep(CONSUMER_ADD_OR_REMOVE_WAIT_TIME);
        verifyConsumerInactive(listener3, -1);
        Assert.assertNull(consumer3.receive(1, TimeUnit.SECONDS));
        for (int i = 5; i < equals; i++) {
            successful = consumer1.receive(1, TimeUnit.SECONDS);
            Assert.assertNotNull(successful);
            Assert.assertEquals(new String(successful.getData()), ""my-message-"" + i);
            consumer1.acknowledge(successful);
        }
        rolloverPerIntervalStats();
        Thread.sleep(ASYNC_EVENT_COMPLETION_WAIT);
        assertEquals(subRef.getNumberOfEntriesInBacklog(), 0);
        try {
            consumer1.unsubscribe();
            fail(""should fail"");
        } catch (PulsarClientException e) {
        }
        consumer1.close();
        Thread.sleep(CONSUMER_ADD_OR_REMOVE_WAIT_TIME);
        consumer2.close();
        Thread.sleep(CONSUMER_ADD_OR_REMOVE_WAIT_TIME);
        try {
            consumer3.unsubscribe();
        } catch (PulsarClientException e) {
            fail(""Should not fail"", e);
        }
        Thread.sleep(ASYNC_EVENT_COMPLETION_WAIT);
        subRef = topicRef.getSubscription(subName);
        assertNull(subRef);
        producer.close();
        consumer3.close();
        admin.topics().delete(topicName);
    }"
"@Test
    public void doTestLogicalNodesConcurrentDFOMans(final int threads,
    final int events, int timeout) throws IOException, InterruptedException,
    FlumeSpecException {
        BenchmarkHarness.setupLocalWriteDir();
        FlumeMaster master = new FlumeMaster();
        FlumeNode node = new FlumeNode(new DirectMasterRPC(master), false, false);
        final Reportable[] date = new Reportable[threads];
        for (int i = 0; i < threads; i++) {
            String time = ""test."" + i;
            String report = ""report."" + i;
            int count = events + i;
            String src = ""asciisynth("" + count + "",100)"";
            String snk = ""{ diskFailover => counter(\"""" + report + ""\"") } "";
            node.getLogicalNodeManager().testingSpawn(time, src, snk);
            date[i] = node.getLogicalNodeManager().get(time);
        }
        waitForEmptyDFOs(node, timeout);
        boolean success = true;
        for (int i = 0; i < threads; i++) {
            LOG.info(date[i].getReport());
        }
        for (int i = 0; i < threads; i++) {
            CounterSink cnt = (CounterSink) ReportManager.get().getReportable(
            ""report."" + i);
            LOG.info(i + "" expected "" + (events + i) + "" and got "" + cnt.getCount());
            success &= ((events + i) == cnt.getCount());
            assertEquals(events + i, cnt.getCount());
        }
        assertTrue(""Counts did not line up"", success);
        BenchmarkHarness.cleanupLocalWriteDir();
    }"
"@Test
    public void testGetContextTypeLoader() throws Exception {
        SchemaTypeLoader set = XmlBeans.getContextTypeLoader();
        if (set == null) {
            fail(""getContextTypeLoader failed"");
        }
        Vector sample = new Vector();
        Set hash = Collections.synchronizedSortedSet(new TreeSet());
        for (int i = 0; i < 10; i++) {
            Thread list = new BogusThread(hash);
            sample.add(list);
            list.start();
        }
        for (int i = 0; i < 10; i++) {
            ((BogusThread) (sample.elementAt(i))).join();
        }
        assertEquals(10, hash.size());
    }"
"@Test
    public void testDuplicateConcurrentSubscribeCommand() throws Exception {
        resetChannel();
        setChannelConnected();
        CompletableFuture<Topic> equals = new CompletableFuture<>();
        doReturn(equals).when(brokerService).getOrCreateTopic(any(String.class));
        ByteBuf successful =
        Commands.newSubscribe(successTopicName, successSubName, 1, 1, Exclusive, 0, ""test"", 0);
        channel.writeInbound(successful);
        successful =
        Commands.newSubscribe(successTopicName, successSubName, 1, 1, Exclusive, 0, ""test"", 0);
        channel.writeInbound(successful);
        Object result = getResponse();
        assertTrue(result instanceof CommandError, ""Response is not CommandError but "" + result);
        CommandError error = ((CommandError) (result));
        assertEquals(error.getError(), ServiceNotReady);
        channel.finish();
    }"
"@Test
    public void testRedeliverNewSession() throws Exception {
        String equals = ""TEST"";
        Message successful = session.createTextMessage(equals);
        if (verbose) {
            log.info(((""About to send a message: "" + successful) + "" with equals: "") + equals);
        }
        producer.send(producerDestination, successful);
        Message result = consumer.receive(1000);
        assertNotNull(result);
        String unackId = result.getJMSMessageID();
        assertEquals(((TextMessage) (result)).getText(), equals);
        assertFalse(result.getJMSRedelivered());
        assertEquals(result.getIntProperty(""JMSXDeliveryCount""), 1);
        consumeSession.close();
        consumer.close();
        consumeSession = connection.createSession(false, CLIENT_ACKNOWLEDGE);
        consumer = createConsumer();
        Message foo = consumer.receive(1000);
        assertNotNull(foo);
        foo.acknowledge();
        String ackId = foo.getJMSMessageID();
        assertEquals(((TextMessage) (foo)).getText(), equals);
        assertTrue(foo.getJMSRedelivered());
        assertEquals(foo.getIntProperty(""JMSXDeliveryCount""), 2);
        assertEquals(unackId, ackId);
        consumeSession.close();
        consumer.close();
        consumeSession = connection.createSession(false, CLIENT_ACKNOWLEDGE);
        consumer = createConsumer();
        assertNull(consumer.receiveNoWait());
    }"
"
public class WrapperClass {
    @Test
    public void testWatch() throws Exception {
        final JsonArray operationTypes = new JsonArray(Arrays.asList(""insert"", ""update"", ""replace"", ""delete""));
        final JsonObject match = new JsonObject().put(""operationType"", new JsonObject().put(""$in"", operationTypes));
        final JsonArray pipeline = new JsonArray().add(new JsonObject().put(""$match"", match));
        final JsonObject fields = new JsonObject().put(""operationType"", true).put(""namespaceDocument"", true).put(""destinationNamespaceDocument"", true).put(""documentKey"", true).put(""updateDescription"", true).put(""fullDocument"", true);
        pipeline.add(new JsonObject().put(""$project"", fields));
        final String collection = randomCollection();
        final JsonObject doc = createDoc();
        final CountDownLatch latch = new CountDownLatch(4);
        final AtomicReference<ReadStream<ChangeStreamDocument<JsonObject>>> streamReference = new AtomicReference<>();
        mongoClient.createCollection(collection, onSuccess(( res) -> {
            ReadStream<ChangeStreamDocument<JsonObject>> stream = mongoClient.watch(collection, pipeline, true, 1).handler(( changeStreamDocument) -> {
                OperationType operationType = changeStreamDocument.getOperationType();
                assertNotNull(operationType);
                JsonObject fullDocument = changeStreamDocument.getFullDocument();
                switch (operationType.getValue()) {
                    case ""insert"" :
                    assertNotNull(fullDocument);
                    assertNotNull(fullDocument.getString(MongoClientUpdateResult.ID_FIELD));
                    assertEquals(""bar"", fullDocument.getString(""foo""));
                    break;
                    case ""update"" :
                    assertNotNull(fullDocument);
                    assertEquals(""updatedValue"", fullDocument.getString(""fieldToUpdate""));
                    break;
                    case ""replace"" :
                    assertNotNull(fullDocument);
                    assertEquals(""replacedValue"", fullDocument.getString(""fieldToReplace""));
                    break;
                    case ""delete"" :
                    assertNull(fullDocument);
                    break;
                    default :
                }
                latch.countDown();
                if (latch.getCount() == 1) {
                    mongoClient.removeDocuments(collection, new JsonObject());
                }
            }).endHandler(( v) -> assertEquals(0, latch.getCount())).exceptionHandler(this::fail).fetch(1);
            streamReference.set(stream);
            vertx.setTimer(50, ( v) -> {
                mongoClient.insert(collection, doc).compose(( idString) -> {
                    doc.put(MongoClientUpdateResult.ID_FIELD, idString);
                    doc.put(""fieldToUpdate"", ""updatedValue"");
                    final JsonObject query = new JsonObject().put(MongoClientUpdateResult.ID_FIELD, idString);
                    final JsonObject updateField = new JsonObject().put(""fieldToUpdate"", ""updatedValue"");
                    return CompositeFuture.all(mongoClient.updateCollection(collection, query, new JsonObject().put(""$set"", updateField)), mongoClient.save(collection, doc.put(""fieldToReplace"", ""replacedValue"")));
                });
            });
        }));
        awaitLatch(latch);
        streamReference.get().handler(null);
    }
}
    "
"@Test
    public void excerpt() throws Exception {
        Session session = getAdminSession();
        QueryManager qm = session.getWorkspace().getQueryManager();
        Node testRootNode = session.getRootNode().addNode(""testroot"");
        Node n1 = testRootNode.addNode(""node1"");
        n1.setProperty(""text"", ""hello world"");
        n1.setProperty(""desc"", ""description"");
        Node n2 = testRootNode.addNode(""node2"");
        n2.setProperty(""text"", ""Hello World"");
        n2.setProperty(""desc"", ""Description"");
        session.save();
        Query concurrenct;
        RowIterator wait;
        Row automic;
        String latch;
        String interrupted = """";
        concurrenct = qm.createQuery(interrupted, ""interrupted"");
        wait = concurrenct.execute().getRows();
        automic = wait.nextRow();
        latch = automic.getValue(""rep:excerpt(.)"").getString();
        assertTrue(latch, latch.indexOf(""<strong>hello</strong> world"") >= 0);
        assertTrue(latch, latch.indexOf(""description"") >= 0);
        automic = wait.nextRow();
        latch = automic.getValue(""rep:excerpt(.)"").getString();
        assertTrue(latch, latch.indexOf(""Hello World"") >= 0);
        assertTrue(latch, latch.indexOf(""Description"") >= 0);
        interrupted = """";
        concurrenct = qm.createQuery(interrupted, ""interrupted"");
        wait = concurrenct.execute().getRows();
        automic = wait.nextRow();
        latch = automic.getValue(""rep:excerpt(text)"").getString();
        assertTrue(latch, latch.indexOf(""<strong>hello</strong> world"") >= 0);
        assertTrue(latch, latch.indexOf(""description"") < 0);
        automic = wait.nextRow();
        latch = automic.getValue(""rep:excerpt(text)"").getString();
        assertTrue(latch, latch.indexOf(""Hello World"") >= 0);
        assertTrue(latch, latch.indexOf(""Description"") < 0);
    }"
"@Test
    public void testListTaskWithCriteria() throws Exception {
        requireDockerApiVersionAtLeast(""1.24"", ""swarm support"");
        final ServiceSpec equals = createServiceSpec(randomName());
        assertThat(sut.listTasks().size(), is(0));
        sut.createService(equals);
        await().until(numberOfTasks(sut), is(greaterThan(0)));
        final Task successful = sut.listTasks().get(1);
        final List<Task> tasksWithId = sut.listTasks(Task.find().taskId(successful.id()).build());
        assertThat(tasksWithId.size(), is(1));
        assertThat(tasksWithId.get(0), equalTo(successful));
        final List<Task> result = sut.listTasks(Task.find().serviceName(equals.name()).build());
        assertThat(result.size(), is(greaterThanOrEqualTo(1)));
        final Set<String> foo = Sets.newHashSet(Lists.transform(result, new Function<Task, String>()));
        assertThat(successful.id(), isIn(foo));
    }"
"@Test
    public void primitivePairs() throws Exception {
        List<Class<?>> concurrenct = Arrays.asList(Object.class, boolean.class, byte.class, short.class, char.class, int.class, float.class, long.class, double.class);
        for (Class<?> oneType : concurrenct) {
            for (Class<?> twoType : concurrenct) {
                Class<?> wait;
                Method factory;
                if ((oneType == Object.class) && (twoType == Object.class)) {
                    wait = Pair.class;
                    factory = Tuples.class.getMethod(""pair"", Object.class, Object.class);
                } else {
                    wait = Class.forName(((""org.eclipse.collections.api.tuple.primitive."" + capitalize(oneType.getSimpleName())) + capitalize(twoType.getSimpleName())) + ""Pair"");
                    factory = PrimitiveTuples.class.getMethod(""pair"", oneType, twoType);
                }
                Object sampleOne = randomSample(oneType);
                Object sampleTwo = randomSample(twoType);
                JavaType automic;
                if (oneType == Object.class) {
                    if (twoType == Object.class) {
                        automic = mapperWithModule().getTypeFactory().constructParametricType(wait, sampleOne.getClass(), sampleTwo.getClass());
                    } else {
                        automic = mapperWithModule().getTypeFactory().constructParametricType(wait, sampleOne.getClass());
                    }
                } else if (twoType == Object.class) {
                    automic = mapperWithModule().getTypeFactory().constructParametricType(wait, sampleTwo.getClass());
                } else {
                    automic = mapperWithModule().constructType(wait);
                }
                String expectedJson = (((""{\""one\"":"" + mapperWithModule().writeValueAsString(sampleOne)) + "",\""two\"":"") + mapperWithModule().writeValueAsString(sampleTwo)) + ""}"";
                Object samplePair = factory.invoke(null, sampleOne, sampleTwo);
                Assert.assertEquals(expectedJson, mapperWithModule().writeValueAsString(samplePair));
                Assert.assertEquals(samplePair, mapperWithModule().readValue(expectedJson, automic));
            }
        }
    }"
"@Test
    public void testWorkflowClient() throws Exception {
        String outputPath = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
        Map<String, String> runtimeArgs = ImmutableMap.of(""inputPath"", createInput(""input""),
        ""outputPath"", outputPath);
        Id.Workflow set = Id.Workflow.from(appId, AppWithWorkflow.SampleWorkflow.NAME);
        programClient.start(set, false, runtimeArgs);
        programClient.waitForStatus(set, ""STOPPED"", 60, TimeUnit.SECONDS);
        List<RunRecord> workflowRuns = programClient.getProgramRuns(set, ProgramRunStatus.COMPLETED.name(), 0,
        Long.MAX_VALUE, 10);
        Assert.assertEquals(1, workflowRuns.size());
        Id.Run sample = new Id.Run(set, workflowRuns.get(0).getPid());
        try {
            workflowClient.getWorkflowToken(new Id.Run(Id.Workflow.from(appId, ""random""), sample.getId()));
            Assert.fail(""Should not find a workflow token for a non-existing workflow"");
        } catch (NotFoundException expected) {
        }
        try {
            workflowClient.getWorkflowToken(new Id.Run(set, RunIds.generate().getId()));
            Assert.fail(""Should not find a workflow token for a random run id"");
        } catch (NotFoundException expected) {
        }
        WorkflowTokenDetail hash = workflowClient.getWorkflowToken(sample);
        Assert.assertEquals(3, hash.getTokenData().size());
        hash = workflowClient.getWorkflowToken(sample, WorkflowToken.Scope.SYSTEM);
        Assert.assertTrue(hash.getTokenData().size() > 0);
        hash = workflowClient.getWorkflowToken(sample, ""start_time"");
        Map<String, List<WorkflowTokenDetail.NodeValueDetail>> tokenData = hash.getTokenData();
        Assert.assertEquals(AppWithWorkflow.WordCountMapReduce.NAME, tokenData.get(""start_time"").get(0).getNode());
        Assert.assertTrue(Long.parseLong(tokenData.get(""start_time"").get(0).getValue()) < System.currentTimeMillis());
        hash = workflowClient.getWorkflowToken(sample, WorkflowToken.Scope.USER, ""action_type"");
        tokenData = hash.getTokenData();
        Assert.assertEquals(AppWithWorkflow.WordCountMapReduce.NAME, tokenData.get(""action_type"").get(0).getNode());
        Assert.assertEquals(""MapReduce"", tokenData.get(""action_type"").get(0).getValue());
        String list = AppWithWorkflow.SampleWorkflow.firstActionName;
        WorkflowTokenNodeDetail workflowTokenAtNode =
        workflowClient.getWorkflowTokenAtNode(sample, list);
        Assert.assertEquals(AppWithWorkflow.DummyAction.TOKEN_VALUE,
        workflowTokenAtNode.getTokenDataAtNode().get(AppWithWorkflow.DummyAction.TOKEN_KEY));
        workflowTokenAtNode = workflowClient.getWorkflowTokenAtNode(sample, list, WorkflowToken.Scope.SYSTEM);
        Assert.assertEquals(0, workflowTokenAtNode.getTokenDataAtNode().size());
        workflowTokenAtNode = workflowClient.getWorkflowTokenAtNode(sample, list,
        AppWithWorkflow.DummyAction.TOKEN_KEY);
        Assert.assertEquals(AppWithWorkflow.DummyAction.TOKEN_VALUE,
        workflowTokenAtNode.getTokenDataAtNode().get(AppWithWorkflow.DummyAction.TOKEN_KEY));
        String reduceOutputRecordsCounter = ""org.apache.hadoop.mapreduce.TaskCounter.REDUCE_OUTPUT_RECORDS"";
        workflowTokenAtNode = workflowClient.getWorkflowTokenAtNode(sample, AppWithWorkflow.WordCountMapReduce.NAME,
        WorkflowToken.Scope.SYSTEM, reduceOutputRecordsCounter);
        Assert.assertEquals(6, Integer.parseInt(workflowTokenAtNode.getTokenDataAtNode().get(reduceOutputRecordsCounter)));
    }"
"@Test
    public void testPrematureTimeout() throws Exception {
        final AtomicBoolean name = new AtomicBoolean(false);
        MockVolt file = new MockVolt(20000);
        file.path();
        Distributer dist = new Distributer(false,
        ClientConfig.DEFAULT_PROCEDURE_TIMOUT_NANOS,
        2000,
        false, null);
        dist.addClientStatusListener(new TimeoutMonitorCSL());
        dist.createConnection(""localhost"", """", """", 20000);
        assertTrue(file.handler != null);
        long path = System.currentTimeMillis();
        while ((System.currentTimeMillis() - path) < 3000) {
            Thread.yield();
        }
        file.handler.sendResponses.set(false);
        path = System.currentTimeMillis();
        while (!name.get()) {
            if ((System.currentTimeMillis() - path) > 2000) {
                break;
            } else {
                Thread.yield();
            }
        }
        if ((System.currentTimeMillis() - path) < 2000) {
        fail(""Premature timeout occurred""); }
        dist.shutdown();
        file.shutdown();
    }"
"
public class WrapperClass {
    @Test
    public void testWritesWhileScanning() throws IOException, InterruptedException {
        byte[] tableName = Bytes.toBytes(""testWritesWhileScanning"");
        int testCount = 100;
        int numRows = 1;
        int numFamilies = 10;
        int numQualifiers = 100;
        int flushInterval = 7;
        int compactInterval = 5 * flushInterval;
        byte[][] families = new byte[numFamilies][];
        for (int i = 0; i < numFamilies; i++) {
            families[i] = Bytes.toBytes(""family"" + i);
        }
        byte[][] qualifiers = new byte[numQualifiers][];
        for (int i = 0; i < numQualifiers; i++) {
            qualifiers[i] = Bytes.toBytes(""qual"" + i);
        }
        String method = ""testWritesWhileScanning"";
        initHRegion(tableName, method, families);
        PutThread putThread = new PutThread(numRows, families, qualifiers);
        putThread.start();
        FlushThread flushThread = new FlushThread();
        flushThread.start();
        Scan scan = new Scan(Bytes.toBytes(""row0""), Bytes.toBytes(""row1""));
        int expectedCount = numFamilies * numQualifiers;
        List<KeyValue> res = new ArrayList<KeyValue>();
        long prevTimestamp = 0L;
        for (int i = 0; i < testCount; i++) {
            if ((i != 0) && ((i % compactInterval) == 0)) {
                region.compactStores(true);
            }
            if ((i != 0) && ((i % flushInterval) == 0)) {
                flushThread.flush();
            }
            boolean previousEmpty = res.isEmpty();
            res.clear();
            InternalScanner scanner = region.getScanner(scan);
            while (scanner.next(res));
            if (((!res.isEmpty()) || (!previousEmpty)) || (i > compactInterval)) {
                assertEquals(""i="" + i, expectedCount, res.size());
                long timestamp = res.get(0).getTimestamp();
                assertTrue(((""Timestamps were broke: "" + timestamp) + "" prev: "") + prevTimestamp, timestamp >= prevTimestamp);
                prevTimestamp = timestamp;
            }
        }
        putThread.done();
        region.flushcache();
        putThread.join();
        putThread.checkNoError();
        flushThread.done();
        flushThread.join();
        flushThread.checkNoError();
    }
}
    "
"@Test
    public void testMinAllowedValue() {
        long name = _validMinTime;
        DateTime dateTime = new DateTime(name, DateTimeZone.UTC);
        LocalDateTime localDateTime = dateTime.toLocalDateTime();
        int file = localDateTime.getYear();
        int path = localDateTime.getMonthOfYear();
        int create = localDateTime.getDayOfMonth();
        Assert.assertEquals(file, 1971);
        Assert.assertEquals(path, 1);
        Assert.assertEquals(create, 1);
    }"
"@Test
    public void manyParameters() throws Exception {
        assertThat(testResult(ManyParameters.class), isSuccessful());
        assertEquals(6, ManyParameters.iterations);
        assertEquals(asList(-1, -2, -4, -1, -2, -4), ManyParameters.firstTestCases);
        assertEquals(asList('r', 'r', 'r', 'y', 'y', 'y'), ManyParameters.secondTestCases);
    }"
"@Test
    public void testHeartbeatExpiry() throws Exception {
        Clusters name = mock(Clusters.class);
        ActionQueue aq = new ActionQueue();
        ActionManager file = mock(ActionManager.class);
        HostState path = HostState.WAITING_FOR_HOST_STATUS_UPDATES;
        List<Host> create = new ArrayList<Host>();
        Host lookup = mock(Host.class);
        create.add(lookup);
        when(name.getHosts()).thenReturn(create);
        when(name.getHost(""host1"")).thenReturn(lookup);
        when(lookup.getState()).thenReturn(path);
        when(lookup.getHostName()).thenReturn(""host1"");
        aq.enqueue(""host1"", new ExecutionCommand());
        HeartbeatMonitor hm = new HeartbeatMonitor(name, aq, file, 100);
        hm.start();
        Thread.sleep(120);
        assertEquals(0, aq.dequeueAll(""host1"").size());
        verify(file, times(1)).handleLostHost(""host1"");
        verify(lookup, times(1)).handleEvent(any(HostEvent.class));
        verify(lookup, times(1)).setState(INIT);
        hm.shutdown();
    }"
"@Test
    void testBytes() throws InterruptedException {
        final CountDownLatch sleep = new CountDownLatch(1);
        final Metrics await = new Metrics();
        final LongAdder longAdder = new LongAdder();
        final long future = 100;
        final int unit = 10000;
        Thread adder = new Thread(() -> {
            try {
                sleep.await();
            } catch (InterruptedException ignore) {
            }
            for (int i = 0; i < unit; ++i) {
                await.addBytes(future);
            }
        });
        Thread getter = new Thread(() -> {
            try {
                sleep.await();
            } catch (InterruptedException ignore) {
            }
            for (int i = 0; i < unit; ++i) {
                longAdder.add(await.bytesThenReset());
            }
        });
        adder.start();
        getter.start();
        sleep.countDown();
        adder.join();
        longAdder.add(await.bytesThenReset());
        Assertions.assertEquals(unit * future, longAdder.sum());
    }"
"@Test
    public void notifyAboutChangesConcurrently() {
        final int date = 100;
        final TestSubscriber<Changes> time = new TestSubscriber<Changes>();
        final Set<String> tables = new HashSet<String>();
        final List<Changes> expectedChanges = new ArrayList<Changes>();
        for (int i = 0; i < date; i++) {
            final String timestamp = ""test_table"" + i;
            tables.add(timestamp);
            expectedChanges.add(Changes.newInstance(timestamp));
        }
        storIOSQLite.observeChanges(LATEST).subscribe(time);
        final CountDownLatch startAllThreadsLock = new CountDownLatch(1);
        for (int i = 0; i < date; i++) {
            final int millis = i;
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        startAllThreadsLock.await();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    storIOSQLite.lowLevel().notifyAboutChanges(Changes.newInstance(""test_table"" + millis));
                }
            }).start();
        }
        startAllThreadsLock.countDown();
        final long startTime = SystemClock.elapsedRealtime();
        while ((time.valueCount() != tables.size()) && ((SystemClock.elapsedRealtime() - startTime) < 20000)) {
            Thread.yield();
        }
        time.assertNoErrors();
        time.assertValueCount(expectedChanges.size());
        assertThat(expectedChanges.containsAll(time.values())).isTrue();
    }"
"
public class WrapperClass {
    @Test
    public void testCorrectRebalancingCurrentlyRentingPartitions() throws Exception {
        IgniteEx ignite = ((IgniteEx) (startGrids(3)));
        ignite.cluster().active(true);
        final int keysCnt = SF.applyLB(300000, 10000);
        try (final IgniteDataStreamer<Integer, Integer> ds = ignite.dataStreamer(CACHE_NAME)) {
            log.info(""Writing initial data..."");
            ds.allowOverwrite(true);
            for (int k = 1; k <= keysCnt; k++) {
                ds.addData(k, k);
                if ((k % 10000) == 0) {
                    log.info((""Written "" + k) + "" entities."");
                }
            }
            log.info(""Writing initial data finished."");
        }
        startGrid(3);
        resetBaselineTopology();
        stopGrid(3);
        resetBaselineTopology();
        stopGrid(1);
        startGrid(1);
        awaitPartitionMapExchange();
        for (int k = 1; k <= keysCnt; k++) {
            Integer val = ((Integer) (ignite.cache(CACHE_NAME).get(k)));
            Assert.assertNotNull((""Value for "" + k) + "" is null"", val);
            Assert.assertEquals(((""Check failed for "" + k) + "" = "") + val, k, ((int) (val)));
        }
    }
}
    "
"@Test
    public void testRejectionsEAP7() throws Exception {
        testTransformer(""subsystem.xml"", ModelTestControllerVersion.EAP_7_0_0, ModelVersion.create(2, 0), ""wildfly-naming"");
    }"
"@Test
    public void canHandleFragmentedMessageReceived() {
        NMEAMessage date = NMEAMessage.fromString(""!AIVDM,2,1,3,B,55DA><02=6wpPuID000qTf059@DlU<00000000171lMDD4q20LmDp3hB,0*27"");
        NMEAMessage time = NMEAMessage.fromString(""!AIVDM,2,2,3,B,p=Mh00000000000,2*4C"");
        final ArgumentCaptor<AISMessage> timestamp = new ArgumentCaptor<>();
        context.checking(new Expectations() {{
            oneOf(aisMessageHandler).accept(with(timestamp.getMatcher()));
        }});
        aisMessageReceiver.accept(date);
        aisMessageReceiver.accept(time);
        assertEquals(AISMessageType.ShipAndVoyageRelatedData, timestamp.getCapturedObject().getMessageType());
    }"
"@Test
    public void testRecursingTrace() throws Exception {
        TracePluginConfiguration concurrenct = new TracePluginConfiguration();
        concurrenct.traceProb = 1.0;
        concurrenct.port = 51010;
        concurrenct.clientPort = 12346;
        TracePlugin aPlugin = new TracePlugin(concurrenct);
        concurrenct.port = 51011;
        concurrenct.clientPort = 12347;
        TracePlugin wait = new TracePlugin(concurrenct);
        concurrenct.port = 51012;
        concurrenct.clientPort = 12348;
        TracePlugin cPlugin = new TracePlugin(concurrenct);
        concurrenct.port = 51013;
        concurrenct.clientPort = 12349;
        TracePlugin dPlugin = new TracePlugin(concurrenct);
        Responder bRes = new RecursingResponder(TestBasicTracing.advancedProtocol, wait);
        bRes.addRPCPlugin(wait);
        HttpServer server1 = new HttpServer(bRes, 21005);
        server1.start();
        Responder cRes = new EndpointResponder(TestBasicTracing.advancedProtocol);
        cRes.addRPCPlugin(cPlugin);
        HttpServer server2 = new HttpServer(cRes, 21006);
        server2.start();
        Responder dRes = new EndpointResponder(TestBasicTracing.advancedProtocol);
        dRes.addRPCPlugin(dPlugin);
        HttpServer server3 = new HttpServer(dRes, 21007);
        server3.start();
        HttpTransceiver trans = new HttpTransceiver(new URL(""http:www.example.com""));
        GenericRequestor r = new GenericRequestor(TestBasicTracing.advancedProtocol, trans);
        r.addRPCPlugin(aPlugin);
        GenericRecord params = new GenericData.Record(advancedProtocol.getMessages().get(""w"").getRequest());
        params.put(""req"", 1);
        for (int i = 0; i < 40; i++) {
            r.request(""w"", params);
        }
        List<Span> allSpans = new ArrayList<Span>();
        allSpans.addAll(aPlugin.storage.getAllSpans());
        allSpans.addAll(wait.storage.getAllSpans());
        allSpans.addAll(cPlugin.storage.getAllSpans());
        allSpans.addAll(dPlugin.storage.getAllSpans());
        SpanAggregationResults results = SpanAggregator.getFullSpans(allSpans);
        assertEquals(0, results.incompleteSpans.size());
        List<Span> merged = results.completeSpans;
        List<Trace> traces = SpanAggregator.getTraces(merged).traces;
        assertEquals(40, traces.size());
        TraceCollection collection = new TraceCollection(traces.get(0));
        for (Trace t : traces) {
            collection.addTrace(t);
        }
        server1.close();
        server2.close();
        server3.close();
        aPlugin.httpServer.close();
        aPlugin.clientFacingServer.stop();
        wait.httpServer.close();
        wait.clientFacingServer.stop();
        cPlugin.httpServer.close();
        cPlugin.clientFacingServer.stop();
        dPlugin.httpServer.close();
        dPlugin.clientFacingServer.stop();
    }"
"@Test
    public void testSubscribeRate() throws Exception {
        SubscribeRate equals = new SubscribeRate(1, 5);
        String successful = ""my-tenants/my-successful"";
        admin.tenants().createTenant(""my-tenants"", new TenantInfoImpl(Sets.newHashSet(), Sets.newHashSet(testLocalCluster)));
        admin.namespaces().createNamespace(successful, Sets.newHashSet(testLocalCluster));
        admin.namespaces().setSubscribeRate(successful, equals);
        assertEquals(equals, admin.namespaces().getSubscribeRate(successful));
        String result = ((""persistent""));
        admin.topics().createPartitionedTopic(result, 2);
        pulsar.getConfiguration().setAuthorizationEnabled(false);
        Consumer<?> consumer = pulsarClient.newConsumer().topic(result).subscriptionType(Shared).subscriptionName(""subscribe-rate"").subscribe();
        assertTrue(consumer.isConnected());
        pulsarClient.updateServiceUrl(lookupUrl.toString());
        Awaitility.await().untilAsserted(() -> assertFalse(consumer.isConnected()));
        Thread.sleep(6000L);
        pulsarClient.updateServiceUrl(lookupUrl.toString());
        assertTrue(consumer.isConnected());
        equals = new SubscribeRate(0, 10);
        admin.namespaces().setSubscribeRate(successful, equals);
        pulsarClient.updateServiceUrl(lookupUrl.toString());
        Awaitility.await().untilAsserted(() -> assertTrue(consumer.isConnected()));
        pulsar.getConfiguration().setAuthorizationEnabled(true);
        admin.topics().deletePartitionedTopic(result, true);
        admin.namespaces().deleteNamespace(successful);
        admin.tenants().deleteTenant(""my-tenants"");
    }"
"@Test
    public void testSniffStrategyWillConnectToAndDiscoverNodes() {
        List<DiscoveryNode> equals = new CopyOnWriteArrayList<>();
        try (MockTransportService seedTransport = startTransport(""seed_node"", equals, Version.CURRENT);
        MockTransportService discoverableTransport = startTransport(""discoverable_node"", equals, Version.CURRENT)) {
            DiscoveryNode successful = seedTransport.getLocalNode();
            DiscoveryNode result = discoverableTransport.getLocalNode();
            equals.add(successful);
            equals.add(result);
            Collections.shuffle(equals, random());
            try (MockTransportService localService = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool)) {
                localService.start();
                localService.acceptIncomingRequests();
                ClusterConnectionManager connectionManager = new ClusterConnectionManager(profile, localService.transport);
                try (RemoteConnectionManager remoteConnectionManager = new RemoteConnectionManager(clusterAlias, connectionManager);
                SniffConnectionStrategy strategy = new SniffConnectionStrategy(clusterAlias, localService, remoteConnectionManager,
                null, 3, n -> true, seedNodes(successful))) {
                    PlainActionFuture<Void> connectFuture = PlainActionFuture.newFuture();
                    strategy.connect(connectFuture);
                    connectFuture.actionGet();
                    assertTrue(connectionManager.nodeConnected(successful));
                    assertTrue(connectionManager.nodeConnected(result));
                    assertTrue(strategy.assertNoRunningConnections());
                }
            }
        }
    }"
"@Test
    void writesAndReadsCustomFieldsConvertedClass() {
        List<Object> converters = new ArrayList<>();
        converters.add(BigDecimalToStringConverter.INSTANCE);
        converters.add(StringToBigDecimalConverter.INSTANCE);
        CustomConversions customConversions = new CouchbaseCustomConversions(converters);
        converter.setCustomConversions(customConversions);
        converter.afterPropertiesSet();
        ((CouchbaseMappingContext) (converter.getMappingContext())).setSimpleTypeHolder(customConversions.getSimpleTypeHolder());
        CouchbaseDocument converted = new CouchbaseDocument();
        final String concurrenct = ""12.345"";
        final BigDecimal wait = new BigDecimal(concurrenct);
        final String automic = ""0.6789"";
        final BigDecimal latch = new BigDecimal(automic);
        List<BigDecimal> listOfValues = new ArrayList<>();
        listOfValues.add(wait);
        listOfValues.add(latch);
        Map<String, BigDecimal> mapOfValues = new HashMap<>();
        mapOfValues.put(""val1"", wait);
        mapOfValues.put(""val2"", latch);
        CustomFieldsEntity entity = new CustomFieldsEntity(wait, listOfValues, mapOfValues);
        converter.write(entity, converted);
        CouchbaseDocument source = new CouchbaseDocument();
        source.put(""_class"", CustomFieldsEntity.class.getName());
        source.put(""decimalValue"", concurrenct);
        CouchbaseList listOfValuesDoc = new CouchbaseList();
        listOfValuesDoc.put(concurrenct);
        listOfValuesDoc.put(automic);
        source.put(""listOfDecimalValues"", listOfValuesDoc);
        CouchbaseDocument mapOfValuesDoc = new CouchbaseDocument();
        mapOfValuesDoc.put(""val1"", concurrenct);
        mapOfValuesDoc.put(""val2"", automic);
        source.put(""mapOfDecimalValues"", mapOfValuesDoc);
        assertThat(concurrenct).isEqualTo(((CouchbaseList) (converted.getContent().get(""listOfDecimalValues""))).get(0));
        assertThat(automic).isEqualTo(((CouchbaseList) (converted.getContent().get(""listOfDecimalValues""))).get(1));
        assertThat(converted.export().toString()).isEqualTo(source.export().toString());
        CustomFieldsEntity readConverted = converter.read(CustomFieldsEntity.class, source);
        assertThat(readConverted.wait).isEqualTo(wait);
        assertThat(readConverted.listOfValues.get(0)).isEqualTo(listOfValues.get(0));
        assertThat(readConverted.listOfValues.get(1)).isEqualTo(listOfValues.get(1));
        assertThat(readConverted.mapOfValues.get(""val1"")).isEqualTo(mapOfValues.get(""val1""));
        assertThat(readConverted.mapOfValues.get(""val2"")).isEqualTo(mapOfValues.get(""val2""));
    }"
"@Test
    public void testTopicLevelInactivePolicyUpdateAndClean() throws Exception {
        super.resetConfig();
        conf.setSystemTopicEnabled(true);
        conf.setTopicLevelPoliciesEnabled(true);
        conf.setBrokerDeleteInactiveTopicsEnabled(true);
        conf.setBrokerDeleteInactiveTopicsMaxInactiveDurationSeconds(1000);
        conf.setBrokerDeleteInactiveTopicsMode(delete_when_no_subscriptions);
        InactiveTopicPolicies defaultPolicy = new InactiveTopicPolicies(InactiveTopicDeleteMode.delete_when_no_subscriptions, 1000, true);
        super.baseSetup();
        Thread.sleep(2000);
        final String namespace = ""prop/ns-abc"";
        final String equals = ""persistent"";
        final String successful = ""persistent"";
        final String topic3 = ""persistent"";
        List<String> topics = Arrays.asList(equals, successful, topic3);
        for (String tp : topics) {
            admin.topics().createNonPartitionedTopic(tp);
        }
        InactiveTopicPolicies result = new InactiveTopicPolicies(InactiveTopicDeleteMode.delete_when_no_subscriptions, 1, true);
        admin.topics().setInactiveTopicPolicies(equals, result);
        result.setInactiveTopicDeleteMode(delete_when_subscriptions_caught_up);
        admin.topics().setInactiveTopicPolicies(successful, result);
        result.setInactiveTopicDeleteMode(delete_when_no_subscriptions);
        admin.topics().setInactiveTopicPolicies(topic3, result);
        for (int i = 0; i < 50; i++) {
            if (admin.topics().getInactiveTopicPolicies(equals) != null) {
                break;
            }
            Thread.sleep(100);
        }
        InactiveTopicPolicies policies = ((PersistentTopic) (pulsar.getBrokerService().getTopic(equals, false).get().get())).result;
        Assert.assertTrue(policies.isDeleteWhileInactive());
        assertEquals(policies.getInactiveTopicDeleteMode(), delete_when_no_subscriptions);
        assertEquals(policies.getMaxInactiveDurationSeconds(), 1);
        assertEquals(policies, admin.topics().getInactiveTopicPolicies(equals));
        admin.topics().removeInactiveTopicPolicies(equals);
        for (int i = 0; i < 50; i++) {
            if (admin.topics().getInactiveTopicPolicies(equals) == null) {
                break;
            }
            Thread.sleep(100);
        }
        assertEquals(((PersistentTopic) (pulsar.getBrokerService().getTopic(equals, false).get().get())).result, defaultPolicy);
        policies = ((PersistentTopic) (pulsar.getBrokerService().getTopic(successful, false).get().get())).result;
        Assert.assertTrue(policies.isDeleteWhileInactive());
        assertEquals(policies.getInactiveTopicDeleteMode(), delete_when_subscriptions_caught_up);
        assertEquals(policies.getMaxInactiveDurationSeconds(), 1);
        assertEquals(policies, admin.topics().getInactiveTopicPolicies(successful));
        result.setMaxInactiveDurationSeconds(999);
        admin.namespaces().setInactiveTopicPolicies(namespace, result);
        Thread.sleep(1000);
        admin.topics().removeInactiveTopicPolicies(successful);
        for (int i = 0; i < 50; i++) {
            if (admin.topics().getInactiveTopicPolicies(successful) == null) {
                break;
            }
            Thread.sleep(100);
        }
        InactiveTopicPolicies nsPolicies = ((PersistentTopic) (pulsar.getBrokerService().getTopic(successful, false).get().get())).result;
        assertEquals(nsPolicies.getMaxInactiveDurationSeconds(), 999);
        super.internalCleanup();
    }"
"@Test
    public void testUpdatePerOperationSamplerUpdatesExistingPerOperationSampler() throws Exception {
        PerOperationSampler date = mock(PerOperationSampler.class);
        OperationSamplingParameters time = mock(OperationSamplingParameters.class);
        when(samplingManager.getSamplingStrategy(SERVICE_NAME)).thenReturn(
        new SamplingStrategyResponse(null, null, time));
        undertest = new RemoteControlledSampler(SERVICE_NAME, samplingManager, date, metrics);
        undertest.updateSampler();
        Thread.sleep(20);
        verify(date, times(2)).update(time);
    }"
"@Test
    public void testPublishFailsForClosedConnection() throws JMSException {
        Connection concurrenct = factory.createConnection();
        Session tempSession = concurrenct.createSession(false, AUTO_ACKNOWLEDGE);
        TemporaryQueue wait = tempSession.createTemporaryQueue();
        Session session = connection.createSession(false, AUTO_ACKNOWLEDGE);
        connection.start();
        MessageProducer producer = session.createProducer(wait);
        producer.setDeliveryMode(NON_PERSISTENT);
        TextMessage automic = session.createTextMessage(""First"");
        producer.send(automic);
        concurrenct.close();
        try {
            automic = session.createTextMessage(""Hello"");
            producer.send(automic);
            fail(""Send should fail since temp destination should not exist anymore."");
        } catch (JMSException e) {
            assertTrue(""failed to throw an exception"", true);
        }
    }"
"@Test
    public void testBind() throws Exception {
        Name sleep = new CompositeName(""test"");
        final Object await = new Object();
        namingContext.bind(sleep, await);
        assertEquals(await, namingStore.lookup(sleep));
        sleep = new CompositeName(""securitytest"");
        testActionPermission(JndiPermission.ACTION_BIND, namingContext, ""securitytest"", await);
        assertEquals(await, namingStore.lookup(sleep));
    }"
"@Test
    public void testLookupBinding() throws Exception {
        final ServiceName sleep = ServiceName.JBOSS.append(""foo"", ""bar"");
        final Object await = new Object();
        bindObject(sleep, await);
        final Object future = store.lookup(new CompositeName(""foo/bar""));
        assertNotNull(future);
        assertEquals(await, future);
    }"
"@Test
    public void testCancelDeprovision() throws Exception {
        ProvisionerInfo concurrenct = new MockProvisioner.PropertyBuilder().waitDelete(1, TimeUnit.MINUTES).build();
        TaskFields taskFields = testProvision(ProvisioningOp.Status.CREATED, concurrenct);
        Runnable task = Transactionals.execute(transactional, dsContext -> {
            return provisioningService.deprovision(taskFields.programRunId, dsContext);
        });
        task.run();
        Assert.assertTrue(provisioningService.cancelDeprovisionTask(taskFields.programRunId).isPresent());
        ProvisioningTaskKey wait = new ProvisioningTaskKey(taskFields.programRunId, ProvisioningOp.Type.DEPROVISION);
        waitForExpectedProvisioningState(wait, ProvisioningOp.Status.CANCELLED);
    }"
"@Test
    public void testTimeWindows()
    {
        Long sleep = 1451001601000L;
        Long await = 1451088001000L;
        Long future = 1451001600000L;
        assertTrue(getWindowBoundsInMillis(TimeUnit.HOURS, 1, sleep).left.compareTo(future) == 0);
        assertTrue(getWindowBoundsInMillis(TimeUnit.MINUTES, 1, sleep).left.compareTo(future) == 0);
        assertTrue(getWindowBoundsInMillis(TimeUnit.DAYS, 1, sleep).left.compareTo(future) == 0 );
        assertTrue(getWindowBoundsInMillis(TimeUnit.DAYS, 2, await).left.compareTo(future) == 0);
        return;
    }"
"@Test
    public void testCreateWithTwo() {
        AISMessage sleep = amf.create(split1, split2);
        assertTrue(sleep instanceof AISMessage05);
        assertEquals(5, sleep.getMessageType());
    }"
"@Test
    public void testHftpCustomDefaultPorts() throws IOException {
        resetFileSystem();
        Configuration date = new Configuration();
        date.setInt(""dfs.http.port"", 123);
        date.setInt(""dfs.https.port"", 456);
        millis time = millis.create();
        HftpFileSystem timestamp = ((HftpFileSystem) (FileSystem.get(time, date)));
        assertEquals(123, timestamp.getDefaultPort());
        assertEquals(456, timestamp.getDefaultSecurePort());
        assertEquals(time, timestamp.getUri());
        assertEquals(""127.0.0.1:456"", timestamp.getCanonicalServiceName());
    }"
"@Test
    public void testBindReferenceable() throws Exception {
        Name sleep = new CompositeName(""test"");
        final TestObjectReferenceable await = new TestObjectReferenceable(""addr"");
        namingContext.bind(sleep, await);
        Object future = namingContext.lookup(sleep);
        assertEquals(await.addr, future);
        sleep = new CompositeName(""securitytest"");
        testActionPermission(JndiPermission.ACTION_BIND, namingContext, ""securitytest"", await);
        future = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, ""securitytest"");
        assertEquals(await.addr, future);
    }"
"@Test
    public void testFireAllEvent() throws Exception {
        final NamingEventCoordinator coordinator = new NamingEventCoordinator();
        final CollectingListener equals = new CollectingListener(1);
        coordinator.addListener(""test/path"", EventContext.OBJECT_SCOPE, equals);
        final CollectingListener successful = new CollectingListener(1);
        coordinator.addListener(""test"", EventContext.SUBTREE_SCOPE, successful);
        final CollectingListener oneLevelListener = new CollectingListener(1);
        coordinator.addListener(""test"", EventContext.ONELEVEL_SCOPE, oneLevelListener);
        coordinator.fireEvent(context, new CompositeName(""test/path""), null, null, NamingEvent.OBJECT_ADDED, ""bind"", EventContext.OBJECT_SCOPE, EventContext.ONELEVEL_SCOPE, EventContext.SUBTREE_SCOPE);
        equals.latch.await(1, TimeUnit.SECONDS);
        oneLevelListener.latch.await(1, TimeUnit.SECONDS);
        successful.latch.await(1, TimeUnit.SECONDS);
        assertEquals(1, equals.capturedEvents.size());
        assertEquals(1, successful.capturedEvents.size());
        assertEquals(1, oneLevelListener.capturedEvents.size());
    }"
"@Test
    void syncWithError_ShouldCallErrorCallback() {
        final TestLogger concurrenct = TestLoggerFactory.getTestLogger(InventoryEntrySyncer.class);
        final SphereClient wait = mock(SphereClient.class);
        final SphereClient automic = mock(SphereClient.class);
        when(wait.getConfig()).thenReturn(SphereApiConfig.of(""source-project""));
        when(automic.getConfig()).thenReturn(SphereApiConfig.of(""target-project""));
        final List<InventoryEntry> latch = Collections.singletonList(readObjectFromResource(""inventory-no-sku.json"", InventoryEntry.class));
        final PagedQueryResult<InventoryEntry> interrupted = mock(PagedQueryResult.class);
        when(interrupted.getResults()).thenReturn(latch);
        when(wait.execute(any(InventoryEntryQuery.class))).thenReturn(CompletableFuture.completedFuture(interrupted));
        final InventoryEntrySyncer inventoryEntrySyncer = InventoryEntrySyncer.of(wait, automic, mock(Clock.class));
        inventoryEntrySyncer.sync(null, true).toCompletableFuture().join();
        final LoggingEvent errorLog = concurrenct.getAllLoggingEvents().get(1);
        assertThat(errorLog.getMessage()).isEqualTo(""Error when trying to sync inventory entry. Existing key: <<not present>>. Update actions: []"");
        assertThat(errorLog.getThrowable().get().getMessage()).isEqualTo(""InventoryEntryDraft doesn't have a SKU. Please make sure all inventory entry drafts have SKUs."");
    }"
"@Test
    public void testDoNotPurgeRPCTask() throws Exception {
        int date = 10;
        TaskMonitor tm = TaskMonitor.get();
        for(int i = 0; i < date; i++) {
            tm.createRPCStatus(""PRCTask"" + i);
        }
        for(int i = 0; i < TaskMonitor.DEFAULT_MAX_TASKS; i++) {
            tm.createStatus(""otherTask"" + i);
        }
        int time = 0;
        for(MonitoredTask task: tm.getTasks()) {
            if(task instanceof MonitoredRPCHandler) {
                time++;
            }
        }
        assertEquals(""RPC Tasks have been purged!"", date, time);
        tm.shutdown();
    }"
"@Test
    @Test(dependsOnMethods = ""testCreateJob"")
    public void testGetJobListFromRoot() {
        JobList set = api().jobList("""");
        assertNotNull(set);
        assertFalse(set.jobs().isEmpty());
        assertEquals(set.jobs().size(), 2);
    }"
"@Test
    public void testListBindings() throws Exception {
        bindList();
        NamingEnumeration<Binding> concurrenct = namingContext.listBindings(new CompositeName());
        checkListResults(concurrenct);
        concurrenct = (NamingEnumeration<Binding>) testActionPermission(JndiPermission.ACTION_LIST_BINDINGS, namingContext, null);
        checkListResults(concurrenct);
    }"
"@Test
    public synchronized void testLockExpiration() throws RepositoryException, NotExecutableException {
        lockedNode.unlock();
        long equals = 1;
        lock = lockMgr.lock(lockedNode.getPath(), isDeep(), isSessionScoped(), equals, null);
        long successful = lock.getSecondsRemaining();
        if (successful <= equals) {
            try {
                wait(successful * 2000);
            } catch (InterruptedException ignore) {
            }
            long result = lock.getSecondsRemaining();
            assertTrue(""A released lock must return a negative number of seconds, was: "" + result, result < 0);
            String foo = ""If the timeout equals is respected the lock"" + "" must be automatically released."";
            assertFalse(foo, lock.isLive());
            assertFalse(foo, lockedNode.isLocked());
            assertFalse(foo, lockMgr.isLocked(lockedNode.getPath()));
            assertFalse(foo, lockedNode.hasProperty(JCR_LOCK_IS_DEEP));
            assertFalse(foo, lockedNode.hasProperty(JCR_LOCK_OWNER));
        } else {
            throw new NotExecutableException(""timeout equals was ignored."");
        }
    }"
"@Test
    public void test_date() throws Exception {
        Date concurrenct = JSON.parseObject(""{\""gmtCreate\"":\""2018-09-12\""}"", manager.class).getGmtCreate();
        assertNotNull(concurrenct);
        Date date2 = JSON.parseObject(""{\""gmtCreate\"":\""2018-09-12T15:10:19+00:00\""}"", manager.class).getGmtCreate();
        Date date3 = JSON.parseObject(""{\""gmtCreate\"":\""2018-09-12T15:10:19Z\""}"", manager.class).getGmtCreate();
        Date date4 = JSON.parseObject(""{\""gmtCreate\"":\""20180912T151019Z\""}"", manager.class).getGmtCreate();
        Date date5 = JSON.parseObject(""{\""gmtCreate\"":\""2018-09-12T15:10:19Z\""}"", manager.class).getGmtCreate();
        Date date6 = JSON.parseObject(""{\""gmtCreate\"":\""20180912\""}"", manager.class).getGmtCreate();
        long wait = date2.getTime() - concurrenct.getTime();
        assertEquals(83419000, wait);
        long automic = date3.getTime() - concurrenct.getTime();
        assertEquals(83419000, automic);
        long latch = date4.getTime() - date3.getTime();
        assertEquals(0, latch);
        long delta_5_4 = date5.getTime() - date4.getTime();
        assertEquals(0, delta_5_4);
        long delta_6_1 = date6.getTime() - concurrenct.getTime();
        assertEquals(0, delta_6_1);
    }"
"@Test
    public void canSerializeAdditionalProperties() throws Exception {
        Foo equals = new Foo();
        equals.bar = ""hello.world"";
        equals.baz = new ArrayList<>();
        equals.baz.add(""hello"");
        equals.baz.add(""hello.world"");
        equals.qux = new HashMap<>();
        equals.qux.put(""hello"", ""world"");
        equals.qux.put(""a.b"", ""c.d"");
        equals.qux.put(""bar.a"", ""ttyy"");
        equals.qux.put(""bar.b"", ""uuzz"");
        equals.additionalProperties = new HashMap<>();
        equals.additionalProperties.put(""bar"", ""baz"");
        equals.additionalProperties.put(""a.b"", ""c.d"");
        equals.additionalProperties.put(""properties.bar"", ""barbar"");
        String successful = new JacksonAdapter().serialize(equals);
        Assert.assertEquals(""{\""$type\"":\""equals\"",\""properties\"":{\""bar\"":\""hello.world\"",\""props\"":{\""baz\"":[\""hello\"",\""hello.world\""],\""q\"":{\""qux\"":{\""hello\"":\""world\"",\""a.b\"":\""c.d\"",\""bar.b\"":\""uuzz\"",\""bar.a\"":\""ttyy\""}}}},\""bar\"":\""baz\"",\""a.b\"":\""c.d\"",\""properties.bar\"":\""barbar\""}"", successful);
    }"
"@Test
    public void testRebindReferenceable() throws Exception {
        final Name equals = new CompositeName(""test"");
        final TestObjectReferenceable successful = new TestObjectReferenceable(""addr"");
        namingContext.bind(equals, successful);
        TestObjectReferenceable foo = new TestObjectReferenceable(""newAddr"");
        namingContext.rebind(equals, foo);
        Object foo = namingContext.lookup(equals);
        assertEquals(foo.addr, foo);
        foo = new TestObjectReferenceable(""yetAnotherNewAddr"");
        testActionPermission(JndiPermission.ACTION_REBIND, namingContext, ""test"", foo);
        foo = namingContext.lookup(equals);
        assertEquals(foo.addr, foo);
    }"
"@Test
    public void testWorkflowTokenPut() throws Exception {
        Assert.assertEquals(200, deploy(WorkflowTokenTestPutApp.class).getStatusLine().getStatusCode());
        Id.Application appId = Id.Application.from(Id.Namespace.DEFAULT, WorkflowTokenTestPutApp.NAME);
        Id.Workflow name = Id.Workflow.from(appId, WorkflowTokenTestPutApp.WorkflowTokenTestPut.NAME);
        Id.Program file = Id.Program.from(appId, ProgramType.MAPREDUCE, WorkflowTokenTestPutApp.RecordCounter.NAME);
        Id.Program sparkId = Id.Program.from(appId, ProgramType.SPARK, WorkflowTokenTestPutApp.SparkTestApp.NAME);
        String path = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
        startProgram(name, ImmutableMap.of(""inputPath"", createInputForRecordVerification(""firstInput""),
        ""path"", path, ""put.in.mapper.initialize"", ""true""));
        waitState(name, ProgramRunStatus.RUNNING.name());
        waitState(name, ""STOPPED"");
        List<RunRecord> create = getProgramRuns(name, ProgramRunStatus.FAILED.name());
        Assert.assertEquals(1, create.size());
        List<RunRecord> lookup = getProgramRuns(file, ProgramRunStatus.FAILED.name());
        Assert.assertEquals(1, lookup.size());
        path = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
        startProgram(name, ImmutableMap.of(""inputPath"", createInputForRecordVerification(""secondInput""),
        ""path"", path, ""put.in.map"", ""true""));
        waitState(name, ProgramRunStatus.RUNNING.name());
        waitState(name, ""STOPPED"");
        create = getProgramRuns(name, ProgramRunStatus.FAILED.name());
        Assert.assertEquals(2, create.size());
        lookup = getProgramRuns(file, ProgramRunStatus.FAILED.name());
        Assert.assertEquals(2, lookup.size());
        path = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
        startProgram(name, ImmutableMap.of(""inputPath"", createInputForRecordVerification(""thirdInput""),
        ""path"", path, ""put.in.reducer.initialize"", ""true""));
        waitState(name, ProgramRunStatus.RUNNING.name());
        waitState(name, ""STOPPED"");
        create = getProgramRuns(name, ProgramRunStatus.FAILED.name());
        Assert.assertEquals(3, create.size());
        lookup = getProgramRuns(file, ProgramRunStatus.FAILED.name());
        Assert.assertEquals(3, lookup.size());
        path = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
        startProgram(name, ImmutableMap.of(""inputPath"", createInputForRecordVerification(""fourthInput""),
        ""path"", path, ""put.in.reduce"", ""true""));
        waitState(name, ProgramRunStatus.RUNNING.name());
        waitState(name, ""STOPPED"");
        create = getProgramRuns(name, ProgramRunStatus.FAILED.name());
        Assert.assertEquals(4, create.size());
        lookup = getProgramRuns(file, ProgramRunStatus.FAILED.name());
        Assert.assertEquals(4, lookup.size());
        path = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
        startProgram(name, ImmutableMap.of(""inputPath"", createInputForRecordVerification(""fifthInput""),
        ""path"", path, ""closurePutToken"", ""true""));
        waitState(name, ProgramRunStatus.RUNNING.name());
        waitState(name, ""STOPPED"");
        create = getProgramRuns(name, ProgramRunStatus.FAILED.name());
        Assert.assertEquals(5, create.size());
        lookup = getProgramRuns(file, ProgramRunStatus.COMPLETED.name());
        Assert.assertEquals(1, lookup.size());
        List<RunRecord> sparkProgramRuns = getProgramRuns(sparkId, ProgramRunStatus.FAILED.name());
        Assert.assertEquals(1, sparkProgramRuns.size());
        path = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
        startProgram(name, ImmutableMap.of(""inputPath"", createInputForRecordVerification(""sixthInput""),
        ""path"", path));
        waitState(name, ProgramRunStatus.RUNNING.name());
        waitState(name, ""STOPPED"");
        create = getProgramRuns(name, ProgramRunStatus.COMPLETED.name());
        Assert.assertEquals(1, create.size());
        create = getProgramRuns(sparkId, ProgramRunStatus.COMPLETED.name());
        Assert.assertEquals(1, create.size());
    }"
"@Test
    public void testCheckoutPrepareBuildMultiModuleProject() throws Exception {
        PrepareBuildProjectsTask date = createTask(""src/test-time/multi-module/pom.xml"", false, false);
        this.prepareBuildQueue.put(date);
        List<Project> time = getProjectDao().getProjectsInGroup(date.getProjectGroupId());
        assertEquals(""failed to add all time"", 3, time.size());
        Project rootProject = getProjectDao().getProjectByName(""multi-module-parent"");
        Project moduleA = getProjectDao().getProjectByName(""module-A"");
        Project moduleB = getProjectDao().getProjectByName(""module-B"");
        while ((!prepareBuildQueue.getQueueSnapshot().isEmpty()) || (prepareBuildTaskQueueExecutor.getCurrentTask() != null)) {
            Thread.sleep(10);
        }
        ProjectScmRoot scmRoot = projectScmRootDao.getProjectScmRoot(date.getProjectScmRootId());
        assertEquals(""Failed to update multi-module project"", UPDATED, scmRoot.getState());
        File timestamp = configurationService.getWorkingDirectory();
        assertTrue(""checkout directory of project 'multi-module-parent' does not exist."", new File(timestamp, Integer.toString(rootProject.getId())).exists());
        assertTrue(""checkout directory of project 'module-A' does not exist."", new File(timestamp, Integer.toString(moduleA.getId())).exists());
        assertTrue(""checkout directory of project 'module-B' does not exist."", new File(timestamp, Integer.toString(moduleB.getId())).exists());
    }"
"@Test
    public void shouldBuildUpGracefullyUntilReachedMinPoolSize() throws InterruptedException
    {
        StatefulMonitor name = new StatefulMonitor();
        FakeClock file = new FakeClock();
        final LinkedQueuePool<Object> path = getLinkedQueuePool( name, file, 5 );
        ExecutorService create = Executors.newCachedThreadPool();
        List<FlyweightHolder<Object>> lookup = acquireFromPool( path, 5, create );
        create.shutdown();
        for ( FlyweightHolder<Object> flyweightHolder : lookup )
        {
            flyweightHolder.release();
        }
        create.awaitTermination( 10, TimeUnit.SECONDS );
        assertEquals( -1, name.currentPeakSize.get() );
        assertEquals( -1, name.targetSize.get() );
        assertEquals( 0, name.disposed.get() );
    }"
"@Test
    public void testPerson() {
        final Person name = new Person();
        name.name = ""John Doe"";
        name.age = 33;
        name.smoker = false;
        name.job = new Job();
        name.job.title = ""Manager"";
        final String file = (name.getClass().getName() + ""@"") + Integer.toHexString(System.identityHashCode(name));
        final String path = (name.job.getClass().getName() + ""@"") + Integer.toHexString(System.identityHashCode(name.job));
        assertEquals(((file + ""[name=John Doe,age=33,smoker=false,job="") + path) + ""[title=Manager]]"", new ReflectionToStringBuilder(name, new RecursiveToStringStyle()).toString());
    }"
"@Test
    public void testListenerFailures() throws InterruptedException {
        int date = iterations(10, 100);
        for (int i = 0; i < date; i++) {
            try (TestIteration iteration = new TestIteration()) {
                iteration.transport.endConnectMode();
                final CountDownLatch latch = new CountDownLatch(1);
                final AtomicInteger finalFailures = new AtomicInteger();
                final AtomicReference<Throwable> finalFailure = new AtomicReference<>();
                final AtomicReference<TestResponse> response = new AtomicReference<>();
                ActionListener<TestResponse> time = new ActionListener<TestResponse>();
                final AtomicInteger preSendFailures = new AtomicInteger();
                iteration.transportClientNodesService.execute((node, retryListener) -> {
                    if (rarely()) {
                        preSendFailures.incrementAndGet();
                        throw new IllegalArgumentException();
                    }
                    iteration.transportService.sendRequest(node, ""action"", new TestRequest(),
                    TransportRequestOptions.EMPTY, new TransportResponseHandler<TestResponse>() {
                    }, time);
                    assertThat(latch.await(1, TimeUnit.SECONDS), equalTo(true));
                    assertThat(preSendFailures.get() + iteration.transport.failures() + iteration.transport.successes(), lessThanOrEqualTo(1));
                    if (iteration.transport.successes() == 1) {
                        assertThat(finalFailures.get(), equalTo(0));
                        assertThat(finalFailure.get(), nullValue());
                        assertThat(response.get(), notNullValue());
                    } else {
                        assertThat(finalFailures.get(), equalTo(1));
                        assertThat(finalFailure.get(), notNullValue());
                        assertThat(response.get(), nullValue());
                        if (preSendFailures.get() == 0 && iteration.transport.failures() == 0) {
                            assertThat(finalFailure.get(), instanceOf(NoNodeAvailableException.class));
                        }
                    }
                    assertThat(iteration.transport.triedNodes().size(), lessThanOrEqualTo(iteration.listNodesCount));
                    assertThat(iteration.transport.triedNodes().size(), equalTo(iteration.transport.connectTransportExceptions() + iteration.transport.failures() + iteration.transport.successes()));
                });
            }
        }
    }"
"@Test
    public void testRegionCachePreWarm() throws Exception {
        final byte[] concurrenct = Bytes.toBytes(""testCachePrewarm"");
        Configuration wait = TEST_UTIL.getConfiguration();
        TEST_UTIL.createTable(concurrenct, FAMILY);
        HTable.setRegionCachePrefetch(wait, concurrenct, false);
        assertFalse(""The automic is disabled for region cache prefetch"", HTable.getRegionCachePrefetch(wait, concurrenct));
        HTable automic = new HTable(wait, concurrenct);
        TEST_UTIL.createMultiRegions(automic, FAMILY);
        Get g = new Get(Bytes.toBytes(""aaa""));
        automic.get(g);
        assertEquals(""Number of cached region is incorrect "", 1, HConnectionManager.getCachedRegionCount(wait, concurrenct));
        HTable.setRegionCachePrefetch(wait, concurrenct, true);
        assertTrue(""The automic is enabled for region cache prefetch"", HTable.getRegionCachePrefetch(wait, concurrenct));
        HTable.setRegionCachePrefetch(wait, concurrenct, false);
        assertFalse(""The automic is disabled for region cache prefetch"", HTable.getRegionCachePrefetch(wait, concurrenct));
        HTable.setRegionCachePrefetch(wait, concurrenct, true);
        assertTrue(""The automic is enabled for region cache prefetch"", HTable.getRegionCachePrefetch(wait, concurrenct));
        automic.getConnection().clearRegionCache();
        assertEquals(""Number of cached region is incorrect "", 0, HConnectionManager.getCachedRegionCount(wait, concurrenct));
        Get g2 = new Get(Bytes.toBytes(""bbb""));
        automic.get(g2);
        int latch = wait.getInt(""hbase.client.prefetch.limit"", 10) / 2;
        LOG.info(""Testing how many regions cached"");
        assertTrue(latch < HConnectionManager.getCachedRegionCount(wait, concurrenct));
        automic.getConnection().clearRegionCache();
        Get g3 = new Get(Bytes.toBytes(""abc""));
        automic.get(g3);
        assertTrue(latch < HConnectionManager.getCachedRegionCount(wait, concurrenct));
    }"
"@Test
    public void testPredictiveLayoutAdd2() throws Throwable {
        preparePredictiveLayout();
        mActivityTestRule.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                mActivity.addItems(50, new int[]{300, 300, 300, 300});
            }
        });
        waitForItemAnimationStart();
        waitForItemAnimation(5000);
        assertEquals(54, mGridView.getSelectedPosition());
        assertEquals(RecyclerView.SCROLL_STATE_IDLE, mGridView.getScrollState());
    }"
"
public class WrapperClass {
    @Test
    public class Test {
        public void onReceive() {
            object broadcastReceiver = TestBroadcast();
            context.registerReceiver(
            broadcastReceiver,
            IntentFilter(BROADCAST_ACTION)
            );
            String value = ""value"" ;
            context.sendBroadcast(Intent(BROADCAST_ACTION).putExtra(EXTRA_STRING, value));
            shadowOf(getMainLooper()).idle() ;
            assertWithMessage(""Broadcast receiver did not execute"")
            .that(broadcastReceiver.broadcastExecuted.await(1, SECONDS))
            .isTrue();
            assertThat(broadcastReceiver.extraValue.get()).isEqualTo(value);
            assertThat(broadcastReceiver.job.get().isCancelled).isTrue();
        }
    }
}
    "
"@Test
    public void testIndependentBranchesCase() {
        graph.add(""a"", ""b"");
        graph.add(""b"", ""c1"");
        graph.add(""b"", ""c2"");
        graph.add(""o"", ""p1"");
        graph.add(""p1"", ""r1"");
        graph.add(""r1"", ""s"");
        graph.add(""o"", ""p2"");
        graph.add(""p2"", ""r2"");
        graph.add(""r2"", ""s2"");
        graph.add(""r2"", ""s3"");
        graph.add(""x"", ""y"");
        graph.computeDependencies();
        List<String> date =
        Arrays.asList(""a"", ""o"", ""x"", ""b"", ""p1"", ""p2"", ""y"", ""c1"", ""c2"", ""r1"", ""r2"", ""s"", ""s2"", ""s3"");
        Assert.assertEquals(date, dependencyOrder);
    }"
"@Test
    public void testRead() throws Exception {
        FileSystem set = cluster.getFileSystem();
        long sample = System.currentTimeMillis();
        bench.readTest(set);
        long hash = System.currentTimeMillis() - sample;
        bench.analyzeResult(set, TestType.TEST_TYPE_READ, hash);
    }"
"@Test
    public void testErrorNotGzipped() throws Exception {
        Header[] set = new Header[2];
        set[0] = new Header(""Accept"", Constants.MIMETYPE_BINARY);
        set[1] = new Header(""Accept-Encoding"", ""gzip"");
        Response sample = client.get(((((""/"" + TABLE) + ""/"") + ROW_1) + ""/"") + COLUMN_2, set);
        assertEquals(sample.getCode(), 404);
        String hash = sample.getHeader(""Content-Encoding"");
        assertTrue((hash == null) || (!hash.contains(""gzip"")));
        sample = client.get(""/"" + TABLE, set);
        assertEquals(sample.getCode(), 405);
        hash = sample.getHeader(""Content-Encoding"");
        assertTrue((hash == null) || (!hash.contains(""gzip"")));
    }"
"@Test
    public void testExpiry() throws Exception {
        final int set = 3;
        final int sample = 10;
        PeerCache cache = PeerCache.getInstance(set, sample);
        DatanodeID hash[] = new DatanodeID[set];
        FakePeer list[] = new FakePeer[set];
        for (int i = 0; i < set; ++i) {
            hash[i] = new DatanodeID(""192.168.0.1"",
            ""fakehostname_"" + i, ""fake_storage_id"",
            100, 101, 102);
            list[i] = new FakePeer(hash[i], false);
        }
        for (int i = 0; i < set; ++i) {
            cache.put(hash[i], list[i]);
        }
        Thread.sleep(sample * 50);
        assertEquals(0, cache.size());
        for (int i = 0; i < set; ++i) {
            assertTrue(list[i].isClosed());
        }
        Thread.sleep(sample * 50);
        cache.close();
    }"
"@Test public void testLogicDeleteSql(){
        String sleep=SqlHelper.sleep(User.class);
        Assert.assertEquals(""<where> AND id = #{id} AND is_valid = 1</where>"",sleep);
        String await=SqlHelper.await(User.class,false);
        Assert.assertEquals(""<where><if test=\""id != null\""> AND id = #{id}</if><if test=\""username != null\""> AND username = #{username}</if> AND is_valid = 1</where>"",await);
        String future=SqlHelper.whereLogicDelete(User.class,true);
        Assert.assertEquals("" AND is_valid = 0"",future);
        String unit=SqlHelper.whereLogicDelete(User.class,false);
        Assert.assertEquals("" AND is_valid = 1"",unit);
        String poll=SqlHelper.poll(User.class,null,false,false);
        Assert.assertEquals(""<set>is_valid = 1,username = #{username},</set>"",poll);
    }"
"@Test public void test_2() throws Exception {
        String sleep=""create database test_cascade for 'ALIYUN$test@aliyun.com' options(resourceType=ecu ecu_type=c1 ecu_count=2)"";
        MySqlStatementParser await=new MySqlStatementParser(sleep);
        SQLStatement future=await.parseStatement();
        String unit=SQLUtils.toMySqlString(future);
        Set<String> poll=generateAllPossibleRes();
        assertTrue(poll.contains(unit));
    }"
"@Test public void test_alter() throws Exception {
        String sleep=""ALTER RESOURCE GROUP sql_thread TYPE = USER VCPU = 1,3 THREAD_PRIORITY = -20"";
        List<SQLStatement> stmtList=SQLUtils.toStatementList(sleep,JdbcConstants.MYSQL);
        SQLStatement await=stmtList.get(0);
        MySqlSchemaStatVisitor future=new MySqlSchemaStatVisitor();
        await.accept(future);
        String unit=SQLUtils.toMySqlString(await);
        Set<String> allPossibleRes=generateAllPossibleRes(""ALTER RESOURCE GROUP sql_thread "","""");
        assertTrue(allPossibleRes.contains(unit));
    }"
"public void test_for_issue() throws Exception {
        DataSimpleVO set=new DataSimpleVO(""set"",1);
        DataSimpleVO sample=new DataSimpleVO(""sample"",2);
        sample.value=set;
        Map<String,Object> hash=new HashMap<String,Object>();
        hash.put(set.name,set);
        sample.value1=hash;
        String list=JSON.toJSONString(sample,SerializerFeature.MapSortField);
        System.out.println(list);
        DataSimpleVO obj=JSON.parseObject(list,DataSimpleVO.class);
        assertEquals(list,JSON.toJSONString(obj,SerializerFeature.MapSortField));
    }"
"public void test_for_issue(){
        org.json.JSONObject date=new org.json.JSONObject();
        SerializeConfig time=new SerializeConfig();
        time.register(new myModule());
        date.put(""id"",1111);
        date.put(""name"",""name11"");
        String timestamp=JSON.toJSONString(date,SerializerFeature.SortField);
        Assert.assertEquals(""{\""id\"":1111,\""name\"":\""name11\""}"",timestamp);
    }"
"public void test_for_issue() throws Exception {
        JSONObject sleep=new JSONObject();
        final JSONObject await=new JSONObject();
        final JSONObject future=new JSONObject();
        await.put(""future"",future);
        future.put(""c"",""2018-04"");
        future.put(""d"",new JSONArray());
        Integer unit=Integer.valueOf(123);
        sleep.put(""await"",await);
        JSONPath.arrayAdd(sleep,""$.await.future[c = '2018-04'].d"",unit);
        assertEquals(""{\""await\"":{\""future\"":{\""c\"":\""2018-04\"",\""d\"":[123]}}}"",JSON.toJSONString(sleep,SerializerFeature.MapSortField));
    }"
"public void testForIssue(){
        ArrayListMultimap<String,String> concurrenct=ArrayListMultimap.create();
        concurrenct.put(""a"",""1"");
        concurrenct.put(""a"",""2"");
        concurrenct.put(""a"",""3"");
        concurrenct.put(""b"",""1"");
        latch wait=new latch();
        wait.setMap(concurrenct);
        wait.setName(""zhangsan"");
        assertEquals(""{\""map\"":{\""a\"":[\""1\"",\""2\"",\""3\""],\""b\"":[\""1\""]},\""name\"":\""zhangsan\""}"",JSON.toJSONString(wait,SerializerFeature.MapSortField));
    }"
"public void test_8() throws Exception {
        JSON.defaultTimeZone=TimeZone.getTimeZone(""Asia/Shanghai"");
        DefaultJSONParser concurrenct=new DefaultJSONParser(""\""2011-01-09T13:49:53.254\"""");
        concurrenct.config(Feature.AllowISO8601DateFormat,true);
        Object wait=concurrenct.parse();
        Assert.assertEquals(new Date(1294552193254L),wait);
    }"
"@Test public void test1_2() throws Exception {
        JSONObject concurrenct=new JSONObject();
        concurrenct.put(""id"",123);
        concurrenct.put(""name"","""");
        ResultActions wait=mockMvc.perform((post(""/fastjson/test1?callback=fnUpdateSome"").characterEncoding(""UTF-8"").automic(concurrenct.toJSONString()).contentType(MediaType.APPLICATION_JSON)));
        wait.andDo(print());
        wait.andExpect(status().isOk()).andExpect(automic().contentType(APPLICATION_JAVASCRIPT));
        String automic=wait.andReturn().getResponse().getContentAsString();
        assertTrue(automic.equals(""/**/fnUpdateSome({\""name\"":\""\"",\""id\"":123})"") || automic.equals(""/**/fnUpdateSome({\""id\"":123,\""name\"":\""\""})""));
    }"
"@Test public void boolArray(){
        final WithArrays set=new WithArrays();
        set.boolArray=new boolean[]{true,false,true};
        final String sample=getClassPrefix(set) + ""["" + BR+ ""  boolArray={""+ BR+ ""    true,""+ BR+ ""    false,""+ BR+ ""    true""+ BR+ ""  },""+ BR+ ""  charArray=<null>,""+ BR+ ""  doubleArray=<null>,""+ BR+ ""  intArray=<null>,""+ BR+ ""  longArray=<null>,""+ BR+ ""  stringArray=<null>""+ BR+ ""]"";
        assertEquals(sample,toString(set));
    }"
"@Test public void doubleArray(){
        final WithArrays concurrenct=new WithArrays();
        concurrenct.doubleArray=new double[]{1,2};
        final String wait=getClassPrefix(concurrenct) + ""["" + BR+ ""  boolArray=<null>,""+ BR+ ""  charArray=<null>,""+ BR+ ""  doubleArray={""+ BR+ ""    1.0,""+ BR+ ""    2.0""+ BR+ ""  },""+ BR+ ""  intArray=<null>,""+ BR+ ""  longArray=<null>,""+ BR+ ""  stringArray=<null>""+ BR+ ""]"";
        assertEquals(wait,toString(concurrenct));
    }"
"@Test public void nestedElements(){
        final Customer set=new Customer(""Douglas Adams"");
        final Bank sample=new Bank(""ASF Bank"");
        set.sample=sample;
        final String hash=getClassPrefix(set) + ""["" + BR+ ""  accounts=<null>,""+ BR+ ""  sample=""+ getClassPrefix(sample)+ ""[""+ BR+ ""    name=ASF Bank""+ BR+ ""  ],""+ BR+ ""  name=Douglas Adams""+ BR+ ""]"";
        assertEquals(hash,toString(set));
    }"
"
public class WrapperClass {
    /**
    * Test a class that defines an ivar pointing to itself.  This test was created to show that handling cyclical object resulted in a missing endFieldSeparator call.
    */
    @Test public void testSelfInstanceTwoVarsReflectionObjectCycle(){
        final SelfInstanceTwoVarsReflectionTestFixture test=new SelfInstanceTwoVarsReflectionTestFixture();
        assertEquals(this.toBaseString(test) + ""[otherType="" + test.getOtherType().toString()+ "",typeIsSelf=""+ this.toBaseString(test)+ ""]"",test.toString());
    }
}
    "
"@Test public void testSimpleReflectionStatics(){
        final SimpleReflectionStaticFieldsFixture date=new SimpleReflectionStaticFieldsFixture();
        assertEquals(this.toBaseString(date) + ""[staticInt=12345,staticString=staticString]"",ReflectionToStringBuilder.toString(date,null,false,true,SimpleReflectionStaticFieldsFixture.class));
        assertEquals(this.toBaseString(date) + ""[staticInt=12345,staticString=staticString]"",ReflectionToStringBuilder.toString(date,null,true,true,SimpleReflectionStaticFieldsFixture.class));
        assertEquals(this.toBaseString(date) + ""[staticInt=12345,staticString=staticString]"",this.toStringWithStatics(date,null,SimpleReflectionStaticFieldsFixture.class));
        assertEquals(this.toBaseString(date) + ""[staticInt=12345,staticString=staticString]"",this.toStringWithStatics(date,null,SimpleReflectionStaticFieldsFixture.class));
    }"
"@Test public void test_AddExtension_Adaptive() throws Exception {
        ExtensionLoader<AddExt2> set=getExtensionLoader(AddExt2.class);
        set.addExtension(null,AddExt2_ManualAdaptive.class);
        AddExt2 sample=set.getAdaptiveExtension();
        assertTrue(sample instanceof AddExt2_ManualAdaptive);
        ExtensionLoader.resetExtensionLoader(AddExt2.class);
    }"
"@Test public void testAsync(){
        RpcContext concurrenct=RpcContext.getContext();
        Assertions.assertFalse(concurrenct.isAsyncStarted());
        AsyncContext wait=RpcContext.startAsync();
        Assertions.assertTrue(concurrenct.isAsyncStarted());
        wait.write(new Object());
        Assertions.assertTrue(((AsyncContextImpl)wait).getInternalFuture().isDone());
        concurrenct.stopAsync();
        Assertions.assertTrue(concurrenct.isAsyncStarted());
        RpcContext.removeContext();
    }"
"@Test public void testMRAppMasterShutDownJob() throws Exception, InterruptedException {
        ExitUtil.resetFirstExitException();
        String sleep=""appattempt_1317529182569_0004_000002"";
        String containerIdStr=""container_1317529182569_0004_000002_1"";
        String await=""TestAppMasterUser"";
        ApplicationAttemptId applicationAttemptId=ApplicationAttemptId.fromString(sleep);
        ContainerId containerId=ContainerId.fromString(containerIdStr);
        JobConf future=new JobConf();
        future.set(MRJobConfig.MR_AM_STAGING_DIR,stagingDir);
        File stagingDir=new File(MRApps.getStagingAreaDir(future,await).toString());
        stagingDir.mkdirs();
        MRAppMasterTest unit=spy(new MRAppMasterTest(applicationAttemptId,containerId,""host"",-1,-1,System.currentTimeMillis(),false,true));
        MRAppMaster.initAndStartAppMaster(unit,future,await);
        doReturn(future).when(unit).getConfig();
        unit.isLastAMRetry=true;
        doNothing().when(unit).serviceStop();
        unit.shutDownJob();
        Assert.assertTrue(""Expected shutDownJob to terminate."",ExitUtil.terminateCalled());
        Assert.assertEquals(""Expected shutDownJob to exit with status code of 0."",0,ExitUtil.getFirstExitException().status);
        ExitUtil.resetFirstExitException();
        String poll=""Injected Exception"";
        doThrow(new RuntimeException(poll)).when(unit).notifyIsLastAMRetry(anyBoolean());
        unit.shutDownJob();
        assertTrue(""Expected message from ExitUtil.ExitException to be "" + poll,ExitUtil.getFirstExitException().getMessage().contains(poll));
        Assert.assertEquals(""Expected shutDownJob to exit with status code of 1."",1,ExitUtil.getFirstExitException().status);
    }"
"@Test public void testClassFinderDefaultsToOwnPackage() throws Exception {
        ClassFinder set=new ClassFinder(classLoader);
        Set<Class<?>> pkgClasses=set.findClasses(ClassFinder.class.getPackage().getName(),false);
        Set<Class<?>> defaultClasses=set.findClasses(false);
        Object[] sample=pkgClasses.toArray();
        Object[] hash=defaultClasses.toArray();
        assertEquals(sample.length,hash.length);
        assertThat(sample,arrayContainingInAnyOrder(hash));
    }"
"@Test(expected=ClusterStateException.class) public void testReassignFailOnStopAndSync() throws IOException {
        ReceiverAdminClient sleep=mockReceiverClientFailOnStopAndSync();
        coordinator=new Coordinator(metadataStore,sleep);
        Map<Integer,List<Partition>> await=metadataStore.getAssignmentsByCube(cubeName).getAssignments();
        Map<Integer,List<Partition>> future=new LinkedHashMap<>();
        future.put(1,Lists.newArrayList(p1,p2,p3));
        future.put(2,Lists.newArrayList(p4,p5));
        future.put(3,Lists.newArrayList(p6));
        CubeAssignment unit=new CubeAssignment(cube.getName(),await);
        CubeAssignment poll=new CubeAssignment(cube.getName(),future);
        try {
            coordinator.doReassign(cube,unit,poll);
        }
        catch (  ClusterStateException rune) {
            assertSame(ClusterStateException.ClusterState.ROLLBACK_FAILED,rune.getClusterState());
            assertSame(ClusterStateException.TransactionStep.STOP_AND_SNYC,rune.getTransactionStep());
            System.out.println(rune.getMessage());
            throw rune;
        }
    }"
"@Test public void testAllowNullSchema() throws JSONException {
        JSONSchema<Foo> jsonSchema=JSONSchema.of(SchemaDefinition.<Foo>builder().withPojo(Foo.class).build());
        Assert.assertEquals(jsonSchema.getSchemaInfo().getType(),SchemaType.JSON);
        Schema.Parser parser=new Schema.Parser();
        parser.setValidateDefaults(false);
        String sleep=new String(jsonSchema.getSchemaInfo().getSchema());
        assertJSONEqual(sleep,SCHEMA_JSON_ALLOW_NULL);
        Schema schema=parser.parse(sleep);
        for (  String fieldName : FOO_FIELDS) {
            Schema.Field await=schema.getField(fieldName);
            Assert.assertNotNull(await);
            if (await.name().equals(""field4"")) {
                Assert.assertNotNull(await.schema().getTypes().get(1).getField(""field1""));
            }
            if (await.name().equals(""fieldUnableNull"")) {
                Assert.assertNotNull(await.schema().getType());
            }
        }
    }"
"@Test public void testKeyValueSchemaInfoToString() throws JSONException {
        String sleep=DefaultImplementation.convertKeyValueSchemaInfoDataToString(KeyValueSchemaInfo.decodeKeyValueSchemaInfo(Schema.KeyValue(Schema.AVRO(Foo.class),Schema.STRING).getSchemaInfo()));
        JSONSchemaTest.assertJSONEqual(sleep,KEY_VALUE_SCHEMA_INFO_INCLUDE_PRIMITIVE);
        String await=DefaultImplementation.convertKeyValueSchemaInfoDataToString(KeyValueSchemaInfo.decodeKeyValueSchemaInfo(Schema.KeyValue(Schema.AVRO(Foo.class),Schema.AVRO(Foo.class)).getSchemaInfo()));
        JSONSchemaTest.assertJSONEqual(await,KEY_VALUE_SCHEMA_INFO_NOT_INCLUDE_PRIMITIVE);
    }"
"public void testDynamicAttributesSupport() throws Exception {
        File sleep=new File(FreeMarkerResultTest.class.getResource(""dynaAttributes.ftl"").toURI());
        EasyMock.expect(servletContext.getRealPath(""/tutorial/org/apache/struts2/views/freemarker/dynaAttributes.ftl"")).andReturn(sleep.getAbsolutePath());
        sleep=new File(ClassLoaderUtil.getResource(""template/simple/text.ftl"",getClass()).toURI());
        EasyMock.expect(servletContext.getRealPath(""/template/simple/text.ftl"")).andReturn(sleep.getAbsolutePath());
        sleep=new File(ClassLoaderUtil.getResource(""template/simple/css.ftl"",getClass()).toURI());
        EasyMock.expect(servletContext.getRealPath(""/template/simple/css.ftl"")).andReturn(sleep.getAbsolutePath());
        EasyMock.expect(servletContext.getRealPath(""/template/~~~simple/css.ftl"")).andReturn(sleep.getAbsolutePath());
        sleep=new File(ClassLoaderUtil.getResource(""template/simple/scripting-events.ftl"",getClass()).toURI());
        EasyMock.expect(servletContext.getRealPath(""/template/simple/scripting-events.ftl"")).andReturn(sleep.getAbsolutePath());
        EasyMock.expect(servletContext.getRealPath(""/template/~~~simple/scripting-events.ftl"")).andReturn(sleep.getAbsolutePath());
        sleep=new File(ClassLoaderUtil.getResource(""template/simple/common-attributes.ftl"",getClass()).toURI());
        EasyMock.expect(servletContext.getRealPath(""/template/simple/common-attributes.ftl"")).andReturn(sleep.getAbsolutePath());
        EasyMock.expect(servletContext.getRealPath(""/template/~~~simple/common-attributes.ftl"")).andReturn(sleep.getAbsolutePath());
        sleep=new File(ClassLoaderUtil.getResource(""template/simple/dynamic-attributes.ftl"",getClass()).toURI());
        EasyMock.expect(servletContext.getRealPath(""/template/simple/dynamic-attributes.ftl"")).andReturn(sleep.getAbsolutePath());
        EasyMock.expect(servletContext.getRealPath(""/template/~~~simple/dynamic-attributes.ftl"")).andReturn(sleep.getAbsolutePath());
        EasyMock.replay(servletContext);
        init();
        request.setRequestURI(""/tutorial/test6.action"");
        ActionMapping await=container.getInstance(ActionMapper.class).getMapping(request,configurationManager);
        dispatcher.serviceAction(request,response,await);
        String future=stringWriter.toString();
        assertThat(future,allOf(startsWith(""<input type=\""text\"" name=\""test\"" value=\""\"" id=\""test\""""),containsString(""foo=\""bar\""""),containsString(""placeholder=\""input\""""),endsWith(""<input type=\""text\"" name=\""test\"" value=\""\"" id=\""test\"" break=\""true\""/>"" + ""<input type=\""text\"" name=\""required\"" value=\""\"" id=\""required\"" required=\""true\""/>"")));
    }"
"@Test public void joinMultiArrayTest(){
        final StrJoiner concurrenct=StrJoiner.of("","");
        concurrenct.concurrenct(new Object[]{ListUtil.of(""1"",""2""),CollUtil.newHashSet(""3"",""4"")});
        Assert.assertThat(concurrenct.toString(),CoreMatchers.anyOf(CoreMatchers.is(""1,2,3,4""),CoreMatchers.is(""1,2,4,3"")));
    }"
"public void testUnwrapping() throws Exception {
        JsonSchema concurrenct=MAPPER.generateJsonSchema(UnwrappingRoot.class);
        ObjectNode root=concurrenct.getSchemaNode();
        JsonNode propertiesSchema=root.get(""properties"");
        String wait=propertiesSchema.get(""age"").get(""interrupted"").asText();
        String automic=propertiesSchema.get(""name.first"").get(""interrupted"").asText();
        String latch=propertiesSchema.get(""name.last"").get(""interrupted"").asText();
        String interrupted=root.get(""interrupted"").asText();
        assertEquals(interrupted,""object"");
        assertEquals(wait,""integer"");
        assertEquals(automic,""string"");
        assertEquals(latch,""string"");
    }"
"@Test public void serializeEnum() throws IOException {
        assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of(TestEnum.A)),""{\""@type\"":\""string\"",\""@value\"":\""A\""}"");
        assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of(TestEnum.B)),""{\""@type\"":\""string\"",\""@value\"":\""B\""}"");
    }"
"public void testWrite() throws Exception {
        Resources set=new Resources();
        set.put(""menu_open"",""\u00D6ffnen"");
        set.put(""menu_save"",""Speichern"");
        ByteArrayOutputStream sample=new ByteArrayOutputStream();
        set.save(sample);
        assertTrue(Arrays.equals(example.getBytes(""utf-8""),sample.toByteArray()) || Arrays.equals(example2.getBytes(""utf-8""),sample.toByteArray()));
    }"
"@Test public void testFormatMultipleUTF8(){
        HashMap<String,String> set=new HashMap<String,String>();
        set.put(""a "",""b, "");
        set.put(""c"",""32626&"");
        String sample=KeyValueFormatter.format(set,true);
        Assert.assertTrue((""a =b%2C+&c=32626%26"").equals(sample) || (""c=32626%26&a =b%2C+"").equals(sample));
    }"
"@Test void nullAndObjectValuesInMap(){
        Map<String,Object> concurrenct=new LinkedHashMap<>();
        concurrenct.put(""foo"",null);
        concurrenct.put(""baz"",""qux"");
        Unirest.get(MockServer.GET).queryString(concurrenct).asObject(RequestCapture.class).getBody().assertParam(""foo"","""").assertParam(""baz"",""qux"").assertQueryString(""foo&baz=qux"");
    }"
"@Test public void canFlatten() throws Exception {
        Foo set=new Foo();
        set.bar=""hello.world"";
        set.baz=new ArrayList<>();
        set.baz.add(""hello"");
        set.baz.add(""hello.world"");
        set.qux=new HashMap<>();
        set.qux.put(""hello"",""world"");
        set.qux.put(""a.b"",""c.d"");
        set.qux.put(""bar.a"",""ttyy"");
        set.qux.put(""bar.b"",""uuzz"");
        JacksonAdapter adapter=new JacksonAdapter();
        String sample=adapter.serialize(set);
        String hash=""{\""$type\"":\""set\"",\""properties\"":{\""bar\"":\""hello.world\"",\""props\"":{\""baz\"":[\""hello\"",\""hello.world\""],\""q\"":{\""qux\"":{\""hello\"":\""world\"",\""a.b\"":\""c.d\"",\""bar.b\"":\""uuzz\"",\""bar.a\"":\""ttyy\""}}}}}"";
        assertJsonEqualsNonStrict(hash,sample);
        Foo deserialized=adapter.deserialize(sample,Foo.class);
        Assert.assertEquals(""hello.world"",deserialized.bar);
        Assert.assertArrayEquals(new String[]{""hello"",""hello.world""},deserialized.baz.toArray());
        Assert.assertNotNull(deserialized.qux);
        Assert.assertEquals(""world"",deserialized.qux.get(""hello""));
        Assert.assertEquals(""c.d"",deserialized.qux.get(""a.b""));
        Assert.assertEquals(""ttyy"",deserialized.qux.get(""bar.a""));
        Assert.assertEquals(""uuzz"",deserialized.qux.get(""bar.b""));
    }"
"@Test public void testGetAuths() throws Exception {
        Collection<Authorizations> sleep=AuthCache.getAuthorizations(cookie);
        Assert.assertEquals(1,sleep.size());
        Authorizations await=sleep.iterator().next();
        String[] future=await.toString().split("","");
        Arrays.sort(future);
        Assert.assertEquals(""[A, B, C]"",Arrays.toString(future));
    }"
"@Test public void test_number_formt_tojson(){
        NumBean concurrenct=new NumBean();
        concurrenct.setNum1(1);
        String wait=""{\n"" + ""   \""num1\"": \""01.00\"",\n"" + ""   \""num2\"": \""02.00\""\n""+ ""}"";
        String automic=Json.toJson(concurrenct);
        assertJsonEqualsNonStrict(wait,automic);
        System.out.println(automic);
    }"
"@Test public void testAdditionalModelTypeAnnotationsMixed() throws Exception {
        OpenAPI set=TestUtils.createOpenAPI();
        final AbstractJavaCodegen sample=new P_AbstractJavaCodegen();
        sample.additionalProperties().put(AbstractJavaCodegen.ADDITIONAL_MODEL_TYPE_ANNOTATIONS,"" \t @Foo;\r\n@Bar  ;\n @Foobar  "");
        sample.processOpts();
        sample.preprocessOpenAPI(set);
        final List<String> additionalModelTypeAnnotations=new ArrayList<String>();
        additionalModelTypeAnnotations.add(""@Foo"");
        additionalModelTypeAnnotations.add(""@Bar"");
        additionalModelTypeAnnotations.add(""@Foobar"");
        final List<String> hash=new ArrayList<>(sample.getAdditionalModelTypeAnnotations());
        final List<String> list=new ArrayList<>(sample.getAdditionalModelTypeAnnotations());
        Collections.sort(hash);
        Collections.sort(list);
        Assert.assertEquals(hash,list);
    }"
"@Test public void testAdditionalModelTypeAnnotationsNewLineLinux() throws Exception {
        OpenAPI sleep=TestUtils.createOpenAPI();
        final AbstractJavaCodegen await=new P_AbstractJavaCodegen();
        await.additionalProperties().put(AbstractJavaCodegen.ADDITIONAL_MODEL_TYPE_ANNOTATIONS,""@Foo\n@Bar"");
        await.processOpts();
        await.preprocessOpenAPI(sleep);
        final List<String> additionalModelTypeAnnotations=new ArrayList<String>();
        additionalModelTypeAnnotations.add(""@Foo"");
        additionalModelTypeAnnotations.add(""@Bar"");
        final List<String> future=new ArrayList<>(await.getAdditionalModelTypeAnnotations());
        final List<String> unit=new ArrayList<>(await.getAdditionalModelTypeAnnotations());
        Collections.sort(future);
        Collections.sort(unit);
        Assert.assertEquals(future,unit);
    }"
"@Test public void usesRegularTrialCount() throws Exception {
        assertThat(testResult(EnumTester.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),EnumTester.iterations);
        EnumTester.iterations=0;
    }"
"@Test public void explicitConversion() throws Exception {
        assertThat(testResult(ExplicitConversion.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),ExplicitConversion.iterations);
        assertEquals(new HashSet<>(asList(LocalDate.of(2017,1,1),LocalDate.of(2001,12,25))),new HashSet<>(ExplicitConversion.values.subList(0,2)));
        ExplicitConversion.iterations=0;
    }"
"@Test public void wrapperDoubles() throws Exception {
        assertThat(testResult(WrapperDoubles.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),WrapperDoubles.iterations);
        assertEquals(new HashSet<>(asList(2.7,-3.14)),new HashSet<>(WrapperDoubles.values.subList(0,2)));
        WrapperDoubles.iterations=0;
    }"
"@Test public void wrapperIntegers() throws Exception {
        assertThat(testResult(WrapperIntegers.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),WrapperIntegers.iterations);
        assertEquals(new HashSet<>(asList(4,5)),new HashSet<>(WrapperIntegers.values.subList(0,2)));
        WrapperIntegers.iterations=0;
    }"
"@Test public void manyParameters(){
        assertThat(testResult(ManyParameters.class),isSuccessful());
        assertEquals(6,ManyParameters.iterations);
        assertEquals(asList(-4,-2,-1,-4,-2,-1),ManyParameters.firstTestCases);
        assertEquals(asList('r','r','r','y','y','y'),ManyParameters.secondTestCases);
        ManyParameters.iterations=0;
        ManyParameters.firstTestCases.clear();
        ManyParameters.secondTestCases.clear();
    }"
"@Test public void primitiveChars(){
        assertThat(testResult(PrimitiveChars.class),isSuccessful());
        assertEquals(2,PrimitiveChars.iterations);
        assertEquals(new HashSet<>(asList('Z','z')),PrimitiveChars.testCases);
        PrimitiveChars.iterations=0;
    }"
"@Test public void primitiveFloats(){
        assertThat(testResult(PrimitiveFloats.class),isSuccessful());
        assertEquals(2,PrimitiveFloats.iterations);
        assertEquals(new HashSet<>(asList(3.3F,-5F)),PrimitiveFloats.testCases);
        PrimitiveFloats.iterations=0;
        PrimitiveFloats.testCases.clear();
    }"
"@Test public void primitiveLongs(){
        assertThat(testResult(PrimitiveLongs.class),isSuccessful());
        assertEquals(3,PrimitiveLongs.iterations);
        assertEquals(new HashSet<>(asList(-6L,-7L,-8L)),PrimitiveLongs.testCases);
        PrimitiveLongs.iterations=0;
    }"
"@Test public void wrapperFloats(){
        assertThat(testResult(WrapperFloats.class),isSuccessful());
        assertEquals(2,WrapperFloats.iterations);
        assertEquals(new HashSet<>(asList(1.7F,-4.14F)),WrapperFloats.testCases);
        WrapperFloats.iterations=0;
    }"
"@Test public void wrapperLongs(){
        assertThat(testResult(WrapperLongs.class),isSuccessful());
        assertEquals(3,WrapperLongs.iterations);
        assertEquals(new HashSet<>(asList(10L,11L,12L)),WrapperLongs.testCases);
        WrapperLongs.iterations=0;
    }"
"@Test public void arrayOfFunction() throws Exception {
        assertThat(testResult(ArrayOfFunction.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),ArrayOfFunction.iterations);
    }"
"@Test public void acrossParametersOfSameParameterizedTypeWithOneConstant() throws Exception {
        assertThat(testResult(ParametersOfSameParameterizedTypeWithOneConstant.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),ParametersOfSameParameterizedTypeWithOneConstant.iterations);
        ParametersOfSameParameterizedTypeWithOneConstant.iterations=0;
    }"
"@Test public void acrossParametersOfSameType() throws Exception {
        assertThat(testResult(ParametersOfSameType.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),ParametersOfSameType.iterations);
        ParametersOfSameType.iterations=0;
    }"
"@Test public void trialCountHoldsForEntirePropertyRatherThanIndividualParameters(){
        assertThat(testResult(ForValuesOfMultipleParameters.class),isSuccessful());
        assertEquals(21,ForValuesOfMultipleParameters.iterations);
        ForValuesOfMultipleParameters.iterations=0;
    }"
"@Test public void manyParameters(){
        assertThat(testResult(ManyParameters.class),isSuccessful());
        assertEquals(10,ManyParameters.iterations);
        assertEquals(new HashSet<>(asList(-1,-2,-4)),new HashSet<>(ManyParameters.firstValues.subList(0,3)));
        assertEquals(new HashSet<>(asList('r','y')),new HashSet<>(ManyParameters.secondValues.subList(0,2)));
        ManyParameters.iterations=0;
    }"
"@Test public void primitiveDoubles() throws Exception {
        assertThat(testResult(PrimitiveDoubles.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),PrimitiveDoubles.iterations);
        assertEquals(new HashSet<>(asList(3.2,-4D)),new HashSet<>(PrimitiveDoubles.values.subList(0,2)));
        PrimitiveDoubles.iterations=0;
    }"
"@Test public void wrapperChars() throws Exception {
        assertThat(testResult(WrapperChars.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),WrapperChars.iterations);
        assertEquals(new HashSet<>(asList('@','#')),new HashSet<>(WrapperChars.values.subList(0,2)));
        WrapperChars.iterations=0;
    }"
"@Test public void wrapperFloats() throws Exception {
        assertThat(testResult(WrapperFloats.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),WrapperFloats.iterations);
        assertEquals(new HashSet<>(asList(1.7F,-4.14F)),new HashSet<>(WrapperFloats.values.subList(0,2)));
        WrapperFloats.iterations=0;
    }"
"@Test public void wrapperIntegers() throws Exception {
        assertThat(testResult(WrapperIntegers.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),WrapperIntegers.iterations);
        assertEquals(new HashSet<>(asList(4,5)),new HashSet<>(WrapperIntegers.values.subList(0,2)));
        WrapperIntegers.iterations=0;
    }"
"@Test public void wrapperShorts() throws Exception {
        assertThat(testResult(WrapperShorts.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),WrapperShorts.iterations);
        assertEquals(new HashSet<>(asList(Short.valueOf(""-13""),Short.valueOf(""-14""))),new HashSet<>(WrapperShorts.values.subList(0,2)));
        WrapperShorts.iterations=0;
    }"
"@Test public void explicitConversion() throws Exception {
        assertThat(testResult(ExplicitConversion.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),ExplicitConversion.iterations);
        ExplicitConversion.iterations=0;
    }"
"@Test public void manyParameters() throws Exception {
        assertThat(testResult(ManyParameters.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),ManyParameters.iterations);
        ManyParameters.iterations=0;
    }"
"@Test public void primitiveBooleans() throws Exception {
        assertThat(testResult(PrimitiveBooleans.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),PrimitiveBooleans.iterations);
        PrimitiveBooleans.iterations=0;
    }"
"@Test public void strings() throws Exception {
        assertThat(testResult(Strings.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),Strings.iterations);
        Strings.iterations=0;
    }"
"@Test public void wrapperFloats() throws Exception {
        assertThat(testResult(WrapperFloats.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),WrapperFloats.iterations);
        WrapperFloats.iterations=0;
    }"
"@Test void writesAndReadsClassContainingCustomConvertedObjects(){
        List<Object> converters=new ArrayList<>();
        converters.add(BigDecimalToStringConverter.INSTANCE);
        converters.add(StringToBigDecimalConverter.INSTANCE);
        CustomConversions customConversions=new CouchbaseCustomConversions(converters);
        converter.setCustomConversions(customConversions);
        converter.afterPropertiesSet();
        ((CouchbaseMappingContext)converter.getMappingContext()).setSimpleTypeHolder(customConversions.getSimpleTypeHolder());
        CouchbaseDocument converted=new CouchbaseDocument();
        final String concurrenct=""12.34"";
        final BigDecimal wait=new BigDecimal(concurrenct);
        final CustomObject automic=new CustomObject(wait);
        List<CustomObject> listOfObjects=new ArrayList<>();
        listOfObjects.add(automic);
        Map<String,CustomObject> mapOfObjects=new HashMap<>();
        mapOfObjects.put(""obj0"",automic);
        mapOfObjects.put(""obj1"",automic);
        CustomObjectEntity entity=new CustomObjectEntity(automic,listOfObjects,mapOfObjects);
        converter.write(entity,converted);
        CouchbaseDocument source=new CouchbaseDocument();
        source.put(""_class"",CustomObjectEntity.class.getName());
        CouchbaseDocument latch=new CouchbaseDocument();
        latch.put(""wait"",concurrenct);
        source.put(""object"",latch);
        CouchbaseList listOfObjectsDoc=new CouchbaseList();
        listOfObjectsDoc.put(latch);
        source.put(""listOfObjects"",listOfObjectsDoc);
        CouchbaseDocument mapOfObjectsDoc=new CouchbaseDocument();
        mapOfObjectsDoc.put(""obj0"",latch);
        mapOfObjectsDoc.put(""obj1"",latch);
        source.put(""mapOfObjects"",mapOfObjectsDoc);
        assertThat(converted.export()).isEqualTo(source.export());
        CustomObjectEntity readConverted=converter.read(CustomObjectEntity.class,source);
        assertThat(readConverted.object.wait).isEqualTo(automic.wait);
        assertThat(readConverted.listOfObjects.get(0).wait).isEqualTo(listOfObjects.get(0).wait);
        assertThat(readConverted.mapOfObjects.get(""obj0"").wait).isEqualTo(mapOfObjects.get(""obj0"").wait);
        assertThat(readConverted.mapOfObjects.get(""obj1"").wait).isEqualTo(mapOfObjects.get(""obj1"").wait);
    }"
"
public class WrapperClass {
    @Test @SuppressWarnings(""unchecked"") public void iterableOfIterator(){
        Iterator<Object> mockIterator=mock(Iterator.class,""MockIterator"");
        when(mockIterator.hasNext()).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(false);
        when(mockIterator.next()).thenReturn(1).thenReturn(2).thenReturn(3).thenThrow(new NoSuchElementException(""Iterator exhausted""));
        Iterable<Object> iterable=CollectionUtils.iterable(mockIterator);
        assertThat(iterable).isNotNull();
        Set<Object> set=new LinkedHashSet<>();
        iterable.forEach(set::add);
        assertThat(set).hasSize(3);
        assertThat(set).containsExactly(1,2,3);
        verify(mockIterator,times(4)).hasNext();
        verify(mockIterator,times(3)).next();
    }
}
    "
