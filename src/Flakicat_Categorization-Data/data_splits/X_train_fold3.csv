full_code
"@Test
public void testBindAndRetrieveObjectFactoryFromNamingContext() throws Exception {
    final Reference reference = new Reference(""java.util.String"", TestObjectFactory.class.getName(), null);
    namingStore.bind(new CompositeName(""test""), reference);
    final Object result = namingContext.lookup(""test"");
    assertTrue(result instanceof String);
    assertEquals(""Test ParsedResult"", result);
}"
"@Test public void testGetAllMetaAnnotations(){
    List<Annotation> metaAnnotations=getAllMetaAnnotations(Service5.class);
    int offset=0;
    HashSet<Object> set1=new HashSet<>();
    metaAnnotations.forEach(t -> set1.add(t.annotationType()));
    HashSet<Object> set2=new HashSet<>();
    set2.add(Inherited.class);
    set2.add(DubboService.class);
    set2.add(Service4.class);
    set2.add(Service3.class);
    set2.add(Service2.class);
    assertEquals(9,metaAnnotations.size());
    assertEquals(set1,set2);
    metaAnnotations=getAllMetaAnnotations(MyAdaptive.class);
    HashSet<Object> set3=new HashSet<>();
    metaAnnotations.forEach(t -> set3.add(t.annotationType()));
    HashSet<Object> set4=new HashSet<>();
    metaAnnotations.forEach(t -> set3.add(t.annotationType()));
    set4.add(Inherited.class);
    set4.add(Adaptive.class);
    assertEquals(2,metaAnnotations.size());
    assertEquals(set3,set4);
}"
"@Test
public void runCollectiveChokeTest() throws InterruptedException, IOException {
    int numChokes = 5;
    for (int i = 0; i < numChokes; i++) {
        chokeMap.put(Integer.toString(i),
        rateFloor + rand.nextInt(rateCeil - rateFloor));
    }
    testChokeMan.updateChokeLimitMap(chokeMap);
    TestChoke[] tchokeArray = new TestChoke[numChokes];
    for (int i = 0; i < numChokes; i++) {
        tchokeArray[i] = new TestChoke<EventSink>(null, Integer.toString(i));
    }
    Set<TestChoke<EventSink>> chokesUsed = new HashSet<TestChoke<EventSink>>();
    DirectDriver[] directDriverArray = new DirectDriver[numDrivers];
    int randChokeIndex = 0;
    for (int i = 0; i < numDrivers; i++) {
        randChokeIndex = rand.nextInt(numChokes);
        directDriverArray[i] = new DirectDriver(new SynthSourceRndSize(0,minMsgSize, maxMsgSize), tchokeArray[randChokeIndex]);
        chokesUsed.add(tchokeArray[randChokeIndex]);
    }
    LOG.info(""Running the Collective Test Now!"");
    for (TestChoke<EventSink> t : chokesUsed) {
        if (!testChokeMan.isChokeId(t.getChokeId())) {
            LOG.error(""ChokeID "" + t.getChokeId() + ""not present"");
            fail();
        }
    }
    testChokeMan.start();
    for (DirectDriver f : directDriverArray) {
        f.start();
    }
    Thread.sleep(testTime);
    for (DirectDriver f : directDriverArray) {
        f.stop();
    }
    testChokeMan.halt();
    for (TestChoke<EventSink> t : chokesUsed) {
        double maxRate = chokeMap.get(t.getChokeId());
        errorRatio = ((double) (chokeMap.get(t.getChokeId()) * testTime)) / (double) (t.getReport().getLongMetric(""number of bytes""));
        assertFalse((errorRatio > this.highErrorLimit || errorRatio < this.lowErrorLimit));
    }
}"
"@Test
public void testVanishingTaskZNode() throws Exception {
    LOG.info(""testVanishingTaskZNode"");
    conf.setInt(""hbase.splitlog.manager.unassigned.timeout"", 0);
    slm = new SplitLogManager(zkw, conf, stopper, ""dummy-master"", null);
    slm.finishInitialization();
    FileSystem fs = TEST_UTIL.getTestFileSystem();
    final Path logDir = new Path(fs.getWorkingDirectory(), UUID.randomUUID().toString());
    fs.mkdirs(logDir);
    Thread thread = null;
    try {
        Path logFile = new Path(logDir, UUID.randomUUID().toString());
        fs.createNewFile(logFile);
        thread = new Thread() {
            public void run() {
                try {
                    slm.splitLogDistributed(logDir);
                } catch (Exception e) {
                    LOG.warn(""splitLogDistributed failed"", e);
                }
            }
        };
        thread.start();
        waitForCounter(tot_mgr_node_create_result, 0, 1, 10000);
        String znode = ZKSplitLog.getEncodedNodeName(zkw, logFile.toString());
        ZKUtil.deleteNode(zkw, znode);
        waitForCounter(tot_mgr_get_data_nonode, 0, 1, 30000);
        waitForCounter(tot_mgr_log_split_batch_success, 0, 1, 1000);
        assertTrue(fs.exists(logFile));
    } finally {
        if (thread != null) {
            thread.interrupt();
        }
        fs.delete(logDir, true);
    }
}"
"@Test
public void testMultiReaderIsAbleToSeekWithTimeOnMiddleOfTopic() throws Exception {
    final String topicName = ""persistent"";
    final int numOfMessage = 10;
    final int halfMessages = numOfMessage / 2;
    admin.topics().createPartitionedTopic(topicName, 3);
    Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName).create();
    long l = System.currentTimeMillis();
    for (int i = 0; i < numOfMessage; i++) {
        producer.send(String.format(""msg num %d"", i).getBytes());
    }
    Reader<byte[]> reader = pulsarClient.newReader().topic(topicName).startMessageId(earliest).create();
    int plusTime = (halfMessages + 1) * 100;
    reader.seek(l + plusTime);
    Set<String> messageSet = Sets.newHashSet();
    for (int i = halfMessages + 1; i < numOfMessage; i++) {
        Message<byte[]> message = reader.readNext();
        String receivedMessage = new String(message.getData());
        Assert.assertTrue(messageSet.add(receivedMessage), ""Received duplicate message "" + receivedMessage);
    }
    reader.close();
    producer.close();
}"
"@Test public void canFlatten() throws Exception {
    Foo foo=new Foo();
    foo.bar=""hello.world"";
    foo.baz=new ArrayList<>();
    foo.baz.add(""hello"");
    foo.baz.add(""hello.world"");
    foo.qux=new HashMap<>();
    foo.qux.put(""hello"",""world"");
    foo.qux.put(""a.b"",""c.d"");
    foo.qux.put(""bar.a"",""ttyy"");
    foo.qux.put(""bar.b"",""uuzz"");
    JacksonAdapter adapter=new JacksonAdapter();
    String serialized=adapter.serialize(foo);
    String expected=""{\""$type\"":\""foo\"",\""properties\"":{\""bar\"":\""hello.world\"",\""props\"":{\""baz\"":[\""hello\"",\""hello.world\""],\""q\"":{\""qux\"":{\""hello\"":\""world\"",\""a.b\"":\""c.d\"",\""bar.b\"":\""uuzz\"",\""bar.a\"":\""ttyy\""}}}}}"";
    assertJsonEqualsNonStrict(expected,serialized);
    Foo deserialized=adapter.deserialize(serialized,Foo.class);
    Assert.assertEquals(""hello.world"",deserialized.bar);
    Assert.assertArrayEquals(new String[]{""hello"",""hello.world""},deserialized.baz.toArray());
    Assert.assertNotNull(deserialized.qux);
    Assert.assertEquals(""world"",deserialized.qux.get(""hello""));
    Assert.assertEquals(""c.d"",deserialized.qux.get(""a.b""));
    Assert.assertEquals(""ttyy"",deserialized.qux.get(""bar.a""));
    Assert.assertEquals(""uuzz"",deserialized.qux.get(""bar.b""));
}"
"@Test
public void testProducerConsumerTopic() throws Exception {
    final CountDownLatch consumerStarted = new CountDownLatch(1);
    Thread producerThread = new Thread(new Runnable());
    final TopicWithDuplicateMessages consumer = new TopicWithDuplicateMessages();
    Thread consumerThread = new Thread(new Runnable() );
    consumerThread.start();
    LOG.info(""Started Consumer"");
    assertTrue(""consumer started eventually"", consumerStarted.await(10, TimeUnit.SECONDS));
    Thread.sleep(2000);
    producerThread.start();
    LOG.info(""Started Producer"");
    producerThread.join();
    consumerThread.join();
    int duplicateCount = 0;
    Map<String, String> map = new HashMap<String, String>();
    for (String msg : consumer.getMessageStrings()) {
        if (map.containsKey(msg)) {
            LOG.info(""got duplicate: "" + msg);
            duplicateCount++;
        }
        map.put(msg, msg);
    }
    if (suppressDuplicateTopicSubs || (dispatchPolicy instanceof PriorityNetworkDispatchPolicy)) {
        assertEquals(""no duplicates"", 0, duplicateCount);
        assertEquals(""got all required messages: "" + map.size(), consumer.getNumMessages(), map.size());
    } else {
        assertTrue(""we got some duplicates"", duplicateCount > 0);
    }
}"
"@Test
public void testCreateSubcontext() throws Exception {
    assertTrue(namingContext.createSubcontext(new CompositeName(""test"")) instanceof NamingContext);
    assertTrue(testActionPermission(JndiPermission.ACTION_CREATE_SUBCONTEXT, namingContext, ""securitytest"") instanceof NamingContext);
}"
"@Test
public void testFromFileToFtp() throws Exception {
    service.suspend();
    template.sendBodyAndHeader(""file:{{ftp.root.dir}}/reconnect"", ""Hello World"", FILE_NAME, ""hello.txt"");
    MockEndpoint mock = getMockEndpoint(""mock:result"");
    mock.expectedMessageCount(0);
    Thread.sleep(3000);
    assertMockEndpointsSatisfied();
    mock.reset();
    mock.expectedMessageCount(1);
    service.resume();
    Thread.sleep(3000);
    assertMockEndpointsSatisfied();
}"
"@Test public void primitiveBytes(){
    assertThat(testResult(PrimitiveBytes.class),isSuccessful());
    assertEquals(2,PrimitiveBytes.iterations);
    assertEquals(new HashSet<>(asList(Byte.valueOf(""12""),Byte.valueOf(""-13""))),PrimitiveBytes.testCases);
    PrimitiveBytes.iterations=0;
}"
"@Test public void testMRAppMasterShutDownJob() throws Exception, InterruptedException {
    ExitUtil.resetFirstExitException();
    String applicationAttemptIdStr=""appattempt_1317529182569_0004_000002"";
    String containerIdStr=""container_1317529182569_0004_000002_1"";
    String userName=""TestAppMasterUser"";
    ApplicationAttemptId applicationAttemptId=ApplicationAttemptId.fromString(applicationAttemptIdStr);
    ContainerId containerId=ContainerId.fromString(containerIdStr);
    JobConf conf=new JobConf();
    conf.set(MRJobConfig.MR_AM_STAGING_DIR,stagingDir);
    File stagingDir=new File(MRApps.getStagingAreaDir(conf,userName).toString());
    stagingDir.mkdirs();
    MRAppMasterTest appMaster=spy(new MRAppMasterTest(applicationAttemptId,containerId,""host"",-1,-1,System.currentTimeMillis(),false,true));
    MRAppMaster.initAndStartAppMaster(appMaster,conf,userName);
    doReturn(conf).when(appMaster).getConfig();
    appMaster.isLastAMRetry=true;
    doNothing().when(appMaster).serviceStop();
    appMaster.shutDownJob();
    Assert.assertTrue(""Expected shutDownJob to terminate."",ExitUtil.terminateCalled());
    Assert.assertEquals(""Expected shutDownJob to exit with status code of 0."",0,ExitUtil.getFirstExitException().status);
    ExitUtil.resetFirstExitException();
    String msg=""Injected Exception"";
    doThrow(new RuntimeException(msg)).when(appMaster).notifyIsLastAMRetry(anyBoolean());
    appMaster.shutDownJob();
    assertTrue(""Expected message from ExitUtil.ExitException to be "" + msg,ExitUtil.getFirstExitException().getMessage().contains(msg));
    Assert.assertEquals(""Expected shutDownJob to exit with status code of 1."",1,ExitUtil.getFirstExitException().status);
}"
"@Test public void serializeBoolean() throws IOException {
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of(true)),""{\""@type\"":\""boolean\"",\""@value\"":true}"");
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of(false)),""{\""@type\"":\""boolean\"",\""@value\"":false}"");
}"
"@Test
public void testBlueprintCompNamespaceWorks() throws Exception {
    Bundle bBiz = getInstalledBundle(""org.apache.aries.jndi.url.itest.biz"");
    assertNotNull(bBiz);
    Bundle bweb = getInstalledBundle(""org.apache.aries.jndi.url.itest.web"");
    assertNotNull(bweb);
    printBundleStatus(""Before first request"");
    try {
        getTestServletResponse();
    } catch (IOException iox) {
    }
    try {
        Thread.sleep(5000);
    } catch (InterruptedException iox) {
    }
    printBundleStatus(""After workaround, before test proper"");
    System.out.println(""In test and trying to get connection...."");
    String response = getTestServletResponse();
    assertEquals(""ITest servlet response wrong"", ""Mark.2.0.three"", response);
}"
"@Test
public void testPredictiveLayoutAdd2() throws Throwable {
    preparePredictiveLayout();
    mActivityTestRule.runOnUiThread(new Runnable() {
        @Override
        public void run() {
            mActivity.addItems(50, new int[]{300, 300, 300, 300});
        }
    });
    waitForItemAnimationStart();
    waitForItemAnimation(5000);
    assertEquals(54, mGridView.getSelectedPosition());
    assertEquals(RecyclerView.SCROLL_STATE_IDLE, mGridView.getScrollState());
}"
"@Test @SuppressWarnings(""unchecked"") public void iterableOfEnumeration(){
    Enumeration<Object> mockEnumeration=mock(Enumeration.class,""MockEnumeration"");
    when(mockEnumeration.hasMoreElements()).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(false);
    when(mockEnumeration.nextElement()).thenReturn(1).thenReturn(2).thenReturn(3).thenThrow(new NoSuchElementException(""Enumeration exhausted""));
    Iterable<Object> iterable=CollectionUtils.iterable(mockEnumeration);
    assertThat(iterable).isNotNull();
    LinkedHashSet<Object> set=StreamSupport.stream(iterable.spliterator(),false).collect(Collectors.toCollection(LinkedHashSet::new));
    assertThat(set).containsExactly(1,2,3);
    verify(mockEnumeration,times(4)).hasMoreElements();
    verify(mockEnumeration,times(3)).nextElement();
}"
"@Test
public void createdWorkerThreadsShouldContainConnectorName() throws Exception
{
    AtomicInteger processNextBatchCount = new AtomicInteger();
    AtomicReference<Thread> poolThread = new AtomicReference<>();
    AtomicReference<String> poolThreadName = new AtomicReference<>();
    String id = UUID.randomUUID().toString();
    BoltConnection connection = newConnection( id );
    when( connection.processNextBatch() ).thenAnswer( inv ->
    {
        poolThread.set( Thread.currentThread() );
        poolThreadName.set( Thread.currentThread().getName() );
        processNextBatchCount.incrementAndGet();
        return true;
    } );
    boltScheduler.start();
    boltScheduler.created( connection );
    boltScheduler.enqueued( connection, Jobs.noop() );
    Predicates.await( () -> processNextBatchCount.get() > 0, 1, MINUTES );
    assertThat( poolThread.get().getName(), not( equalTo( poolThreadName.get() ) ) );
    assertThat( poolThread.get().getName(), containsString( String.format( ""[%s]"", CONNECTOR_KEY ) ) );
    assertThat( poolThread.get().getName(), not( containsString( String.format( ""[%s]"", connection.remoteAddress() ) ) ) );
}"
"@Test
public void testRejectionsEAP6() throws Exception {
    testTransformer(""subsystem.xml"", ModelTestControllerVersion.EAP_6_4_0, ModelVersion.create(1, 3),""jboss-as-naming"");
}"
"@Test public void manyParametersWithBooleanAndEnum(){
    assertThat(testResult(ManyParametersWithBooleanAndEnum.class),isSuccessful());
    int expectedCount=4 * 4 * 2* RoundingMode.values().length;
    assertEquals(expectedCount,ManyParametersWithBooleanAndEnum.iterations);
    for (int i=0; i < expectedCount / 4; ++i) {
        assertEquals(String.valueOf(i),asList(3,7),ManyParametersWithBooleanAndEnum.firstTestCases.subList(i * 4,i * 4 + 2));
    }
    for (int i=0; i < expectedCount / 16; ++i) {
        assertEquals(String.valueOf(i),asList('a','a','a','a','b','b','b','b','c','c','c','c'),ManyParametersWithBooleanAndEnum.secondTestCases.subList(i * 16,i * 16 + 12));
    }
    for (int i=0; i < expectedCount / 32; ++i) {
        assertEquals(asList(false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false),ManyParametersWithBooleanAndEnum.thirdTestCases.subList(i * 32,i * 32 + 16));
        assertEquals(asList(true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true),ManyParametersWithBooleanAndEnum.thirdTestCases.subList(i * 32 + 16,i * 32 + 32));
    }
    assertEquals(expectedCount,ManyParametersWithBooleanAndEnum.fourthTestCases.size());
    assertEquals(EnumSet.allOf(RoundingMode.class),new HashSet<>(ManyParametersWithBooleanAndEnum.fourthTestCases));
    ManyParametersWithBooleanAndEnum.iterations=0;
    ManyParametersWithBooleanAndEnum.fourthTestCases.clear();
}"
"@Test
public void create_repo_and_uploads_commits() throws Exception {
    String challengeId = ""TCH"";
    String participantId = generateId();
    String s3destination = String.format(""%s/%s/file.srcs"", challengeId, participantId);
    TestSrcsFile srcsForTestChallenge = new TestSrcsFile(""HmmmLang_R1Cov33_R2Cov44.srcs"");
    S3Event s3Event = localS3Bucket.putObject(srcsForTestChallenge.asFile(), s3destination);
    coverageUploadHandler.handleRequest(convertToMap(wrapAsSNSEvent(s3Event)),NO_CONTEXT);
    waitForQueueToReceiveEvents();
    assertThat(languageDetectedEvents.size(), equalTo(1));
    System.out.println(""Received language detected events: ""+languageDetectedEvents);
    ProgrammingLanguageDetectedEvent languageEvent = languageDetectedEvents.get(0);
    assertThat(languageEvent.getParticipant(), equalTo(participantId));
    assertThat(languageEvent.getChallengeId(), equalTo(challengeId));
    assertThat(languageEvent.getProgrammingLanguage(), equalTo(""HmmmLang""));
    assertThat(coverageComputedEvents.size(), equalTo(2));
    System.out.println(""Received coverage events: ""+coverageComputedEvents);
    coverageComputedEvents.sort(Comparator.comparing(CoverageComputedEvent::getRoundId));
    CoverageComputedEvent coverageRound1 = coverageComputedEvents.get(0);
    assertThat(coverageRound1.getParticipant(), equalTo(participantId));
    assertThat(coverageRound1.getRoundId(), equalTo(challengeId+""_R1""));
    assertThat(coverageRound1.getCoverage(), equalTo(33));
    CoverageComputedEvent coverageRound2 = coverageComputedEvents.get(1);
    assertThat(coverageRound2.getParticipant(), equalTo(participantId));
    assertThat(coverageRound2.getRoundId(), equalTo(challengeId+""_R2""));
    assertThat(coverageRound2.getCoverage(), equalTo(44));
}"
"@Test public void testGetAuths() throws Exception {
    Collection<Authorizations> auths=AuthCache.getAuthorizations(cookie);
    Assert.assertEquals(1,auths.size());
    Authorizations a=auths.iterator().next();
    String[] authStrings=a.toString().split("","");
    Arrays.sort(authStrings);
    Assert.assertEquals(""[A, B, C]"",Arrays.toString(authStrings));
}"
"@Test
public void testRepairSuccessfully() throws InterruptedException {
    Collection<LongTokenRange> ranges = new ArrayList<>();
    LongTokenRange range1 = new LongTokenRange(1, 2);
    LongTokenRange range2 = new LongTokenRange(3, 4);
    ranges.add(range1);
    ranges.add(range2);
    final RepairTask repairTask = new RepairTask.Builder().withJMXProxyFactory(jmxProxyFactory).withTableReference(myTableReference).withTokenRanges(ranges).withTableRepairMetrics(myTableRepairMetrics).withRepairHistory(repairHistory).withJobId(jobId).withReplicas(participants).build();
    CountDownLatch cdl = startRepair(repairTask, false);
    Notification notification = new Notification(""progress"", ""repair:1"", 0, getRepairMessage(range1));
    notification.setUserData(getNotificationData(PROGRESS.ordinal(), 1, 2));
    proxy.notify(notification);
    notification = new Notification(""progress"", ""repair:1"", 1, getRepairMessage(range2));
    notification.setUserData(getNotificationData(PROGRESS.ordinal(), 2, 2));
    proxy.notify(notification);
    notification = new Notification(""progress"", ""repair:1"", 2, ""Done with repair"");
    notification.setUserData(getNotificationData(COMPLETE.ordinal(), 2, 2));
    proxy.notify(notification);
    cdl.await();
    assertThat(repairTask.getUnknownRanges()).isNull();
    assertThat(repairTask.getCompletedRanges()).containsExactlyElementsOf(ranges);
    assertThat(proxy.myOptions.get(RANGES_KEY)).isNotEmpty();
    verify(myTableRepairMetrics).repairTiming(eq(TABLE_REFERENCE), anyLong(), any(TimeUnit.class), eq(true));
    verify(repairSessions.get(range1)).start();
    verify(repairSessions.get(range2)).start();
    verify(repairSessions.get(range1)).finish(eq(SUCCESS));
    verify(repairSessions.get(range2)).finish(eq(SUCCESS));
}"
"public void test_for_issue() throws Exception {
    JSONObject jsonObject=new JSONObject();
    final JSONObject a=new JSONObject();
    final JSONObject b=new JSONObject();
    a.put(""b"",b);
    b.put(""c"",""2018-04"");
    b.put(""d"",new JSONArray());
    Integer obj=Integer.valueOf(123);
    jsonObject.put(""a"",a);
    JSONPath.arrayAdd(jsonObject,""$.a.b[c = '2018-04'].d"",obj);
    assertEquals(""{\""a\"":{\""b\"":{\""c\"":\""2018-04\"",\""d\"":[123]}}}"",JSON.toJSONString(jsonObject,SerializerFeature.MapSortField));
}"
"@Test
public void testClientHang() throws Exception {
    clientTransport = new TcpTransport(new OpenWireFormat(), SocketFactory.getDefault(), new URI(""tcp://localhost:61616""), null) ;
    clientTransport.setTransportListener(new TransportListener() {
        public void onCommand(Object command) {
            clientReceiveCount.incrementAndGet();
            if (clientRunOnCommand != null) {
                clientRunOnCommand.run();
            }
        }
        clientTransport.start();
        WireFormatInfo info = new WireFormatInfo();
        info.setMaxInactivityDuration(1000);
        clientTransport.oneway(info);
        assertEquals(0, serverErrorCount.get());
        assertEquals(0, clientErrorCount.get());
        Thread.sleep(3000);
        assertEquals(0, clientErrorCount.get());
        assertTrue(serverErrorCount.get() > 0);
    }"
"public void testWrite() throws Exception {
    Resources res=new Resources();
    res.put(""menu_open"",""\u00D6ffnen"");
    res.put(""menu_save"",""Speichern"");
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    res.save(baos);
    assertTrue(Arrays.equals(example.getBytes(""utf-8""),baos.toByteArray()) || Arrays.equals(example2.getBytes(""utf-8""),baos.toByteArray()));
}"
"@Test
public void testRecovery() throws Exception {
    SpringBusFactory bf = new SpringBusFactory();
    bus = bf.createBus();
    BusFactory.setDefaultBus(bus);
    LOG.fine((""Created bus "" + bus) + "" with default cfg"");
    ControlService cs = new ControlService();
    Control control = cs.getControlPort();
    updateAddressPort(control, PORT);
    assertTrue(""Failed to start greeter"", control.startGreeter(SERVER_LOSS_CFG));
    LOG.fine(""Started greeter server."");
    greeterBus = new SpringBusFactory().createBus(CFG);
    LOG.fine(((""Created bus "" + greeterBus) + "" with cfg : "") + CFG);
    BusFactory.setDefaultBus(greeterBus);
    greeterBus.getExtension(RMManager.class).getRMAssertion().getBaseRetransmissionInterval().setMilliseconds(new BigInteger(""60000""));
    GreeterService gs = new GreeterService();
    Greeter greeter = gs.getGreeterPort();
    updateAddressPort(greeter, PORT);
    LOG.fine(""Created greeter client."");
    ConnectionHelper.setKeepAliveConnection(greeter, true);
    Client c = ClientProxy.getClient(greeter);
    HTTPConduit hc = ((HTTPConduit) (c.getConduit()));
    HTTPClientPolicy cp = hc.getClient();
    cp.setDecoupledEndpoint((""http:example.com""));
    out = new OutMessageRecorder();
    in = new InMessageRecorder();
    greeterBus.getOutInterceptors().add(out);
    greeterBus.getInInterceptors().add(in);
    LOG.fine(""Configured greeter client."");
    Response<GreetMeResponse>[] responses = cast(new Response[4]);
    responses[0] = greeter.greetMeAsync(""one"");
    responses[1] = greeter.greetMeAsync(""two"");
    responses[2] = greeter.greetMeAsync(""three"");
    verifyMissingResponse(responses);
    control.stopGreeter(SERVER_LOSS_CFG);
    LOG.fine(""Stopped greeter server"");
    out.getOutboundMessages().clear();
    in.getInboundMessages().clear();
    control.startGreeter(CFG);
    String nl = System.getProperty(""line.separator"");
    LOG.fine((""Restarted greeter server"" + nl) + nl);
    verifyServerRecovery(responses);
    out.getOutboundMessages().clear();
    in.getInboundMessages().clear();
    responses[3] = greeter.greetMeAsync(""four"");
    verifyRetransmissionQueue();
    greeterBus.shutdown(true);
    control.stopGreeter(CFG);
    bus.shutdown(true);
}"
"@Test
public void testProcessAction_ok() {
    final Mock mockResponse = mock(ActionResponse.class);
    PortletMode mode = PortletMode.VIEW;
    Map<String, String> initParams = new HashMap<String, String>();
    initParams.put(""viewNamespace"", ""/view"");
    Map<String, String[]> requestParams = new HashMap<String, String[]>();
    requestParams.put(ACTION_PARAM, new String[]{""/view/testAction""});
    requestParams.put(MODE_PARAM, new String[]{mode.toString()});
    initParams.put(StrutsConstants.STRUTS_ALWAYS_SELECT_FULL_NAMESPACE, ""true"");
    initPortletConfig(initParams, new HashMap<String, Object>());
    initRequest(requestParams, new HashMap<String, Object>(), new HashMap<String, Object>(), PortletMode.VIEW, WindowState.NORMAL, true, null);
    setupActionFactory(""/view"", ""testAction"", ""success"", EasyMock.createNiceMock(ValueStack.class));
    try {
        dispatcher
        .setActionProxyFactory((ActionProxyFactory) mockActionFactory
        .proxy());
        dispatcher.init((PortletConfig) mockConfig.proxy());
        dispatcher.processAction((ActionRequest) mockRequest.proxy(),
        (ActionResponse) mockResponse.proxy());
    } catch (Exception e) {
        e.printStackTrace();
        fail(""Error occured"");
    }
}"
"@Test @SuppressWarnings(""unchecked"") public void iterableOfIterator(){
    Iterator<Object> mockIterator=mock(Iterator.class,""MockIterator"");
    when(mockIterator.hasNext()).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(false);
    when(mockIterator.next()).thenReturn(1).thenReturn(2).thenReturn(3).thenThrow(new NoSuchElementException(""Iterator exhausted""));
    Iterable<Object> iterable=CollectionUtils.iterable(mockIterator);
    assertThat(iterable).isNotNull();
    Set<Object> set=new LinkedHashSet<>();
    iterable.forEach(set::add);
    assertThat(set).hasSize(3);
    assertThat(set).containsExactly(1,2,3);
    verify(mockIterator,times(4)).hasNext();
    verify(mockIterator,times(3)).next();
}"
"@Test
public void should_insert_using_static_strategy_an_consistency_level() throws Exception {
    final long id = RandomUtils.nextLong(0L, Long.MAX_VALUE);
    scriptExecutor.executeScriptTemplate(""EntityWithStaticAnnotations/insert_single_row.cql"", ImmutableMap.of(""id"", id));
    final EntityWithStaticAnnotations entity = new EntityWithStaticAnnotations(id, ""new_val"", null);
    final CassandraLogAsserter logAsserter = new CassandraLogAsserter();
    logAsserter.prepareLogLevelForDriverConnection();
    manager.crud().insert(entity).usingTimeToLive(1000).execute();
    Row actual = session.execute(""SELECT * FROM entity_static_annotations WHERE partition_key = "" + id).one();
    assertThat(actual).isNotNull();
    assertThat(actual.getString(""value"")).isEqualTo(""new_val"");
    assertThat(actual.getString(""\""overRiden\"""")).isEqualTo(""overriden_val"");
    logAsserter.assertConsistencyLevels(LOCAL_ONE);
}"
"@Test
public void testCompositeKeys() {
    EntityHelper.initEntityNameMap(UserCompositeKeys.class, config);
    EntityTable entityTable = EntityHelper.getEntityTable(UserCompositeKeys.class);
    Assert.assertNotNull(entityTable);
    Set<EntityColumn> columns = entityTable.getEntityClassColumns();
    Assert.assertEquals(2, columns.size());
    Assert.assertEquals(2, entityTable.getEntityClassPKColumns().size());
    for (EntityColumn column : columns) {
        Assert.assertTrue(column.isId());
    }
    ResultMap resultMap = entityTable.getResultMap(configuration);
    Assert.assertEquals(2, resultMap.getResultMappings().size());
    Assert.assertTrue(resultMap.getResultMappings().get(0).getFlags().contains(ID));
    Assert.assertTrue(resultMap.getResultMappings().get(1).getFlags().contains(ID));
    Assert.assertEquals(""<where> AND name = #{name} AND orgId = #{orgId}</where>"", SqlHelper.wherePKColumns(UserCompositeKeys.class));
}"
"@Test
public void shutdownDatabaseDuringIndexPopulations() {
    AssertableLogProvider assertableLogProvider = new AssertableLogProvider(true);
    File storeDir = directory.directory(""shutdownDbTest"");
    Label testLabel = Label.label(""testLabel"");
    String propertyName = ""testProperty"";
    GraphDatabaseService shutDownDb = new TestGraphDatabaseFactory().setInternalLogProvider(assertableLogProvider).newEmbeddedDatabase(storeDir);
    prePopulateDatabase(shutDownDb, testLabel, propertyName);
    try (final Transaction transaction = shutDownDb.beginTx()) {
        shutDownDb.schema().indexFor(testLabel).on(propertyName).create();
        transaction.success();
    }
    shutDownDb.shutdown();
    assertableLogProvider.assertNone(AssertableLogProvider.inLog(IndexPopulationJob.class).anyError());
}"
"@Test public void wrapperShorts(){
    assertThat(testResult(WrapperShorts.class),isSuccessful());
    assertEquals(2,WrapperShorts.iterations);
    assertEquals(new HashSet<>(asList(Short.valueOf(""-13""),Short.valueOf(""-14""))),WrapperShorts.testCases);
    WrapperShorts.iterations=0;
    WrapperShorts.testCases.clear();
}"
"@Test
public void testTimeWindows()
{
    Long tstamp1 = 1451001601000L;
    Long tstamp2 = 1451088001000L;
    Long lowHour = 1451001600000L;
    assertTrue(getWindowBoundsInMillis(TimeUnit.HOURS, 1, tstamp1).left.compareTo(lowHour) == 0);
    assertTrue(getWindowBoundsInMillis(TimeUnit.MINUTES, 1, tstamp1).left.compareTo(lowHour) == 0);
    assertTrue(getWindowBoundsInMillis(TimeUnit.DAYS, 1, tstamp1).left.compareTo(lowHour) == 0 );
    assertTrue(getWindowBoundsInMillis(TimeUnit.DAYS, 2, tstamp2).left.compareTo(lowHour) == 0);
    return;
}"
"@Test
public void testRecursingTrace() throws Exception {
    TracePluginConfiguration conf = new TracePluginConfiguration();
    conf.traceProb = 1.0;
    conf.port = 51010;
    conf.clientPort = 12346;
    TracePlugin aPlugin = new TracePlugin(conf);
    conf.port = 51011;
    conf.clientPort = 12347;
    TracePlugin bPlugin = new TracePlugin(conf);
    conf.port = 51012;
    conf.clientPort = 12348;
    TracePlugin cPlugin = new TracePlugin(conf);
    conf.port = 51013;
    conf.clientPort = 12349;
    TracePlugin dPlugin = new TracePlugin(conf);
    Responder bRes = new RecursingResponder(TestBasicTracing.advancedProtocol, bPlugin);
    bRes.addRPCPlugin(bPlugin);
    HttpServer server1 = new HttpServer(bRes, 21005);
    server1.start();
    Responder cRes = new EndpointResponder(TestBasicTracing.advancedProtocol);
    cRes.addRPCPlugin(cPlugin);
    HttpServer server2 = new HttpServer(cRes, 21006);
    server2.start();
    Responder dRes = new EndpointResponder(TestBasicTracing.advancedProtocol);
    dRes.addRPCPlugin(dPlugin);
    HttpServer server3 = new HttpServer(dRes, 21007);
    server3.start();
    HttpTransceiver trans = new HttpTransceiver(new URL(""http:www.example.com""));
    GenericRequestor r = new GenericRequestor(TestBasicTracing.advancedProtocol, trans);
    r.addRPCPlugin(aPlugin);
    GenericRecord params = new GenericData.Record(advancedProtocol.getMessages().get(""w"").getRequest());
    params.put(""req"", 1);
    for (int i = 0; i < 40; i++) {
        r.request(""w"", params);
    }
    List<Span> allSpans = new ArrayList<Span>();
    allSpans.addAll(aPlugin.storage.getAllSpans());
    allSpans.addAll(bPlugin.storage.getAllSpans());
    allSpans.addAll(cPlugin.storage.getAllSpans());
    allSpans.addAll(dPlugin.storage.getAllSpans());
    SpanAggregationResults results = SpanAggregator.getFullSpans(allSpans);
    assertEquals(0, results.incompleteSpans.size());
    List<Span> merged = results.completeSpans;
    List<Trace> traces = SpanAggregator.getTraces(merged).traces;
    assertEquals(40, traces.size());
    TraceCollection collection = new TraceCollection(traces.get(0));
    for (Trace t : traces) {
        collection.addTrace(t);
    }
    server1.close();
    server2.close();
    server3.close();
    aPlugin.httpServer.close();
    aPlugin.clientFacingServer.stop();
    bPlugin.httpServer.close();
    bPlugin.clientFacingServer.stop();
    cPlugin.httpServer.close();
    cPlugin.clientFacingServer.stop();
    dPlugin.httpServer.close();
    dPlugin.clientFacingServer.stop();
}"
"@Test public void onlyTrumpsGenerators() throws Exception {
    assertThat(testResult(OnlyTrumpsGenerators.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),OnlyTrumpsGenerators.iterations);
    OnlyTrumpsGenerators.iterations=0;
}"
"@Test
public void testQualifiedUriContents() throws Exception {
    dirString = fs.makeQualified(new Path(""d1"")).toString();
    item = new PathData(dirString, conf);
    PathData[] items = item.getDirectoryContents();
    assertEquals(sortedString(dirString + ""/f1"", dirString + ""/f1.1"", dirString + ""/f2""), sortedString(items));
}"
"/**
* Test destory registry, exporter can be normal by destroyed
*/
@Test public void testDestoryRegistry(){
    URL newRegistryUrl=registryUrl.addParameter(Constants.EXPORT_KEY,serviceUrl);
    Invoker<RegistryProtocolTest> invoker=new MockInvoker<RegistryProtocolTest>(RegistryProtocolTest.class,newRegistryUrl);
    Exporter<?> exporter=protocol.export(invoker);
    destroyRegistryProtocol();
    try {
        Thread.sleep(ConfigurationUtils.getServerShutdownTimeout() + 100);
    }
    catch (  InterruptedException e) {
        e.printStackTrace();
    }
    assertEquals(false,exporter.getInvoker().isAvailable());
}"
"@Test
public void testEmptyByteArrayForEmptyInput() throws IOException {
    this.fstObjectInput = new FstObjectInput(new ByteArrayInputStream("""".getBytes()));
    byte[] bytes = fstObjectInput.readBytes();
    assertThat(bytes.length, is(0));
}"
"@Test
public class Test {
    public void onReceive() {
        object broadcastReceiver = TestBroadcast();
        context.registerReceiver(
        broadcastReceiver,
        IntentFilter(BROADCAST_ACTION)
        );
        String value = ""value"" ;
        context.sendBroadcast(Intent(BROADCAST_ACTION).putExtra(EXTRA_STRING, value));
        shadowOf(getMainLooper()).idle() ;
        assertWithMessage(""Broadcast receiver did not execute"")
        .that(broadcastReceiver.broadcastExecuted.await(1, SECONDS))
        .isTrue();
        assertThat(broadcastReceiver.extraValue.get()).isEqualTo(value);
        assertThat(broadcastReceiver.job.get().isCancelled).isTrue();
    }
}"
"@Test public void primitiveBooleans() throws Exception {
    assertThat(testResult(PrimitiveBooleans.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveBooleans.iterations);
    assertEquals(true,PrimitiveBooleans.values.get(0));
    assertEquals(new HashSet<>(asList(true,false)),new HashSet<>(PrimitiveBooleans.values));
    PrimitiveBooleans.iterations=0;
}"
"@Test
public void testBrokerDiscoveryRoundRobin() throws Exception {
    addBrokerToZk(5);
    String prevUrl = null;
    for (int i = 0; i < 10; i++) {
        String current = service.getDiscoveryProvider().nextBroker().getPulsarServiceUrl();
        assertNotEquals(prevUrl, current);
        prevUrl = current;
    }
}"
"@Test
public void testWrite() throws Exception {
    FileSystem fs = cluster.getFileSystem();
    long tStart = System.currentTimeMillis();
    bench.writeTest(fs);
    long execTime = System.currentTimeMillis() - tStart;
    bench.analyzeResult(fs, TestType.TEST_TYPE_WRITE, execTime);
}"
"/**
* Tests ReflectionToStringBuilder.toString() for statics.
*/
@Test public void testReflectionStatics(){
    final ReflectionStaticFieldsFixture instance1=new ReflectionStaticFieldsFixture();
    assertEquals(this.toBaseString(instance1) + ""[instanceInt=67890,instanceString=instanceString,staticInt=12345,staticString=staticString]"",ReflectionToStringBuilder.toString(instance1,null,false,true,ReflectionStaticFieldsFixture.class));
    assertEquals(this.toBaseString(instance1) + ""[instanceInt=67890,instanceString=instanceString,staticInt=12345,staticString=staticString,staticTransientInt=54321,staticTransientString=staticTransientString,transientInt=98765,transientString=transientString]"",ReflectionToStringBuilder.toString(instance1,null,true,true,ReflectionStaticFieldsFixture.class));
    assertEquals(this.toBaseString(instance1) + ""[instanceInt=67890,instanceString=instanceString,staticInt=12345,staticString=staticString]"",this.toStringWithStatics(instance1,null,ReflectionStaticFieldsFixture.class));
    assertEquals(this.toBaseString(instance1) + ""[instanceInt=67890,instanceString=instanceString,staticInt=12345,staticString=staticString]"",this.toStringWithStatics(instance1,null,ReflectionStaticFieldsFixture.class));
}"
"@Test
public void atScope1() throws Exception {
    System.out.println(""atScope1"");
    BThread b1 = new BThread(""ThreadB1"");
    BThread b2 = new BThread(""ThreadB2"");
    CThread c1 = new CThread(""ThreadC1"");
    CThread c2 = new CThread(""ThreadC2"");
    b1.start();
    b2.start();
    c1.start();
    c2.start();
    b1.join();
    b2.join();
    c1.join();
    c2.join();
    Assert.assertEquals(""None"", b1.failedReason);
    Assert.assertEquals(""None"", b2.failedReason);
    Assert.assertEquals(""None"", c1.failedReason);
    Assert.assertEquals(""None"", c2.failedReason);
}"
"@Test
public void testStopTimer_withCleanUp() throws InterruptedException {
    TestTimeLimitExceededListener listenerSpy = spy(mListener);
    mWorkTimer.startTimer(WORKSPEC_ID_1, 100, listenerSpy);
    mWorkTimer.stopTimer(WORKSPEC_ID_1);
    Thread.sleep(100);
    verify(listenerSpy, times(0)).onTimeLimitExceeded(WORKSPEC_ID_1);
    assertThat(mWorkTimer.getTimerMap().size(), is(0));
    assertThat(mWorkTimer.getListeners().size(), is(0));
}"
"@Test
void writesAndReadsCustomFieldsConvertedClass() {
    List<Object> converters = new ArrayList<>();
    converters.add(BigDecimalToStringConverter.INSTANCE);
    converters.add(StringToBigDecimalConverter.INSTANCE);
    CustomConversions customConversions = new CouchbaseCustomConversions(converters);
    converter.setCustomConversions(customConversions);
    converter.afterPropertiesSet();
    ((CouchbaseMappingContext) (converter.getMappingContext())).setSimpleTypeHolder(customConversions.getSimpleTypeHolder());
    CouchbaseDocument converted = new CouchbaseDocument();
    final String valueStr = ""12.345"";
    final BigDecimal value = new BigDecimal(valueStr);
    final String value2Str = ""0.6789"";
    final BigDecimal value2 = new BigDecimal(value2Str);
    List<BigDecimal> listOfValues = new ArrayList<>();
    listOfValues.add(value);
    listOfValues.add(value2);
    Map<String, BigDecimal> mapOfValues = new HashMap<>();
    mapOfValues.put(""val1"", value);
    mapOfValues.put(""val2"", value2);
    CustomFieldsEntity entity = new CustomFieldsEntity(value, listOfValues, mapOfValues);
    converter.write(entity, converted);
    CouchbaseDocument source = new CouchbaseDocument();
    source.put(""_class"", CustomFieldsEntity.class.getName());
    source.put(""decimalValue"", valueStr);
    CouchbaseList listOfValuesDoc = new CouchbaseList();
    listOfValuesDoc.put(valueStr);
    listOfValuesDoc.put(value2Str);
    source.put(""listOfDecimalValues"", listOfValuesDoc);
    CouchbaseDocument mapOfValuesDoc = new CouchbaseDocument();
    mapOfValuesDoc.put(""val1"", valueStr);
    mapOfValuesDoc.put(""val2"", value2Str);
    source.put(""mapOfDecimalValues"", mapOfValuesDoc);
    assertThat(valueStr).isEqualTo(((CouchbaseList) (converted.getContent().get(""listOfDecimalValues""))).get(0));
    assertThat(value2Str).isEqualTo(((CouchbaseList) (converted.getContent().get(""listOfDecimalValues""))).get(1));
    assertThat(converted.export().toString()).isEqualTo(source.export().toString());
    CustomFieldsEntity readConverted = converter.read(CustomFieldsEntity.class, source);
    assertThat(readConverted.value).isEqualTo(value);
    assertThat(readConverted.listOfValues.get(0)).isEqualTo(listOfValues.get(0));
    assertThat(readConverted.listOfValues.get(1)).isEqualTo(listOfValues.get(1));
    assertThat(readConverted.mapOfValues.get(""val1"")).isEqualTo(mapOfValues.get(""val1""));
    assertThat(readConverted.mapOfValues.get(""val2"")).isEqualTo(mapOfValues.get(""val2""));
}"
"@Test public void testDoNotPurgeRPCTask() throws Exception {
    int RPCTaskNums=10;
    TaskMonitor tm=TaskMonitor.get();
    for (int i=0; i < RPCTaskNums; i++) {
        tm.createRPCStatus(""PRCTask"" + i);
    }
    for (int i=0; i < TaskMonitor.DEFAULT_MAX_TASKS; i++) {
        tm.createStatus(""otherTask"" + i);
    }
    int remainRPCTask=0;
    for (  MonitoredTask task : tm.getTasks()) {
        if (task instanceof MonitoredRPCHandler) {
            remainRPCTask++;
        }
    }
    assertEquals(""RPC Tasks have been purged!"",RPCTaskNums,remainRPCTask);
    tm.shutdown();
    tm.purgeAllTasks();
}"
"@Test public void primitiveBooleans(){
    assertThat(testResult(PrimitiveBooleans.class),isSuccessful());
    assertEquals(1,PrimitiveBooleans.iterations);
    assertEquals(singleton(true),PrimitiveBooleans.testCases);
    PrimitiveBooleans.iterations=0;
}"
"@Test public void wrapperIntegers() throws Exception {
    assertThat(testResult(WrapperIntegers.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperIntegers.iterations);
    assertEquals(new HashSet<>(asList(4,5)),new HashSet<>(WrapperIntegers.values.subList(0,2)));
    WrapperIntegers.iterations=0;
}"
"@Test
public void testBindReferenceable() throws Exception {
    Name name = new CompositeName(""test"");
    final TestObjectReferenceable referenceable = new TestObjectReferenceable(""addr"");
    namingContext.bind(name, referenceable);
    Object result = namingContext.lookup(name);
    assertEquals(referenceable.addr, result);
    name = new CompositeName(""securitytest"");
    testActionPermission(JndiPermission.ACTION_BIND, namingContext, ""securitytest"", referenceable);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, ""securitytest"");
    assertEquals(referenceable.addr, result);
}"
"@Test
public void testAuthenticationFromMultipleThreadsWithCachedToken()
{
    ExecutorService executor = newCachedThreadPool(daemonThreadsNamed(this.getClass().getName() + ""%n""));
    MockTokenPoller tokenPoller = new MockTokenPoller()
    .withResult(URI.create(""http://token.uri""), successful(new Token(""valid-token"")));
    MockRedirectHandler redirectHandler = new MockRedirectHandler()
    .sleepOnRedirect(Duration.ofMillis(10));
    ExternalAuthenticator authenticator = new ExternalAuthenticator(redirectHandler, tokenPoller, KnownToken.memoryCached(), Duration.ofSeconds(1));
    List<Future<Request>> requests = times(
    4, () -> authenticator.authenticate(null, getUnauthorizedResponse(""Bearer x_token_server=\""http://token.uri\"", x_redirect_server=\""http://redirect.uri\"""")))
    .map(executor::submit)
    .collect(toImmutableList());
    ConcurrentRequestAssertion assertion = new ConcurrentRequestAssertion(requests);
    assertion.requests()
    .extracting(Request::headers)
    .extracting(headers -> headers.get(AUTHORIZATION))
    .containsOnly(""Bearer valid-token"");
    assertion.assertThatNoExceptionsHasBeenThrown();
    assertThat(redirectHandler.getRedirectionCount()).isEqualTo(1);
}"
"@Test public void trialCountHoldsForEntirePropertyRatherThanIndividualParameters(){
    assertThat(testResult(ForValuesOfMultipleParameters.class),isSuccessful());
    assertEquals(4,ForValuesOfMultipleParameters.iterations);
    List<Foo> foos=ForValuesOfMultipleParameters.foos;
    assertEquals(8,foos.size());
    assertEquals(foos.get(0),foos.get(4));
    assertEquals(foos.get(1),foos.get(3));
    assertEquals(foos.get(2),foos.get(6));
    assertEquals(foos.get(5),foos.get(7));
    ForValuesOfMultipleParameters.iterations=0;
    ForValuesOfMultipleParameters.foos.clear();
}"
"@Test public void testSimpleReflectionStatics(){
    final SimpleReflectionStaticFieldsFixture instance1=new SimpleReflectionStaticFieldsFixture();
    assertEquals(this.toBaseString(instance1) + ""[staticInt=12345,staticString=staticString]"",ReflectionToStringBuilder.toString(instance1,null,false,true,SimpleReflectionStaticFieldsFixture.class));
    assertEquals(this.toBaseString(instance1) + ""[staticInt=12345,staticString=staticString]"",ReflectionToStringBuilder.toString(instance1,null,true,true,SimpleReflectionStaticFieldsFixture.class));
    assertEquals(this.toBaseString(instance1) + ""[staticInt=12345,staticString=staticString]"",this.toStringWithStatics(instance1,null,SimpleReflectionStaticFieldsFixture.class));
    assertEquals(this.toBaseString(instance1) + ""[staticInt=12345,staticString=staticString]"",this.toStringWithStatics(instance1,null,SimpleReflectionStaticFieldsFixture.class));
}"
"/**
* for issue https://github.com/nutzam/nutz/issues/1393
*/
@Test public void test_final_field(){
    Issue1393 obj=new Issue1393(""test1"",99);
    String json=Json.toJson(obj,JsonFormat.compact());
    assertJsonEqualsNonStrict(""{\""name\"":\""test1\"",\""age\"":99}"",json);
}"
"@Test
public void testTakeSnapshot() throws Exception {
    String snapshotName1 = ""snapshotName1"";
    String snapshotName2 = ""snapshotName2"";
    TableName tableName = TableName.valueOf(""testTakeSnapshot"");
    Admin syncAdmin = TEST_UTIL.getAdmin();
    try {
        Table table = TEST_UTIL.createTable(tableName, Bytes.toBytes(""f1""));
        for (int i = 0; i < 3000; i++) {
            table.put(new Put(Bytes.toBytes(i)).addColumn(Bytes.toBytes(""f1""), Bytes.toBytes(""cq""),
            Bytes.toBytes(i)));
        }
        admin.snapshot(snapshotName1, tableName).get();
        admin.snapshot(snapshotName2, tableName).get();
        List<SnapshotDescription> snapshots = syncAdmin.listSnapshots();
        Collections.sort(snapshots, (snap1, snap2) -> {
            Assert.assertNotNull(snap1);
            Assert.assertNotNull(snap1.getName());
            Assert.assertNotNull(snap2);
            Assert.assertNotNull(snap2.getName());
            return snap1.getName().compareTo(snap2.getName());
        });
        Assert.assertEquals(snapshotName1, snapshots.get(0).getName());
        Assert.assertEquals(tableName, snapshots.get(0).getTableName());
        Assert.assertEquals(SnapshotType.FLUSH, snapshots.get(0).getType());
        Assert.assertEquals(snapshotName2, snapshots.get(1).getName());
        Assert.assertEquals(tableName, snapshots.get(1).getTableName());
        Assert.assertEquals(SnapshotType.FLUSH, snapshots.get(1).getType());
    } finally {
        syncAdmin.deleteSnapshot(snapshotName1);
        syncAdmin.deleteSnapshot(snapshotName2);
        TEST_UTIL.deleteTable(tableName);
    }"
"@Test public void serializeFloat() throws IOException {
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of(1.0f)),""{\""@type\"":\""float\"",\""@value\"":1.0}"");
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of(42.4f)),""{\""@type\"":\""float\"",\""@value\"":42.4}"");
}"
"@Test
public void assertPersistEphemeralSequential() throws Exception {
    zkRegCenter.persistEphemeralSequential(""/sequential/test_ephemeral_sequential"");
    zkRegCenter.persistEphemeralSequential(""/sequential/test_ephemeral_sequential"");
    CuratorFramework client = CuratorFrameworkFactory.newClient(EmbedTestingServer.getConnectionString(), new RetryOneTime(2000));
    client.start();
    client.blockUntilConnected();
    List<String> actual = client.getChildren().forPath(""/"" + ZookeeperRegistryCenterModifyTest.class.getName() + ""/sequential"");
    assertThat(actual.size(), is(2));
    for (String each : actual) {
        assertThat(each, startsWith(""test_ephemeral_sequential""));
    }
    zkRegCenter.close();
    actual = client.getChildren().forPath(""/"" + ZookeeperRegistryCenterModifyTest.class.getName() + ""/sequential"");
    assertTrue(actual.isEmpty());
    zkRegCenter.init();
}"
"@Test(expected=ClusterStateException.class) public void testReassignFailOnStartNew() throws IOException {
    ReceiverAdminClient receiverAdminClient=mockReceiverClientFailOnStartNewComsumer();
    coordinator=new Coordinator(metadataStore,receiverAdminClient);
    Map<Integer,List<Partition>> preAssignMap=metadataStore.getAssignmentsByCube(cubeName).getAssignments();
    Map<Integer,List<Partition>> newAssignMap=new LinkedHashMap<>();
    newAssignMap.put(1,Lists.newArrayList(p1,p2,p3));
    newAssignMap.put(2,Lists.newArrayList(p4,p5));
    newAssignMap.put(3,Lists.newArrayList(p6));
    CubeAssignment preAssigment=new CubeAssignment(cube.getName(),preAssignMap);
    CubeAssignment newAssigment=new CubeAssignment(cube.getName(),newAssignMap);
    try {
        coordinator.doReassign(cube,preAssigment,newAssigment);
    }
    catch (  ClusterStateException rune) {
        assertSame(ClusterStateException.ClusterState.ROLLBACK_FAILED,rune.getClusterState());
        assertSame(ClusterStateException.TransactionStep.START_NEW,rune.getTransactionStep());
        System.out.println(rune.getMessage());
        throw rune;
    }
}"
"@Test public void primitiveFloats(){
    assertThat(testResult(PrimitiveFloats.class),isSuccessful());
    assertEquals(2,PrimitiveFloats.iterations);
    assertEquals(new HashSet<>(asList(3.3F,-5F)),PrimitiveFloats.testCases);
    PrimitiveFloats.iterations=0;
    PrimitiveFloats.testCases.clear();
}"
"@Test public void testObject(){
    RpcContext context=RpcContext.getContext();
    Map<String,Object> map=new HashMap<String,Object>();
    map.put(""_11"",""1111"");
    map.put(""_22"",""2222"");
    map.put("".33"",""3333"");
    map.forEach(context::set);
    Assertions.assertEquals(map,context.get());
    Assertions.assertEquals(""1111"",context.get(""_11""));
    context.set(""_11"",""11.11"");
    Assertions.assertEquals(""11.11"",context.get(""_11""));
    context.set(null,""22222"");
    context.set(""_22"",null);
    Assertions.assertEquals(""22222"",context.get(null));
    Assertions.assertNull(context.get(""_22""));
    Assertions.assertNull(context.get(""_33""));
    Assertions.assertEquals(""3333"",context.get("".33""));
    map.keySet().forEach(context::remove);
    Assertions.assertNull(context.get(""_11""));
    RpcContext.removeContext();
}"
"@Test
public void testRemoveFirstConsumer() throws Exception {
    this.conf.setSubscriptionKeySharedEnable(true);
    String topic = ""testReadAheadWhenAddingConsumers-"" + UUID.randomUUID();
    @Cleanup
    Producer<Integer> producer = createProducer(topic, false);
    @Cleanup
    Consumer<Integer> c1 = pulsarClient.newConsumer(INT32).topic(topic).subscriptionName(""key_shared"").subscriptionType(Key_Shared).receiverQueueSize(10).consumerName(""c1"").subscribe();
    for (int i = 0; i < 10; i++) {
        producer.newMessage().key(String.valueOf(random.nextInt(NUMBER_OF_KEYS))).value(i).send();
    }
    @Cleanup
    Consumer<Integer> c2 = pulsarClient.newConsumer(INT32).topic(topic).subscriptionName(""key_shared"").subscriptionType(Key_Shared).receiverQueueSize(10).consumerName(""c2"").subscribe();
    for (int i = 10; i < 20; i++) {
        producer.newMessage().key(String.valueOf(random.nextInt(NUMBER_OF_KEYS))).value(i).send();
    }
    assertNull(c2.receive(100, TimeUnit.MILLISECONDS));
    c1.close();
    for (int i = 0; i < 20; i++) {
        Message<Integer> msg = c2.receive();
        assertEquals(msg.getValue().intValue(), i);
        c2.acknowledge(msg);
    }
}"
"@Test
public void test_1() throws Exception {
    V1 entity = new V1();
    String text = JSON.toJSONString(entity, SortField);
    System.out.println(text);
    Assert.assertEquals(""{\""f1\"":0,\""f2\"":0,\""f3\"":0,\""f4\"":0,\""f5\"":0}"", text);
    JSONObject object = JSON.parseObject(text);
    text = JSON.toJSONString(object, SortField);
    Assert.assertEquals(""{\""f1\"":0,\""f2\"":0,\""f3\"":0,\""f4\"":0,\""f5\"":0}"", text);
}"
"@Test public void shouldDeserializeSerializedContentPack() throws Exception {
    final ContentPack contentPack=createTestContentPack();
    final URL contentPackURL=ContentPackTest.class.getResource(""expected_content_pack.json"");
    Path path=Paths.get(contentPackURL.toURI());
    String expectedJSON=String.join("""",Files.readAllLines(path)).replace(""\n"","""").replace(""\r"","""");
    final String jsonTxt=objectMapper.writeValueAsString(contentPack);
    assertJSONEqual(jsonTxt,expectedJSON);
    final ContentPack readContentPack=objectMapper.readValue(jsonTxt,ContentPack.class);
    assertThat(readContentPack.id()).isEqualTo(contentPack.id());
    assertThat(readContentPack.version()).isEqualTo(contentPack.version());
    assertThat(readContentPack.revision()).isEqualTo(contentPack.revision());
}"
"@Test
public void shouldBeAbleToCancelJob() throws Exception {
    RobustJobSchedulerWrapper robustWrapper = new RobustJobSchedulerWrapper(actualScheduler, log);
    AtomicInteger count = new AtomicInteger();
    JobHandle jobHandle = robustWrapper.scheduleRecurring(""JobName"", 1, count::incrementAndGet);
    assertEventually(""run count"", count::get, Matchers.greaterThanOrEqualTo(100), DEFAULT_TIMEOUT_MS, MILLISECONDS);
    robustWrapper.cancelAndWaitTermination(jobHandle);
    int finalCount = count.get();
    Thread.sleep(50);
    assertEquals(finalCount, count.get());
}"
"@Test public void primitiveDoubles() throws Exception {
    assertThat(testResult(PrimitiveDoubles.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveDoubles.iterations);
    PrimitiveDoubles.iterations=0;
}"
"@Test
public void testWorkerInstances() throws Exception {
    ApplicationManager applicationManager = deployApplication(testSpace, AppUsingGetServiceURL.class);
    WorkerManager workerManager = applicationManager.getWorkerManager(PINGING_WORKER).start();
    workerManager.waitForStatus(true);
    workerInstancesCheck(workerManager, 5);
    workerManager.setInstances(10);
    workerInstancesCheck(workerManager, 10);
    workerManager.setInstances(2);
    workerInstancesCheck(workerManager, 2);
    workerManager.setInstances(2);
    workerInstancesCheck(workerManager, 2);
    WorkerManager lifecycleWorkerManager = applicationManager.getWorkerManager(LIFECYCLE_WORKER).start();
    lifecycleWorkerManager.waitForStatus(true);
    lifecycleWorkerManager.setInstances(5);
    workerInstancesCheck(lifecycleWorkerManager, 5);
    for (int i = 0; i < 5; i++) {
        kvTableKeyCheck(testSpace, WORKER_INSTANCES_DATASET, Bytes.toBytes(String.format(""init.%d"", i)));
    }
    lifecycleWorkerManager.stop();
    lifecycleWorkerManager.waitForStatus(false);
    if (workerManager.isRunning()) {
        workerManager.stop();
    }
    workerManager.waitForStatus(false);
    workerInstancesCheck(lifecycleWorkerManager, 5);
    workerInstancesCheck(workerManager, 2);
    assertWorkerDatasetWrites(Bytes.toBytes(""init""), Bytes.stopKeyForPrefix(Bytes.toBytes(""init.2"")), 3, 3);
    assertWorkerDatasetWrites(Bytes.toBytes(""init.3""), Bytes.stopKeyForPrefix(Bytes.toBytes(""init"")), 2, 5);
    byte[] startRow = Bytes.toBytes(""stop"");
    assertWorkerDatasetWrites(startRow, Bytes.stopKeyForPrefix(startRow), 5, 5);
}"
"@Test public void testProxy() throws Exception {
    service2.export();
    assertThat(service2.getExportedUrls(),hasSize(1));
    assertEquals(2,TestProxyFactory.count);
    TestProxyFactory.count=0;
}"
"@Test public void favorValueOf() throws Exception {
    assertThat(testResult(FavorValueOf.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),FavorValueOf.iterations);
    FavorValueOf.iterations=0;
}"
"@Test
public void testNotAllowNullSchema() {
    AvroSchema<Foo> avroSchema = AvroSchema.of(SchemaDefinition.<Foo>builder().withPojo(Foo.class).withAlwaysAllowNull(false).build());
    assertEquals(avroSchema.getSchemaInfo().getType(), AVRO);
    Schema.Parser parser = new Schema.Parser();
    String schemaJson = new String(avroSchema.getSchemaInfo().getSchema());
    assertEquals(schemaJson, SCHEMA_AVRO_NOT_ALLOW_NULL);
    Schema schema = parser.parse(schemaJson);
    for (String fieldName : FOO_FIELDS) {
        Schema.Field field = schema.getField(fieldName);
        Assert.assertNotNull(field);
        if (field.name().equals(""field4"")) {
            Assert.assertNotNull(field.schema().getTypes().get(1).getField(""field1""));
        }
        if (field.name().equals(""fieldUnableNull"")) {
            Assert.assertNotNull(field.schema().getType());
        }
    }
}"
"@Test
public void testOnlyExternalContextAllowsCache() throws Exception {
    KernelServices services = createKernelServicesBuilder(AdditionalInitialization.MANAGEMENT)
    .build();
    Assert.assertTrue(services.isSuccessfulBoot());
    List<ModelNode> list = parse(ModelTestUtils.readResource(this.getClass(), ""subsystem.xml""));
    for (ModelNode addOp : list) {
        PathAddress addr = PathAddress.pathAddress(addOp.require(ModelDescriptionConstants.OP_ADDR));
        if (addr.size() == 2 && addr.getLastElement().getKey().equals(NamingSubsystemModel.BINDING) && BindingType.forName(addOp.get(NamingBindingResourceDefinition.BINDING_TYPE.getName()).asString()) != BindingType.EXTERNAL_CONTEXT) {
            addOp.get(NamingBindingResourceDefinition.CACHE.getName()).set(true);
            services.executeForFailure(addOp);
            addOp.remove(NamingBindingResourceDefinition.CACHE.getName());
            ModelTestUtils.checkOutcome(services.executeOperation(addOp));
            ModelTestUtils.checkFailed(services.executeOperation(Util.getWriteAttributeOperation(addr, NamingBindingResourceDefinition.CACHE.getName(), new ModelNode(true))));
        } else {
            ModelTestUtils.checkOutcome(services.executeOperation(addOp));
        }
    }"
"/**
* Fruits - serialization tests for simple property on sub-classes
*/
public void testExistingPropertySerializationFruits() throws Exception {
    Map<String,Object> result=writeAndMap(MAPPER,pinguo);
    assertEquals(3,result.size());
    assertEquals(pinguo.name,result.get(""name""));
    assertEquals(pinguo.seedCount,result.get(""seedCount""));
    assertEquals(pinguo.type,result.get(""type""));
    result=writeAndMap(MAPPER,mandarin);
    assertEquals(3,result.size());
    assertEquals(mandarin.name,result.get(""name""));
    assertEquals(mandarin.color,result.get(""color""));
    assertEquals(mandarin.type,result.get(""type""));
    String pinguoSerialized=MAPPER.writeValueAsString(pinguo);
    assertEquals(pinguoSerialized,pinguoJson);
    String mandarinSerialized=MAPPER.writeValueAsString(mandarin);
    assertEquals(mandarinSerialized,mandarinJson);
    String fruitWrapperSerialized=MAPPER.writeValueAsString(pinguoWrapper);
    assertEquals(fruitWrapperSerialized,pinguoWrapperJson);
    String fruitListSerialized=MAPPER.writeValueAsString(fruitList);
    assertEquals(fruitListSerialized,fruitListJson);
}"
"@Test public void enums(){
    assertThat(testResult(Enums.class),isSuccessful());
    assertEquals(2,Enums.iterations);
    assertEquals(EnumSet.of(HALF_UP,HALF_EVEN),Enums.testCases);
    Enums.iterations=0;
}"
"@Test
public void testFlowNoConflictsWithClients() throws Exception {
    startComputation(0, stopFlag0);
    if (!tcpDiscovery())
    return;
    startComputation(1, stopFlag1);
    startComputation(2, stopFlag2);
    startComputation(3, stopFlag3);
    startComputation(4, stopFlag4);
    final Set<Integer> deafClientObservedIds = new ConcurrentHashSet<>();
    startListening(5, true, deafClientObservedIds);
    final Set<Integer> regClientObservedIds = new ConcurrentHashSet<>();
    startListening(6, false, regClientObservedIds);
    START_LATCH.countDown();
    Thread killer = new Thread(new ServerNodeKiller());
    Thread resurrection = new Thread(new ServerNodeResurrection());
    killer.setName(""node-killer-thread"");
    killer.start();
    resurrection.setName(""node-resurrection-thread"");
    resurrection.start();
    while (!updatesQueue.isEmpty())
    Thread.sleep(1000);
    killer.interrupt();
    resurrection.interrupt();
}"
"public void test_set() throws Exception {
    Set<Object> set=new LinkedHashSet<Object>();
    set.add(3L);
    set.add(4L);
    Entity entity=new Entity();
    entity.setValue(set);
    String text=JSON.toJSONString(entity,SerializerFeature.WriteClassName);
    System.out.println(text);
    Assert.assertEquals(""{\""@type\"":\""com.alibaba.json.bvt.bug.Bug_for_smoothrat6$Entity\"",\""value\"":Set[3L,4L]}"",text);
    Entity entity2=JSON.parseObject(text,Entity.class);
    Assert.assertEquals(set,entity2.getValue());
}"
"public void test_for_multimap() throws Exception {
    HashMultimap map=HashMultimap.create();
    map.put(""name"",""a"");
    map.put(""name"",""b"");
    String json=JSON.toJSONString(map);
    assertTrue(json.equals(""{\""name\"":[\""a\"",\""b\""]}"") || json.equals(""{\""name\"":[\""b\"",\""a\""]}""));
}"
"@Test
public void testFireObjectEvent() throws Exception {
    final NamingEventCoordinator coordinator = new NamingEventCoordinator();
    final CollectingListener objectListener = new CollectingListener(1);
    coordinator.addListener(""test/path"", EventContext.OBJECT_SCOPE, objectListener);
    final CollectingListener subtreeListener = new CollectingListener(0);
    coordinator.addListener(""test"", EventContext.SUBTREE_SCOPE, subtreeListener);
    final CollectingListener oneLevelListener = new CollectingListener(0);
    coordinator.addListener(""test"", EventContext.ONELEVEL_SCOPE, oneLevelListener);
    coordinator.fireEvent(context, new CompositeName(""test/path""), null, null, NamingEvent.OBJECT_ADDED, ""bind"", EventContext.OBJECT_SCOPE);
    objectListener.latch.await(1, TimeUnit.SECONDS);
    assertEquals(1, objectListener.capturedEvents.size());
    assertTrue(oneLevelListener.capturedEvents.isEmpty());
    assertTrue(subtreeListener.capturedEvents.isEmpty());
}"
"/**
* Tests ReflectionToStringBuilder.toString() for statics.
*/
@Test public void testInheritedReflectionStatics(){
    final InheritedReflectionStaticFieldsFixture instance1=new InheritedReflectionStaticFieldsFixture();
    assertEquals(this.toBaseString(instance1) + ""[staticInt2=67890,staticString2=staticString2]"",ReflectionToStringBuilder.toString(instance1,null,false,true,InheritedReflectionStaticFieldsFixture.class));
    assertEquals(this.toBaseString(instance1) + ""[staticInt2=67890,staticString2=staticString2,staticInt=12345,staticString=staticString]"",ReflectionToStringBuilder.toString(instance1,null,false,true,SimpleReflectionStaticFieldsFixture.class));
    assertEquals(this.toBaseString(instance1) + ""[staticInt2=67890,staticString2=staticString2,staticInt=12345,staticString=staticString]"",this.toStringWithStatics(instance1,null,SimpleReflectionStaticFieldsFixture.class));
    assertEquals(this.toBaseString(instance1) + ""[staticInt2=67890,staticString2=staticString2,staticInt=12345,staticString=staticString]"",this.toStringWithStatics(instance1,null,SimpleReflectionStaticFieldsFixture.class));
}"
"@Test
public void testingUserServiceGaugeMetrics() throws Exception {
    MetricsCollector collector =
    collectionService.getCollector(getUserServiceContext(Constants.DEFAULT_NAMESPACE, ""WordCount"", ""CounterService"",
    ""CountRunnable""));
    collector.increment(""gmetric"", 1);
    collector.gauge(""gmetric"", 10);
    collector.increment(""gmetric"", 1);
    TimeUnit.SECONDS.sleep(1);
    collector.gauge(""gmetric"", 10);
    TimeUnit.SECONDS.sleep(2);
    String runnableRequest =
    ""/system/apps/WordCount/services/CounterService/runnables/CountRunnable/gmetric?aggregate=true"";
    String serviceRequest =
    ""/system/apps/WordCount/services/CounterService/gmetric?aggregate=true"";
    testSingleMetric(runnableRequest, 10);
    testSingleMetric(serviceRequest, 10);
}"
"@Test public void primitiveIntegers() throws Exception {
    assertThat(testResult(PrimitiveIntegers.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveIntegers.iterations);
    PrimitiveIntegers.iterations=0;
}"
"@Test
public void manyParameters() throws Exception {
    assertThat(testResult(ManyParameters.class), isSuccessful());
    assertEquals(6, ManyParameters.iterations);
    assertEquals(asList(-1, -2, -4, -1, -2, -4), ManyParameters.firstTestCases);
    assertEquals(asList('r', 'r', 'r', 'y', 'y', 'y'), ManyParameters.secondTestCases);
}"
"@Test
public void testTrackMetadata_rowTombstone() throws Throwable
{
    createTable(""CREATE TABLE %s (a int, b int, c text, PRIMARY KEY (a, b))"");
    ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(currentTable());
    execute(""DELETE FROM %s USING TIMESTAMP 9999 WHERE a = 1"");
    cfs.forceBlockingFlush();
    assertEquals(1, cfs.getLiveSSTables().size());
    StatsMetadata metadata = cfs.getLiveSSTables().iterator().next().getSSTableMetadata();
    assertEquals(9999, metadata.minTimestamp);
    assertEquals(9999, metadata.maxTimestamp);
    assertEquals(System.currentTimeMillis()/1000, metadata.maxLocalDeletionTime, 5);
    assertEquals(nowInSec(), metadata.maxLocalDeletionTime, DELTA);
    cfs.forceMajorCompaction();
    StatsMetadata metadata2 = cfs.getLiveSSTables().iterator().next().getSSTableMetadata();
    assertEquals(metadata.maxLocalDeletionTime, metadata2.maxLocalDeletionTime);
    assertEquals(metadata.minTimestamp, metadata2.minTimestamp);
    assertEquals(metadata.maxTimestamp, metadata2.maxTimestamp);
}"
"@Test public void test_enum(){
    assertEquals(""\""K\"""",Json.toJson(K.K));
    String expected=""{\n"" + ""   \""name\"": \""t\"",\n"" + ""   \""index\"": 1\n""+ ""}"";
    assertJsonEqualsNonStrict(expected,Json.toJson(TT.T));
    assertEquals(""\""T\"""",Json.toJson(TT.T,JsonFormat.full().ignoreJsonShape()));
}"
"@Test
void testTimedMethod() throws InterruptedException {
    assertTrue(Jobs.latch01.await(5, TimeUnit.SECONDS));
    assertTrue(Jobs.latch02.await(5, TimeUnit.SECONDS));
    Timer timer1 = registry.get(""scheduled.methods"")
    .tag(""method"", ""everySecond"")
    .tag(""class"", ""io.quarkus.scheduler.test.metrics.MicrometerTimedTest$Jobs"")
    .tag(""exception"", ""none"")
    .timer();
    assertNotNull(timer1);
    assertTrue(timer1.count() > 0);
    Timer timer2 = registry.get(""foo"")
    .tag(""method"", ""anotherEverySecond"")
    .tag(""class"", ""io.quarkus.scheduler.test.metrics.MicrometerTimedTest$Jobs"")
    .tag(""exception"", ""none"")
    .timer();
    assertNotNull(timer2);
    assertTrue(timer2.count() > 0);
}"
"@Test public void BuilderAndGettersWithMultipleValuesTest(){
    List<String> emails=Arrays.asList(""email0"",""email1"");
    List<String> phones=Arrays.asList(""1234567890"",""2062062006"");
    List<GenderEnum> genders=Arrays.asList(GenderEnum.MALE,GenderEnum.FEMALE);
    List<String> datesOfBirth=Arrays.asList(""20000101"",""20000102"");
    List<String> lastNames=Arrays.asList(""lastname-1"",""lastname-2"");
    List<String> firstNames=Arrays.asList(""firstname-2"",""firstname-3"");
    List<String> cities=Arrays.asList(""Seattle"",""Portland"");
    List<String> states=Arrays.asList(""WA"",""CA"");
    List<String> zipcodes=Arrays.asList(""98123"",""98122"");
    List<String> countryCodes=Arrays.asList(""USA"",""CA"");
    List<String> externalIds=Arrays.asList(""external-1"",""external-2"",""external-2"");
    UserData userData=new UserData();
    userData.emails(emails).phones(phones).genders(genders).datesOfBirth(datesOfBirth).lastNames(lastNames).firstNames(firstNames).cities(cities).states(states).zipcodes(zipcodes).countryCodes(countryCodes).externalIds(externalIds);
    assertEquals(userData.getEmails(),emails);
    assertEquals(userData.getPhones(),phones);
    assertEquals(userData.getGenders(),genders);
    assertEquals(userData.getDatesOfBirth(),datesOfBirth);
    assertEquals(userData.getLastNames(),lastNames);
    assertEquals(userData.getFirstNames(),firstNames);
    assertEquals(userData.getCities(),cities);
    assertEquals(userData.getStates(),states);
    assertEquals(userData.getZipcodes(),zipcodes);
    assertEquals(userData.getCountryCodes(),countryCodes);
    List<String> sortedActualExternalIds=userData.getExternalIds();
    Collections.sort(sortedActualExternalIds);
    assertEquals(sortedActualExternalIds,externalIds.subList(0,2));
}"
"@Test
public void testAsyncFunction() throws Exception {
    InstanceConfig instanceConfig = new InstanceConfig();
    Function<String, CompletableFuture<String>> function = (input, context) -> {
        log.info(""input string: {}"", input);
        CompletableFuture<String> result  = new CompletableFuture<>();
        Executors.newCachedThreadPool().submit(() -> {
            try {
                Thread.sleep(500);
                result.complete(String.format(""%s-lambda"", input));
            } catch (Exception e) {
                result.completeExceptionally(e);
            }
        });
        return result;
    };
    JavaInstance instance = new JavaInstance(
    mock(ContextImpl.class),
    function,
    instanceConfig);
    String testString = ""ABC123"";
    CompletableFuture<JavaExecutionResult> result = instance.handleMessage(mock(Record.class), testString);
    assertNotNull(result.get().getResult());
    assertEquals(new String(testString + ""-lambda""), result.get().getResult());
    instance.close();
}"
"@Test public void disablingShrinking(){
    assertThat(testResult(DisablingShrinking.class),failureCountIs(1));
    assertEquals(1,DisablingShrinking.attempts.size());
    DisablingShrinking.attempts.clear();
}"
"@Test
public void testAddLocation() throws Exception {
    DataSize maxResponseSize = DataSize.of(10, MEGABYTE);
    MockExchangeRequestProcessor processor = new MockExchangeRequestProcessor(maxResponseSize);
    TaskId task1 = new TaskId(new StageId(""query"", 1), 0, 0);
    TaskId task2 = new TaskId(new StageId(""query"", 1), 1, 0);
    TaskId task3 = new TaskId(new StageId(""query"", 1), 2, 0);
    URI location1 = URI.create(""http:www.example1.com"");
    URI location2 = URI.create(""http:www.example2.com"");
    URI location3 = URI.create(""http:www.example3.com"");
    processor.addPage(location1, createSerializedPage(1));
    processor.addPage(location1, createSerializedPage(2));
    TestingExchangeClientBuffer buffer = new TestingExchangeClientBuffer(DataSize.of(1, MEGABYTE));
    @SuppressWarnings(""resource"")
    ExchangeClient exchangeClient = new ExchangeClient(""localhost"", DataIntegrityVerification.ABORT, buffer, maxResponseSize, 1, new Duration(1, TimeUnit.MINUTES), true, new TestingHttpClient(processor, scheduler), scheduler, new SimpleLocalMemoryContext(newSimpleAggregatedMemoryContext(), ""test""), pageBufferClientCallbackExecutor, ( taskId, failure) -> {
    });
    assertThat(buffer.getAllTasks()).isEmpty();
    assertThat(buffer.getPages().asMap()).isEmpty();
    assertThat(buffer.getFinishedTasks()).isEmpty();
    assertThat(buffer.getFailedTasks().asMap()).isEmpty();
    assertFalse(buffer.isNoMoreTasks());
    exchangeClient.addLocation(task1, location1);
    assertThat(buffer.getAllTasks()).containsExactly(task1);
    assertTaskIsNotFinished(buffer, task1);
    processor.setComplete(location1);
    buffer.whenTaskFinished(task1).get(10, SECONDS);
    assertThat(buffer.getPages().get(task1)).hasSize(2);
    assertThat(buffer.getFinishedTasks()).containsExactly(task1);
    exchangeClient.addLocation(task2, location2);
    assertThat(buffer.getAllTasks()).containsExactlyInAnyOrder(task1, task2);
    assertTaskIsNotFinished(buffer, task2);
    processor.setComplete(location2);
    buffer.whenTaskFinished(task2).get(10, SECONDS);
    assertThat(buffer.getFinishedTasks()).containsExactlyInAnyOrder(task1, task2);
    assertThat(buffer.getPages().get(task2)).hasSize(0);
    exchangeClient.addLocation(task3, location3);
    assertThat(buffer.getAllTasks()).containsExactlyInAnyOrder(task1, task2, task3);
    assertTaskIsNotFinished(buffer, task3);
    exchangeClient.noMoreLocations();
    assertTrue(buffer.isNoMoreTasks());
    assertThat(buffer.getAllTasks()).containsExactlyInAnyOrder(task1, task2, task3);
    assertTaskIsNotFinished(buffer, task3);
    exchangeClient.close();
    assertEventually(() -> assertEquals(exchangeClient.getStatus().getPageBufferClientStatuses().get(0).getHttpRequestState(), ""not scheduled"", ""httpRequestState""));
    assertEventually(() -> assertEquals(exchangeClient.getStatus().getPageBufferClientStatuses().get(1).getHttpRequestState(), ""not scheduled"", ""httpRequestState""));
    assertEventually(() -> assertEquals(exchangeClient.getStatus().getPageBufferClientStatuses().get(2).getHttpRequestState(), ""not scheduled"", ""httpRequestState""));
    assertThat(buffer.getFinishedTasks()).containsExactlyInAnyOrder(task1, task2, task3);
    assertThat(buffer.getFailedTasks().asMap()).isEmpty();
    assertTrue(exchangeClient.isFinished());
}"
"@Test public void primitiveIntegers() throws Exception {
    assertThat(testResult(PrimitiveIntegers.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveIntegers.iterations);
    assertEquals(new HashSet<>(asList(1,2,3)),new HashSet<>(PrimitiveIntegers.values.subList(0,3)));
    PrimitiveIntegers.iterations=0;
}"
"@Test
public void testUnqualifiedUriContents() throws Exception {
    dirString = ""d1"";
    item = new PathData(dirString, conf);
    PathData[] items = item.getDirectoryContents();
    assertEquals(sortedString(""d1/f1"", ""d1/f1.1"", ""d1/f2""), sortedString(items));
}"
"public void test_for_issue() throws Exception {
    DataSimpleVO a=new DataSimpleVO(""a"",1);
    DataSimpleVO b=new DataSimpleVO(""b"",2);
    b.value=a;
    Map<String,Object> map=new HashMap<String,Object>();
    map.put(a.name,a);
    b.value1=map;
    String jsonStr=JSON.toJSONString(b,SerializerFeature.MapSortField);
    System.out.println(jsonStr);
    DataSimpleVO obj=JSON.parseObject(jsonStr,DataSimpleVO.class);
    assertEquals(jsonStr,JSON.toJSONString(obj,SerializerFeature.MapSortField));
}"
"@Test public void testNotAllowNullSchema() throws JSONException {
    AvroSchema<Foo> avroSchema=AvroSchema.of(SchemaDefinition.<Foo>builder().withPojo(Foo.class).withAlwaysAllowNull(false).build());
    assertEquals(avroSchema.getSchemaInfo().getType(),SchemaType.AVRO);
    Schema.Parser parser=new Schema.Parser();
    String schemaJson=new String(avroSchema.getSchemaInfo().getSchema());
    assertJSONEquals(schemaJson,SCHEMA_AVRO_NOT_ALLOW_NULL);
    Schema schema=parser.parse(schemaJson);
    for (  String fieldName : FOO_FIELDS) {
        Schema.Field field=schema.getField(fieldName);
        Assert.assertNotNull(field);
        if (field.name().equals(""field4"")) {
            Assert.assertNotNull(field.schema().getTypes().get(1).getField(""field1""));
        }
        if (field.name().equals(""fieldUnableNull"")) {
            Assert.assertNotNull(field.schema().getType());
        }
    }
}"
"@Test public void acrossParametersOfSameParameterizedType() throws Exception {
    assertThat(testResult(ParametersOfSameParameterizedType.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ParametersOfSameParameterizedType.iterations);
    ParametersOfSameParameterizedType.iterations=0;
}"
"@Test public void getFieldNamesTest(){
    List<String> names=EnumUtil.getFieldNames(TestEnum.class);
    Assert.assertTrue(names.contains(""type""));
    Assert.assertTrue(names.contains(""name""));
}"
"@Test
public void testTokenExpiry() throws Exception {
    ClockMock clock = ClockMock.frozen();
    TokenService tokenService = createTokenService(tokenServiceEnabledSettings, clock);
    Authentication authentication = new Authentication(new User(""joe"", ""admin""), new RealmRef(""native_realm"", ""native"", ""node1""), null);
    PlainActionFuture<Tuple<UserToken, String>> tokenFuture = new PlainActionFuture<>();
    tokenService.createUserToken(authentication, authentication, tokenFuture, Collections.emptyMap(), true);
    final UserToken token = tokenFuture.get().v1();
    mockGetTokenFromId(token);
    mockCheckTokenInvalidationFromId(token);
    authentication = token.getAuthentication();
    ThreadContext requestContext = new ThreadContext(Settings.EMPTY);
    storeTokenHeader(requestContext, tokenService.getUserTokenString(token));
    try (ThreadContext.StoredContext ignore = requestContext.newStoredContext(true)) {
        PlainActionFuture<UserToken> future = new PlainActionFuture<>();
        tokenService.getAndValidateToken(requestContext, future);
        assertAuthenticationEquals(authentication, future.get().getAuthentication());
    }
    final TimeValue defaultExpiration = TokenService.TOKEN_EXPIRATION.get(Settings.EMPTY);
    final int fastForwardAmount = randomIntBetween(1, Math.toIntExact(defaultExpiration.getSeconds()) - 5);
    try (ThreadContext.StoredContext ignore = requestContext.newStoredContext(true)) {
        clock.fastForwardSeconds(Math.toIntExact(defaultExpiration.getSeconds()) - fastForwardAmount);
        clock.rewind(TimeValue.timeValueNanos(clock.instant().getNano()));
        PlainActionFuture<UserToken> future = new PlainActionFuture<>();
        tokenService.getAndValidateToken(requestContext, future);
        assertAuthenticationEquals(authentication, future.get().getAuthentication());
    }
    assertSettingDeprecationsAndWarnings(new Setting[] { TokenService.BWC_ENABLED });
}"
"@Test
public void testLookupReference() throws Exception {
    final Name name = new CompositeName(""test"");
    final Reference reference = new Reference(String.class.getName(), new StringRefAddr(""blah"", ""test""), TestObjectFactory.class.getName(), null);
    namingStore.bind(name, reference);
    Object result = namingContext.lookup(name);
    assertEquals(""test"", result);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, ""test"");
    assertEquals(""test"", result);
}"
"@Test
public void testLookupWithContinuation() throws Exception {
    namingStore.bind(new CompositeName(""comp/nested""), ""test"");
    final Reference reference = new Reference(String.class.getName(), new StringRefAddr(""nns"", ""comp""), TestObjectFactoryWithNameResolution.class.getName(), null);
    namingStore.bind(new CompositeName(""test""), reference);
    Object result = namingContext.lookup(new CompositeName(""test/nested""));
    assertEquals(""test"", result);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, Arrays.asList(new JndiPermission(""comp/nested"", ""lookup"")), namingContext, ""test/nested"");
    assertEquals(""test"", result);
}"
"@Test
public void canHandleFragmentedMessageReceived() {
    NMEAMessage fragmentedNMEAMessage1 = NMEAMessage.fromString(""!AIVDM,2,1,3,B,55DA><02=6wpPuID000qTf059@DlU<00000000171lMDD4q20LmDp3hB,0*27"");
    NMEAMessage fragmentedNMEAMessage2 = NMEAMessage.fromString(""!AIVDM,2,2,3,B,p=Mh00000000000,2*4C"");
    final ArgumentCaptor<AISMessage> aisMessage = new ArgumentCaptor<>();
    context.checking(new Expectations() {{
        oneOf(aisMessageHandler).accept(with(aisMessage.getMatcher()));
    }});
    aisMessageReceiver.accept(fragmentedNMEAMessage1);
    aisMessageReceiver.accept(fragmentedNMEAMessage2);
    assertEquals(AISMessageType.ShipAndVoyageRelatedData, aisMessage.getCapturedObject().getMessageType());
}"
"@Test
public void testPerTopicStats() throws Exception {
    String randSeed = randomName(16);
    System.out.println(""The randSeed of testPerTopicStats() is: "" + randSeed);
    Producer<byte[]> p1 = pulsarClient.newProducer().topic(""persistent://my-property/use/"" + randSeed + ""/my-topic1"").create();
    Producer<byte[]> p2 = pulsarClient.newProducer().topic(""persistent://my-property/use/"" + randSeed + ""/my-topic2"").create();
    for (int i = 0; i < 10; i++) {
        String message = ""my-message-"" + i;
        p1.send(message.getBytes());
        p2.send(message.getBytes());
    }
    ByteArrayOutputStream statsOut = new ByteArrayOutputStream();
    PrometheusMetricsGenerator.generate(pulsar, true, false, statsOut);
    String metricsStr = new String(statsOut.toByteArray());
    Multimap<String, Metric> metrics = parseMetrics(metricsStr);
    metrics.entries().forEach(e -> {
        System.out.println(e.getKey() + "": "" + e.getValue());
    });
    List<Metric> cm = (List<Metric>) metrics.get(""pulsar_storage_write_latency_le_1"");
    List<Metric> matchingMetrics = cm.stream().filter(t -> t.tags.containsValue(""my-property/use/"" + randSeed)).collect(Collectors.toList());
    int positionOfTopic1;
    int positionOfTopic2;
    if(cm.get(0).tags.get(""topic"").equals(""persistent://my-property/use/"" + randSeed + ""/my-topic1"")) {
        positionOfTopic1 = 0;
        positionOfTopic2 = 1;
    } else {
        positionOfTopic2 = 0;
        positionOfTopic1 = 1;
    }
    matchingMetrics = cm.stream().filter(t -> t.tags.containsValue(""my-property/use/"" + randSeed)).collect(Collectors.toList());
    if(matchingMetrics.size() > 2){
        System.out.println(""matchingMetrics.size() > 2 in testPerTopicStats(). First check. Debug entries: "");
        matchingMetrics.forEach(t -> t.tags.entrySet().forEach(kv -> System.out.println(kv.getKey() + "":""  + kv.getValue())));
    }
    assertEquals(matchingMetrics.size(), 2);
    assertEquals(matchingMetrics.get(positionOfTopic2).tags.get(""topic""), ""persistent://my-property/use/"" + randSeed + ""/my-topic2"");
    assertEquals(matchingMetrics.get(positionOfTopic2).tags.get(""namespace""), ""my-property/use/"" + randSeed);
    assertEquals(matchingMetrics.get(positionOfTopic1).tags.get(""topic""), ""persistent://my-property/use/"" + randSeed + ""/my-topic1"");
    assertEquals(matchingMetrics.get(positionOfTopic1).tags.get(""namespace""), ""my-property/use/"" + randSeed);
    cm = (List<Metric>) metrics.get(""pulsar_producers_count"");
    if(cm.get(1).tags.get(""topic"").equals(""persistent://my-property/use/"" + randSeed + ""/my-topic1"")) {
        positionOfTopic1 = 1;
        positionOfTopic2 = 2;
    } else {
        positionOfTopic2 = 1;
        positionOfTopic1 = 2;
    }
    matchingMetrics = cm.stream().filter(t -> t.tags.containsValue(""my-property/use/"" + randSeed)).collect(Collectors.toList());
    if(matchingMetrics.size() > 2){
        System.out.println(""matchingMetrics.size() > 2 in testPerTopicStats(). Second check. Debug entries: "");
        matchingMetrics.forEach(t -> t.tags.entrySet().forEach(kv -> System.out.println(kv.getKey() + "":""  + kv.getValue())));
    }
    assertEquals(matchingMetrics.size(), 2);
    assertEquals(matchingMetrics.get(positionOfTopic2).tags.get(""topic""), ""persistent://my-property/use/"" + randSeed + ""/my-topic2"");
    assertEquals(matchingMetrics.get(positionOfTopic2).tags.get(""namespace""), ""my-property/use/"" + randSeed);
    assertEquals(matchingMetrics.get(positionOfTopic1).tags.get(""topic""), ""persistent://my-property/use/"" + randSeed + ""/my-topic1"");
    assertEquals(matchingMetrics.get(positionOfTopic1).tags.get(""namespace""), ""my-property/use/"" + randSeed);
    cm = (List<Metric>) metrics.get(""topic_load_times_count"");
    if(cm.size() > 1){
        System.out.println(""matchingMetrics.size() > 2 in testPerTopicStats(). Third check. Debug entries: "");
        cm.forEach(t -> t.tags.entrySet().forEach(kv -> System.out.println(kv.getKey() + "":""  + kv.getValue())));
    }
    assertEquals(cm.size(), 1);
    assertEquals(cm.get(0).tags.get(""cluster""), ""test"");
    cm = (List<Metric>) metrics.get(""pulsar_in_bytes_total"");
    if(cm.get(0).tags.get(""topic"").equals(""persistent://my-property/use/"" + randSeed + ""/my-topic1"")) {
        positionOfTopic1 = 0;
        positionOfTopic2 = 1;
    } else {
        positionOfTopic2 = 0;
        positionOfTopic1 = 1;
    }
    matchingMetrics = cm.stream().filter(t -> t.tags.containsValue(""my-property/use/"" + randSeed)).collect(Collectors.toList());
    if(matchingMetrics.size() > 2){
        System.out.println(""matchingMetrics.size() > 2 in testPerTopicStats(). Fourth check. Debug entries: "");
        matchingMetrics.forEach(t -> t.tags.entrySet().forEach(kv -> System.out.println(kv.getKey() + "":""  + kv.getValue())));
    }
    assertEquals(matchingMetrics.size(), 2);
    assertEquals(matchingMetrics.get(positionOfTopic2).tags.get(""topic""), ""persistent://my-property/use/"" + randSeed + ""/my-topic2"");
    assertEquals(matchingMetrics.get(positionOfTopic2).tags.get(""namespace""), ""my-property/use/"" + randSeed);
    assertEquals(matchingMetrics.get(positionOfTopic1).tags.get(""topic""), ""persistent://my-property/use/"" + randSeed + ""/my-topic1"");
    assertEquals(matchingMetrics.get(positionOfTopic1).tags.get(""namespace""), ""my-property/use/"" + randSeed);
    cm = (List<Metric>) metrics.get(""pulsar_in_messages_total"");
    if(cm.get(0).tags.get(""topic"").equals(""persistent://my-property/use/"" + randSeed + ""/my-topic1"")) {
        positionOfTopic1 = 0;
        positionOfTopic2 = 1;
    } else {
        positionOfTopic2 = 0;
        positionOfTopic1 = 1;
    }
    matchingMetrics = cm.stream().filter(t -> t.tags.containsValue(""my-property/use/"" + randSeed)).collect(Collectors.toList());
    if(matchingMetrics.size() > 2){
        System.out.println(""matchingMetrics.size() > 2 in testPerTopicStats(). Fifth check. Debug entries: "");
        matchingMetrics.forEach(t -> t.tags.entrySet().forEach(kv -> System.out.println(kv.getKey() + "":""  + kv.getValue())));
    }
    assertEquals(matchingMetrics.size(), 2);
    assertEquals(matchingMetrics.get(positionOfTopic2).tags.get(""topic""), ""persistent://my-property/use/"" + randSeed + ""/my-topic2"");
    assertEquals(matchingMetrics.get(positionOfTopic2).tags.get(""namespace""), ""my-property/use/"" + randSeed);
    assertEquals(matchingMetrics.get(positionOfTopic1).tags.get(""topic""), ""persistent://my-property/use/"" + randSeed + ""/my-topic1"");
    assertEquals(matchingMetrics.get(positionOfTopic1).tags.get(""namespace""), ""my-property/use/"" + randSeed);
    p1.close();
    p2.close();
}"
"@Test void nullAndObjectValuesInMap(){
    Map<String,Object> queryParams=new LinkedHashMap<>();
    queryParams.put(""foo"",null);
    queryParams.put(""baz"",""qux"");
    Unirest.get(MockServer.GET).queryString(queryParams).asObject(RequestCapture.class).getBody().assertParam(""foo"","""").assertParam(""baz"",""qux"").assertQueryString(""foo&baz=qux"");
}"
"@Test public void strings() throws Exception {
    assertThat(testResult(Strings.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),Strings.iterations);
    assertEquals(new HashSet<>(asList(""some"",""values"")),new HashSet<>(Strings.values.subList(0,2)));
    Strings.iterations=0;
}"
"@Test
public void testModTime() throws IOException {
    Configuration conf = new Configuration();
    MiniDFSCluster cluster = new MiniDFSCluster(conf, numDatanodes, true, null);
    cluster.waitActive();
    InetSocketAddress addr = new InetSocketAddress(""localhost"", cluster.getNameNodePort());
    DFSClient client = new DFSClient(addr, conf);
    DatanodeInfo[] info = client.datanodeReport(LIVE);
    assertEquals(""Number of Datanodes "", numDatanodes, info.length);
    FileSystem fileSys = cluster.getFileSystem();
    int replicas = numDatanodes - 1;
    assertTrue(fileSys instanceof DistributedFileSystem);
    try {
        System.out.println(""Creating testdir1 and testdir1/test1.dat."");
        Path dir1 = new Path(""testdir1"");
        Path file1 = new Path(dir1, ""test1.dat"");
        writeFile(fileSys, file1, replicas);
        FileStatus stat = fileSys.getFileStatus(file1);
        long mtime1 = stat.getModificationTime();
        assertTrue(mtime1 != 0);
        stat = fileSys.getFileStatus(dir1);
        long mdir1 = stat.getModificationTime();
        System.out.println(""Creating testdir1/test2.dat."");
        Path file2 = new Path(dir1, ""test2.dat"");
        writeFile(fileSys, file2, replicas);
        stat = fileSys.getFileStatus(file2);
        stat = fileSys.getFileStatus(dir1);
        assertTrue(stat.getModificationTime() >= mdir1);
        mdir1 = stat.getModificationTime();
        Path dir2 = new Path(""testdir2/"").makeQualified(fileSys);
        System.out.println(""Creating testdir2 "" + dir2);
        assertTrue(fileSys.mkdirs(dir2));
        stat = fileSys.getFileStatus(dir2);
        long mdir2 = stat.getModificationTime();
        Path newfile = new Path(dir2, ""testnew.dat"");
        System.out.println(((""Moving "" + file1) + "" to "") + newfile);
        fileSys.rename(file1, newfile);
        stat = fileSys.getFileStatus(newfile);
        assertTrue(stat.getModificationTime() == mtime1);
        stat = fileSys.getFileStatus(dir1);
        assertTrue(stat.getModificationTime() != mdir1);
        mdir1 = stat.getModificationTime();
        stat = fileSys.getFileStatus(dir2);
        assertTrue(stat.getModificationTime() != mdir2);
        mdir2 = stat.getModificationTime();
        System.out.println(""Deleting testdir2/testnew.dat."");
        assertTrue(fileSys.delete(newfile, true));
        stat = fileSys.getFileStatus(dir1);
        assertTrue(stat.getModificationTime() == mdir1);
        stat = fileSys.getFileStatus(dir2);
        assertTrue(stat.getModificationTime() != mdir2);
        mdir2 = stat.getModificationTime();
        cleanupFile(fileSys, file2);
        cleanupFile(fileSys, dir1);
        cleanupFile(fileSys, dir2);
    } catch (IOException e) {
        info = client.datanodeReport(ALL);
        printDatanodeReport(info);
        throw e;
    } finally {
        fileSys.close();
        cluster.shutdown();
    }
}"
"@Test
public class Test {
    @Test(timeout = 300000)
    public void testRSSplitEphemeralsDisappearButDaughtersAreOnlinedAfterShutdownHandling() throws IOException, InterruptedException, NodeExistsException, KeeperException {
        final byte[] tableName = Bytes.toBytes(""ephemeral"");
        HTable t = TESTING_UTIL.createTable(tableName, CATALOG_FAMILY);
        List<HRegion> regions = cluster.getRegions(tableName);
        HRegionInfo hri = getAndCheckSingleTableRegion(regions);
        int tableRegionIndex = ensureTableRegionNotOnSameServerAsMeta(admin, hri);
        this.admin.setBalancerRunning(false, true);
        cluster.getMaster().setCatalogJanitorEnabled(false);
        try {
            TESTING_UTIL.loadTable(t, CATALOG_FAMILY);
            HRegionServer server = cluster.getRegionServer(tableRegionIndex);
            printOutRegions(server, ""Initial regions: "");
            int regionCount = server.getOnlineRegions().size();
            SplitRegionHandler.TEST_SKIP = true;
            split(hri, server, regionCount);
            List<HRegion> daughters = cluster.getRegions(tableName);
            assertTrue(daughters.size() >= 2);
            String path = ZKAssign.getNodeName(t.getConnection().getZooKeeperWatcher(), hri.getEncodedName());
            Stat stats = t.getConnection().getZooKeeperWatcher().getRecoverableZooKeeper().exists(path, false);
            LOG.info(((""EPHEMERAL NODE BEFORE SERVER ABORT, path="" + path) + "", stats="") + stats);
            RegionTransitionData rtd = ZKAssign.getData(t.getConnection().getZooKeeperWatcher(), hri.getEncodedName());
            assertTrue(rtd.getEventType().equals(RS_ZK_REGION_SPLIT) || rtd.getEventType().equals(RS_ZK_REGION_SPLITTING));
            cluster.abortRegionServer(tableRegionIndex);
            waitUntilRegionServerDead();
            while (cluster.getRegions(tableName).size() < daughters.size()) {
                LOG.info(""Waiting for repair to happen"");
                Thread.sleep(1000);
            }
            regions = cluster.getRegions(tableName);
            for (HRegion r : regions) {
                assertTrue(daughters.contains(r));
            }
            stats = t.getConnection().getZooKeeperWatcher().getRecoverableZooKeeper().exists(path, false);
            LOG.info(((""EPHEMERAL NODE AFTER SERVER ABORT, path="" + path) + "", stats="") + stats);
            assertTrue(stats == null);
        } finally {
            SplitRegionHandler.TEST_SKIP = false;
            admin.setBalancerRunning(true, false);
            cluster.getMaster().setCatalogJanitorEnabled(true);
        }
    }
}"
"public void test_for_issue() throws Exception {
    Multimap<String,String> multimap=ArrayListMultimap.create();
    multimap.put(""admin"",""admin.create"");
    multimap.put(""admin"",""admin.update"");
    multimap.put(""admin"",""admin.delete"");
    multimap.put(""user"",""user.create"");
    multimap.put(""user"",""user.delete"");
    String json=JSON.toJSONString(multimap,SerializerFeature.MapSortField);
    assertEquals(""{\""admin\"":[\""admin.create\"",\""admin.update\"",\""admin.delete\""],\""user\"":[\""user.create\"",\""user.delete\""]}"",json);
    ArrayListMultimap multimap1=JSON.parseObject(json,ArrayListMultimap.class);
    assertEquals(multimap.size(),multimap1.size());
    assertEquals(json,JSON.toJSONString(multimap1,SerializerFeature.MapSortField));
}"
"@Test public void wrapperFloats() throws Exception {
    assertThat(testResult(WrapperFloats.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperFloats.iterations);
    assertEquals(new HashSet<>(asList(1.7F,-4.14F)),new HashSet<>(WrapperFloats.values.subList(0,2)));
    WrapperFloats.iterations=0;
}"
"@Test
public void shouldBeAbleToUpdateAllMessageTypes() throws Throwable
{
    int durationNanos = 5;
    for ( RaftMessages.Type type : RaftMessages.Type.values() )
    {
        metric.updateTimer( type, Duration.ofNanos( durationNanos ) );
        assertEquals( 1, metric.timer( type ).getCount() );
        assertEquals( durationNanos, metric.timer( type ).getSnapshot().getMean(), 0 );
    }
    assertEquals( RaftMessages.Type.values().length, metric.timer().getCount() );
    assertEquals( 0, metric.timer().getSnapshot().getMean(), durationNanos );
}"
"@Test public void canSerializeMapKeysWithDotAndSlash() throws Exception {
    String serialized=new JacksonAdapter().serialize(prepareSchoolModel());
    String expected=""{\""teacher\"":{\""students\"":{\""af.B/D\"":{},\""af.B/C\"":{}}},\""tags\"":{\""foo.aa\"":\""bar\"",\""x.y\"":\""zz\""},\""properties\"":{\""name\"":\""school1\""}}"";
    assertJsonEqualsNonStrict(expected,serialized);
}"
"@Test public void test_create2() throws Exception {
    String sql=""CREATE RESOURCE GROUP sql_thread TYPE = USER VCPU = 1,3 THREAD_PRIORITY = -20 disable"";
    List<SQLStatement> stmtList=SQLUtils.toStatementList(sql,JdbcConstants.MYSQL);
    SQLStatement stmt=stmtList.get(0);
    MySqlSchemaStatVisitor visitor=new MySqlSchemaStatVisitor();
    stmt.accept(visitor);
    String output=SQLUtils.toMySqlString(stmt);
    Set<String> allPossibleRes=generateAllPossibleRes(""CREATE RESOURCE GROUP sql_thread "","" DISABLE"");
    assertTrue(allPossibleRes.contains(output));
}"
"@Test public void summarizeUsersReturnsListOfUsersIfCurrentUserIsNull(){
    this.currentUser=null;
    final User user1=mock(User.class);
    when(user1.getName()).thenReturn(""franz"");
    when(user1.getFullName()).thenReturn(""Franz Josef Strauss"");
    final User user2=mock(User.class);
    when(user2.getName()).thenReturn(""friedrich"");
    when(user2.getFullName()).thenReturn(""Friedrich Merz"");
    final User peter=mock(User.class);
    when(peter.getName()).thenReturn(""peter"");
    when(peter.getFullName()).thenReturn(""Peter Altmaier"");
    when(userService.loadAll()).thenReturn(ImmutableList.of(user1,user2,peter));
    final Set<UserShortSummary> users=this.viewSharingResource.summarizeUsers(""viewId"");
    assertThat(users).containsExactlyInAnyOrder(UserShortSummary.create(""franz"",""Franz Josef Strauss""),UserShortSummary.create(""friedrich"",""Friedrich Merz""),UserShortSummary.create(""peter"",""Peter Altmaier""));
}"
"@Test
public void testConnectedComponents() {
    System.out.println(""graph is "" + graph.toString());
    List<Set<Integer>> ccs = graph.getConnectedComponents();
    for (Set<Integer> cc : ccs) {
        System.out.println(""Connected component: "" + cc);
    }
    assertEquals(ccs.size(), 4);
    assertEquals(CollectionUtils.sorted(ccs.get(0)), Arrays.asList(1, 2, 3, 4));
}"
"@Test public void manyParameters() throws Exception {
    assertThat(testResult(ManyParameters.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ManyParameters.iterations);
    ManyParameters.iterations=0;
}"
"public void test_for_multimap() throws Exception {
    ArrayListMultimap<String,Integer> multimap=ArrayListMultimap.create();
    multimap.putAll(""b"",Ints.asList(2,4,6));
    multimap.putAll(""a"",Ints.asList(4,2,1));
    multimap.putAll(""c"",Ints.asList(2,5,3));
    String json=JSON.toJSONString(multimap,SerializerFeature.MapSortField);
    assertEquals(""{\""a\"":[4,2,1],\""b\"":[2,4,6],\""c\"":[2,5,3]}"",json);
    TreeMultimap treeMultimap=TreeMultimap.create(multimap);
    String json2=JSON.toJSONString(treeMultimap);
    assertEquals(""{\""a\"":[1,2,4],\""b\"":[2,4,6],\""c\"":[2,3,5]}"",json2);
}"
"@Test public void wrapperChars() throws Exception {
    assertThat(testResult(WrapperChars.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperChars.iterations);
    WrapperChars.iterations=0;
}"
"@Test public void wrapperLongs(){
    assertThat(testResult(WrapperLongs.class),isSuccessful());
    assertEquals(3,WrapperLongs.iterations);
    assertEquals(new HashSet<>(asList(10L,11L,12L)),WrapperLongs.testCases);
    WrapperLongs.iterations=0;
}"
"@Test
public void testCorrectRebalancingCurrentlyRentingPartitions() throws Exception {
    IgniteEx ignite = ((IgniteEx) (startGrids(3)));
    ignite.cluster().active(true);
    final int keysCnt = SF.applyLB(300000, 10000);
    try (final IgniteDataStreamer<Integer, Integer> ds = ignite.dataStreamer(CACHE_NAME)) {
        log.info(""Writing initial data..."");
        ds.allowOverwrite(true);
        for (int k = 1; k <= keysCnt; k++) {
            ds.addData(k, k);
            if ((k % 10000) == 0) {
                log.info((""Written "" + k) + "" entities."");
            }
        }
        log.info(""Writing initial data finished."");
    }
    startGrid(3);
    resetBaselineTopology();
    stopGrid(3);
    resetBaselineTopology();
    stopGrid(1);
    startGrid(1);
    awaitPartitionMapExchange();
    for (int k = 1; k <= keysCnt; k++) {
        Integer val = ((Integer) (ignite.cache(CACHE_NAME).get(k)));
        Assert.assertNotNull((""Value for "" + k) + "" is null"", val);
        Assert.assertEquals(((""Check failed for "" + k) + "" = "") + val, k, ((int) (val)));
    }
}"
"@Test
public void testCancelDeprovision() throws Exception {
    ProvisionerInfo provisionerInfo = new MockProvisioner.PropertyBuilder().waitDelete(1, TimeUnit.MINUTES).build();
    TaskFields taskFields = testProvision(ProvisioningOp.Status.CREATED, provisionerInfo);
    Runnable task = Transactionals.execute(transactional, dsContext -> {
        return provisioningService.deprovision(taskFields.programRunId, dsContext);
    });
    task.run();
    Assert.assertTrue(provisioningService.cancelDeprovisionTask(taskFields.programRunId).isPresent());
    ProvisioningTaskKey taskKey = new ProvisioningTaskKey(taskFields.programRunId, ProvisioningOp.Type.DEPROVISION);
    waitForExpectedProvisioningState(taskKey, ProvisioningOp.Status.CANCELLED);
}"
"@Test
public void testInitFirstVerifyCallBacks() throws Exception {
    DefaultMetricsSystem.shutdown();
    new ConfigBuilder().add(""*.period"", 8).add(""test.sink.test.class"", TestSink.class.getName()).add(""test.*.source.filter.exclude"", ""s0"").add(""test.source.s1.metric.filter.exclude"", ""X*"").add(""test.sink.sink1.metric.filter.exclude"", ""Y*"").add(""test.sink.sink2.metric.filter.exclude"", ""Y*"").save(TestMetricsConfig.getTestFilename(""hadoop-metrics2-test""));
    MetricsSystemImpl ms = new MetricsSystemImpl(""Test"");
    ms.start();
    ms.register(""s0"", ""s0 desc"", new TestSource(""s0rec""));
    TestSource s1 = ms.register(""s1"", ""s1 desc"", new TestSource(""s1rec""));
    s1.c1.incr();
    s1.xxx.incr();
    s1.g1.set(2);
    s1.yyy.incr(2);
    s1.s1.add(0);
    MetricsSink sink1 = mock(MetricsSink.class);
    MetricsSink sink2 = mock(MetricsSink.class);
    ms.registerSink(""sink1"", ""sink1 desc"", sink1);
    ms.registerSink(""sink2"", ""sink2 desc"", sink2);
    ms.publishMetricsNow();
    try {
        verify(sink1, timeout(200).times(2)).putMetrics(r1.capture());
        verify(sink2, timeout(200).times(2)).putMetrics(r2.capture());
    } finally {
        ms.stop();
        ms.shutdown();
    }
    List<MetricsRecord> mr1 = r1.getAllValues();
    List<MetricsRecord> mr2 = r2.getAllValues();
    checkMetricsRecords(mr1);
    assertEquals(""output"", mr1, mr2);
}"
"@Test
public void testUnpackOverWriteIfNewer() throws Exception {
    final long now = System.currentTimeMillis();
    mojo.setSilent( false );
    stubFactory.setCreateFiles( true );
    Artifact artifact = stubFactory.getSnapshotArtifact();
    assertTrue( artifact.getFile().setLastModified( now - 20000 ) );
    ArtifactItem item = new ArtifactItem( createArtifact( artifact ) );
    List<ArtifactItem> list = Collections.singletonList( item );
    mojo.setArtifactItems( list );
    mojo.setOverWriteIfNewer( true );
    mojo.execute();
    File unpackedFile = getUnpackedFile( item );
    long time = now;
    time = time - ( time % 1000 );
    time -= 10000;
    assertTrue( unpackedFile.setLastModified( time ) );
    assertTrue( artifact.getFile().setLastModified( time + 5000 ) );
    File marker = new File( mojo.getMarkersDirectory(), artifact.getId().replace( ':', '-' ) + "".marker"" );
    assertTrue( marker.setLastModified( time ) );
    displayFile( ""unpackedFile"", unpackedFile );
    displayFile( ""artifact    "", artifact.getFile() );
    displayFile( ""marker      "", marker );
    System.out.println( ""mojo.execute()"" );
    mojo.execute();
    displayFile( ""unpackedFile"", unpackedFile );
    displayFile( ""artifact    "", artifact.getFile() );
    displayFile( ""marker      "", marker );
    System.out.println( ""marker.lastModified() = "" + marker.lastModified() );
    System.out.println( ""unpackedFile.lastModified() = "" + unpackedFile.lastModified() );
    assertTrue( ""unpackedFile '"" + unpackedFile + ""' lastModified() == "" + marker.lastModified()
    + "": should be different"", marker.lastModified() != unpackedFile.lastModified() );
}"
"@Test
private void multiClientTestBase() throws Exception {
    URL wsdl = getClass().getResource(""/wsdl/calculator.wsdl"");
    assertNotNull(wsdl);
    CalculatorService service = new CalculatorService(wsdl, new QName(""http://apache.org/cxf/calculator"", ""CalculatorService""));
    QName endpoint = new QName(""http://apache.org/cxf/calculator"", ""CalculatorPort"");
    service.addPort(endpoint, SOAPBinding.SOAP12HTTP_BINDING, ""http://localhost:19000/CalculatorService/SoapPort"");
    CalculatorPortType port = service.getPort(endpoint, CalculatorPortType.class);
    ClientProxy.getClient(port).getInInterceptors().add(new LoggingInInterceptor());
    ClientProxy.getClient(port).getOutInterceptors().add(new LoggingOutInterceptor());
    MultiClientThread[] clients = new MultiClientThread[2];
    for (int i = 0; i < clients.length; i++) {
        clients[i] = new MultiClientThread(port, i);
    }
    for (int i = 0; i < clients.length; i++) {
        clients[i].start();
        Thread.sleep(2000);
    }
    for (int i = 0; i < clients.length; i++) {
        clients[i].join();
        assertEquals(clients[i].getResult(), ""20"");
    }
}"
"@Test
void scanShouldIterateOverAvailableEntries() {
    adapter.put(""1"", object1, COLLECTION_1);
    adapter.put(""2"", object2, COLLECTION_1);
    CloseableIterator<Map.Entry<Object, Object>> iterator = adapter.entries(COLLECTION_1);
    assertThat(iterator.next()).isEqualTo(new AbstractMap.SimpleEntry<>(""1"", object1));
    assertThat(iterator.next()).isEqualTo(new AbstractMap.SimpleEntry<>(""2"", object2));
    Map.Entry<Object, Object> entry1 = iterator.next();
    Map.Entry<Object, Object> entry2 = iterator.next();
    assertThat(iterator.hasNext()).isFalse();
}"
"@Test(expected=ClusterStateException.class) public void testReassignFailOnStopAndSync() throws IOException {
    ReceiverAdminClient receiverAdminClient=mockReceiverClientFailOnStopAndSync();
    coordinator=new Coordinator(metadataStore,receiverAdminClient);
    Map<Integer,List<Partition>> preAssignMap=metadataStore.getAssignmentsByCube(cubeName).getAssignments();
    Map<Integer,List<Partition>> newAssignMap=new LinkedHashMap<>();
    newAssignMap.put(1,Lists.newArrayList(p1,p2,p3));
    newAssignMap.put(2,Lists.newArrayList(p4,p5));
    newAssignMap.put(3,Lists.newArrayList(p6));
    CubeAssignment preAssigment=new CubeAssignment(cube.getName(),preAssignMap);
    CubeAssignment newAssigment=new CubeAssignment(cube.getName(),newAssignMap);
    try {
        coordinator.doReassign(cube,preAssigment,newAssigment);
    }
    catch (  ClusterStateException rune) {
        assertSame(ClusterStateException.ClusterState.ROLLBACK_FAILED,rune.getClusterState());
        assertSame(ClusterStateException.TransactionStep.STOP_AND_SNYC,rune.getTransactionStep());
        System.out.println(rune.getMessage());
        throw rune;
    }
}"
"@Test
public void test() throws Exception {
    JBIContainer jbi = new JBIContainer();
    jbi.setEmbedded(true);
    jbi.init();
    QuartzComponent quartz = new QuartzComponent();
    QuartzEndpoint endpoint = new QuartzEndpoint();
    endpoint.setService(new QName(""quartz""));
    endpoint.setEndpoint(""endpoint"");
    endpoint.setTargetService(new QName(""countDownReceiver""));
    SimpleTriggerBean trigger = new SimpleTriggerBean();
    trigger.setRepeatInterval(100);
    trigger.setName(""trigger"");
    trigger.afterPropertiesSet();
    endpoint.setTrigger(trigger);
    quartz.setEndpoints(new QuartzEndpoint[]{ endpoint });
    jbi.activateComponent(quartz, ""servicemix-quartz"");
    CountDownReceiverComponent receiver = new CountDownReceiverComponent(new QName(""countDownReceiver""), ""endpoint"", 1, 3000);
    jbi.activateComponent(receiver, ""countDownReceiver"");
    jbi.start();
    assertTrue(receiver.getMessageList().flushMessages().size() > 0);
    quartz.stop();
    receiver.getMessageList().flushMessages();
    Thread.sleep(1000);
    assertEquals(0, receiver.getMessageList().flushMessages().size());
    quartz.start();
    receiver.reset();
    assertTrue(receiver.getMessageList().flushMessages().size() > 0);
    jbi.shutDown();
}"
"@Test public void test2_2() throws Exception {
    String jsonStr=""[{\""name\"":\""p1\"",\""sonList\"":[{\""name\"":\""s1\""}]},{\""name\"":\""p2\"",\""sonList\"":[{\""name\"":\""s2\""},{\""name\"":\""s3\""}]}]"";
    ResultActions actions=mockMvc.perform((post(""/fastjson/test2?jsonp=fnUpdateSome"").characterEncoding(""UTF-8"").content(jsonStr).contentType(MediaType.APPLICATION_JSON)));
    actions.andDo(print());
    actions.andExpect(status().isOk()).andExpect(content().contentType(APPLICATION_JAVASCRIPT));
    String content=actions.andReturn().getResponse().getContentAsString();
    assertTrue(content.equals(""/**/fnUpdateSome({\""p1\"":1,\""p2\"":2})"") || content.equals(""/**/fnUpdateSome({\""p2\"":2,\""p1\"":1})""));
}"
"@Test
public void testRejectionsEAP7() throws Exception {
    testTransformer(""subsystem.xml"", ModelTestControllerVersion.EAP_7_0_0, ModelVersion.create(2, 0), ""wildfly-naming"");
}"
"@Test public void joinMultiArrayTest(){
    final StrJoiner append=StrJoiner.of("","");
    append.append(new Object[]{ListUtil.of(""1"",""2""),CollUtil.newHashSet(""3"",""4"")});
    Assert.assertThat(append.toString(),CoreMatchers.anyOf(CoreMatchers.is(""1,2,3,4""),CoreMatchers.is(""1,2,4,3"")));
}"
"@Test
public void testToMetricResponse() throws Exception {
    String subscriptionId = ""12345"";
    long ts = 1000L;
    List<Tag> tags = new ArrayList<>();
    tags.add(new Tag(""tag1"", ""value1""));
    Metric m = Metric.newBuilder().name(""sys.cpu.user"").value(ts, 2.0).tags(tags).tag(VISIBILITY_TAG, ""(a&b)|(c&d)"").build();
    String json = JsonUtil.getObjectMapper().writeValueAsString(MetricResponse.fromMetric(m, subscriptionId));
    String expected = ""{\""metric\"":\""sys.cpu.user\"",\""timestamp\"":1000,\""value\"":2.0,\""tags\"":[{\""tag1\"":\""value1\""},{\""viz\"":\""(a&b)|(c&d)\""}],\""subscriptionId\"":\""12345\"",\""complete\"":false}"";
    Assert.assertEquals(expected, json);
}"
"@Test
public void primitivePairs() throws Exception {
    List<Class<?>> types = Arrays.asList(Object.class, boolean.class, byte.class, short.class, char.class, int.class, float.class, long.class, double.class);
    for (Class<?> oneType : types) {
        for (Class<?> twoType : types) {
            Class<?> pairClass;
            Method factory;
            if ((oneType == Object.class) && (twoType == Object.class)) {
                pairClass = Pair.class;
                factory = Tuples.class.getMethod(""pair"", Object.class, Object.class);
            } else {
                pairClass = Class.forName(((""org.eclipse.collections.api.tuple.primitive."" + capitalize(oneType.getSimpleName())) + capitalize(twoType.getSimpleName())) + ""Pair"");
                factory = PrimitiveTuples.class.getMethod(""pair"", oneType, twoType);
            }
            Object sampleOne = randomSample(oneType);
            Object sampleTwo = randomSample(twoType);
            JavaType pairType;
            if (oneType == Object.class) {
                if (twoType == Object.class) {
                    pairType = mapperWithModule().getTypeFactory().constructParametricType(pairClass, sampleOne.getClass(), sampleTwo.getClass());
                } else {
                    pairType = mapperWithModule().getTypeFactory().constructParametricType(pairClass, sampleOne.getClass());
                }
            } else if (twoType == Object.class) {
                pairType = mapperWithModule().getTypeFactory().constructParametricType(pairClass, sampleTwo.getClass());
            } else {
                pairType = mapperWithModule().constructType(pairClass);
            }
            String expectedJson = (((""{\""one\"":"" + mapperWithModule().writeValueAsString(sampleOne)) + "",\""two\"":"") + mapperWithModule().writeValueAsString(sampleTwo)) + ""}"";
            Object samplePair = factory.invoke(null, sampleOne, sampleTwo);
            Assert.assertEquals(expectedJson, mapperWithModule().writeValueAsString(samplePair));
            Assert.assertEquals(samplePair, mapperWithModule().readValue(expectedJson, pairType));
        }
    }
}"
"@Test
public void testSubscribeRate() throws Exception {
    SubscribeRate subscribeRate = new SubscribeRate(1, 5);
    String namespace = ""my-tenants/my-namespace"";
    admin.tenants().createTenant(""my-tenants"", new TenantInfoImpl(Sets.newHashSet(), Sets.newHashSet(testLocalCluster)));
    admin.namespaces().createNamespace(namespace, Sets.newHashSet(testLocalCluster));
    admin.namespaces().setSubscribeRate(namespace, subscribeRate);
    assertEquals(subscribeRate, admin.namespaces().getSubscribeRate(namespace));
    String topicName = ((""persistent""));
    admin.topics().createPartitionedTopic(topicName, 2);
    pulsar.getConfiguration().setAuthorizationEnabled(false);
    Consumer<?> consumer = pulsarClient.newConsumer().topic(topicName).subscriptionType(Shared).subscriptionName(""subscribe-rate"").subscribe();
    assertTrue(consumer.isConnected());
    pulsarClient.updateServiceUrl(lookupUrl.toString());
    Awaitility.await().untilAsserted(() -> assertFalse(consumer.isConnected()));
    Thread.sleep(6000L);
    pulsarClient.updateServiceUrl(lookupUrl.toString());
    assertTrue(consumer.isConnected());
    subscribeRate = new SubscribeRate(0, 10);
    admin.namespaces().setSubscribeRate(namespace, subscribeRate);
    pulsarClient.updateServiceUrl(lookupUrl.toString());
    Awaitility.await().untilAsserted(() -> assertTrue(consumer.isConnected()));
    pulsar.getConfiguration().setAuthorizationEnabled(true);
    admin.topics().deletePartitionedTopic(topicName, true);
    admin.namespaces().deleteNamespace(namespace);
    admin.tenants().deleteTenant(""my-tenants"");
}"
"public void test_for_issue() throws Exception {
    String text=""{\""a\"":{\""x\"":\""y\""},\""b\"":{\""x\"":\""y\""}}"";
    Map<String,Model> jsonObject=JSONObject.parseObject(text,new TypeReference<LinkedHashMap<String,Model>>(){
    }
    );
    System.out.println(JSON.toJSONString(jsonObject));
    String jsonpath=""$..x"";
    String value=""y2"";
    JSONPath.set(jsonObject,jsonpath,value);
    assertEquals(""{\""a\"":{\""x\"":\""y2\""},\""b\"":{\""x\"":\""y2\""}}"",JSON.toJSONString(jsonObject));
}"
"@Test
public void testForceMetadataRefreshForPatternSubscriptionDuringRebalance() {
    final String consumerId = ""consumer"";
    subscriptions.subscribe(Pattern.compile("".*""), rebalanceListener);
    client.updateMetadata(TestUtils.metadataUpdateWith(1, singletonMap(topic1, 1)));
    assertEquals(singleton(topic1), subscriptions.subscription());
    client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));
    coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));
    client.prepareMetadataUpdate(metadataResponse);
    client.prepareResponse(joinGroupFollowerResponse(1, consumerId, ""leader"", Errors.NONE));
    client.prepareResponse(new MockClient.RequestMatcher() {
        @Override
        public boolean matches(AbstractRequest body) {
            SyncGroupRequest sync = (SyncGroupRequest) body;
            return sync.memberId().equals(consumerId) &&
            sync.generationId() == 1 &&
            sync.groupAssignment().isEmpty();
        }
    }, syncGroupResponse(singletonList(t1p), Errors.NONE));
    partitionAssignor.prepare(singletonMap(consumerId, singletonList(t1p)));
    coordinator.poll(time.timer(Long.MAX_VALUE));
    final Set<String> updatedSubscriptionSet = new HashSet<>(Arrays.asList(topic1, topic2));
    assertEquals(updatedSubscriptionSet, subscriptions.subscription());
    metadata.requestUpdate();
    client.poll(Long.MAX_VALUE, time.milliseconds());
    assertFalse(coordinator.rejoinNeededOrPending());
}"
"@Test
public void testRegionCachePreWarm() throws Exception {
    final byte[] TABLENAME = Bytes.toBytes(""testCachePrewarm"");
    Configuration conf = TEST_UTIL.getConfiguration();
    TEST_UTIL.createTable(TABLENAME, FAMILY);
    HTable.setRegionCachePrefetch(conf, TABLENAME, false);
    assertFalse(""The table is disabled for region cache prefetch"", HTable.getRegionCachePrefetch(conf, TABLENAME));
    HTable table = new HTable(conf, TABLENAME);
    TEST_UTIL.createMultiRegions(table, FAMILY);
    Get g = new Get(Bytes.toBytes(""aaa""));
    table.get(g);
    assertEquals(""Number of cached region is incorrect "", 1, HConnectionManager.getCachedRegionCount(conf, TABLENAME));
    HTable.setRegionCachePrefetch(conf, TABLENAME, true);
    assertTrue(""The table is enabled for region cache prefetch"", HTable.getRegionCachePrefetch(conf, TABLENAME));
    HTable.setRegionCachePrefetch(conf, TABLENAME, false);
    assertFalse(""The table is disabled for region cache prefetch"", HTable.getRegionCachePrefetch(conf, TABLENAME));
    HTable.setRegionCachePrefetch(conf, TABLENAME, true);
    assertTrue(""The table is enabled for region cache prefetch"", HTable.getRegionCachePrefetch(conf, TABLENAME));
    table.getConnection().clearRegionCache();
    assertEquals(""Number of cached region is incorrect "", 0, HConnectionManager.getCachedRegionCount(conf, TABLENAME));
    Get g2 = new Get(Bytes.toBytes(""bbb""));
    table.get(g2);
    int prefetchRegionNumber = conf.getInt(""hbase.client.prefetch.limit"", 10) / 2;
    LOG.info(""Testing how many regions cached"");
    assertTrue(prefetchRegionNumber < HConnectionManager.getCachedRegionCount(conf, TABLENAME));
    table.getConnection().clearRegionCache();
    Get g3 = new Get(Bytes.toBytes(""abc""));
    table.get(g3);
    assertTrue(prefetchRegionNumber < HConnectionManager.getCachedRegionCount(conf, TABLENAME));
}"
"@Test
public void testLogicalTypePreviewRun(Engine engine) throws Exception {
    PreviewManager previewManager = getPreviewManager();
    String sourceTableName = ""singleInput"";
    String sinkTableName = ""singleOutput"";
    Schema schema = Schema.recordOf(
    ""testRecord"",
    Schema.Field.of(""name"", Schema.of(Schema.Type.STRING)),
    Schema.Field.of(""date"", Schema.of(Schema.LogicalType.DATE)),
    Schema.Field.of(""ts"", Schema.of(Schema.LogicalType.TIMESTAMP_MILLIS))
    );
    ETLBatchConfig etlConfig = ETLBatchConfig.builder()
    .addStage(new ETLStage(""source"", MockSource.getPlugin(sourceTableName, schema)))
    .addStage(new ETLStage(""transform"", IdentityTransform.getPlugin()))
    .addStage(new ETLStage(""sink"", MockSink.getPlugin(sinkTableName)))
    .addConnection(""source"", ""transform"")
    .addConnection(""transform"", ""sink"")
    .setEngine(engine)
    .setNumOfRecordsPreview(100)
    .build();
    PreviewConfig previewConfig = new PreviewConfig(SmartWorkflow.NAME, ProgramType.WORKFLOW,
    Collections.<String, String>emptyMap(), 10);
    addDatasetInstance(Table.class.getName(), sourceTableName,
    DatasetProperties.of(ImmutableMap.of(""schema"", schema.toString())));
    DataSetManager<Table> inputManager = getDataset(NamespaceId.DEFAULT.dataset(sourceTableName));
    ZonedDateTime expectedMillis = ZonedDateTime.of(2018, 11, 11, 11, 11, 11, 123 * 1000 * 1000,
    ZoneId.ofOffset(""UTC"", ZoneOffset.UTC));
    StructuredRecord recordSamuel = StructuredRecord.builder(schema).set(""name"", ""samuel"")
    .setDate(""date"", LocalDate.of(2002, 11, 18)).setTimestamp(""ts"", expectedMillis).build();
    StructuredRecord recordBob = StructuredRecord.builder(schema).set(""name"", ""bob"")
    .setDate(""date"", LocalDate.of(2003, 11, 18)).setTimestamp(""ts"", expectedMillis).build();
    MockSource.writeInput(inputManager, ImmutableList.of(recordSamuel, recordBob));
    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(APP_ARTIFACT_RANGE, etlConfig, previewConfig);
    ApplicationId previewId = previewManager.start(NamespaceId.DEFAULT, appRequest);
    Tasks.waitFor(PreviewStatus.Status.COMPLETED, new Callable<PreviewStatus.Status>() {
        @Override
        public PreviewStatus.Status call() throws Exception {
            PreviewStatus status = previewManager.getStatus(previewId);
            return status == null ? null : status.getStatus();
        }
    }, 5, TimeUnit.MINUTES);
    checkPreviewStore(previewManager, previewId, ""source"", 2);
    List<JsonElement> data = previewManager.getData(previewId, ""source"").get(DATA_TRACER_PROPERTY);
    StructuredRecord actualRecordSamuel = GSON.fromJson(data.get(0), StructuredRecord.class);
    Assert.assertEquals(actualRecordSamuel.get(""date""), ""2002-11-18"");
    Assert.assertEquals(actualRecordSamuel.get(""ts""), ""2018-11-11T11:11:11.123Z[UTC]"");
    StructuredRecord actualRecordBob = GSON.fromJson(data.get(1), StructuredRecord.class);
    Assert.assertEquals(actualRecordBob.get(""date""), ""2003-11-18"");
    Assert.assertEquals(actualRecordBob.get(""ts""), ""2018-11-11T11:11:11.123Z[UTC]"");
    checkPreviewStore(previewManager, previewId, ""transform"", 2);
    checkPreviewStore(previewManager, previewId, ""sink"", 2);
    validateMetric(2, previewId, ""source.records.in"", previewManager);
    validateMetric(2, previewId, ""source.records.out"", previewManager);
    validateMetric(2, previewId, ""transform.records.in"", previewManager);
    validateMetric(2, previewId, ""transform.records.out"", previewManager);
    validateMetric(2, previewId, ""sink.records.out"", previewManager);
    validateMetric(2, previewId, ""sink.records.in"", previewManager);
    DataSetManager<Table> sinkManager = getDataset(sinkTableName);
    Assert.assertNull(sinkManager.get());
    deleteDatasetInstance(NamespaceId.DEFAULT.dataset(sourceTableName));
    Assert.assertNotNull(previewManager.getRunId(previewId));
}"
"@Test
public void testBindNested() throws Exception {
    final Name name = new CompositeName(""nested/test"");
    final Object value = new Object();
    WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);
    try {
        store.bind(name, value);
    } finally {
        WritableServiceBasedNamingStore.popOwner();
    }
    assertEquals(value, store.lookup(name));
}"
"@Test
public void testRateLimitingMax() {
    int n = 10;
    double rate = 10.0;
    long duration = runWithRate(n, rate, new IdentityFn<Integer>());
    long perElementPause = (long) (1000L / rate);
    long minDuration = (n - 1) * perElementPause;
    Assert.assertThat(duration, greaterThan(minDuration));
}"
"@Test
public void testShortCircuited() {
    HystrixCommandKey key = Factory.asKey(""CMD-Health-G"");
    stream = HealthCountsStream.getInstance(key, 10, 100);
    final CountDownLatch latch = new CountDownLatch(1);
    stream.observe().take(10).subscribe(getSubscriber(latch));
    CommandStreamTest.Command failure1 = Command.from(groupKey, key, FAILURE, 20);
    CommandStreamTest.Command failure2 = Command.from(groupKey, key, FAILURE, 20);
    CommandStreamTest.Command failure3 = Command.from(groupKey, key, FAILURE, 20);
    CommandStreamTest.Command shortCircuit1 = Command.from(groupKey, key, SUCCESS);
    CommandStreamTest.Command shortCircuit2 = Command.from(groupKey, key, SUCCESS);
    failure1.observe();
    failure2.observe();
    failure3.observe();
    try {
        Thread.sleep(100);
    } catch (InterruptedException ie) {
        fail(ie.getMessage());
    }
    shortCircuit1.observe();
    shortCircuit2.observe();
    try {
        assertTrue(latch.await(10000, TimeUnit.MILLISECONDS));
    } catch (InterruptedException ex) {
        fail(""Interrupted ex"");
    }
    assertTrue(shortCircuit1.isResponseShortCircuited());
    assertTrue(shortCircuit2.isResponseShortCircuited());
    System.out.println(""ReqLog : "" + HystrixRequestLog.getCurrentRequest().getExecutedCommandsAsString());
    assertEquals(3L, stream.getLatest().getErrorCount());
    assertEquals(3L, stream.getLatest().getTotalRequests());
}"
"@Test public void testRequestMetaForSuccessfulRequest() throws Exception {
    ListenerMeta listenerMeta=listenerMetaIndexProvider.get().getListenerMetas().get(0);
    OnlineServerMetaIndexProvider onlineServerMetaIndexProvider=listenerMeta.getOnlineServerMetaIndexProvider();
    await().until(() -> {
        assertThat(onlineServerMetaIndexProvider.get().getBalancer().size(),equalTo(3));
    }
    );
    String content=fetch(""http://example.com/request-meta"");
    RequestMeta requestMeta=RequestMeta.fromJSON(content);
    requestMeta.getHeaders().remove(""Via"");
    requestMeta.getHeaders().remove(""Cache-Control"");
    requestMeta.getHeaders().remove(""Accept"");
    requestMeta.getHeaders().remove(""Pragma"");
    assertEquals(""foo"",requestMeta.getHeaders().get(""X-foo""));
    content=requestMeta.toJSON();
    JSONAssert.assertEquals(content,corporaAsserter.getCorporaCache().read(""testRequestMetaForSuccessfulRequest""),false);
}"
"@Test
public void testGetPartialRepairTasks() {
    Node node = mockNode(""DC1"");
    Node node2 = mockNode(""DC1"");
    ImmutableList<LongTokenRange> vnodes = ImmutableList.of(new LongTokenRange(1, 2), new LongTokenRange(2, 3), new LongTokenRange(4, 5));
    ReplicaRepairGroup replicaRepairGroup = new ReplicaRepairGroup(ImmutableSet.of(node, node2), vnodes);
    RepairGroup repairGroup = builderFor(replicaRepairGroup).build(priority);
    Collection<RepairTask> tasks = repairGroup.getRepairTasks();
    assertThat(tasks.size()).isEqualTo(3);
    Set<LongTokenRange> repairTaskRanges = new HashSet<>();
    for (RepairTask repairTask : tasks) {
        assertThat(repairTask.getTokenRanges().size()).isEqualTo(1);
        LongTokenRange range = repairTask.getTokenRanges().iterator().next();
        repairTaskRanges.add(range);
        assertThat(repairTask.getReplicas()).containsExactlyInAnyOrder(node, node2);
        assertThat(repairTask.getTableReference()).isEqualTo(tableReference);
        assertThat(repairTask.getRepairConfiguration().getRepairParallelism()).isEqualTo(PARALLEL);
    }
    assertThat(repairTaskRanges).containsExactlyElementsOf(vnodes);
}"
"@Test
public void testQueryRaw() throws Exception {
    Dao<Foo, Integer> dao = createDao(Foo.class, true);
    Foo foo = new Foo();
    foo.stringField = ""zipper"";
    dao.create(foo);
    QueryBuilder<Foo, Integer> qb = dao.queryBuilder();
    assertEquals(1, qb.countOf());
    GenericRawResults<String[]> results = qb.queryRaw();
    List<String[]> stringResults = results.getResults();
    assertEquals(1, stringResults.size());
    assertEquals(Integer.toString(foo.id), stringResults.get(0)[0]);
    assertEquals(foo.stringField, stringResults.get(0)[3]);
}"
"public void test_sqlDate() throws Exception {
    java.util.Date date=new java.util.Date();
    long millis=date.getTime();
    long millis2=(millis / 1000) * 1000;
    SimpleDateFormat dateFormat=new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss.SSS"",JSON.defaultLocale);
    dateFormat.setTimeZone(JSON.defaultTimeZone);
    String text=dateFormat.format(millis);
    text=text.replace(' ','T');
    SimpleDateFormat dateFormat2=new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"",JSON.defaultLocale);
    dateFormat2.setTimeZone(JSON.defaultTimeZone);
    String text2=dateFormat2.format(millis2);
    text2=text2.replace(' ','T');
    Assert.assertNull(JSON.parseObject(""null"",Date.class));
    Assert.assertNull(JSON.parseObject(""\""\"""",Date.class));
    Assert.assertNull(JSON.parseArray(""null"",Date.class));
    Assert.assertNull(JSON.parseArray(""[null]"",Date.class).get(0));
    Assert.assertNull(JSON.parseObject(""{\""value\"":null}"",VO.class).getValue());
    Assert.assertEquals(new Date(millis),JSON.parseObject("""" + millis,Date.class));
    Assert.assertEquals(new Date(millis),JSON.parseObject(""{\""@type\"":\""java.sql.Date\"",\""val\"":"" + millis + ""}"",Date.class));
    Assert.assertEquals(new Date(millis),JSON.parseObject(""\"""" + millis + ""\"""",Date.class));
    Assert.assertEquals(new Date(millis2),JSON.parseObject(""\"""" + text2 + ""\"""",Date.class));
    Assert.assertEquals(new Date(millis),JSON.parseObject(""\"""" + text + ""\"""",Date.class));
}"
"@Test
public void testPull() throws Exception {
    PullPoint pullPoint = wsnCreatePullPoint.createPullPoint();
    wsnBroker.subscribe(pullPoint.getEndpoint(), ""myTopic"", null);
    wsnBroker.notify(""myTopic"", new Notify());
    Thread.sleep(500);
    List<NotificationMessageHolderType> msgs = pullPoint.getMessages(0);
    assertNotNull(msgs);
    assertEquals(1, msgs.size());
    Thread.sleep(500);
}"
"@Test public void primitiveChars(){
    assertThat(testResult(PrimitiveChars.class),isSuccessful());
    assertEquals(2,PrimitiveChars.iterations);
    assertEquals(new HashSet<>(asList('Z','z')),PrimitiveChars.testCases);
    PrimitiveChars.iterations=0;
}"
"@Test
public void testContinuousScheduling() throws Exception {
    FairScheduler fs = new FairScheduler();
    Configuration conf = createConfiguration();
    conf.setBoolean(CONTINUOUS_SCHEDULING_ENABLED, true);
    fs.reinitialize(conf, resourceManager.getRMContext());
    Assert.assertTrue(""Continuous scheduling should be enabled."", fs.isContinuousSchedulingEnabled());
    RMNode node1 = MockNodes.newNodeInfo(1, Resources.createResource(8 * 1024, 8), 1, ""127.0.0.1"");
    NodeAddedSchedulerEvent nodeEvent1 = new NodeAddedSchedulerEvent(node1);
    fs.handle(nodeEvent1);
    Assert.assertEquals(fs.getClusterCapacity().getMemory(), 8 * 1024);
    Assert.assertEquals(fs.getClusterCapacity().getVirtualCores(), 8);
    ApplicationAttemptId appAttemptId = createAppAttemptId(this.APP_ID++, this.ATTEMPT_ID++);
    fs.addApplication(appAttemptId, ""queue11"", ""user11"");
    List<ResourceRequest> ask = new ArrayList<ResourceRequest>();
    ResourceRequest request = createResourceRequest(1024, 1, ANY, 1, 1, true);
    ask.add(request);
    fs.allocate(appAttemptId, ask, new ArrayList<ContainerId>(), null, null);
    Thread.sleep(fs.getConf().getContinuousSchedulingSleepMs() + 500);
    Resource consumption = fs.applications.get(appAttemptId).getCurrentConsumption();
    Assert.assertEquals(1024, consumption.getMemory());
    Assert.assertEquals(1, consumption.getVirtualCores());
}"
"@Test public void test_create() throws Exception {
    String sql=""CREATE RESOURCE GROUP sql_thread TYPE = USER VCPU = 1,3 THREAD_PRIORITY = -20"";
    List<SQLStatement> stmtList=SQLUtils.toStatementList(sql,JdbcConstants.MYSQL);
    SQLStatement stmt=stmtList.get(0);
    MySqlSchemaStatVisitor visitor=new MySqlSchemaStatVisitor();
    stmt.accept(visitor);
    String output=SQLUtils.toMySqlString(stmt);
    Set<String> allPossibleRes=generateAllPossibleRes(""CREATE RESOURCE GROUP sql_thread "","""");
    assertTrue(allPossibleRes.contains(output));
}"
"@Test public void booleansUnmarked(){
    assertThat(testResult(UnmarkedBooleans.class),isSuccessful());
    assertEquals(2,UnmarkedBooleans.iterations);
    assertEquals(new HashSet<>(asList(true,false)),UnmarkedBooleans.testCases);
    UnmarkedBooleans.iterations=0;
}"
"@Test
public void testGenerateCleanupCallback_deletesOldFinishedWork() {
    Work work1 = new Work.Builder(TestWorker.class)
    .withInitialState(SUCCEEDED)
    .withPeriodStartTime(0L)
    .build();
    Work work2 = new Work.Builder(TestWorker.class).withPeriodStartTime(Long.MAX_VALUE).build();
    insertWorkSpecAndTags(work1);
    insertWorkSpecAndTags(work2);
    SupportSQLiteOpenHelper openHelper = mDatabase.getOpenHelper();
    SupportSQLiteDatabase db = openHelper.getWritableDatabase();
    WorkDatabase.generateCleanupCallback().onOpen(db);
    WorkSpecDao workSpecDao = mDatabase.workSpecDao();
    assertThat(workSpecDao.getWorkSpec(work1.getId()), is(nullValue()));
    assertThat(workSpecDao.getWorkSpec(work2.getId()), is(not(nullValue())));
}"
"@Test
public void testListBindingsWithContinuation() throws Exception {
    bindListWithContinuations();
    NamingEnumeration<Binding> results = namingContext.listBindings(new CompositeName(""comp""));
    checkListWithContinuationsResults(results);
    results = (NamingEnumeration<Binding>) testActionPermission(JndiPermission.ACTION_LIST_BINDINGS, Arrays.asList(
    new JndiPermission(""test"", ""listBindings"")), namingContext, ""comp"");
    checkListWithContinuationsResults(results);
}"
"@Test
public void doTestLogicalNodesConcurrentDFOMans(final int threads,
final int events, int timeout) throws IOException, InterruptedException,
FlumeSpecException {
    BenchmarkHarness.setupLocalWriteDir();
    FlumeMaster master = new FlumeMaster();
    FlumeNode node = new FlumeNode(new DirectMasterRPC(master), false, false);
    final Reportable[] dfos = new Reportable[threads];
    for (int i = 0; i < threads; i++) {
        String name = ""test."" + i;
        String report = ""report."" + i;
        int count = events + i;
        String src = ""asciisynth("" + count + "",100)"";
        String snk = ""{ diskFailover => counter(\"""" + report + ""\"") } "";
        node.getLogicalNodeManager().testingSpawn(name, src, snk);
        dfos[i] = node.getLogicalNodeManager().get(name);
    }
    waitForEmptyDFOs(node, timeout);
    boolean success = true;
    for (int i = 0; i < threads; i++) {
        LOG.info(dfos[i].getReport());
    }
    for (int i = 0; i < threads; i++) {
        CounterSink cnt = (CounterSink) ReportManager.get().getReportable(
        ""report."" + i);
        LOG.info(i + "" expected "" + (events + i) + "" and got "" + cnt.getCount());
        success &= ((events + i) == cnt.getCount());
        assertEquals(events + i, cnt.getCount());
    }
    assertTrue(""Counts did not line up"", success);
    BenchmarkHarness.cleanupLocalWriteDir();
}"
"public void test_0() throws Exception {
    JSONSerializer serializer=new JSONSerializer();
    serializer.getMapping().clearSerializers();
    int size=JSONSerializerMapTest.size(serializer.getMapping());
    serializer.config(SerializerFeature.WriteEnumUsingToString,false);
    serializer.config(SerializerFeature.WriteEnumUsingName,false);
    serializer.write(Type.A);
    Assert.assertTrue(size < JSONSerializerMapTest.size(serializer.getMapping()));
    Assert.assertEquals(Integer.toString(Type.A.ordinal()),serializer.getWriter().toString());
}"
"@Test
public void notifyAboutChangesConcurrently() {
    final int numberOfThreads = 100;
    final TestSubscriber<Changes> testSubscriber = new TestSubscriber<Changes>();
    final Set<String> tables = new HashSet<String>();
    final List<Changes> expectedChanges = new ArrayList<Changes>();
    for (int i = 0; i < numberOfThreads; i++) {
        final String table = ""test_table"" + i;
        tables.add(table);
        expectedChanges.add(Changes.newInstance(table));
    }
    storIOSQLite.observeChanges(LATEST).subscribe(testSubscriber);
    final CountDownLatch startAllThreadsLock = new CountDownLatch(1);
    for (int i = 0; i < numberOfThreads; i++) {
        final int finalI = i;
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    startAllThreadsLock.await();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                storIOSQLite.lowLevel().notifyAboutChanges(Changes.newInstance(""test_table"" + finalI));
            }
        }).start();
    }
    startAllThreadsLock.countDown();
    final long startTime = SystemClock.elapsedRealtime();
    while ((testSubscriber.valueCount() != tables.size()) && ((SystemClock.elapsedRealtime() - startTime) < 20000)) {
        Thread.yield();
    }
    testSubscriber.assertNoErrors();
    testSubscriber.assertValueCount(expectedChanges.size());
    assertThat(expectedChanges.containsAll(testSubscriber.values())).isTrue();
}"
"@Test void scanShouldIterateOverAvailableEntries(){
    adapter.put(""1"",object1,COLLECTION_1);
    adapter.put(""2"",object2,COLLECTION_1);
    CloseableIterator<Map.Entry<Object,Object>> iterator=adapter.entries(COLLECTION_1);
    Map.Entry<Object,Object> entry1=iterator.next();
    Map.Entry<Object,Object> entry2=iterator.next();
    if (entry1.getKey().equals(""1"")) {
        assertThat(entry1).isEqualTo(new AbstractMap.SimpleEntry<>(""1"",object1));
        assertThat(entry2).isEqualTo(new AbstractMap.SimpleEntry<>(""2"",object2));
    }
    else {
        assertThat(entry2).isEqualTo(new AbstractMap.SimpleEntry<>(""2"",object2));
        assertThat(entry1).isEqualTo(new AbstractMap.SimpleEntry<>(""1"",object1));
    }
    assertThat(iterator.hasNext()).isFalse();
}"
"@Test
public void testMinAllowedValue() {
    long millis = _validMinTime;
    DateTime dateTime = new DateTime(millis, DateTimeZone.UTC);
    LocalDateTime localDateTime = dateTime.toLocalDateTime();
    int year = localDateTime.getYear();
    int month = localDateTime.getMonthOfYear();
    int day = localDateTime.getDayOfMonth();
    Assert.assertEquals(year, 1971);
    Assert.assertEquals(month, 1);
    Assert.assertEquals(day, 1);
}"
"@Test public void primitiveBooleans() throws Exception {
    assertThat(testResult(PrimitiveBooleans.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveBooleans.iterations);
    assertEquals(singletonList(true),PrimitiveBooleans.values.subList(0,1));
    PrimitiveBooleans.iterations=0;
}"
"@Test
public void testWithStringAndConfForBuggyPath() throws Exception {
    dirString = ""file"" ;
    testDir = new Path(dirString);
    item = new PathData(dirString, conf);
    assertEquals(""file:/tmp"", testDir.toString());
    checkPathData();
}"
"@Test public void testAdditionalModelTypeAnnotationsSemiColon() throws Exception {
    OpenAPI openAPI=TestUtils.createOpenAPI();
    final AbstractJavaCodegen codegen=new P_AbstractJavaCodegen();
    codegen.additionalProperties().put(AbstractJavaCodegen.ADDITIONAL_MODEL_TYPE_ANNOTATIONS,""@Foo;@Bar"");
    codegen.processOpts();
    codegen.preprocessOpenAPI(openAPI);
    final List<String> additionalModelTypeAnnotations=new ArrayList<String>();
    additionalModelTypeAnnotations.add(""@Foo"");
    additionalModelTypeAnnotations.add(""@Bar"");
    final List<String> sortedCodegenAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    final List<String> sortedAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    Collections.sort(sortedCodegenAdditionalModelTypeAnnotations);
    Collections.sort(sortedAdditionalModelTypeAnnotations);
    Assert.assertEquals(sortedCodegenAdditionalModelTypeAnnotations,sortedAdditionalModelTypeAnnotations);
}"
"@Test public void enums() throws Exception {
    assertThat(testResult(Enums.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),Enums.iterations);
    assertEquals(EnumSet.of(HALF_UP,HALF_EVEN),new HashSet<>(Enums.values.subList(0,2)));
    Enums.iterations=0;
}"
"@Test
public void testListTaskWithCriteria() throws Exception {
    requireDockerApiVersionAtLeast(""1.24"", ""swarm support"");
    final ServiceSpec spec = createServiceSpec(randomName());
    assertThat(sut.listTasks().size(), is(0));
    sut.createService(spec);
    await().until(numberOfTasks(sut), is(greaterThan(0)));
    final Task task = sut.listTasks().get(1);
    final List<Task> tasksWithId = sut.listTasks(Task.find().taskId(task.id()).build());
    assertThat(tasksWithId.size(), is(1));
    assertThat(tasksWithId.get(0), equalTo(task));
    final List<Task> tasksWithServiceName = sut.listTasks(Task.find().serviceName(spec.name()).build());
    assertThat(tasksWithServiceName.size(), is(greaterThanOrEqualTo(1)));
    final Set<String> taskIds = Sets.newHashSet(Lists.transform(tasksWithServiceName, new Function<Task, String>()));
    assertThat(task.id(), isIn(taskIds));
}"
"public void testForIssue(){
    ArrayListMultimap<String,String> multimap=ArrayListMultimap.create();
    multimap.put(""a"",""1"");
    multimap.put(""a"",""2"");
    multimap.put(""a"",""3"");
    multimap.put(""b"",""1"");
    VO vo=new VO();
    vo.setMap(multimap);
    vo.setName(""zhangsan"");
    assertEquals(""{\""map\"":{\""a\"":[\""1\"",\""2\"",\""3\""],\""b\"":[\""1\""]},\""name\"":\""zhangsan\""}"",JSON.toJSONString(vo,SerializerFeature.MapSortField));
}"
"@Test
public void testTopicLevelInactivePolicyUpdateAndClean() throws Exception {
    super.resetConfig();
    conf.setSystemTopicEnabled(true);
    conf.setTopicLevelPoliciesEnabled(true);
    conf.setBrokerDeleteInactiveTopicsEnabled(true);
    conf.setBrokerDeleteInactiveTopicsMaxInactiveDurationSeconds(1000);
    conf.setBrokerDeleteInactiveTopicsMode(delete_when_no_subscriptions);
    InactiveTopicPolicies defaultPolicy = new InactiveTopicPolicies(InactiveTopicDeleteMode.delete_when_no_subscriptions, 1000, true);
    super.baseSetup();
    Thread.sleep(2000);
    final String namespace = ""prop/ns-abc"";
    final String topic = ""persistent"";
    final String topic2 = ""persistent"";
    final String topic3 = ""persistent"";
    List<String> topics = Arrays.asList(topic, topic2, topic3);
    for (String tp : topics) {
        admin.topics().createNonPartitionedTopic(tp);
    }
    InactiveTopicPolicies inactiveTopicPolicies = new InactiveTopicPolicies(InactiveTopicDeleteMode.delete_when_no_subscriptions, 1, true);
    admin.topics().setInactiveTopicPolicies(topic, inactiveTopicPolicies);
    inactiveTopicPolicies.setInactiveTopicDeleteMode(delete_when_subscriptions_caught_up);
    admin.topics().setInactiveTopicPolicies(topic2, inactiveTopicPolicies);
    inactiveTopicPolicies.setInactiveTopicDeleteMode(delete_when_no_subscriptions);
    admin.topics().setInactiveTopicPolicies(topic3, inactiveTopicPolicies);
    for (int i = 0; i < 50; i++) {
        if (admin.topics().getInactiveTopicPolicies(topic) != null) {
            break;
        }
        Thread.sleep(100);
    }
    InactiveTopicPolicies policies = ((PersistentTopic) (pulsar.getBrokerService().getTopic(topic, false).get().get())).inactiveTopicPolicies;
    Assert.assertTrue(policies.isDeleteWhileInactive());
    assertEquals(policies.getInactiveTopicDeleteMode(), delete_when_no_subscriptions);
    assertEquals(policies.getMaxInactiveDurationSeconds(), 1);
    assertEquals(policies, admin.topics().getInactiveTopicPolicies(topic));
    admin.topics().removeInactiveTopicPolicies(topic);
    for (int i = 0; i < 50; i++) {
        if (admin.topics().getInactiveTopicPolicies(topic) == null) {
            break;
        }
        Thread.sleep(100);
    }
    assertEquals(((PersistentTopic) (pulsar.getBrokerService().getTopic(topic, false).get().get())).inactiveTopicPolicies, defaultPolicy);
    policies = ((PersistentTopic) (pulsar.getBrokerService().getTopic(topic2, false).get().get())).inactiveTopicPolicies;
    Assert.assertTrue(policies.isDeleteWhileInactive());
    assertEquals(policies.getInactiveTopicDeleteMode(), delete_when_subscriptions_caught_up);
    assertEquals(policies.getMaxInactiveDurationSeconds(), 1);
    assertEquals(policies, admin.topics().getInactiveTopicPolicies(topic2));
    inactiveTopicPolicies.setMaxInactiveDurationSeconds(999);
    admin.namespaces().setInactiveTopicPolicies(namespace, inactiveTopicPolicies);
    Thread.sleep(1000);
    admin.topics().removeInactiveTopicPolicies(topic2);
    for (int i = 0; i < 50; i++) {
        if (admin.topics().getInactiveTopicPolicies(topic2) == null) {
            break;
        }
        Thread.sleep(100);
    }
    InactiveTopicPolicies nsPolicies = ((PersistentTopic) (pulsar.getBrokerService().getTopic(topic2, false).get().get())).inactiveTopicPolicies;
    assertEquals(nsPolicies.getMaxInactiveDurationSeconds(), 999);
    super.internalCleanup();
}"
"@Test
public void invalidationInAnotherInstance_closed() throws Exception {
    final SampleDatabase db1 = openDatabase(true);
    final SampleDatabase db2 = openDatabase(true);
    final SampleDatabase db3 = openDatabase(true);
    final CountDownLatch invalidated1 = prepareTableObserver(db1);
    final Pair<CountDownLatch, CountDownLatch> changed1 = prepareLiveDataObserver(db1);
    final CountDownLatch invalidated2 = prepareTableObserver(db2);
    final Pair<CountDownLatch, CountDownLatch> changed2 = prepareLiveDataObserver(db2);
    final CountDownLatch invalidated3 = prepareTableObserver(db3);
    final Pair<CountDownLatch, CountDownLatch> changed3 = prepareLiveDataObserver(db3);
    db2.getCustomerDao().insert(CUSTOMER_1);
    assertTrue(invalidated1.await(3, TimeUnit.SECONDS));
    assertTrue(changed1.first.await(3, TimeUnit.SECONDS));
    assertTrue(invalidated2.await(3, TimeUnit.SECONDS));
    assertTrue(changed2.first.await(3, TimeUnit.SECONDS));
    assertTrue(invalidated3.await(3, TimeUnit.SECONDS));
    assertTrue(changed3.first.await(3, TimeUnit.SECONDS));
    db3.close();
    db2.getCustomerDao().insert(CUSTOMER_2);
    assertTrue(changed1.second.await(3, TimeUnit.SECONDS));
    assertTrue(changed2.second.await(3, TimeUnit.SECONDS));
    assertFalse(changed3.second.await(300, TimeUnit.MILLISECONDS));
}"
"@Test
public void shouldDeserializeSerializedContentPack() throws Exception {
    final ContentPack contentPack = createTestContentPack();
    final URL contentPackURL = ContentPackTest.class.getResource(""expected_content_pack.json"");
    Path path = Paths.get(contentPackURL.toURI());
    String expectedJSON = String.join("""", Files.readAllLines(path)).replace(""\n"", """").replace(""\r"", """");
    final String jsonTxt = objectMapper.writeValueAsString(contentPack);
    assertThat(jsonTxt).isEqualTo(expectedJSON);
    final ContentPack readContentPack = objectMapper.readValue(jsonTxt, ContentPack.class);
    assertThat(readContentPack.id()).isEqualTo(contentPack.id());
    assertThat(readContentPack.version()).isEqualTo(contentPack.version());
    assertThat(readContentPack.revision()).isEqualTo(contentPack.revision());
}"
"@Test public void testAdditionalModelTypeAnnotationsNewLineLinux() throws Exception {
    OpenAPI openAPI=TestUtils.createOpenAPI();
    final AbstractJavaCodegen codegen=new P_AbstractJavaCodegen();
    codegen.additionalProperties().put(AbstractJavaCodegen.ADDITIONAL_MODEL_TYPE_ANNOTATIONS,""@Foo\n@Bar"");
    codegen.processOpts();
    codegen.preprocessOpenAPI(openAPI);
    final List<String> additionalModelTypeAnnotations=new ArrayList<String>();
    additionalModelTypeAnnotations.add(""@Foo"");
    additionalModelTypeAnnotations.add(""@Bar"");
    final List<String> sortedCodegenAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    final List<String> sortedAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    Collections.sort(sortedCodegenAdditionalModelTypeAnnotations);
    Collections.sort(sortedAdditionalModelTypeAnnotations);
    Assert.assertEquals(sortedCodegenAdditionalModelTypeAnnotations,sortedAdditionalModelTypeAnnotations);
}"
"@Test
public void testSequenceListenerWithIncorrectOrder() {
    SequenceListener sl = new SequenceListener();
    sl.sentenceRead(AIS_05_2);
    assertNull(sl.received);
    sl.sentenceRead(AIS_05_1);
    assertNull(sl.received);
    sl.sentenceRead(AIS_05_2);
    assertEquals(sl.received.toString(), MSG_05.toString());
}"
"@Test
public void serverStatusThrottledIfJournalUtilizationIsHigherThanThreshold() throws Exception {
    serverStatus.running();
    final Size segmentSize = Size.kilobytes(1L);
    final KafkaJournal journal = new KafkaJournal(journalDirectory, scheduler, segmentSize, Duration.standardSeconds(1L), Size.kilobytes(4L), Duration.standardSeconds(1L), 1000000, Duration.standardSeconds(1L), 90, new MetricRegistry(), serverStatus);
    createBulkChunks(journal, segmentSize, 4);
    journal.flushDirtyLogs();
    journal.cleanupLogs();
    assertThat(serverStatus.getLifecycle()).isEqualTo(THROTTLED);
}"
"@Test public void explicitConversion() throws Exception {
    assertThat(testResult(ExplicitConversion.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ExplicitConversion.iterations);
    assertEquals(new HashSet<>(asList(LocalDate.of(2017,1,1),LocalDate.of(2001,12,25))),new HashSet<>(ExplicitConversion.values.subList(0,2)));
    ExplicitConversion.iterations=0;
}"
"@Test
public void testStartDoesNotFailWithNonExistentVersion() {
    BundleContext bundleContext = EasyMock.createMock(BundleContext.class);
    final Map<String, Map<String, Feature>> features = new HashMap<String, Map<String, Feature>>();
    Map<String, Feature> versions = new HashMap<String, Feature>();
    versions.put(""1.0.0"", new FeatureImpl(""transaction"", ""1.0.0""));
    versions.put(""2.0.0"", new FeatureImpl(""transaction"", ""2.0.0""));
    features.put(""transaction"", versions);
    Map<String, Feature> versions2 = new HashMap<String, Feature>();
    versions2.put(""1.0.0"", new FeatureImpl(""ssh"", ""1.0.0""));
    features.put(""ssh"", versions2);
    final FeaturesServiceImpl impl = new FeaturesServiceImpl() ;
    impl.setBundleContext(bundleContext);
    try {
        Thread.currentThread().setContextClassLoader(new URLClassLoader(new URL[0]));
        impl.setBoot(""transaction;version=1.2,ssh;version=1.0.0"");
        impl.start();
        assertFalse(""Feature transaction 1.0.0 should not be installed"", impl.isInstalled(impl.getFeature(""transaction"", ""1.0.0"")));
        assertFalse(""Feature transaction 2.0.0 should not be installed"", impl.isInstalled(impl.getFeature(""transaction"", ""2.0.0"")));
        assertFalse(""Feature ssh should be installed"", impl.isInstalled(impl.getFeature(""ssh"", ""1.0.0"")));
    } catch (Exception e) {
        fail(String.format(""Service should not throw start-up exception but log the error instead: %s"", e));
    }
}"
"public void testUnwrapping() throws Exception {
    JsonSchema jsonSchema=MAPPER.generateJsonSchema(UnwrappingRoot.class);
    ObjectNode root=jsonSchema.getSchemaNode();
    JsonNode propertiesSchema=root.get(""properties"");
    String ageType=propertiesSchema.get(""age"").get(""type"").asText();
    String firstType=propertiesSchema.get(""name.first"").get(""type"").asText();
    String lastType=propertiesSchema.get(""name.last"").get(""type"").asText();
    String type=root.get(""type"").asText();
    assertEquals(type,""object"");
    assertEquals(ageType,""integer"");
    assertEquals(firstType,""string"");
    assertEquals(lastType,""string"");
}"
"@Test
public void testInterruption() throws InterruptedException {
    OneTimeWorkRequest work = new OneTimeWorkRequest.Builder(TestWorker.class).build();
    insertWork(work);
    WorkerWrapper workerWrapper =
    createBuilder(work.getStringId())
    .withSchedulers(Collections.singletonList(mMockScheduler))
    .build();
    FutureListener listener = createAndAddFutureListener(workerWrapper);
    Executors.newSingleThreadExecutor().submit(workerWrapper);
    workerWrapper.interrupt();
    Thread.sleep(6000L);
    assertThat(listener.mResult, is(true));
}"
"@Test
public void testInitialFactory() throws Exception {
    System.setProperty(Context.INITIAL_CONTEXT_FACTORY, InitialContextFactory.class.getName());
    InitialContext initialContext = new InitialContext();
    Context context = (Context) initialContext.lookup("""");
    assertTrue(context instanceof NamingContext);
    if (!NamingManager.hasInitialContextFactoryBuilder()) {
        NamingManager.setInitialContextFactoryBuilder(new InitialContextFactoryBuilder());
    }
    initialContext = new InitialContext();
    context = (Context) initialContext.lookup("""");
    assertTrue(context instanceof NamingContext);
}"
"@Test
public void testBindAndRetrieveObjectFactoryFromInitialContext() throws Exception {
    final Reference reference = new Reference(""java.util.String"", TestObjectFactory.class.getName(), null);
    namingStore.bind(new CompositeName(""test""), reference);
    final InitialContext initialContext = new InitialContext();
    final Object result = initialContext.lookup(""test"");
    assertTrue(result instanceof String);
    assertEquals(""Test ParsedResult"", result);
}"
"@Test
public void testBuildTokenServiceSockAddr() {
    assertEquals(""127.0.0.1:123"", SecurityUtil.buildTokenService(new InetSocketAddress(""LocalHost"", 123)).toString());
    assertEquals(""127.0.0.1:123"", SecurityUtil.buildTokenService(new InetSocketAddress(""127.0.0.1"", 123)).toString());
    assertEquals(""127.0.0.1:123"", SecurityUtil.buildTokenService(NetUtils.createSocketAddr(""127.0.0.1"", 123)).toString());
}"
"@Test public void charArray(){
    final WithArrays wa=new WithArrays();
    wa.charArray=new char[]{'a','A'};
    final String exp=getClassPrefix(wa) + ""["" + BR+ ""  boolArray=<null>,""+ BR+ ""  charArray={""+ BR+ ""    a,""+ BR+ ""    A""+ BR+ ""  },""+ BR+ ""  doubleArray=<null>,""+ BR+ ""  intArray=<null>,""+ BR+ ""  longArray=<null>,""+ BR+ ""  stringArray=<null>""+ BR+ ""]"";
    assertEquals(exp,toString(wa));
}"
"public void test_list() throws Exception {
    Model model=new Model();
    Map tables=new LinkedHashMap();
    tables.put(""1001"",new ExtTable(1001));
    tables.put(""1002"",new Table());
    model.setTables(tables);
    String json=JSON.toJSONString(model);
    assertEquals(""{\""tables\"":{\""1001\"":{\""@type\"":\""com.alibaba.json.bvt.writeClassName.WriteClassNameTest_Map$ExtTable\"",\""id\"":1001},\""1002\"":{}}}"",json);
    JSONObject jsonObject=JSON.parseObject(json,Feature.IgnoreAutoType);
    assertEquals(""{\""tables\"":{\""1001\"":{\""id\"":1001},\""1002\"":{}}}"",JSON.toJSONString(jsonObject,SerializerFeature.MapSortField));
    Model model2=JSON.parseObject(json,Model.class);
    assertEquals(ExtTable.class,model2.getTables().get(""1001"").getClass());
}"
"@Test @MongoDBFixtures(""V20161215163900_MoveIndexSetDefaultConfigTest.json"") public void upgrade() throws Exception {
    final long count=collection.count();
    migration.upgrade();
    final MigrationCompleted migrationCompleted=clusterConfigService.get(MigrationCompleted.class);
    assertThat(collection.count()).withFailMessage(""No document should be deleted by the migration!"").isEqualTo(count);
    assertThat(collection.count(Filters.exists(""default""))).withFailMessage(""The migration should have deleted the \""default\"" field from the documents!"").isEqualTo(0L);
    assertThat(clusterConfigService.get(DefaultIndexSetConfig.class)).withFailMessage(""The DefaultIndexSetConfig should have been written to cluster config!"").isNotNull();
    assertThat(clusterConfigService.get(DefaultIndexSetConfig.class).defaultIndexSetId()).isEqualTo(""57f3d721a43c2d59cb750001"");
    assertThat(migrationCompleted).isNotNull();
    assertThat(migrationCompleted.indexSetIds()).containsExactlyInAnyOrder(""57f3d721a43c2d59cb750001"",""57f3d721a43c2d59cb750003"");
}"
"@Test
public void manyParameters() throws Exception {
    assertThat(testResult(ManyParameters.class), isSuccessful());
    assertEquals(16, ManyParameters.iterations);
    assertEquals(asList(-1, -2, -4), ManyParameters.firstTestCases.subList(0, 3));
    assertEquals(asList(-1, -2, -4), ManyParameters.firstTestCases.subList(4, 7));
    assertEquals(asList(-1, -2, -4), ManyParameters.firstTestCases.subList(8, 11));
    assertEquals(asList(-1, -2, -4), ManyParameters.firstTestCases.subList(12, 15));
    assertEquals(asList('r', 'r', 'r', 'r', 'y', 'y', 'y', 'y'), ManyParameters.secondTestCases.subList(0, 8));
}"
"@Test public void boxOfFoo() throws Exception {
    assertThat(testResult(BoxOfFoo.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),BoxOfFoo.iterations);
    BoxOfFoo.iterations=0;
}"
"@Test
public void testDelegationTokenWithRealUser() throws IOException {
    UserGroupInformation ugi = UserGroupInformation.createRemoteUser(REAL_USER);
    final UserGroupInformation proxyUgi = UserGroupInformation.createProxyUserForTesting(PROXY_USER, ugi, GROUP_NAMES);
    try {
        Token<?>[] tokens = proxyUgi.doAs(new PrivilegedExceptionAction<Token<?>[]>() {
            @Override
            public Token<?>[] run() throws IOException {
                return cluster.getFileSystem().addDelegationTokens(""RenewerUser"", null);
            }
        });
        DelegationTokenIdentifier identifier = new DelegationTokenIdentifier();
        byte[] tokenId = tokens[0].getIdentifier();
        identifier.readFields(new DataInputStream(new ByteArrayInputStream(tokenId)));
        Assert.assertEquals(identifier.getUser().getUserName(), PROXY_USER);
        Assert.assertEquals(identifier.getUser().getRealUser().getUserName(), REAL_USER);
    } catch (InterruptedException e) {
    }
}"
"@Test public void primitiveDoubles() throws Exception {
    assertThat(testResult(PrimitiveDoubles.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveDoubles.iterations);
    assertEquals(new HashSet<>(asList(3.2,-4D)),new HashSet<>(PrimitiveDoubles.values.subList(0,2)));
    PrimitiveDoubles.iterations=0;
}"
"@Test
public void testOneTimeRequest_noInitialDelay_withConstraintNetworkConnected() {
    val now = System.currentTimeMillis() ;
    when(mTaskConverter.now()).thenReturn(now) ;
    val constraints = Constraints.Builder().setRequiredNetworkType(NetworkType.METERED).setRequiresCharging(true).build() ;
    val request = OneTimeWorkRequestBuilder<TestWorker>()
    .setConstraints(constraints)
    .build() ;
    val task = mTaskConverter.convert(request.workSpec) ;
    val expected = request.workSpec.calculateNextRunTime() ;
    val offset = offset(expected, now) ;
    assertEquals(task.serviceName, WorkManagerGcmService::class.java.name) ;
    assertEquals(task.isPersisted, false) ;
    assertEquals(task.isUpdateCurrent, true) ;
    assertEquals(task.requiredNetwork, Task.NETWORK_STATE_CONNECTED) ;
    assertEquals(task.requiresCharging, true) ;
    assertEquals(task.windowStart, offset) ;
    assertEquals(task.windowEnd, offset + EXECUTION_WINDOW_SIZE_IN_SECONDS) ;
}"
"@Test
public void testSetName() throws Exception {
    Configuration conf = new Configuration();
    WritableName.setName(SimpleWritable.class, testName);
    Class<?> test = WritableName.getClass(testName, conf);
    assertTrue(test.equals(SimpleWritable.class));
}"
"@Test void writesAndReadsClassContainingCustomConvertedObjects(){
    List<Object> converters=new ArrayList<>();
    converters.add(BigDecimalToStringConverter.INSTANCE);
    converters.add(StringToBigDecimalConverter.INSTANCE);
    CustomConversions customConversions=new CouchbaseCustomConversions(converters);
    converter.setCustomConversions(customConversions);
    converter.afterPropertiesSet();
    ((CouchbaseMappingContext)converter.getMappingContext()).setSimpleTypeHolder(customConversions.getSimpleTypeHolder());
    CouchbaseDocument converted=new CouchbaseDocument();
    final String weightStr=""12.34"";
    final BigDecimal weight=new BigDecimal(weightStr);
    final CustomObject addy=new CustomObject(weight);
    List<CustomObject> listOfObjects=new ArrayList<>();
    listOfObjects.add(addy);
    Map<String,CustomObject> mapOfObjects=new HashMap<>();
    mapOfObjects.put(""obj0"",addy);
    mapOfObjects.put(""obj1"",addy);
    CustomObjectEntity entity=new CustomObjectEntity(addy,listOfObjects,mapOfObjects);
    converter.write(entity,converted);
    CouchbaseDocument source=new CouchbaseDocument();
    source.put(""_class"",CustomObjectEntity.class.getName());
    CouchbaseDocument objectDoc=new CouchbaseDocument();
    objectDoc.put(""weight"",weightStr);
    source.put(""object"",objectDoc);
    CouchbaseList listOfObjectsDoc=new CouchbaseList();
    listOfObjectsDoc.put(objectDoc);
    source.put(""listOfObjects"",listOfObjectsDoc);
    CouchbaseDocument mapOfObjectsDoc=new CouchbaseDocument();
    mapOfObjectsDoc.put(""obj0"",objectDoc);
    mapOfObjectsDoc.put(""obj1"",objectDoc);
    source.put(""mapOfObjects"",mapOfObjectsDoc);
    assertThat(converted.export()).isEqualTo(source.export());
    CustomObjectEntity readConverted=converter.read(CustomObjectEntity.class,source);
    assertThat(readConverted.object.weight).isEqualTo(addy.weight);
    assertThat(readConverted.listOfObjects.get(0).weight).isEqualTo(listOfObjects.get(0).weight);
    assertThat(readConverted.mapOfObjects.get(""obj0"").weight).isEqualTo(mapOfObjects.get(""obj0"").weight);
    assertThat(readConverted.mapOfObjects.get(""obj1"").weight).isEqualTo(mapOfObjects.get(""obj1"").weight);
}"
"@Test public void testMwRecentCurrentDumpFileProcessing() throws IOException {
    Path dmPath=Paths.get(System.getProperty(""user.dir""));
    MockDirectoryManager dm=new MockDirectoryManager(dmPath,true,true);
    mockLocalDumpFile(""20140420"",4,DumpContentType.DAILY,dm);
    mockLocalDumpFile(""20140419"",3,DumpContentType.DAILY,dm);
    mockLocalDumpFile(""20140418"",2,DumpContentType.DAILY,dm);
    mockLocalDumpFile(""20140417"",1,DumpContentType.DAILY,dm);
    mockLocalDumpFile(""20140418"",2,DumpContentType.CURRENT,dm);
    DumpProcessingController dpc=new DumpProcessingController(""wikidatawiki"");
    dpc.downloadDirectoryManager=dm;
    dpc.setOfflineMode(true);
    StatisticsMwRevisionProcessor mwrpStats=new StatisticsMwRevisionProcessor(""stats"",2);
    dpc.registerMwRevisionProcessor(mwrpStats,null,true);
    dpc.processAllRecentRevisionDumps();
    assertEquals(5,mwrpStats.getTotalRevisionCount());
    assertEquals(1,mwrpStats.getCurrentRevisionCount());
}"
"@Test
public void testCommit() throws Exception {
    producer2.send(session.createTextMessage(""X""));
    producer2.send(session.createTextMessage(""Y""));
    producer2.send(session.createTextMessage(""Z""));
    expect(""A"", consumer1.receive(1000));
    expect(""B"", consumer1.receive(1000));
    expect(""C"", consumer1.receive(1000));
    session.commit();
    expect(""X"", testConsumer2.receive(1000));
    expect(""Y"", testConsumer2.receive(1000));
    expect(""Z"", testConsumer2.receive(1000));
    assertTrue(null == testConsumer1.receive(1000));
    assertTrue(null == testConsumer2.receive(1000));
}"
"@Test public void testGetPartialRepairTasks(){
    Node node=mockNode(""DC1"");
    Node node2=mockNode(""DC1"");
    ImmutableList<LongTokenRange> vnodes=ImmutableList.of(new LongTokenRange(1,2),new LongTokenRange(2,3),new LongTokenRange(4,5));
    ReplicaRepairGroup replicaRepairGroup=new ReplicaRepairGroup(ImmutableSet.of(node,node2),vnodes);
    RepairGroup repairGroup=builderFor(replicaRepairGroup).build(priority);
    Collection<RepairTask> tasks=repairGroup.getRepairTasks();
    assertThat(tasks.size()).isEqualTo(3);
    Set<LongTokenRange> repairTaskRanges=new HashSet<>();
    for (  RepairTask repairTask : tasks) {
        assertThat(repairTask.getTokenRanges().size()).isEqualTo(1);
        LongTokenRange range=repairTask.getTokenRanges().iterator().next();
        repairTaskRanges.add(range);
        assertThat(repairTask.getReplicas()).containsExactlyInAnyOrder(node,node2);
        assertThat(repairTask.getTableReference()).isEqualTo(tableReference);
        assertThat(repairTask.getRepairConfiguration().getRepairParallelism()).isEqualTo(RepairOptions.RepairParallelism.PARALLEL);
    }
    assertThat(repairTaskRanges).containsExactlyInAnyOrderElementsOf(vnodes);
}"
"@Test
public void testReadWithTimeoutInterleaved() {
    int space = 0xfd;
    long address = 0x12345678;
    int length = 4;
    MemoryConfigurationService.McsReadHandler hnd = mock(McsReadHandler.class);
    MemoryConfigurationService.McsReadHandler hnd2 = mock(McsReadHandler.class);
    iface.getDatagramMeteringBuffer().setTimeout(30);
    iface.getMemoryConfigurationService().setTimeoutMillis(30);
    {
        iface.getMemoryConfigurationService().requestRead(farID, space, address, length, hnd);
        expectMessageAndNoMore(new DatagramMessage(hereID, farID, new int[]{ 0x20, 0x41, 0x12, 0x34, 0x56, 0x78, 4 }));
        System.err.println(""Expect 'Never received reply' here -->"");
        delay(50);
        System.err.println(""<--"");
        verify(hnd).handleFailure(0x100);
        verifyNoMoreInteractions(hnd);
        iface.getMemoryConfigurationService().requestRead(farID, space, address + 1, length, hnd2);
        expectMessageAndNoMore(new DatagramMessage(hereID, farID, new int[]{ 0x20, 0x41, 0x12, 0x34, 0x56, 0x79, 4 }));
        sendMessage(new DatagramAcknowledgedMessage(farID, hereID, 0x80));
        consumeMessages();
        sendMessage(new DatagramRejectedMessage(farID, hereID, 0x2020));
        consumeMessages();
        System.err.println(""Expect 'unexpected response datagram' here -->"");
        sendMessageAndExpectResult(new DatagramMessage(farID, hereID, new int[]{ 0x20, 0x51, 0x12, 0x34, 0x56, 0x78, 0xaa }), new DatagramAcknowledgedMessage(hereID, farID));
        System.err.println(""<--"");
        expectNoMessages();
        delay(50);
        expectMessageAndNoMore(new DatagramMessage(hereID, farID, new int[]{ 0x20, 0x41, 0x12, 0x34, 0x56, 0x79, 4 }));
        sendMessage(new DatagramAcknowledgedMessage(farID, hereID, 0x80));
        consumeMessages();
        sendMessage(new DatagramAcknowledgedMessage(farID, hereID, 0x80));
        consumeMessages();
        sendMessageAndExpectResult(new DatagramMessage(farID, hereID, new int[]{ 0x20, 0x51, 0x12, 0x34, 0x56, 0x79, 0xaa }), new DatagramAcknowledgedMessage(hereID, farID));
        verify(hnd2).handleReadData(farID, space, address + 1, new byte[]{ ((byte) (0xaa)) });
        verifyNoMoreInteractions(hnd2);
    }
    System.err.println(""Sending another request..."");
    sendAnother(space, address + 5);
}"
"@Test public void nestedElements(){
    final Customer customer=new Customer(""Douglas Adams"");
    final Bank bank=new Bank(""ASF Bank"");
    customer.bank=bank;
    final String exp=getClassPrefix(customer) + ""["" + BR+ ""  accounts=<null>,""+ BR+ ""  bank=""+ getClassPrefix(bank)+ ""[""+ BR+ ""    name=ASF Bank""+ BR+ ""  ],""+ BR+ ""  name=Douglas Adams""+ BR+ ""]"";
    assertEquals(exp,toString(customer));
}"
"@Test public void wrapperFloats() throws Exception {
    assertThat(testResult(WrapperFloats.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperFloats.iterations);
    assertEquals(new HashSet<>(asList(1.7F,-4.14F)),new HashSet<>(WrapperFloats.values.subList(0,2)));
    WrapperFloats.iterations=0;
}"
"@Test
public void testSkipCheckoutWhenCheckoutDirectoryExistsAndSkip() throws Exception {
    checkoutDir.mkdirs();
    CheckoutMojo mojo = ((CheckoutMojo) (lookupMojo(""checkout"", getTestFile(""src/test/resources/mojos/checkout/checkoutWhenCheckoutDirectoryExistsAndSkip.xml""))));
    mojo.setCheckoutDirectory(checkoutDir);
    mojo.execute();
    assertEquals(0, checkoutDir.listFiles().length);
}"
"@Test
public void testScannerResultCodes() throws Exception {
    Header[] headers = new Header[3];
    headers[0] = new Header(""Content-Type"", Constants.MIMETYPE_XML);
    headers[1] = new Header(""Accept"", Constants.MIMETYPE_JSON);
    headers[2] = new Header(""Accept-Encoding"", ""gzip"");
    Response response = client.post((""/"" + TABLE) + ""/scanner"", headers, ""<Scanner/>"".getBytes());
    assertEquals(response.getCode(), 201);
    String scannerUrl = response.getLocation();
    assertNotNull(scannerUrl);
    response = client.get(scannerUrl);
    assertEquals(response.getCode(), 200);
    response = client.get(scannerUrl);
    assertEquals(response.getCode(), 204);
}"
"@Test
public void duplexWithRedirect() throws Exception {
    enableProtocol(HTTP_2);
    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(new MockResponse().clearHeaders().setResponseCode(HttpURLConnection.HTTP_MOVED_PERM).addHeader(""Location: /b""), new MockDuplexResponseBody().sendResponse(""/a has moved!\n"").requestIOException().exhaustResponse());
    server.enqueue(new MockResponse().setBody(""this is /b""));
    Call call = client.newCall(new Request.Builder().url(server.url(""/"")).post(new AsyncRequestBody()).build());
    try (final Response response = call.execute()) {
        BufferedSource responseBody = response.body().source();
        assertThat(responseBody.readUtf8Line()).isEqualTo(""this is /b"");
    }
    BufferedSink requestBody = ((AsyncRequestBody) (call.request().body())).takeSink();
    try {
        requestBody.writeUtf8(""request body\n"");
        requestBody.flush();
        fail();
    } catch (IOException expected) {
        assertThat(expected.getMessage()).isEqualTo(""stream was reset: CANCEL"");
    }
    mockDuplexResponseBody.awaitSuccess();
    assertThat(listener.recordedEventTypes()).containsExactly(""CallStart"", ""DnsStart"", ""DnsEnd"", ""ConnectStart"", ""SecureConnectStart"", ""SecureConnectEnd"", ""ConnectEnd"", ""ConnectionAcquired"", ""RequestHeadersStart"", ""RequestHeadersEnd"", ""RequestBodyStart"", ""ResponseHeadersStart"", ""ResponseHeadersEnd"", ""ResponseBodyStart"", ""ResponseBodyEnd"", ""RequestHeadersStart"", ""RequestHeadersEnd"", ""ResponseHeadersStart"", ""ResponseHeadersEnd"", ""ResponseBodyStart"", ""ResponseBodyEnd"", ""ConnectionReleased"", ""CallEnd"", ""RequestFailed"");
}"
"@Test
void syncWithError_ShouldCallErrorCallback() {
    final TestLogger syncerTestLogger = TestLoggerFactory.getTestLogger(InventoryEntrySyncer.class);
    final SphereClient sourceClient = mock(SphereClient.class);
    final SphereClient targetClient = mock(SphereClient.class);
    when(sourceClient.getConfig()).thenReturn(SphereApiConfig.of(""source-project""));
    when(targetClient.getConfig()).thenReturn(SphereApiConfig.of(""target-project""));
    final List<InventoryEntry> inventoryEntries = Collections.singletonList(readObjectFromResource(""inventory-no-sku.json"", InventoryEntry.class));
    final PagedQueryResult<InventoryEntry> pagedQueryResult = mock(PagedQueryResult.class);
    when(pagedQueryResult.getResults()).thenReturn(inventoryEntries);
    when(sourceClient.execute(any(InventoryEntryQuery.class))).thenReturn(CompletableFuture.completedFuture(pagedQueryResult));
    final InventoryEntrySyncer inventoryEntrySyncer = InventoryEntrySyncer.of(sourceClient, targetClient, mock(Clock.class));
    inventoryEntrySyncer.sync(null, true).toCompletableFuture().join();
    final LoggingEvent errorLog = syncerTestLogger.getAllLoggingEvents().get(1);
    assertThat(errorLog.getMessage()).isEqualTo(""Error when trying to sync inventory entry. Existing key: <<not present>>. Update actions: []"");
    assertThat(errorLog.getThrowable().get().getMessage()).isEqualTo(""InventoryEntryDraft doesn't have a SKU. Please make sure all inventory entry drafts have SKUs."");
}"
"@Test public void serializePrefixOnly(){
    final LookupCacheKey cacheKey=LookupCacheKey.createFromJSON(""prefix"",null);
    final JsonNode node=objectMapper.convertValue(cacheKey,JsonNode.class);
    assertThat(node.isObject()).isTrue();
    assertThat(node.fieldNames()).containsExactlyInAnyOrder(""prefix"",""key"");
    assertThat(node.path(""prefix"").isTextual()).isTrue();
    assertThat(node.path(""prefix"").asText()).isEqualTo(""prefix"");
    assertThat(node.path(""key"").isNull()).isTrue();
}"
"@Test
public void testSimpleClassloading() throws Exception {
    final AtomicInteger count = new AtomicInteger(0);
    final List<Event> finishedEvents = Collections.synchronizedList(new ArrayList<Event>());
    final ServiceRegistration jcReg = this.registerJobConsumer(TOPIC, new JobConsumer() {
        @Override
        public JobResult process(Job job) {
            count.incrementAndGet();
            return JobResult.OK;
        }
    });
    final ServiceRegistration ehReg = this.registerEventHandler(TOPIC_JOB_FINISHED, new EventHandler() {
        @Override
        public void handleEvent(Event event) {
            finishedEvents.add(event);
        }
    });
    try {
        final JobManager jobManager = this.getJobManager();
        final List<String> list = new ArrayList<String>();
        list.add(""1"");
        list.add(""2"");
        final EventPropertiesMap map = new EventPropertiesMap();
        map.put(""a"", ""a1"");
        map.put(""b"", ""b2"");
        final Map<String, Object> props = new HashMap<String, Object>();
        props.put(""string"", ""Hello"");
        props.put(""int"", new Integer(5));
        props.put(""long"", new Long(7));
        props.put(""list"", list);
        props.put(""map"", map);
        jobManager.addJob(TOPIC, null, props);
        while (finishedEvents.size() < 1) {
            Thread.sleep(100);
        }
        Thread.sleep(100);
        assertEquals(0, jobManager.getStatistics().getNumberOfQueuedJobs());
        assertEquals(1, count.get());
        assertEquals(0, jobManager.findJobs(ALL, TOPIC, -1, ((Map<String, Object>[]) (null))).size());
        final String jobTopic = ((String) (finishedEvents.get(0).getProperty(NOTIFICATION_PROPERTY_JOB_TOPIC)));
        assertNotNull(jobTopic);
        assertEquals(""Hello"", finishedEvents.get(0).getProperty(""string""));
        assertEquals(new Integer(5), Integer.valueOf(finishedEvents.get(0).getProperty(""int"").toString()));
        assertEquals(new Long(7), Long.valueOf(finishedEvents.get(0).getProperty(""long"").toString()));
        assertEquals(list, finishedEvents.get(0).getProperty(""list""));
        assertEquals(map, finishedEvents.get(0).getProperty(""map""));
    } finally {
        jcReg.unregister();
        ehReg.unregister();
    }
}"
"@Test
public void testRunWriteAfterRead() {
    final Function1<CancelIndicator, Integer> _function = (CancelIndicator it) -> {
        return Integer.valueOf(this.sharedState.incrementAndGet());
    };
    this.requestManager.<Integer>runRead(_function);
    final Function0<Object> _function_1 = () -> {
        return null;
    };
    final Function2<CancelIndicator, Object, Integer> _function_2 = (CancelIndicator $0,Object $1) -> {
        int _xblockexpression = ((int) (0));
        {
            Assert.assertEquals(1, this.sharedState.get());
            _xblockexpression = this.sharedState.incrementAndGet();
        }
        return Integer.valueOf(_xblockexpression);
    };
    this.requestManager.<Object, Integer>runWrite(_function_1, _function_2).join();
    Assert.assertEquals(2, this.sharedState.get());
}"
"@Test public void test_inherit_from_abstract_class_1(){
    issue3655_b b=new issue3655_b(null,null,null,null,null,null,null,null,null);
    String result=JSON.toJSONString(b,filter,SerializerFeature.WriteNullStringAsEmpty);
    System.out.println(result);
    Assert.assertEquals(jsonStr,result);
}"
"@Test
public void testBrokerSelectionForAntiAffinityGroup() throws Exception {
    final String broker1 = primaryHost;
    final String broker2 = secondaryHost;
    final String cluster = pulsar1.getConfiguration().getClusterName();
    final String tenant = ""tenant-"" + UUID.randomUUID().toString();
    final String namespace1 = ((tenant + ""/"") + cluster) + ""/ns1"";
    final String namespace2 = ((tenant + ""/"") + cluster) + ""/ns2"";
    final String namespaceAntiAffinityGroup = ""group"";
    FailureDomain domain1 = new FailureDomain();
    domain1.brokers = Sets.newHashSet(broker1);
    admin1.clusters().createFailureDomain(cluster, ""domain1"", domain1);
    FailureDomain domain2 = new FailureDomain();
    domain2.brokers = Sets.newHashSet(broker2);
    admin1.clusters().createFailureDomain(cluster, ""domain2"", domain2);
    admin1.tenants().createTenant(tenant, new TenantInfo(null, Sets.newHashSet(cluster)));
    admin1.namespaces().createNamespace(namespace1);
    admin1.namespaces().createNamespace(namespace2);
    admin1.namespaces().setNamespaceAntiAffinityGroup(namespace1, namespaceAntiAffinityGroup);
    admin1.namespaces().setNamespaceAntiAffinityGroup(namespace2, namespaceAntiAffinityGroup);
    for (int i = 0; i < 5; i++) {
        if ((!isLoadManagerUpdatedDomainCache(primaryLoadManager)) || (!isLoadManagerUpdatedDomainCache(secondaryLoadManager))) {
            Thread.sleep(200);
        } else {
            break;
        }
    }
    assertTrue(isLoadManagerUpdatedDomainCache(primaryLoadManager));
    assertTrue(isLoadManagerUpdatedDomainCache(secondaryLoadManager));
    ServiceUnitId serviceUnit1 = makeBundle(tenant, cluster, ""ns1"");
    String selectedBroker1 = primaryLoadManager.selectBrokerForAssignment(serviceUnit1).get();
    ServiceUnitId serviceUnit2 = makeBundle(tenant, cluster, ""ns2"");
    String selectedBroker2 = primaryLoadManager.selectBrokerForAssignment(serviceUnit2).get();
    assertNotEquals(selectedBroker1, selectedBroker2);
}"
"@Test public void wrapperBytes() throws Exception {
    assertThat(testResult(WrapperBytes.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperBytes.iterations);
    WrapperBytes.iterations=0;
}"
"@Test public void ctorOnly(){
    assertThat(testResult(CtorOnly.class),isSuccessful());
    assertEquals(2,CtorOnly.iterations);
    assertEquals(new HashSet<>(asList(new CtorOnly.Target(""a""),new CtorOnly.Target(""b""))),CtorOnly.testCases);
    CtorOnly.iterations=0;
    CtorOnly.testCases.clear();
}"
"@Test
public void testReadSkip() throws Exception {
    FileSystem fs = cluster.getFileSystem();
    long tStart = System.currentTimeMillis();
    bench.getConf().setLong(""test.io.skip.size"", 1);
    bench.randomReadTest(fs);
    long execTime = System.currentTimeMillis() - tStart;
    bench.analyzeResult(fs, TestType.TEST_TYPE_READ_SKIP, execTime);
}"
"@Test
public void testDelegationTokenSecretManager() throws Exception {
    DelegationTokenSecretManager dtSecretManager = cluster.getNameNode().getNamesystem().getDelegationTokenSecretManager();
    Token<DelegationTokenIdentifier> token = generateDelegationToken(""SomeUser"", ""JobTracker"");
    try {
        dtSecretManager.renewToken(token, ""FakeRenewer"");
        Assert.fail(""should have failed"");
    } catch (AccessControlException ace) {
    }
    dtSecretManager.renewToken(token, ""JobTracker"");
    DelegationTokenIdentifier identifier = new DelegationTokenIdentifier();
    byte[] tokenId = token.getIdentifier();
    identifier.readFields(new DataInputStream(new ByteArrayInputStream(tokenId)));
    Assert.assertTrue(null != dtSecretManager.retrievePassword(identifier));
    LOG.info(""Sleep to expire the token"");
    Thread.sleep(6000);
    try {
        dtSecretManager.retrievePassword(identifier);
        Assert.fail(""Token should have expired"");
    } catch (InvalidToken e) {
    }
    dtSecretManager.renewToken(token, ""JobTracker"");
    LOG.info(""Sleep beyond the max lifetime"");
    Thread.sleep(5000);
    try {
        dtSecretManager.renewToken(token, ""JobTracker"");
        Assert.fail(""should have been expired"");
    } catch (InvalidToken it) {
    }
}"
"@Test public void wrapperIntegers(){
    assertThat(testResult(WrapperIntegers.class),isSuccessful());
    assertEquals(2,WrapperIntegers.iterations);
    assertEquals(new HashSet<>(asList(4,5)),WrapperIntegers.testCases);
    WrapperIntegers.iterations=0;
    WrapperIntegers.testCases.clear();
}"
"public void test_dupType() throws Exception {
    DianDianCart cart=new DianDianCart();
    cart.setId(1001);
    LinkedHashMap<String,JSONObject> cartMap=new LinkedHashMap<String,JSONObject>();
    JSONObject obj=new JSONObject();
    obj.put(""id"",1001);
    obj.put(JSON.DEFAULT_TYPE_KEY,""com.alibaba.json.bvt.writeClassName.WriteDuplicateType$DianDianCart"");
    cartMap.put(""1001"",obj);
    String text1=JSON.toJSONString(cartMap,SerializerFeature.WriteClassName);
    assertTrue(text1.equals(""{\""@type\"":\""java.util.LinkedHashMap\"",\""1001\"":{\""@type\"":\""com.alibaba.json.bvt.writeClassName.WriteDuplicateType$DianDianCart\"",\""id\"":1001}}"") || text1.equals(""{\""@type\"":\""java.util.LinkedHashMap\"",\""1001\"":{\""id\"":1001,\""@type\"":\""com.alibaba.json.bvt.writeClassName.WriteDuplicateType$DianDianCart\""}}""));
}"
"@Test
public void createDirectoryManagerIoException() throws IOException {
    DirectoryManagerFactory.createDirectoryManager(
    ""/nonexisting-directory/123456789/hopefully"", true);
}"
"@Test public void wrapperIntegers() throws Exception {
    assertThat(testResult(WrapperIntegers.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperIntegers.iterations);
    WrapperIntegers.iterations=0;
}"
"@Test public void wrapperDoubles() throws Exception {
    assertThat(testResult(WrapperDoubles.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperDoubles.iterations);
    assertEquals(new HashSet<>(asList(2.7,-3.14)),new HashSet<>(WrapperDoubles.values.subList(0,2)));
    WrapperDoubles.iterations=0;
}"
"@Test
public void testSubscriber() throws InterruptedException, ExecutionException, TimeoutException {
    LineageWriter lineageWriter = getInjector().getInstance(MessagingLineageWriter.class);
    ProgramRunId run1 = service1.run(RunIds.generate());
    lineageWriter.addAccess(run1, dataset1, AccessType.READ);
    lineageWriter.addAccess(run1, dataset2, AccessType.WRITE);
    LineageStoreReader lineageReader = getInjector().getInstance(LineageStoreReader.class);
    ProgramRunId run1 = service1.run(RunIds.generate());
    Set<NamespacedEntityId> entities = lineageReader.getEntitiesForRun(run1);
    Assert.assertTrue(entities.isEmpty());
    LineageWriter lineageWriter = getInjector().getInstance(MessagingLineageWriter.class);
    lineageWriter.addAccess(run1, dataset1, AccessType.READ);
    lineageWriter.addAccess(run1, dataset2, AccessType.WRITE);
    FieldLineageWriter fieldLineageWriter = getInjector().getInstance(MessagingLineageWriter.class);
    ProgramRunId spark1Run1 = spark1.run(RunIds.generate(100));
    ReadOperation read = new ReadOperation(""read"", ""some read"", EndPoint.of(""ns"", ""endpoint1""), ""offset"", ""body"");
    TransformOperation parse = new TransformOperation(""parse"", ""parse body"",
    Collections.singletonList(InputField.of(""read"", ""body"")),
    ""name"", ""address"");
    WriteOperation write = new WriteOperation(""write"", ""write data"", EndPoint.of(""ns"", ""endpoint2""),
    Arrays.asList(InputField.of(""read"", ""offset""),
    InputField.of(""parse"", ""name""),
    InputField.of(""parse"", ""address"")));
    List<Operation> operations = new ArrayList<>();
    operations.add(read);
    operations.add(write);
    operations.add(parse);
    FieldLineageInfo info1 = new FieldLineageInfo(operations);
    fieldLineageWriter.write(spark1Run1, info1);
    ProgramRunId spark1Run2 = spark1.run(RunIds.generate(200));
    fieldLineageWriter.write(spark1Run2, info1);
    List<Operation> operations2 = new ArrayList<>();
    operations2.add(read);
    operations2.add(parse);
    TransformOperation normalize = new TransformOperation(""normalize"", ""normalize address"",
    Collections.singletonList(InputField.of(""parse"", ""address"")),
    ""address"");
    operations2.add(normalize);
    WriteOperation anotherWrite = new WriteOperation(""anotherwrite"", ""write data"", EndPoint.of(""ns"", ""endpoint2""),
    Arrays.asList(InputField.of(""read"", ""offset""),
    InputField.of(""parse"", ""name""),
    InputField.of(""normalize"", ""address"")));
    operations2.add(anotherWrite);
    FieldLineageInfo info2 = new FieldLineageInfo(operations2);
    ProgramRunId spark1Run3 = spark1.run(RunIds.generate(300));
    fieldLineageWriter.write(spark1Run3, info2);
    UsageWriter usageWriter = getInjector().getInstance(MessagingUsageWriter.class);
    usageWriter.register(spark1, dataset1);
    usageWriter.registerAll(Collections.singleton(spark1), dataset3);
    Set<NamespacedEntityId> expectedLineage = new HashSet<>(Arrays.asList(run1.getParent(), dataset1, dataset2));
    Tasks.waitFor(true, () -> expectedLineage.equals(lineageReader.getEntitiesForRun(run1)),
    10, TimeUnit.SECONDS, 100, TimeUnit.MILLISECONDS);
    Assert.assertTrue(lineageReader.getRelations(spark1, 0L, Long.MAX_VALUE, x -> true).isEmpty());
    FieldLineageReader fieldLineageReader = getInjector().getInstance(FieldLineageReader.class);
    Set<Operation> expectedOperations = new HashSet<>();
    expectedOperations.add(read);
    expectedOperations.add(anotherWrite);
    List<ProgramRunOperations> expected = new ArrayList<>();
    expected.add(new ProgramRunOperations(Collections.singleton(spark1Run3), expectedOperations));
    expectedOperations = new HashSet<>();
    expectedOperations.add(read);
    expectedOperations.add(write);
    expected.add(new ProgramRunOperations(new HashSet<>(Arrays.asList(spark1Run1, spark1Run2)),
    expectedOperations));
    EndPointField endPointField = new EndPointField(EndPoint.of(""ns"", ""endpoint2""), ""offset"");
    Tasks.waitFor(expected, () -> fieldLineageReader.getIncomingOperations(endPointField, 1L, Long.MAX_VALUE - 1),
    10, TimeUnit.SECONDS, 100, TimeUnit.MILLISECONDS);
    Set<EntityId> expectedUsage = new HashSet<>(Arrays.asList(dataset1, dataset3));
    UsageRegistry usageRegistry = getInjector().getInstance(UsageRegistry.class);
    Tasks.waitFor(true, () -> expectedUsage.equals(usageRegistry.getDatasets(spark1)),
    10, TimeUnit.SECONDS, 100, TimeUnit.MILLISECONDS);
}"
"public void testConnectedComponents(){
    System.out.println(""graph is "" + graph.toString());
    Set<Set<Integer>> ccs=new HashSet<>(graph.getConnectedComponents());
    for (  Set<Integer> cc : ccs) {
        System.out.println(""Connected component: "" + cc);
    }
    Set<Integer> edge1=new HashSet<>(Arrays.asList(1,2,3,4));
    Set<Integer> edge2=new HashSet<>(Arrays.asList(5,6,7));
    Set<Integer> edge3=new HashSet<>(Arrays.asList(8));
    Set<Integer> edge4=new HashSet<>(Arrays.asList(9,10));
    Set<Set<Integer>> expectedCcs=new HashSet<>(Arrays.asList(edge1,edge2,edge3,edge4));
    assertEquals(expectedCcs,ccs);
}"
"public void test_for_issue() throws Exception {
    Map<Integer,Integer> map=new LinkedHashMap<Integer,Integer>();
    map.put(1,10);
    map.put(2,4);
    map.put(3,5);
    map.put(4,5);
    map.put(37306,98);
    map.put(36796,9);
    String json=JSON.toJSONString(map);
    System.out.println(json);
    Assert.assertEquals(""{1:10,2:4,3:5,4:5,37306:98,36796:9}"",json);
    Map<Integer,Integer> map1=JSON.parseObject(json,new TypeReference<HashMap<Integer,Integer>>(){
    }
    );
    Assert.assertEquals(map1.get(Integer.valueOf(1)),Integer.valueOf(10));
    Assert.assertEquals(map1.get(Integer.valueOf(2)),Integer.valueOf(4));
    Assert.assertEquals(map1.get(Integer.valueOf(3)),Integer.valueOf(5));
    Assert.assertEquals(map1.get(Integer.valueOf(4)),Integer.valueOf(5));
    Assert.assertEquals(map1.get(Integer.valueOf(37306)),Integer.valueOf(98));
    Assert.assertEquals(map1.get(Integer.valueOf(36796)),Integer.valueOf(9));
    JSONObject map2=JSON.parseObject(""{35504:1,1:10,2:4,3:5,4:5,37306:98,36796:9\n"" + ""}"");
    Assert.assertEquals(map2.get(Integer.valueOf(1)),Integer.valueOf(10));
    Assert.assertEquals(map2.get(Integer.valueOf(2)),Integer.valueOf(4));
    Assert.assertEquals(map2.get(Integer.valueOf(3)),Integer.valueOf(5));
    Assert.assertEquals(map2.get(Integer.valueOf(4)),Integer.valueOf(5));
    Assert.assertEquals(map2.get(Integer.valueOf(37306)),Integer.valueOf(98));
    Assert.assertEquals(map2.get(Integer.valueOf(36796)),Integer.valueOf(9));
}"
"@Test
public void testBuildDTServiceName() {
    assertEquals(""127.0.0.1:123"", SecurityUtil.buildDTServiceName(URI.create()));
    assertEquals(""127.0.0.1:123"", SecurityUtil.buildDTServiceName(URI.create()));
    assertEquals(""127.0.0.1:123"", SecurityUtil.buildDTServiceName(URI.create()));
    assertEquals(""127.0.0.1:123"", SecurityUtil.buildDTServiceName(URI.create()));
}"
"@Test
public void testWorkflowClient() throws Exception {
    String outputPath = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
    Map<String, String> runtimeArgs = ImmutableMap.of(""inputPath"", createInput(""input""),
    ""outputPath"", outputPath);
    Id.Workflow workflowId = Id.Workflow.from(appId, AppWithWorkflow.SampleWorkflow.NAME);
    programClient.start(workflowId, false, runtimeArgs);
    programClient.waitForStatus(workflowId, ""STOPPED"", 60, TimeUnit.SECONDS);
    List<RunRecord> workflowRuns = programClient.getProgramRuns(workflowId, ProgramRunStatus.COMPLETED.name(), 0,
    Long.MAX_VALUE, 10);
    Assert.assertEquals(1, workflowRuns.size());
    Id.Run workflowRunId = new Id.Run(workflowId, workflowRuns.get(0).getPid());
    try {
        workflowClient.getWorkflowToken(new Id.Run(Id.Workflow.from(appId, ""random""), workflowRunId.getId()));
        Assert.fail(""Should not find a workflow token for a non-existing workflow"");
    } catch (NotFoundException expected) {
    }
    try {
        workflowClient.getWorkflowToken(new Id.Run(workflowId, RunIds.generate().getId()));
        Assert.fail(""Should not find a workflow token for a random run id"");
    } catch (NotFoundException expected) {
    }
    WorkflowTokenDetail workflowToken = workflowClient.getWorkflowToken(workflowRunId);
    Assert.assertEquals(3, workflowToken.getTokenData().size());
    workflowToken = workflowClient.getWorkflowToken(workflowRunId, WorkflowToken.Scope.SYSTEM);
    Assert.assertTrue(workflowToken.getTokenData().size() > 0);
    workflowToken = workflowClient.getWorkflowToken(workflowRunId, ""start_time"");
    Map<String, List<WorkflowTokenDetail.NodeValueDetail>> tokenData = workflowToken.getTokenData();
    Assert.assertEquals(AppWithWorkflow.WordCountMapReduce.NAME, tokenData.get(""start_time"").get(0).getNode());
    Assert.assertTrue(Long.parseLong(tokenData.get(""start_time"").get(0).getValue()) < System.currentTimeMillis());
    workflowToken = workflowClient.getWorkflowToken(workflowRunId, WorkflowToken.Scope.USER, ""action_type"");
    tokenData = workflowToken.getTokenData();
    Assert.assertEquals(AppWithWorkflow.WordCountMapReduce.NAME, tokenData.get(""action_type"").get(0).getNode());
    Assert.assertEquals(""MapReduce"", tokenData.get(""action_type"").get(0).getValue());
    String nodeName = AppWithWorkflow.SampleWorkflow.firstActionName;
    WorkflowTokenNodeDetail workflowTokenAtNode =
    workflowClient.getWorkflowTokenAtNode(workflowRunId, nodeName);
    Assert.assertEquals(AppWithWorkflow.DummyAction.TOKEN_VALUE,
    workflowTokenAtNode.getTokenDataAtNode().get(AppWithWorkflow.DummyAction.TOKEN_KEY));
    workflowTokenAtNode = workflowClient.getWorkflowTokenAtNode(workflowRunId, nodeName, WorkflowToken.Scope.SYSTEM);
    Assert.assertEquals(0, workflowTokenAtNode.getTokenDataAtNode().size());
    workflowTokenAtNode = workflowClient.getWorkflowTokenAtNode(workflowRunId, nodeName,
    AppWithWorkflow.DummyAction.TOKEN_KEY);
    Assert.assertEquals(AppWithWorkflow.DummyAction.TOKEN_VALUE,
    workflowTokenAtNode.getTokenDataAtNode().get(AppWithWorkflow.DummyAction.TOKEN_KEY));
    String reduceOutputRecordsCounter = ""org.apache.hadoop.mapreduce.TaskCounter.REDUCE_OUTPUT_RECORDS"";
    workflowTokenAtNode = workflowClient.getWorkflowTokenAtNode(workflowRunId, AppWithWorkflow.WordCountMapReduce.NAME,
    WorkflowToken.Scope.SYSTEM, reduceOutputRecordsCounter);
    Assert.assertEquals(6, Integer.parseInt(workflowTokenAtNode.getTokenDataAtNode().get(reduceOutputRecordsCounter)));
}"
"public void test_for_issue_1() throws Exception {
    DataSimpleVO a=new DataSimpleVO(""a"",1);
    DataSimpleVO b=new DataSimpleVO(""b"",2);
    b.value1=a;
    Map<String,Object> map=new HashMap<String,Object>();
    map.put(a.name,a);
    b.value=map;
    String jsonStr=JSON.toJSONString(b,SerializerFeature.MapSortField);
    System.out.println(jsonStr);
    DataSimpleVO obj=JSON.parseObject(jsonStr,DataSimpleVO.class);
    System.out.println(obj.toString());
    assertNotNull(obj.value1);
    assertEquals(jsonStr,JSON.toJSONString(obj,SerializerFeature.MapSortField));
}"
"@Test public void testResponse1() throws Exception {
    SearchLookupResponse response=new SearchLookupResponse();
    response.setType(""LOOKUP"");
    response.setMetric(""sys.cpu.user"");
    response.putTag(""host"",""localhost"");
    response.putTag(""rack"",""r1"");
    response.setTime(1500);
    List<Result> results=new ArrayList<>();
    Result r1=new Result();
    r1.setMetric(""sys.cpu.idle"");
    r1.setTsuid(""000011000008203D00"");
    r1.putTag(""host"",""localhost"");
    r1.putTag(""rack"",""r1"");
    Result r2=new Result();
    r2.setMetric(""sys.cpu.user"");
    r2.setTsuid(""000011000008203D01"");
    r2.putTag(""host"",""localhost"");
    r2.putTag(""rack"",""r1"");
    results.add(r1);
    results.add(r2);
    response.setResults(results);
    response.setTotalResults(results.size());
    String r=JsonUtil.getObjectMapper().writeValueAsString(response);
    String expected=""{\""type\"":\""LOOKUP\"",\""metric\"":\""sys.cpu.user\"",\""tags\"":{\""host\"":\""localhost\"",\""rack\"":\""r1\""},\""limit\"":0,\""time\"":1500,\""totalResults\"":2,\""results\"":[{\""tags\"":{\""host\"":\""localhost\"",\""rack\"":\""r1\""},\""metric\"":\""sys.cpu.idle\"",\""tsuid\"":\""000011000008203D00\""},{\""tags\"":{\""host\"":\""localhost\"",\""rack\"":\""r1\""},\""metric\"":\""sys.cpu.user\"",\""tsuid\"":\""000011000008203D01\""}]}"";
    Assert.assertEquals(expected,r);
    SearchLookupResponse slr=JsonUtil.getObjectMapper().readValue(r,SearchLookupResponse.class);
    Assert.assertEquals(response,slr);
}"
"public void test_1() throws Exception {
    V1 entity=new V1();
    String text=JSON.toJSONString(entity,SerializerFeature.SortField);
    Assert.assertEquals(""{\""f1\"":0,\""f2\"":0,\""f3\"":0,\""f4\"":0,\""f5\"":0}"",text);
    JSONObject object=JSON.parseObject(text);
    text=JSON.toJSONString(object,SerializerFeature.MapSortField);
    Assert.assertEquals(""{\""f1\"":0,\""f2\"":0,\""f3\"":0,\""f4\"":0,\""f5\"":0}"",text);
}"
"@Test public void test_alter() throws Exception {
    String sql=""ALTER RESOURCE GROUP sql_thread TYPE = USER VCPU = 1,3 THREAD_PRIORITY = -20"";
    List<SQLStatement> stmtList=SQLUtils.toStatementList(sql,JdbcConstants.HIVE);
    SQLStatement stmt=stmtList.get(0);
    MySqlSchemaStatVisitor visitor=new MySqlSchemaStatVisitor();
    stmt.accept(visitor);
    String output=SQLUtils.toMySqlString(stmt);
    Set<String> allPossibleRes=generateAllPossibleRes(""ALTER RESOURCE GROUP sql_thread "");
    assertTrue(allPossibleRes.contains(output));
}"
"@Test
public void createDefaultDirectoryManagerPath() throws IOException {
    Path path = Paths.get(System.getProperty(""user.dir""));
    DirectoryManager dm = DirectoryManagerFactory.createDirectoryManager(
    path, true);
    assertTrue(dm instanceof DirectoryManagerImpl);
    DirectoryManagerImpl dmi = (DirectoryManagerImpl) dm;
    assertTrue(dmi.readOnly);
    assertEquals(path, dmi.directory);
}"
"@Test
public void testHftpDefaultPorts() throws IOException {
    resetFileSystem();
    Configuration conf = new Configuration();
    URI uri = URI.create();
    HftpFileSystem fs = ((HftpFileSystem) (FileSystem.get(uri, conf)));
    assertEquals(DFS_NAMENODE_HTTP_PORT_DEFAULT, fs.getDefaultPort());
    assertEquals(DFS_NAMENODE_HTTPS_PORT_DEFAULT, fs.getDefaultSecurePort());
    assertEquals(uri, fs.getUri());
    assertEquals(""127.0.0.1:"" + DFSConfigKeys.DFS_NAMENODE_HTTPS_PORT_DEFAULT, fs.getCanonicalServiceName());
}"
"@Test
public void testReplicaThreadedThroughputDegradationAndRejection() throws Exception {
    Settings settings = Settings.builder().put(IndexingPressure.MAX_INDEXING_BYTES.getKey(), ""10KB"")
    .put(ShardIndexingPressureSettings.SHARD_INDEXING_PRESSURE_ENABLED.getKey(), true)
    .put(ShardIndexingPressureSettings.SHARD_INDEXING_PRESSURE_ENFORCED.getKey(), true)
    .put(ShardIndexingPressureMemoryManager.THROUGHPUT_DEGRADATION_LIMITS.getKey(), 1)
    .put(ShardIndexingPressureSettings.REQUEST_SIZE_WINDOW.getKey(), 100)
    .build();
    final int NUM_THREADS = scaledRandomIntBetween(100, 120);
    ShardIndexingPressure shardIndexingPressure = new ShardIndexingPressure(settings, clusterService);
    Index index = new Index(""IndexName"", ""UUID"");
    ShardId shardId1 = new ShardId(index, 0);
    fireConcurrentAndParallelRequestsForUniformThroughPut(NUM_THREADS, shardIndexingPressure, shardId1, 100, 100,
    OperationType.REPLICA);
    fireAllThenCompleteConcurrentRequestsWithUniformDelay(ShardIndexingPressureSettings.REQUEST_SIZE_WINDOW.get(settings),
    shardIndexingPressure, shardId1, 100, 200, OperationType.REPLICA);
    expectThrows(OpenSearchRejectedExecutionException.class,
    () -> shardIndexingPressure.markReplicaOperationStarted(shardId1, 11 * 1024, false));
    assertEquals(0, shardIndexingPressure.coldStats().getIndexingPressureShardStats(shardId1).getCurrentReplicaBytes());
    assertEquals(15, shardIndexingPressure.coldStats().getIndexingPressureShardStats(shardId1).getCurrentReplicaLimits());
}"
"@Test public void onlyTrumpsAlso() throws Exception {
    assertThat(testResult(OnlyTrumpsAlso.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),OnlyTrumpsAlso.iterations);
    OnlyTrumpsAlso.iterations=0;
}"
"@Test
public synchronized void testLockExpiration() throws RepositoryException, NotExecutableException {
    lockedNode.unlock();
    long hint = 1;
    lock = lockMgr.lock(lockedNode.getPath(), isDeep(), isSessionScoped(), hint, null);
    long remaining = lock.getSecondsRemaining();
    if (remaining <= hint) {
        try {
            wait(remaining * 2000);
        } catch (InterruptedException ignore) {
        }
        long secs = lock.getSecondsRemaining();
        assertTrue(""A released lock must return a negative number of seconds, was: "" + secs, secs < 0);
        String message = ""If the timeout hint is respected the lock"" + "" must be automatically released."";
        assertFalse(message, lock.isLive());
        assertFalse(message, lockedNode.isLocked());
        assertFalse(message, lockMgr.isLocked(lockedNode.getPath()));
        assertFalse(message, lockedNode.hasProperty(JCR_LOCK_IS_DEEP));
        assertFalse(message, lockedNode.hasProperty(JCR_LOCK_OWNER));
    } else {
        throw new NotExecutableException(""timeout hint was ignored."");
    }
}"
"@Test public void wrapperDoubles() throws Exception {
    assertThat(testResult(WrapperDoubles.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperDoubles.iterations);
    assertEquals(new HashSet<>(asList(2.7,-3.14)),new HashSet<>(WrapperDoubles.values.subList(0,2)));
    WrapperDoubles.iterations=0;
}"
"@Test
public void testQueryTimeout()
throws Exception
{
    try (Connection connection = createConnection(""blackhole"", ""blackhole"");
    Statement statement = connection.createStatement()) {
        statement.executeUpdate(""CREATE TABLE test_query_timeout (key BIGINT) "" +
        ""WITH ("" +
        ""   split_count = 1, "" +
        ""   pages_per_split = 1, "" +
        ""   rows_per_page = 1, "" +
        ""   page_processing_delay = '1m'"" +
        "")"");
    }
    CountDownLatch queryFinished = new CountDownLatch(1);
    AtomicReference<Throwable> queryFailure = new AtomicReference<>();
    executorService.submit(() -> {
        try (Connection connection = createConnection(""blackhole"", ""default"");
        Statement statement = connection.createStatement()) {
            statement.setQueryTimeout(1);
            try (ResultSet resultSet = statement.executeQuery(""SELECT * FROM test_query_timeout"")) {
                try {
                    resultSet.next();
                }
                catch (SQLException t) {
                    queryFailure.set(t);
                }
                finally {
                    queryFinished.countDown();
                }
            }
        }
        return null;
    });
    assertTrue(queryFinished.await(2, SECONDS));
    assertNotNull(queryFailure.get());
    assertContains(queryFailure.get().getMessage(), ""Query exceeded maximum time limit of 1.00s"");
    try (Connection connection = createConnection(""blackhole"", ""blackhole"");
    Statement statement = connection.createStatement()) {
        statement.executeUpdate(""DROP TABLE test_query_timeout"");
    }
}"
"@Test
public void testUpdatePerOperationSamplerUpdatesExistingPerOperationSampler() throws Exception {
    PerOperationSampler perOperationSampler = mock(PerOperationSampler.class);
    OperationSamplingParameters parameters = mock(OperationSamplingParameters.class);
    when(samplingManager.getSamplingStrategy(SERVICE_NAME)).thenReturn(
    new SamplingStrategyResponse(null, null, parameters));
    undertest = new RemoteControlledSampler(SERVICE_NAME, samplingManager, perOperationSampler, metrics);
    undertest.updateSampler();
    Thread.sleep(20);
    verify(perOperationSampler, times(2)).update(parameters);
}"
"@Test public void testAdditionalModelTypeAnnotationsNewLineWindows() throws Exception {
    OpenAPI openAPI=TestUtils.createOpenAPI();
    final AbstractJavaCodegen codegen=new P_AbstractJavaCodegen();
    codegen.additionalProperties().put(AbstractJavaCodegen.ADDITIONAL_MODEL_TYPE_ANNOTATIONS,""@Foo\r\n@Bar"");
    codegen.processOpts();
    codegen.preprocessOpenAPI(openAPI);
    final List<String> additionalModelTypeAnnotations=new ArrayList<String>();
    additionalModelTypeAnnotations.add(""@Foo"");
    additionalModelTypeAnnotations.add(""@Bar"");
    final List<String> sortedCodegenAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    final List<String> sortedAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    Collections.sort(sortedCodegenAdditionalModelTypeAnnotations);
    Collections.sort(sortedAdditionalModelTypeAnnotations);
    Assert.assertEquals(sortedCodegenAdditionalModelTypeAnnotations,sortedAdditionalModelTypeAnnotations);
}"
"@Test public void assertPersistSequential() throws Exception {
    assertThat(zkRegCenter.persistSequential(""/sequential/test_sequential"",""test_value""),startsWith(""/sequential/test_sequential""));
    assertThat(zkRegCenter.persistSequential(""/sequential/test_sequential"",""test_value""),startsWith(""/sequential/test_sequential""));
    CuratorFramework client=CuratorFrameworkFactory.newClient(EmbedTestingServer.getConnectionString(),new RetryOneTime(2000));
    client.start();
    client.blockUntilConnected();
    List<String> actual=client.getChildren().forPath(""/"" + ZookeeperRegistryCenterModifyTest.class.getName() + ""/sequential"");
    assertThat(actual.size(),is(2));
    for (  String each : actual) {
        assertThat(each,startsWith(""test_sequential""));
        assertThat(zkRegCenter.get(""/sequential/"" + each),startsWith(""test_value""));
    }
    zkRegCenter.remove(""/sequential"");
    assertFalse(zkRegCenter.isExisted(""/sequential""));
}"
"@Test
public void outerInnerErrorRace() {
    for (int i = 0; i < 500; i++) {
        List<Throwable> errors = TestHelper.trackPluginErrors();
        try {
            final PublishSubject<Integer> ps1 = PublishSubject.create();
            final PublishSubject<Integer> ps2 = PublishSubject.create();
            ps1.switchMap(new Function<Integer, ObservableSource<Integer>>() {
                @Override
                public ObservableSource<Integer> apply(Integer v) throws Exception {
                    if (v == 1) {
                        return ps2;
                    }
                    return Observable.never();
                }
            })
            .test();
            final TestException ex1 = new TestException();
            Runnable r1 = new Runnable() {
                @Override
                public void run() {
                    ps1.onError(ex1);
                }
            };
            final TestException ex2 = new TestException();
            Runnable r2 = new Runnable() {
                @Override
                public void run() {
                    ps2.onError(ex2);
                }
            };
            TestHelper.race(r1, r2);
            for (Throwable e : errors) {
                assertTrue(e.toString(), e instanceof TestException);
            }
        } finally {
            RxJavaPlugins.reset();
        }
    }
}"
"public void test_reserve() throws Exception {
    JSONObject object=JSON.parseObject(""{\""id\"":1001,\""name\"":\""ljw\"",\""age\"":50}"");
    assertEquals(""[1001,\""ljw\""]"",JSONPath.reserveToArray(object,""id"",""name"").toString());
    assertEquals(""[\""ljw\"",1001]"",JSONPath.reserveToArray(object,""name"",""id"").toString());
    String text=JSON.toJSONString(JSONPath.reserveToArray(object,""name"",""*""),SerializerFeature.MapSortField);
    assertTrue(text.equals(""[\""ljw\"",[\""ljw\"",1001,50]]"") || text.equals(""[\""ljw\"",[\""ljw\"",50,1001]]"") || text.equals(""[\""ljw\"",[50,1001,\""ljw\""]]"")|| text.equals(""[\""ljw\"",[1001,50,\""ljw\""]]"")|| text.equals(""[\""ljw\"",[1001,\""ljw\"",50]]"")|| text.equals(""[\""ljw\"",[50,\""ljw\"",1001]]""));
}"
"@Test
public void testExpiredRequestAllocationOnAnyHost() throws Exception {
    MockClusterResourceManager spyManager = spy(new MockClusterResourceManager(callback, state));
    ContainerManager spyContainerManager = spy(new ContainerManager(containerPlacementMetadataStore, state, spyManager, true, false, mock(LocalityManager.class), faultDomainManager, config));
    spyAllocator = Mockito.spy(new ContainerAllocator(spyManager, config, state, true, spyContainerManager));
    spyAllocator.requestResources(new HashMap<String, String>() {
        {
            put(""0"", ""hostname-0"");
            put(""1"", ""hostname-1"");
        }
    });
    spyAllocatorThread = new Thread(spyAllocator);
    spyAllocatorThread.start();
    Thread.sleep(1000);
    assertTrue(state.preferredHostRequests.get() == 2);
    assertTrue(state.expiredPreferredHostRequests.get() == 2);
    verify(spyContainerManager, times(1)).handleExpiredRequest(eq(""0""), eq(""hostname-0""), any(SamzaResourceRequest.class), any(ContainerAllocator.class), any(ResourceRequestState.class));
    verify(spyContainerManager, times(1)).handleExpiredRequest(eq(""1""), eq(""hostname-1""), any(SamzaResourceRequest.class), any(ContainerAllocator.class), any(ResourceRequestState.class));
    ArgumentCaptor<SamzaResourceRequest> cancelledRequestCaptor = ArgumentCaptor.forClass(SamzaResourceRequest.class);
    verify(spyManager, atLeast(2)).cancelResourceRequest(cancelledRequestCaptor.capture());
    assertTrue(cancelledRequestCaptor.getAllValues().stream().map(( resourceRequest) -> resourceRequest.getPreferredHost()).collect(Collectors.toSet()).size() > 2);
    assertTrue(state.matchedResourceRequests.get() == 0);
    assertTrue(state.anyHostRequests.get() > 2);
    spyAllocator.stop();
}"
"@Test public void test_2() throws Exception {
    String sql=""create database test_cascade for 'ALIYUN$test@aliyun.com' options(resourceType=ecu ecu_type=c1 ecu_count=2)"";
    MySqlStatementParser parser=new MySqlStatementParser(sql);
    SQLStatement stmt=parser.parseStatement();
    String output=SQLUtils.toMySqlString(stmt);
    Set<String> allPossibleRes=generateAllPossibleRes();
    assertTrue(allPossibleRes.contains(output));
}"
"@Test
public void testHftpCustomUriPortWithDefaultPorts() throws IOException {
    resetFileSystem();
    Configuration conf = new Configuration();
    URI uri = URI.create() ;
    HftpFileSystem fs = ((HftpFileSystem) (FileSystem.get(uri, conf)));
    assertEquals(DFS_NAMENODE_HTTP_PORT_DEFAULT, fs.getDefaultPort());
    assertEquals(DFS_NAMENODE_HTTPS_PORT_DEFAULT, fs.getDefaultSecurePort());
    assertEquals(uri, fs.getUri());
    assertEquals(""127.0.0.1:"" + DFSConfigKeys.DFS_NAMENODE_HTTPS_PORT_DEFAULT, fs.getCanonicalServiceName());
}"
"@Test
public void assertGetLocalFailoverItemsIfShutdown() {
    assertThat(failoverService.getLocalFailoverItems(), is(Collections.<Integer>emptyList()));
    verify(jobNodeStorage, times(0)).getJobNodeChildrenKeys(""sharding"");
}"
"@Test
public void earlyUnstableStatusShouldReportPunStateAsRunningAndResultAsUnknown() throws Exception {
    WorkflowJob p = j.createProject(WorkflowJob.class, ""project"");
    URL resource = Resources.getResource(getClass(), ""earlyUnstableStatusShouldReportPunStateAsRunningAndResultAsUnknown.jenkinsfile"");
    String jenkinsFile = Resources.toString(resource, Charsets.UTF_8);
    p.setDefinition(new CpsFlowDefinition(jenkinsFile, true));
    p.save();
    Run r = p.scheduleBuild2(0).waitForStart();
    String url = ""/organizations/jenkins/pipelines/project/runs/"" + r.getId() + ""/"";
    Map m = request().get(url).build(Map.class);
    j.waitForMessage(""Running on master"", r);
    while (!""FINISHED"".equals(m.get(""state"").toString())) {
        Assert.assertEquals(""RUNNING"", m.get(""state""));
        Assert.assertEquals(""UNKNOWN"", m.get(""result""));
        Thread.sleep(1000);
        m = request().get(url).build(Map.class);
    }
    Assert.assertEquals(""FINISHED"", m.get(""state""));
    Assert.assertEquals(""UNSTABLE"", m.get(""result""));
}"
"@Test
public void testListenerFailures() throws InterruptedException {
    int iters = iterations(10, 100);
    for (int i = 0; i < iters; i++) {
        try (TestIteration iteration = new TestIteration()) {
            iteration.transport.endConnectMode();
            final CountDownLatch latch = new CountDownLatch(1);
            final AtomicInteger finalFailures = new AtomicInteger();
            final AtomicReference<Throwable> finalFailure = new AtomicReference<>();
            final AtomicReference<TestResponse> response = new AtomicReference<>();
            ActionListener<TestResponse> actionListener = new ActionListener<TestResponse>();
            final AtomicInteger preSendFailures = new AtomicInteger();
            iteration.transportClientNodesService.execute((node, retryListener) -> {
                if (rarely()) {
                    preSendFailures.incrementAndGet();
                    throw new IllegalArgumentException();
                }
                iteration.transportService.sendRequest(node, ""action"", new TestRequest(),
                TransportRequestOptions.EMPTY, new TransportResponseHandler<TestResponse>() {
                }, actionListener);
                assertThat(latch.await(1, TimeUnit.SECONDS), equalTo(true));
                assertThat(preSendFailures.get() + iteration.transport.failures() + iteration.transport.successes(), lessThanOrEqualTo(1));
                if (iteration.transport.successes() == 1) {
                    assertThat(finalFailures.get(), equalTo(0));
                    assertThat(finalFailure.get(), nullValue());
                    assertThat(response.get(), notNullValue());
                } else {
                    assertThat(finalFailures.get(), equalTo(1));
                    assertThat(finalFailure.get(), notNullValue());
                    assertThat(response.get(), nullValue());
                    if (preSendFailures.get() == 0 && iteration.transport.failures() == 0) {
                        assertThat(finalFailure.get(), instanceOf(NoNodeAvailableException.class));
                    }
                }
                assertThat(iteration.transport.triedNodes().size(), lessThanOrEqualTo(iteration.listNodesCount));
                assertThat(iteration.transport.triedNodes().size(), equalTo(iteration.transport.connectTransportExceptions() + iteration.transport.failures() + iteration.transport.successes()));
            });
        }
    }
}"
"@Test
public void serverStatusUnthrottledIfJournalUtilizationIsLowerThanThreshold() throws Exception {
    serverStatus.throttle();
    final Size segmentSize = Size.kilobytes(1L);
    final KafkaJournal journal = new KafkaJournal(journalDirectory, scheduler, segmentSize, Duration.standardSeconds(1L), Size.kilobytes(4L), Duration.standardSeconds(1L), 1000000, Duration.standardSeconds(1L), 90, new MetricRegistry(), serverStatus);
    journal.flushDirtyLogs();
    journal.cleanupLogs();
    assertThat(serverStatus.getLifecycle()).isEqualTo(RUNNING);
}"
"@Test public void wrapperBytes(){
    assertThat(testResult(WrapperBytes.class),isSuccessful());
    assertEquals(2,WrapperBytes.iterations);
    assertEquals(new HashSet<>(asList(Byte.valueOf(""14""),Byte.valueOf(""-15""))),WrapperBytes.testCases);
    WrapperBytes.iterations=0;
}"
"@Test public void testJSONMap(){
    Map<Object,Object> map=new LinkedHashMap<>();
    map.put(1,""bar"");
    map.put(""foo"",2);
    assertEquals(""[\""A\"",{\""1\"":\""bar\"",\""foo\"":2},\""B\""]"",TextUtils.joinJSON(Arrays.asList(""A"",map,""B"")));
}"
"@Test
public void testWritesWhileGetting() throws IOException, InterruptedException {
    byte[] tableName = Bytes.toBytes(""testWritesWhileScanning"");
    int testCount = 100;
    int numRows = 1;
    int numFamilies = 10;
    int numQualifiers = 100;
    int flushInterval = 10;
    int compactInterval = 10 * flushInterval;
    byte[][] families = new byte[numFamilies][];
    for (int i = 0; i < numFamilies; i++) {
        families[i] = Bytes.toBytes(""family"" + i);
    }
    byte[][] qualifiers = new byte[numQualifiers][];
    for (int i = 0; i < numQualifiers; i++) {
        qualifiers[i] = Bytes.toBytes(""qual"" + i);
    }
    String method = ""testWritesWhileScanning"";
    initHRegion(tableName, method, families);
    PutThread putThread = new PutThread(numRows, families, qualifiers);
    putThread.start();
    FlushThread flushThread = new FlushThread();
    flushThread.start();
    Get get = new Get(Bytes.toBytes(""row0""));
    Result result = null;
    int expectedCount = numFamilies * numQualifiers;
    long prevTimestamp = 0L;
    for (int i = 0; i < testCount; i++) {
        if ((i != 0) && ((i % compactInterval) == 0)) {
            region.compactStores(true);
        }
        if ((i != 0) && ((i % flushInterval) == 0)) {
            flushThread.flush();
        }
        boolean previousEmpty = (result == null) || result.isEmpty();
        result = region.get(get, null);
        if (((!result.isEmpty()) || (!previousEmpty)) || (i > compactInterval)) {
            assertEquals(""i="" + i, expectedCount, result.size());
            long timestamp = 0;
            for (KeyValue kv : result.sorted()) {
                if (Bytes.equals(kv.getFamily(), families[0]) && Bytes.equals(kv.getQualifier(), qualifiers[0])) {
                    timestamp = kv.getTimestamp();
                }
            }
            assertTrue(timestamp >= prevTimestamp);
            prevTimestamp = timestamp;
            byte[] gotValue = null;
            for (KeyValue kv : result.raw()) {
                byte[] thisValue = kv.getValue();
                if (gotValue != null) {
                    assertEquals(gotValue, thisValue);
                }
                gotValue = thisValue;
            }
        }
    }
    putThread.done();
    region.flushcache();
    putThread.join();
    putThread.checkNoError();
    flushThread.done();
    flushThread.join();
    flushThread.checkNoError();
}"
"@Test public void indexesCreated(){
    QueryService queryService=gemfireCache.getQueryService();
    List<String> expectedDefinedIndexNames=Arrays.asList(id.getName(),birthDate.getName(),name.getName());
    expectedDefinedIndexNames.sort((a,b) -> (a.compareTo(b)));
    definedIndexNames.sort((a,b) -> (a.compareTo(b)));
    assertThat(definedIndexNames).isEqualTo(expectedDefinedIndexNames);
    assertThat(id).isEqualTo(queryService.getIndex(people,id.getName()));
    assertThat(birthDate).isEqualTo(queryService.getIndex(people,birthDate.getName()));
    assertThat(lastName).isEqualTo(queryService.getIndex(people,lastName.getName()));
    assertThat(name).isEqualTo(queryService.getIndex(people,name.getName()));
}"
"@Test
public void testGeneratedBlock() throws Exception {
    LOG.info(""Test testGeneratedBlock started."");
    long blockSize = 8192L;
    int stripeLength = 3;
    mySetup(stripeLength, -1);
    Path file1 = new Path(""/user/dhruba/raidtest/file1"");
    Path destPath = new Path(""/destraid/user/dhruba/raidtest"");
    long crc1 = TestRaidDfs.createTestFile(fileSys, file1, 1, 7, blockSize);
    long file1Len = fileSys.getFileStatus(file1).getLen();
    LOG.info(""Test testGeneratedBlock created test files"");
    Configuration localConf = new Configuration(conf);
    localConf.set(RAID_LOCATION_KEY, ""/destraid"");
    localConf.setInt(""raid.blockfix.interval"", 1000);
    localConf.setLong(""raid.blockfix.filespertask"", 2L);
    try {
        cnode = RaidNode.createRaidNode(null, localConf);
        TestRaidDfs.waitForFileRaided(LOG, fileSys, file1, destPath);
        cnode.stop();
        cnode.join();
        FileStatus srcStat = fileSys.getFileStatus(file1);
        DistributedFileSystem dfs = ((DistributedFileSystem) (fileSys));
        LocatedBlocks locs = RaidDFSUtil.getBlockLocations(dfs, file1.toUri().getPath(), 0, srcStat.getLen());
        String[] corruptFiles = RaidDFSUtil.getCorruptFiles(conf);
        assertEquals(corruptFiles.length, 0);
        assertEquals(0, cnode.blockFixer.filesFixed());
        corruptBlock(locs.get(0).getBlock().getBlockName());
        reportCorruptBlocks(dfs, file1, new int[]{ 0 }, blockSize);
        corruptFiles = RaidDFSUtil.getCorruptFiles(conf);
        assertEquals(corruptFiles.length, 1);
        assertEquals(corruptFiles[0], file1.toUri().getPath());
        cnode = RaidNode.createRaidNode(null, localConf);
        long start = System.currentTimeMillis();
        while ((cnode.blockFixer.filesFixed() < 1) && ((System.currentTimeMillis() - start) < 120000)) {
            LOG.info(""Test testGeneratedBlock waiting for files to be fixed."");
            Thread.sleep(1000);
        }
        assertEquals(1, cnode.blockFixer.filesFixed());
        cnode.stop();
        cnode.join();
        cnode = null;
        dfs = getDFS(conf, dfs);
        assertTrue(TestRaidDfs.validateFile(dfs, file1, file1Len, crc1));
        locs = RaidDFSUtil.getBlockLocations(dfs, file1.toUri().getPath(), 0, srcStat.getLen());
        corruptBlock(locs.get(0).getBlock().getBlockName());
        reportCorruptBlocks(dfs, file1, new int[]{ 0 }, blockSize);
        try {
            Thread.sleep(5 * 1000);
        } catch (InterruptedException ignore) {
        }
        try {
            TestRaidDfs.validateFile(dfs, file1, file1Len, crc1);
            fail(""Expected exception not thrown"");
        } catch (ChecksumException ce) {
        } catch (BlockMissingException bme) {
        }
    } catch (Exception e) {
        LOG.info((""Test testGeneratedBlock Exception "" + e) + StringUtils.stringifyException(e));
        throw e;
    } finally {
        myTearDown();
    }
    LOG.info(""Test testGeneratedBlock completed."");
}"
"@Test
public void giteeSample() throws Exception {
    Map<String, Object> value = new ObjectMapper().readValue(new ClassPathResource(""pathsamples/gitee.json"").getInputStream(), new TypeReference<Map<String, Object>>() {});
    this.headers.set(""x-git-oschina-event"", ""Push Hook"");
    PropertyPathNotification extracted = this.extractor.extract(this.headers, value);
    assertThat(extracted).isNotNull();
    assertThat(extracted.getPaths()[0]).isEqualTo(""d.txt"");
}"
"public void test_for_issue() throws Exception {
    HashSet<Map.Entry<String,Map.Entry<String,String>>> nestedSet=new HashSet<Map.Entry<String,Map.Entry<String,String>>>();
    nestedSet.add(new AbstractMap.SimpleEntry<String,Map.Entry<String,String>>(""a"",new AbstractMap.SimpleEntry<String,String>(""b"",""c"")));
    nestedSet.add(new AbstractMap.SimpleEntry<String,Map.Entry<String,String>>(""d"",new AbstractMap.SimpleEntry<String,String>(""e"",""f"")));
    String content=JSON.toJSONString(nestedSet);
    HashSet<Map.Entry<String,Map.Entry<String,String>>> deserializedNestedSet;
    Type type=new TypeReference<HashSet<Map.Entry<String,Map.Entry<String,String>>>>(){
    }
    .getType();
    deserializedNestedSet=JSON.parseObject(content,type);
    assertEquals(nestedSet,deserializedNestedSet);
}"
"@Test public void acrossParametersOfSameParameterizedTypeWithOneConstant() throws Exception {
    assertThat(testResult(ParametersOfSameParameterizedTypeWithOneConstant.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ParametersOfSameParameterizedTypeWithOneConstant.iterations);
    ParametersOfSameParameterizedTypeWithOneConstant.iterations=0;
}"
"@Test
public void socketTest() throws Exception {
    URI consumeUri = URI.create(CONSUME_URI);
    URI produceUri = URI.create(PRODUCE_URI);
    WebSocketClient consumeClient = new WebSocketClient();
    SimpleConsumerSocket consumeSocket = new SimpleConsumerSocket();
    WebSocketClient produceClient = new WebSocketClient();
    SimpleProducerSocket produceSocket = new SimpleProducerSocket();
    try {
        consumeClient.start();
        ClientUpgradeRequest consumeRequest = new ClientUpgradeRequest();
        Future<Session> consumerFuture = consumeClient.connect(consumeSocket, consumeUri, consumeRequest);
        log.info(""Connecting to : {}"", consumeUri);
        ClientUpgradeRequest produceRequest = new ClientUpgradeRequest();
        produceClient.start();
        Future<Session> producerFuture = produceClient.connect(produceSocket, produceUri, produceRequest);
        Thread.sleep(1000);
        Assert.assertTrue(consumerFuture.get().isOpen());
        Assert.assertTrue(producerFuture.get().isOpen());
        consumeSocket.awaitClose(1, TimeUnit.SECONDS);
        produceSocket.awaitClose(1, TimeUnit.SECONDS);
        Assert.assertTrue(produceSocket.getBuffer().size() > 0);
        Assert.assertEquals(produceSocket.getBuffer(), consumeSocket.getBuffer());
    } finally {
        try {
            consumeClient.stop();
            produceClient.stop();
        } catch (Exception e) {
            log.error(e.getMessage());
        }
    }
}"
"public void test_for_issue(){
    Issue2428 demoBean=new Issue2428();
    demoBean.setMyName(""test name"");
    demoBean.setNestedBean(new NestedBean(""test id""));
    String text=JSON.toJSONString(JSON.toJSON(demoBean),SerializerFeature.MapSortField);
    assertEquals(""{\""myName\"":\""test name\"",\""nestedBean\"":{\""myId\"":\""test id\""}}"",text);
    SerializeConfig serializeConfig=new SerializeConfig();
    serializeConfig.propertyNamingStrategy=PropertyNamingStrategy.SnakeCase;
    text=JSON.toJSONString(JSON.toJSON(demoBean,serializeConfig),SerializerFeature.MapSortField);
    assertEquals(""{\""my_name\"":\""test name\"",\""nested_bean\"":{\""my_id\"":\""test id\""}}"",text);
}"
"@Test
public void testMenuInvalidationAfterDestroy() throws Throwable {
    final A activity = getActivity();
    getInstrumentation().runOnMainSync(new Runnable() {
        @Override
        public void run() {
            activity.reset();
            assertNull(activity.getMenu());
            activity.supportInvalidateOptionsMenu();
            getInstrumentation().callActivityOnDestroy(activity);
        }
    });
    Thread.sleep(100);
    assertNull(activity.getMenu());
}"
"@Test public void test_AddExtension_NoExtend() throws Exception {
    getExtensionLoader(Ext9Empty.class).addExtension(""ext9"",Ext9EmptyImpl.class);
    Ext9Empty ext=getExtensionLoader(Ext9Empty.class).getExtension(""ext9"");
    assertThat(ext,instanceOf(Ext9Empty.class));
    assertEquals(""ext9"",getExtensionLoader(Ext9Empty.class).getExtensionName(Ext9EmptyImpl.class));
    ExtensionLoader.resetExtensionLoader(Ext9Empty.class);
}"
"@Test public void orderingOfStatements(){
    assertThat(testResult(PropertyBasedTests.class),isSuccessful());
    assertEquals(expectedStatements,PropertyBasedTests.LOGS);
    PropertyBasedTests.clearLogs();
}"
"@Test
public void testRetryWithBackpressure() throws InterruptedException {
    final int NUM_RETRIES = RxRingBuffer.SIZE * 2;
    for (int i = 0; i < 400; i++) {
        @SuppressWarnings(""unchecked"")
        Observer<String> observer = mock(Observer.class);
        Observable<String> origin = Observable.create(new FuncWithErrors(NUM_RETRIES));
        TestSubscriber<String> ts = new TestSubscriber<String>(observer);
        origin.retry().observeOn(Schedulers.computation()).unsafeSubscribe(ts);
        ts.awaitTerminalEvent(5, TimeUnit.SECONDS);
        InOrder inOrder = inOrder(observer);
        verify(observer, never()).onError(any(Throwable.class));
        inOrder.verify(observer, times(NUM_RETRIES + 1)).onNext(""beginningEveryTime"");
        inOrder.verify(observer, times(1)).onNext(""onSuccessOnly"");
        inOrder.verify(observer, times(1)).onCompleted();
        inOrder.verifyNoMoreInteractions();
    }
}"
"@Test public void voidParameter() throws Exception {
    assertThat(testResult(VoidParameter.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),VoidParameter.iterations);
    VoidParameter.iterations=0;
}"
"@Test
void canOffsetMutableClock() {
    final var offset = Duration.ofMinutes(10);
    final var response = endpoint.modify(""add"", null, offset.toMillis());
    final var offsetMinimum = Instant.now().plus(offset).truncatedTo(ChronoUnit.MILLIS);
    final var offsetMaximum = Instant.now().plus(offset.plus(Duration.ofMinutes(1)));
    assertThat(response.getStatus()).isEqualTo(200);
    assertThat(response.getBody()).isNotNull().asInstanceOf(instanceOfRecord).satisfies(( body) -> assertThat(body.instant).isBetween(offsetMinimum, offsetMaximum));
}"
"@Test public void canSerializeAdditionalProperties() throws Exception {
    Foo foo=new Foo();
    foo.bar=""hello.world"";
    foo.baz=new ArrayList<>();
    foo.baz.add(""hello"");
    foo.baz.add(""hello.world"");
    foo.qux=new HashMap<>();
    foo.qux.put(""hello"",""world"");
    foo.qux.put(""a.b"",""c.d"");
    foo.qux.put(""bar.a"",""ttyy"");
    foo.qux.put(""bar.b"",""uuzz"");
    foo.additionalProperties=new HashMap<>();
    foo.additionalProperties.put(""bar"",""baz"");
    foo.additionalProperties.put(""a.b"",""c.d"");
    foo.additionalProperties.put(""properties.bar"",""barbar"");
    String serialized=new JacksonAdapter().serialize(foo);
    String expected=""{\""$type\"":\""foo\"",\""properties\"":{\""bar\"":\""hello.world\"",\""props\"":{\""baz\"":[\""hello\"",\""hello.world\""],\""q\"":{\""qux\"":{\""hello\"":\""world\"",\""a.b\"":\""c.d\"",\""bar.b\"":\""uuzz\"",\""bar.a\"":\""ttyy\""}}}},\""bar\"":\""baz\"",\""a.b\"":\""c.d\"",\""properties.bar\"":\""barbar\""}"";
    assertJsonEqualsNonStrict(expected,serialized);
}"
"@Test
public void testRender_ok() {
    final Mock mockResponse = mock(RenderResponse.class);
    mockResponse.stubs().method(ANYTHING);
    PortletMode mode = PortletMode.VIEW;
    Map<String, String[]> requestParams = new HashMap<String, String[]>();
    requestParams.put(ACTION_PARAM, new String[] { ""/view/testAction"" });
    requestParams.put(EVENT_ACTION, new String[] { ""true"" });
    requestParams.put(MODE_PARAM, new String[] { mode.toString() });
    Map<String, Object> sessionMap = new HashMap<String, Object>();
    Map<String, String> initParams = new HashMap<String, String>();
    initParams.put(""viewNamespace"", ""/view"");
    initParams.put(StrutsConstants.STRUTS_ALWAYS_SELECT_FULL_NAMESPACE,
    ""true"");
    initPortletConfig(initParams, new HashMap<String, Object>());
    initRequest(requestParams, new HashMap<String, Object>(), sessionMap,
    PortletMode.VIEW, WindowState.NORMAL, false, null);
    setupActionFactory(""/view"", ""testAction"", ""success"",
    EasyMock.createNiceMock(ValueStack.class));
    mockInvocation.expects(once()).method(""getStack"")
    .will(returnValue(null));
    try {
        dispatcher
        .setActionProxyFactory((ActionProxyFactory) mockActionFactory
        .proxy());
        dispatcher.init((PortletConfig) mockConfig.proxy());
        dispatcher.render((RenderRequest) mockRequest.proxy(),
        (RenderResponse) mockResponse.proxy());
    } catch (Exception e) {
        e.printStackTrace();
        fail(""Error occured"");
    }
}"
"@Test
public void testProxy() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
    Queue<String> output = ExamplesTestUtil.runClientInMockedEnvironment(ProxyClient.class);
    HttpResponse expectedHeader = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
    expectedHeader.headers().add(((CharSequence) (""X-Proxied-By"")), ""RxNetty"");
    expectedHeader.headers().add(TRANSFER_ENCODING, CHUNKED);
    String expectedHeaderString = HttpMessageFormatter.formatResponse(expectedHeader.protocolVersion(), expectedHeader.status(), expectedHeader.headers().iteratorCharSequence());
    assertThat(""Unexpected number of messages echoed"", output, hasSize(2));
    assertThat(""Unexpected response."", output, contains(expectedHeaderString, ""HelloWorld!""));
}"
"@Test public void testMwMostRecentFullDumpFileProcessing() throws IOException {
    Path dmPath=Paths.get(System.getProperty(""user.dir""));
    MockDirectoryManager dm=new MockDirectoryManager(dmPath,true,true);
    mockLocalDumpFile(""20140418"",2,DumpContentType.FULL,dm);
    DumpProcessingController dpc=new DumpProcessingController(""wikidatawiki"");
    dpc.downloadDirectoryManager=dm;
    dpc.setOfflineMode(true);
    StatisticsMwRevisionProcessor mwrpStats=new StatisticsMwRevisionProcessor(""stats"",2);
    dpc.registerMwRevisionProcessor(mwrpStats,null,false);
    dpc.processMostRecentMainDump();
    assertEquals(9,mwrpStats.getTotalRevisionCount());
    assertEquals(9,mwrpStats.getCurrentRevisionCount());
}"
"@Test public void wrapperChars(){
    assertThat(testResult(WrapperChars.class),isSuccessful());
    assertEquals(23,WrapperChars.iterations);
    assertEquals(new HashSet<>(asList('@','#')),new HashSet<>(WrapperChars.values.subList(0,2)));
    WrapperChars.iterations=0;
}"
"@Test public void wrapperFloats() throws Exception {
    assertThat(testResult(WrapperFloats.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperFloats.iterations);
    WrapperFloats.iterations=0;
}"
"@Test
public void testFireMultiLevelEvent() throws Exception {
    final NamingEventCoordinator coordinator = new NamingEventCoordinator();
    final CollectingListener subtreeListener = new CollectingListener(1);
    coordinator.addListener(""foo"", EventContext.SUBTREE_SCOPE, subtreeListener);
    final CollectingListener subtreeListenerTwo = new CollectingListener(1);
    coordinator.addListener(""foo/bar"", EventContext.SUBTREE_SCOPE, subtreeListenerTwo);
    final CollectingListener subtreeListenerThree = new CollectingListener(1);
    coordinator.addListener(""foo/bar/baz"", EventContext.SUBTREE_SCOPE, subtreeListenerThree);
    coordinator.fireEvent(context, new CompositeName(""foo/bar/baz/boo""), null, null, NamingEvent.OBJECT_ADDED, ""bind"", EventContext.OBJECT_SCOPE, EventContext.ONELEVEL_SCOPE, EventContext.SUBTREE_SCOPE);
    subtreeListener.latch.await(1, TimeUnit.SECONDS);
    subtreeListenerTwo.latch.await(1, TimeUnit.SECONDS);
    subtreeListenerThree.latch.await(1, TimeUnit.SECONDS);
    assertEquals(1, subtreeListener.capturedEvents.size());
    assertEquals(1, subtreeListenerTwo.capturedEvents.size());
    assertEquals(1, subtreeListenerThree.capturedEvents.size());
}"
"@Test public void testAsync(){
    RpcContext rpcContext=RpcContext.getContext();
    Assertions.assertFalse(rpcContext.isAsyncStarted());
    AsyncContext asyncContext=RpcContext.startAsync();
    Assertions.assertTrue(rpcContext.isAsyncStarted());
    asyncContext.write(new Object());
    Assertions.assertTrue(((AsyncContextImpl)asyncContext).getInternalFuture().isDone());
    rpcContext.stopAsync();
    Assertions.assertTrue(rpcContext.isAsyncStarted());
    RpcContext.removeContext();
}"
"@Test
public void testPriorityReadOnlyCancelsReaders() throws Exception {
    Thread.interrupted();
    XtextDocument document = new XtextDocument(createTokenSource(), null, outdatedStateManager, operationCanceledManager);
    XtextResource resource = new XtextResource();
    new XtextResourceSet().getResources().add(resource);
    document.setInput(resource);
    CountDownLatch check = new CountDownLatch(1);
    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            document.readOnly(new CancelableUnitOfWork<Object, XtextResource>() {
                @Override
                public Object exec(XtextResource state, CancelIndicator cancelIndicator) throws Exception {
                    check.countDown();
                    int wait = 4000;
                    int i = 0;
                    while (!cancelIndicator.isCanceled()) {
                        Thread.sleep(10L);
                        if (i > wait) {
                            throw new InterruptedException();
                        }
                        i = i + 1;
                    }
                    return null;
                }
            });
        }
    };
    Thread thread = new Thread(runnable);
    thread.start();
    check.await();
    document.priorityReadOnly(( r) -> null);
    Assert.assertFalse(thread.isInterrupted());
}"
"@Test
public void manyParametersWithBooleanAndEnum() throws Exception {
    assertThat(testResult(ManyParametersWithBooleanAndEnum.class), isSuccessful());
    int expectedCount = ((4 * 4) * 2) * RoundingMode.values().length;
    assertEquals(expectedCount, ManyParametersWithBooleanAndEnum.iterations);
    for (int i = 0; i < (expectedCount / 4); ++i) {
        assertEquals(String.valueOf(i), asList(3, 7), ManyParametersWithBooleanAndEnum.firstTestCases.subList(i * 4, (i * 4) + 2));
    }
    for (int i = 0; i < (expectedCount / 16); ++i) {
        assertEquals(String.valueOf(i), asList('a', 'a', 'a', 'a', 'b', 'b', 'b', 'b', 'c', 'c', 'c', 'c'), ManyParametersWithBooleanAndEnum.secondTestCases.subList(i * 16, (i * 16) + 12));
    }
    for (int i = 0; i < (expectedCount / 32); ++i) {
        assertEquals(asList(false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false), ManyParametersWithBooleanAndEnum.thirdTestCases.subList(i * 32, (i * 32) + 16));
        assertEquals(asList(true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true), ManyParametersWithBooleanAndEnum.thirdTestCases.subList((i * 32) + 16, (i * 32) + 32));
    }
}"
"@Test public void testPerson(){
    final Person p=new Person();
    p.name=""John Doe"";
    p.age=33;
    p.smoker=false;
    p.job=new Job();
    p.job.title=""Manager"";
    final String pBaseStr=p.getClass().getName() + ""@"" + Integer.toHexString(System.identityHashCode(p));
    final String pJobStr=p.job.getClass().getName() + ""@"" + Integer.toHexString(System.identityHashCode(p.job));
    assertEquals(pBaseStr + ""[age=33,job="" + pJobStr+ ""[title=Manager],name=John Doe,smoker=false]"",new ReflectionToStringBuilder(p,new RecursiveToStringStyle()).toString());
}"
"@Test
public void testLookupBinding() throws Exception {
    final ServiceName bindingName = ServiceName.JBOSS.append(""foo"", ""bar"");
    final Object value = new Object();
    bindObject(bindingName, value);
    final Object obj = store.lookup(new CompositeName(""foo/bar""));
    assertNotNull(obj);
    assertEquals(value, obj);
}"
"@Test
public void testDeadlockTimeout() throws SQLException, InterruptedException {
    setAutoCommit(false);
    Statement s = createStatement();
    assertUpdateCount(s, 1, ""update t set text='xxx' where id=1"");
    Connection c2 = openDefaultConnection();
    c2.setAutoCommit(false);
    Statement s2 = c2.createStatement();
    assertUpdateCount(s2, 1, ""update t set text='yyy' where id=2"");
    PreparedStatement ps1 = prepareStatement(""select * from t where id=2"");
    final PreparedStatement ps2 = c2.prepareStatement(""select * from t where id=1"");
    final Barrier barrier = new Barrier(2);
    final SQLException[] holder = new SQLException[2];
    final Throwable[] unexpected = new Throwable[1];
    Thread t = new Thread(new Runnable() {
        public void run() {
            try {
                barrier.await();
                JDBC.assertDrainResults(ps2.executeQuery());
            } catch (SQLException e) {
                holder[0] = e;
            } catch (Throwable t) {
                unexpected[0] = t;
            }
        }
    });
    t.start();
    barrier.await();
    try {
        JDBC.assertDrainResults(ps1.executeQuery());
    } catch (SQLException e) {
        holder[1] = e;
    }
    t.join();
    if (unexpected[0] != null) {
        fail(""Helper thread failed unexpectedly"", unexpected[0]);
    }
    assertFalse(""No deadlock"", (holder[0] == null) && (holder[1] == null));
    if ((holder[0] != null) && (holder[1] != null)) {
        printStackTrace(holder[0]);
        printStackTrace(holder[1]);
        fail(""Only one of the waiters should be aborted"");
    }
    SQLException deadlock = (holder[0] == null) ? holder[1] : holder[0];
    assertSQLState(""Not a deadlock"", ""40001"", deadlock);
    String[] lines = deadlock.getMessage().split(""\n"");
    assertEquals(""Unexpected number of lines in message"", 8, lines.length);
    Pattern[] patterns = new Pattern[]{ Pattern.compile(""Lock : ROW, T, \\(\\d+,\\d+\\)""), Pattern.compile("" *Waiting XID : \\{\\d+, S\\} , APP, "" + ""select \\* from t where id=(1|2)""), Pattern.compile("" *Granted XID : \\{\\d+, X\\} *"") };
    for (int i = 0; i < (patterns.length * 2); i++) {
        String line = lines[i + 1];
        Matcher m = patterns[i % patterns.length].matcher(line);
        assertTrue(""mismatch: "" + line, m.matches());
    }
    s.close();
    s2.close();
    c2.rollback();
    c2.close();
}"
"@Test
public void testLookupContextLink() throws Exception {
    final Name name = new CompositeName(""test/value"");
    namingStore.bind(name, ""testValue"");
    final Name linkName = new CompositeName(""link"");
    namingStore.bind(linkName, new LinkRef(""./test""));
    Object result = namingContext.lookup(""link/value"");
    assertEquals(""testValue"", result);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, Arrays.asList(new JndiPermission(""test"", ""lookup""),
    new JndiPermission(""test/value"", ""lookup"")), namingContext, ""link/value"");
    assertEquals(""testValue"", result);
}"
"@Test public void primitiveChars() throws Exception {
    assertThat(testResult(PrimitiveChars.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveChars.iterations);
    assertEquals(new HashSet<>(asList('Z','z')),new HashSet<>(PrimitiveChars.values.subList(0,2)));
    PrimitiveChars.iterations=0;
}"
"@Test public void whenConstrained() throws Exception {
    assertThat(testResult(EnumWithConstraint.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),EnumWithConstraint.values.size());
    assertThat(EnumWithConstraint.values,not(hasItem(E3)));
    EnumWithConstraint.values.clear();
}"
"@Test public void explicitConversion(){
    assertThat(testResult(ExplicitConversion.class),isSuccessful());
    assertEquals(2,ExplicitConversion.iterations);
    assertEquals(new HashSet<>(asList(LocalDate.of(2017,1,1),LocalDate.of(2001,12,25))),ExplicitConversion.testCases);
    ExplicitConversion.iterations=0;
    ExplicitConversion.testCases.clear();
}"
"@Test public void toXmlTest(){
    final JSONObject put=JSONUtil.createObj().set(""aaa"",""你好"").set(""键2"",""test"");
    final String s=JSONUtil.toXmlStr(put);
    Assert.assertThat(s,CoreMatchers.anyOf(CoreMatchers.is(""<aaa>你好</aaa><键2>test</键2>""),CoreMatchers.is(""<键2>test</键2><aaa>你好</aaa>"")));
}"
"@Test public void test_replaceExtension() throws Exception {
    try {
        getExtensionLoader(AddExt1.class).getExtension(""Manual2"");
        fail();
    }
    catch (  IllegalStateException expected) {
        assertThat(expected.getMessage(),containsString(""No such extension org.apache.dubbo.common.extension.ext8_add.AddExt1 by name Manual""));
    }
    {
        AddExt1 ext=getExtensionLoader(AddExt1.class).getExtension(""impl1"");
        assertThat(ext,instanceOf(AddExt1Impl1.class));
        assertEquals(""impl1"",getExtensionLoader(AddExt1.class).getExtensionName(AddExt1Impl1.class));
    }
    {
        getExtensionLoader(AddExt1.class).replaceExtension(""impl1"",AddExt1_ManualAdd2.class);
        AddExt1 ext=getExtensionLoader(AddExt1.class).getExtension(""impl1"");
        assertThat(ext,instanceOf(AddExt1_ManualAdd2.class));
        assertEquals(""impl1"",getExtensionLoader(AddExt1.class).getExtensionName(AddExt1_ManualAdd2.class));
    }
    ExtensionLoader.resetExtensionLoader(AddExt1.class);
}"
"@Test
public void testLedgerReachMaximumRolloverTime() throws Exception {
    ManagedLedgerConfig config = new ManagedLedgerConfig();
    config.setMinimumRolloverTime(1, TimeUnit.MILLISECONDS);
    config.setMaximumRolloverTime(1, TimeUnit.SECONDS);
    ManagedLedger ml = factory.open(""ledger-reach-maximum-rollover-time"", config);
    long firstLedgerId = ml.addEntry(""test"".getBytes()).getLedgerId();
    Awaitility.await()
    .atMost(1100, TimeUnit.MILLISECONDS)
    .pollInterval(100, TimeUnit.MILLISECONDS)
    .until(() -> firstLedgerId != ml.addEntry(""test"".getBytes()).getLedgerId());
}"
"@Test
public void testActivateSamples() throws Exception {
    UUID collectionExerciseId = UUID.randomUUID();
    UUID surveyId = UUID.randomUUID();
    UUID sampleSummaryId = UUID.randomUUID();
    SampleLink sampleLink = new SampleLink();
    sampleLink.setSampleSummaryId(sampleSummaryId);
    sampleLink.setCollectionExerciseId(collectionExerciseId);
    List<SampleLink> sampleLinks = new ArrayList<>();
    sampleLinks.add(sampleLink);
    CollectionExercise collectionExercise = new CollectionExercise();
    collectionExercise.setId(collectionExerciseId);
    collectionExercise.setSurveyId(surveyId);
    Event event = new Event();
    event.setTimestamp(new Timestamp(System.currentTimeMillis()));
    when(collectionExerciseRepository.findOneById(collectionExerciseId)).thenReturn(collectionExercise);
    when(sampleLinkRepository.findByCollectionExerciseId(collectionExerciseId)).thenReturn(sampleLinks);
    when(eventRepository.findOneByCollectionExerciseAndTag(collectionExercise, go_live.name())).thenReturn(event);
    sampleSummaryService.activateSamples(collectionExerciseId);
    sampleSummaryService.sampleSummaryValidated(true, collectionExerciseId);
    sampleSummaryService.sampleSummaryDistributed(true, collectionExerciseId);
    verify(collectionExerciseRepository, times(3)).findOneById(collectionExerciseId);
    verify(sampleSummaryActivationPublisher, times(1)).sendSampleSummaryActivation(collectionExerciseId, sampleSummaryId, surveyId);
    verify(collectionExerciseService, times(1)).transitionCollectionExercise(collectionExercise, EXECUTE);
    verify(collectionExerciseService, times(1)).transitionCollectionExercise(collectionExercise, VALIDATE);
    verify(collectionExerciseService, times(1)).transitionCollectionExercise(collectionExercise, EXECUTION_COMPLETE);
    verify(collectionExerciseService, times(1)).transitionCollectionExercise(collectionExercise, GO_LIVE);
}"
"@Test
public void testFireOneLevelEvent() throws Exception {
    final NamingEventCoordinator coordinator = new NamingEventCoordinator();
    final CollectingListener objectListener = new CollectingListener(0);
    coordinator.addListener(""test/path"", EventContext.OBJECT_SCOPE, objectListener);
    final CollectingListener subtreeListener = new CollectingListener(0);
    coordinator.addListener(""test"", EventContext.SUBTREE_SCOPE, subtreeListener);
    final CollectingListener oneLevelListener = new CollectingListener(1);
    coordinator.addListener(""test"", EventContext.ONELEVEL_SCOPE, oneLevelListener);
    coordinator.fireEvent(context, new CompositeName(""test/path""), null, null, NamingEvent.OBJECT_ADDED, ""bind"", EventContext.ONELEVEL_SCOPE);
    oneLevelListener.latch.await(1, TimeUnit.SECONDS);
    assertTrue(objectListener.capturedEvents.isEmpty());
    assertTrue(subtreeListener.capturedEvents.isEmpty());
    assertEquals(1, oneLevelListener.capturedEvents.size());
}"
"@Test
public void testRedeliverNewSession() throws Exception {
    String text = ""TEST"";
    Message sendMessage = session.createTextMessage(text);
    if (verbose) {
        log.info(((""About to send a message: "" + sendMessage) + "" with text: "") + text);
    }
    producer.send(producerDestination, sendMessage);
    Message unackMessage = consumer.receive(1000);
    assertNotNull(unackMessage);
    String unackId = unackMessage.getJMSMessageID();
    assertEquals(((TextMessage) (unackMessage)).getText(), text);
    assertFalse(unackMessage.getJMSRedelivered());
    assertEquals(unackMessage.getIntProperty(""JMSXDeliveryCount""), 1);
    consumeSession.close();
    consumer.close();
    consumeSession = connection.createSession(false, CLIENT_ACKNOWLEDGE);
    consumer = createConsumer();
    Message ackMessage = consumer.receive(1000);
    assertNotNull(ackMessage);
    ackMessage.acknowledge();
    String ackId = ackMessage.getJMSMessageID();
    assertEquals(((TextMessage) (ackMessage)).getText(), text);
    assertTrue(ackMessage.getJMSRedelivered());
    assertEquals(ackMessage.getIntProperty(""JMSXDeliveryCount""), 2);
    assertEquals(unackId, ackId);
    consumeSession.close();
    consumer.close();
    consumeSession = connection.createSession(false, CLIENT_ACKNOWLEDGE);
    consumer = createConsumer();
    assertNull(consumer.receiveNoWait());
}"
"@Test
public void testBasicRollingRestart() throws Exception {
    final int NUM_MASTERS = 2;
    final int NUM_RS = 3;
    final int NUM_REGIONS_TO_CREATE = 20;
    int expectedNumRS = 3;
    log(""Starting cluster"");
    Configuration conf = HBaseConfiguration.create();
    conf.setInt(""hbase.master.assignment.timeoutmonitor.period"", 2000);
    conf.setInt(""hbase.master.assignment.timeoutmonitor.timeout"", 5000);
    HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility(conf);
    TEST_UTIL.startMiniCluster(NUM_MASTERS, NUM_RS);
    MiniHBaseCluster cluster = TEST_UTIL.getHBaseCluster();
    log(""Waiting for active/ready master"");
    cluster.waitForActiveAndReadyMaster();
    ZooKeeperWatcher zkw = new ZooKeeperWatcher(conf, ""testRollingRestart"", null);
    HMaster master = cluster.getMaster();
    byte[] table = Bytes.toBytes(""tableRestart"");
    byte[] family = Bytes.toBytes(""family"");
    log((""Creating table with "" + NUM_REGIONS_TO_CREATE) + "" regions"");
    HTable ht = TEST_UTIL.createTable(table, family);
    int numRegions = TEST_UTIL.createMultiRegions(conf, ht, family, NUM_REGIONS_TO_CREATE);
    numRegions += 2;
    log(""Waiting for no more RIT\n"");
    blockUntilNoRIT(zkw, master);
    log(""Disabling table\n"");
    TEST_UTIL.getHBaseAdmin().disableTable(table);
    log(""Waiting for no more RIT\n"");
    blockUntilNoRIT(zkw, master);
    NavigableSet<String> regions = getAllOnlineRegions(cluster);
    log(""Verifying only catalog regions are assigned\n"");
    if (regions.size() != 2) {
        for (String oregion : regions) {
            log(""Region still online: "" + oregion);
        }
    }
    assertEquals(2, regions.size());
    log(""Enabling table\n"");
    TEST_UTIL.getHBaseAdmin().enableTable(table);
    log(""Waiting for no more RIT\n"");
    blockUntilNoRIT(zkw, master);
    log((""Verifying there are "" + numRegions) + "" assigned on cluster\n"");
    regions = getAllOnlineRegions(cluster);
    assertRegionsAssigned(cluster, regions);
    assertEquals(expectedNumRS, cluster.getRegionServerThreads().size());
    log(""Adding a fourth RS"");
    RegionServerThread restarted = cluster.startRegionServer();
    expectedNumRS++;
    restarted.waitForServerOnline();
    log(""Additional RS is online"");
    log(""Waiting for no more RIT"");
    blockUntilNoRIT(zkw, master);
    log((""Verifying there are "" + numRegions) + "" assigned on cluster"");
    assertRegionsAssigned(cluster, regions);
    assertEquals(expectedNumRS, cluster.getRegionServerThreads().size());
    List<MasterThread> masterThreads = cluster.getMasterThreads();
    MasterThread activeMaster = null;
    MasterThread backupMaster = null;
    assertEquals(2, masterThreads.size());
    if (masterThreads.get(0).getMaster().isActiveMaster()) {
        activeMaster = masterThreads.get(0);
        backupMaster = masterThreads.get(1);
    } else {
        activeMaster = masterThreads.get(1);
        backupMaster = masterThreads.get(0);
    }
    log(""Stopping backup master\n\n"");
    backupMaster.getMaster().stop(""Stop of backup during rolling restart"");
    cluster.hbaseCluster.waitOnMaster(backupMaster);
    log(""Stopping primary master\n\n"");
    activeMaster.getMaster().stop(""Stop of active during rolling restart"");
    cluster.hbaseCluster.waitOnMaster(activeMaster);
    log(""Restarting primary master\n\n"");
    activeMaster = cluster.startMaster();
    cluster.waitForActiveAndReadyMaster();
    master = activeMaster.getMaster();
    log(""Restarting backup master\n\n"");
    backupMaster = cluster.startMaster();
    assertEquals(expectedNumRS, cluster.getRegionServerThreads().size());
    List<RegionServerThread> regionServers = cluster.getLiveRegionServerThreads();
    int num = 1;
    int total = regionServers.size();
    for (RegionServerThread rst : regionServers) {
        ServerName serverName = rst.getRegionServer().getServerName();
        log((((((""Stopping region server "" + num) + "" of "") + total) + "" [ "") + serverName) + ""]"");
        rst.getRegionServer().stop(""Stopping RS during rolling restart"");
        cluster.hbaseCluster.waitOnRegionServer(rst);
        log(""Waiting for RS shutdown to be handled by master"");
        waitForRSShutdownToStartAndFinish(activeMaster, serverName);
        log(""RS shutdown done, waiting for no more RIT"");
        blockUntilNoRIT(zkw, master);
        log((""Verifying there are "" + numRegions) + "" assigned on cluster"");
        assertRegionsAssigned(cluster, regions);
        expectedNumRS--;
        assertEquals(expectedNumRS, cluster.getRegionServerThreads().size());
        log(((""Restarting region server "" + num) + "" of "") + total);
        restarted = cluster.startRegionServer();
        restarted.waitForServerOnline();
        expectedNumRS++;
        log((""Region server "" + num) + "" is back online"");
        log(""Waiting for no more RIT"");
        blockUntilNoRIT(zkw, master);
        log((""Verifying there are "" + numRegions) + "" assigned on cluster"");
        assertRegionsAssigned(cluster, regions);
        assertEquals(expectedNumRS, cluster.getRegionServerThreads().size());
        num++;
    }
    Thread.sleep(2000);
    assertRegionsAssigned(cluster, regions);
    RegionServerThread rootServer = getServerHostingRoot(cluster);
    RegionServerThread metaServer = getServerHostingMeta(cluster);
    if (rootServer == metaServer) {
        log(""ROOT and META on the same server so killing another random server"");
        int i = 0;
        while (rootServer == metaServer) {
            metaServer = cluster.getRegionServerThreads().get(i);
            i++;
        }
    }
    log(""Stopping server hosting ROOT"");
    rootServer.getRegionServer().stop(""Stopping ROOT server"");
    log(""Stopping server hosting META #1"");
    metaServer.getRegionServer().stop(""Stopping META server"");
    cluster.hbaseCluster.waitOnRegionServer(rootServer);
    log(""Root server down"");
    cluster.hbaseCluster.waitOnRegionServer(metaServer);
    log(""Meta server down #1"");
    expectedNumRS -= 2;
    log(""Waiting for meta server #1 RS shutdown to be handled by master"");
    waitForRSShutdownToStartAndFinish(activeMaster, metaServer.getRegionServer().getServerName());
    log(""Waiting for no more RIT"");
    blockUntilNoRIT(zkw, master);
    log((""Verifying there are "" + numRegions) + "" assigned on cluster"");
    assertRegionsAssigned(cluster, regions);
    assertEquals(expectedNumRS, cluster.getRegionServerThreads().size());
    metaServer = getServerHostingMeta(cluster);
    log(""Stopping server hosting META #2"");
    metaServer.getRegionServer().stop(""Stopping META server"");
    cluster.hbaseCluster.waitOnRegionServer(metaServer);
    log(""Meta server down"");
    expectedNumRS--;
    log(""Waiting for RS shutdown to be handled by master"");
    waitForRSShutdownToStartAndFinish(activeMaster, metaServer.getRegionServer().getServerName());
    log(""RS shutdown done, waiting for no more RIT"");
    blockUntilNoRIT(zkw, master);
    log((""Verifying there are "" + numRegions) + "" assigned on cluster"");
    assertRegionsAssigned(cluster, regions);
    assertEquals(expectedNumRS, cluster.getRegionServerThreads().size());
    cluster.startRegionServer().waitForServerOnline();
    cluster.startRegionServer().waitForServerOnline();
    cluster.startRegionServer().waitForServerOnline();
    Thread.sleep(1000);
    log(""Waiting for no more RIT"");
    blockUntilNoRIT(zkw, master);
    log((""Verifying there are "" + numRegions) + "" assigned on cluster"");
    assertRegionsAssigned(cluster, regions);
    metaServer = getServerHostingMeta(cluster);
    log(""Stopping server hosting META (1 of 3)"");
    metaServer.getRegionServer().stop(""Stopping META server"");
    cluster.hbaseCluster.waitOnRegionServer(metaServer);
    log(""Meta server down (1 of 3)"");
    log(""Waiting for RS shutdown to be handled by master"");
    waitForRSShutdownToStartAndFinish(activeMaster, metaServer.getRegionServer().getServerName());
    log(""RS shutdown done, waiting for no more RIT"");
    blockUntilNoRIT(zkw, master);
    log((""Verifying there are "" + numRegions) + "" assigned on cluster"");
    assertRegionsAssigned(cluster, regions);
    metaServer = getServerHostingMeta(cluster);
    log(""Stopping server hosting META (2 of 3)"");
    metaServer.getRegionServer().stop(""Stopping META server"");
    cluster.hbaseCluster.waitOnRegionServer(metaServer);
    log(""Meta server down (2 of 3)"");
    log(""Waiting for RS shutdown to be handled by master"");
    waitForRSShutdownToStartAndFinish(activeMaster, metaServer.getRegionServer().getServerName());
    log(""RS shutdown done, waiting for no more RIT"");
    blockUntilNoRIT(zkw, master);
    log((""Verifying there are "" + numRegions) + "" assigned on cluster"");
    assertRegionsAssigned(cluster, regions);
    metaServer = getServerHostingMeta(cluster);
    log(""Stopping server hosting META (3 of 3)"");
    metaServer.getRegionServer().stop(""Stopping META server"");
    cluster.hbaseCluster.waitOnRegionServer(metaServer);
    log(""Meta server down (3 of 3)"");
    log(""Waiting for RS shutdown to be handled by master"");
    waitForRSShutdownToStartAndFinish(activeMaster, metaServer.getRegionServer().getServerName());
    log(""RS shutdown done, waiting for no more RIT"");
    blockUntilNoRIT(zkw, master);
    log((""Verifying there are "" + numRegions) + "" assigned on cluster"");
    assertRegionsAssigned(cluster, regions);
    if (cluster.getRegionServerThreads().size() != 1) {
        log(""Online regionservers:"");
        for (RegionServerThread rst : cluster.getRegionServerThreads()) {
            log(""RS: "" + rst.getRegionServer().getServerName());
        }
    }
    assertEquals(1, cluster.getRegionServerThreads().size());
    TEST_UTIL.shutdownMiniCluster();
}"
"@Test
public void test_for_issue() throws Exception {
    ParserConfig config = new ParserConfig();
    String json = ""{\""k\"":1,\""v\"":\""A\""}"";
    {
        Map.Entry entry = JSON.parseObject(json, Map.Entry.class, config);
        assertEquals(""v"", entry.getKey());
        assertEquals(""A"", entry.getValue());
    }
    config.putDeserializer(Map.Entry.class, new ObjectDeserializer() {
        public <T> T deserialze(DefaultJSONParser parser, Type type, Object fieldName) {
            JSONObject object = parser.parseObject();
            Object k = object.get(""k"");
            Object v = object.get(""v"");
            return ((T) (Collections.singletonMap(k, v).entrySet().iterator().next()));
        }
        public int getFastMatchToken() {
            return 0;
        }
    });
    Map.Entry entry = JSON.parseObject(json, Map.Entry.class, config);
    assertEquals(1, entry.getKey());
    assertEquals(""A"", entry.getValue());
}"
"@Test
public void testAddAnExistingBuildAgent() {
    String BUILD_AGENT_NAME = getProperty(""BUILD_AGENT_NAME"");
    String BUILD_AGENT_DESCRIPTION = getProperty(""BUILD_AGENT_DESCRIPTION"");
    enableDistributedBuilds();
    goToAddBuildAgent();
    addBuildAgent(BUILD_AGENT_NAME, BUILD_AGENT_DESCRIPTION, false, false);
    assertTextPresent(""Build agent already exists"");
    disableDistributedBuilds();
}"
"@Test
public void testSetrepIncWithUnderReplicatedBlocks() throws Exception {
    Configuration conf = new HdfsConfiguration();
    final short REPLICATION_FACTOR = 2;
    final String FILE_NAME = ""/testFile"";
    final Path FILE_PATH = new Path(FILE_NAME);
    MiniDFSCluster cluster = new MiniDFSCluster.Builder(conf).numDataNodes(REPLICATION_FACTOR + 1).build();
    try {
        final FileSystem fs = cluster.getFileSystem();
        DFSTestUtil.createFile(fs, FILE_PATH, 1L, REPLICATION_FACTOR, 1L);
        DFSTestUtil.waitReplication(fs, FILE_PATH, REPLICATION_FACTOR);
        final BlockManager bm = cluster.getNamesystem().getBlockManager();
        ExtendedBlock b = DFSTestUtil.getFirstBlock(fs, FILE_PATH);
        DatanodeDescriptor dn = bm.blocksMap.nodeIterator(b.getLocalBlock()).next();
        bm.addToInvalidates(b.getLocalBlock(), dn);
        bm.blocksMap.removeNode(b.getLocalBlock(), dn);
        FsShell shell = new FsShell(conf);
        assertEquals(0, shell.run(new String[]{ ""-setrep"", ""-w"", Integer.toString(1 + REPLICATION_FACTOR), FILE_NAME }));
    } finally {
        cluster.shutdown();
    }
}"
"@Test
public void testUnwrapping() throws Exception {
    JsonSchema jsonSchema = MAPPER.generateJsonSchema(UnwrappingRoot.class);
    String json = jsonSchema.toString().replaceAll(""\"""", ""'"");
    String EXP = ""{'type':'object',"" + (""'properties':{'age':{'type':'integer'},"" + ""'name.first':{'type':'string'},'name.last':{'type':'string'}}}"");
    assertEquals(EXP, json);
}"
"@Test
public void upload_success_shouldInvokeListener() throws Exception {
    TransferListener listener = mock(TransferListener.class);
    Path path = newTempFile();
    Files.write(path, randomBytes(contentLength));
    UploadRequest uploadRequest = UploadRequest.builder().putObjectRequest(( r) -> r.bucket(""bucket"").key(""key"")).source(path).overrideConfiguration(( b) -> b.addListener(listener)).build();
    Upload upload = tm.upload(uploadRequest);
    upload.completionFuture().join();
    ArgumentCaptor<TransferListener.Context.TransferInitiated> captor1 = ArgumentCaptor.forClass(TransferInitiated.class);
    verify(listener, times(1)).transferInitiated(captor1.capture());
    TransferListener.Context.TransferInitiated ctx1 = captor1.getValue();
    assertThat(ctx1.request()).isSameAs(uploadRequest);
    assertThat(ctx1.progressSnapshot().transferSizeInBytes()).hasValue(contentLength);
    assertThat(ctx1.progressSnapshot().bytesTransferred()).isZero();
    ArgumentCaptor<TransferListener.Context.BytesTransferred> captor2 = ArgumentCaptor.forClass(BytesTransferred.class);
    verify(listener, times(1)).bytesTransferred(captor2.capture());
    TransferListener.Context.BytesTransferred ctx2 = captor2.getValue();
    assertThat(ctx2.request()).isSameAs(uploadRequest);
    assertThat(ctx2.progressSnapshot().transferSizeInBytes()).hasValue(contentLength);
    assertThat(ctx2.progressSnapshot().bytesTransferred()).isPositive();
    ArgumentCaptor<TransferListener.Context.TransferComplete> captor3 = ArgumentCaptor.forClass(TransferComplete.class);
    verify(listener, times(1)).transferComplete(captor3.capture());
    TransferListener.Context.TransferComplete ctx3 = captor3.getValue();
    assertThat(ctx3.request()).isSameAs(uploadRequest);
    assertThat(ctx3.progressSnapshot().transferSizeInBytes()).hasValue(contentLength);
    assertThat(ctx3.progressSnapshot().bytesTransferred()).isEqualTo(contentLength);
    assertThat(ctx3.completedTransfer()).isSameAs(upload.completionFuture().get());
    verifyNoMoreInteractions(listener);
}"
"@Test public void TestSimpleDiamond(){
    Node x=new Node(4);
    Node n=new Node(1).addkid((new Node(2)).addkid(x)).addkid((new Node(3)).addkid(x));
    Graph g=new Graph(n);
    MHGDominatorsFinder<Node> finder=new MHGDominatorsFinder<Node>(g);
    DominatorTree<Node> tree=new DominatorTree<Node>(finder);
    assertThat(tree.getHeads().size(),is(1));
    DominatorNode<Node> head=tree.getHeads().get(0);
    assertThat(head.getGode().id,is(1));
    Set<Integer> kids=kid_ids(head);
    assertThat(kids.size(),is(3));
    assertThat(kids,containsInAnyOrder(2,3,4));
}"
"@Test
public void iterableOfIterator() {
    Iterator<Object> mockIterator = mock(Iterator.class, ""MockIterator"");
    when(mockIterator.hasNext()).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(false);
    when(mockIterator.next()).thenReturn(1).thenReturn(2).thenReturn(3).thenThrow(new NoSuchElementException(""Iterator exhausted""));
    Iterable<Object> iterable = CollectionUtils.iterable(mockIterator);
    assertThat(iterable).isNotNull();
    Set<Object> set = new HashSet<>();
    iterable.forEach(set::add);
    assertThat(set).hasSize(3);
    assertThat(set).containsExactly(1, 2, 3);
    verify(mockIterator, times(4)).hasNext();
    verify(mockIterator, times(3)).next();
}"
"@Test public void manyParametersWithBooleanAndEnum(){
    assertThat(testResult(ManyParametersWithBooleanAndEnum.class),isSuccessful());
    assertEquals(2 * 5 * 2* RoundingMode.values().length,ManyParametersWithBooleanAndEnum.iterations);
    assertEquals(newHashSet(3,7),new HashSet<>(ManyParametersWithBooleanAndEnum.firstTestCases));
    assertEquals(newHashSet('a','b','c','d','e'),new HashSet<>(ManyParametersWithBooleanAndEnum.secondTestCases));
    assertEquals(newHashSet(false,true),new HashSet<>(ManyParametersWithBooleanAndEnum.thirdTestCases));
    assertEquals(EnumSet.allOf(RoundingMode.class),new HashSet<>(ManyParametersWithBooleanAndEnum.fourthTestCases));
    ManyParametersWithBooleanAndEnum.iterations=0;
    ManyParametersWithBooleanAndEnum.firstTestCases.clear();
    ManyParametersWithBooleanAndEnum.secondTestCases.clear();
    ManyParametersWithBooleanAndEnum.thirdTestCases.clear();
    ManyParametersWithBooleanAndEnum.fourthTestCases.clear();
}"
"@Test
public void testRITAssignmentManagerMetrics() throws Exception {
    final TableName TABLENAME = TableName.valueOf(name.getMethodName());
    final byte[] FAMILY = Bytes.toBytes(""family"");
    Table table = null;
    try {
        table = TEST_UTIL.createTable(TABLENAME, FAMILY);
        final byte[] row = Bytes.toBytes(""row"");
        final byte[] qualifier = Bytes.toBytes(""qualifier"");
        final byte[] value = Bytes.toBytes(""value"");
        Put put = new Put(row);
        put.addColumn(FAMILY, qualifier, value);
        table.put(put);
        Thread.sleep(msgInterval * 3);
        MetricsAssignmentManagerSource amSource =
        master.getAssignmentManager().getAssignmentManagerMetrics().getMetricsProcSource();
        metricsHelper.assertGauge(MetricsAssignmentManagerSource.RIT_COUNT_NAME, 0, amSource);
        metricsHelper.assertGauge(MetricsAssignmentManagerSource.RIT_COUNT_OVER_THRESHOLD_NAME, 0,
        amSource);
        ColumnFamilyDescriptor hcd = ColumnFamilyDescriptorBuilder.newBuilder(FAMILY).build();
        TableDescriptor htd = TableDescriptorBuilder.newBuilder(TABLENAME).addColumnFamily(hcd).
        addCoprocessorWithSpec(""hdfs:///foo.jar|com.foo.FooRegionObserver|1001|arg1=1,arg2=2"").
        build();
        try {
            TEST_UTIL.getAdmin().modifyTable(htd);
            fail(""Expected region failed to open"");
        } catch (IOException e) {
            LOG.info(""Expected exception"", e);
        }
        Thread.sleep(msgInterval * 3);
        metricsHelper.assertGauge(MetricsAssignmentManagerSource.RIT_COUNT_NAME, 2, amSource);
        metricsHelper.assertGauge(MetricsAssignmentManagerSource.RIT_COUNT_OVER_THRESHOLD_NAME, 2,
        amSource);
    } finally {
        if (table != null) {
            table.close();
        }
    }
}"
"public void test_for_issue(){
    org.json.JSONObject req=new org.json.JSONObject();
    req.put(""id"",1111);
    req.put(""name"",""name11"");
    String text=JSON.toJSONString(req,SerializerFeature.SortField);
    Assert.assertEquals(""{\""id\"":1111,\""name\"":\""name11\""}"",text);
}"
"@Test public void strings() throws Exception {
    assertThat(testResult(Strings.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),Strings.iterations);
    assertEquals(new HashSet<>(asList(""some"",""values"")),new HashSet<>(Strings.values.subList(0,2)));
    Strings.iterations=0;
}"
"@Test
public void testPasswordHistory() throws Exception {
    assertTrue(""should be allowed to authenticate"", ums.authenticate(""testcred"", ""password""));
    Thread.sleep(10);
    ums.setPassword(""testcred"", ""password"", ""password1"");
    Thread.sleep(10);
    ums.setPassword(""testcred"", ""password1"", ""password2"");
    assertTrue(""should be allowed to authenticate"", ums.authenticate(""testcred"", ""password2""));
    try {
        Thread.sleep(10);
        ums.setPassword(""testcred"", ""password2"", ""password"");
        fail(""Should not be allowed to reuse a password from password history"");
    } catch (SecurityException sex) {
        assertTrue(SecurityException.PASSWORD_ALREADY_USED.equals(sex.getKeyedMessage()));
    }
    Thread.sleep(10);
    ums.setPassword(""testcred"", ""password2"", ""password3"");
    Thread.sleep(10);
    ums.setPassword(""testcred"", ""password3"", ""password4"");
    Thread.sleep(10);
    ums.setPassword(""testcred"", ""password4"", ""password"");
    assertTrue(""should be allowed to authenticate"", ums.authenticate(""testcred"", ""password""));
}"
"@Test public void primitiveIntegers(){
    assertThat(testResult(PrimitiveIntegers.class),isSuccessful());
    assertEquals(3,PrimitiveIntegers.iterations);
    assertEquals(new HashSet<>(asList(1,2,3)),PrimitiveIntegers.testCases);
    PrimitiveIntegers.iterations=0;
    PrimitiveIntegers.testCases.clear();
}"
"@Test
public void assertIsShutdownAlready() {
    shutdownListenerManager.new InstanceShutdownStatusJobListener().dataChanged(""/test_job/instances/127.0.0.1@-@0"", Type.NODE_REMOVED, """");
    verify(schedulerFacade, times(0)).shutdownInstance();
}"
"@Test
public void testListBindings() throws Exception {
    final Object value = new Object();
    bindObject(ServiceName.JBOSS.append(""TestBean""), value);
    bindObject(ServiceName.JBOSS.append(""foo"", ""TestBean""), value);
    bindObject(ServiceName.JBOSS.append(""foo"", ""bar"", ""TestBean""), value);
    bindObject(ServiceName.JBOSS.append(""foo"", ""bar"", ""baz"", ""TestBean""), value);
    store.add(ServiceName.JBOSS.append(""foos"", ""bar""));
    store.add(ServiceName.JBOSS.append(""fo"", ""bar""));
    store.add(ServiceName.JBOSS.append(""foo"", ""ba"", ""baz""));
    store.add(ServiceName.JBOSS.append(""foo"", ""bart"", ""baz""));
    store.add(ServiceName.JBOSS.append(""foo"", ""bar"", ""ba""));
    store.add(ServiceName.JBOSS.append(""foo"", ""bar"", ""bazt""));
    store.add(ServiceName.JBOSS.append(""foo"", ""bar"", ""art""));
    store.add(ServiceName.JBOSS.append(""other"", ""one""));
    List<Binding> list = store.listBindings(new CompositeName(""""));
    assertEquals(5, list.size());
    assertContains(list, ""TestBean"", Object.class);
    assertContains(list, ""foo"", NamingContext.class);
    assertContains(list, ""fo"", NamingContext.class);
    assertContains(list, ""foos"", NamingContext.class);
    assertContains(list, ""other"", NamingContext.class);
    list = store.listBindings(new CompositeName(""foo""));
    assertEquals(4, list.size());
    assertContains(list, ""TestBean"", Object.class);
    assertContains(list, ""ba"", NamingContext.class);
    assertContains(list, ""bart"", NamingContext.class);
    assertContains(list, ""bar"", NamingContext.class);
    for (Binding binding : list) {
        if (binding.getName().equals(""bar"")) {
            final Object bean = Context.class.cast(binding.getObject()).lookup(""TestBean"");
            assertNotNull(bean);
            assertEquals(value, bean);
        }
    }
}"
"@Test
public void testHeartbeatExpiry() throws Exception {
    Clusters fsm = mock(Clusters.class);
    ActionQueue aq = new ActionQueue();
    ActionManager am = mock(ActionManager.class);
    HostState hs = HostState.WAITING_FOR_HOST_STATUS_UPDATES;
    List<Host> allHosts = new ArrayList<Host>();
    Host hostObj = mock(Host.class);
    allHosts.add(hostObj);
    when(fsm.getHosts()).thenReturn(allHosts);
    when(fsm.getHost(""host1"")).thenReturn(hostObj);
    when(hostObj.getState()).thenReturn(hs);
    when(hostObj.getHostName()).thenReturn(""host1"");
    aq.enqueue(""host1"", new ExecutionCommand());
    HeartbeatMonitor hm = new HeartbeatMonitor(fsm, aq, am, 100);
    hm.start();
    Thread.sleep(120);
    assertEquals(0, aq.dequeueAll(""host1"").size());
    verify(am, times(1)).handleLostHost(""host1"");
    verify(hostObj, times(1)).handleEvent(any(HostEvent.class));
    verify(hostObj, times(1)).setState(INIT);
    hm.shutdown();
}"
"@Test public void intArray(){
    final WithArrays wa=new WithArrays();
    wa.intArray=new int[]{1,2};
    final String exp=getClassPrefix(wa) + ""["" + BR+ ""  boolArray=<null>,""+ BR+ ""  charArray=<null>,""+ BR+ ""  doubleArray=<null>,""+ BR+ ""  intArray={""+ BR+ ""    1,""+ BR+ ""    2""+ BR+ ""  },""+ BR+ ""  longArray=<null>,""+ BR+ ""  stringArray=<null>""+ BR+ ""]"";
    assertEquals(exp,toString(wa));
}"
"@Test
public void testSkipCheckoutWithoutConnectionUrl() throws Exception {
    CheckoutMojo mojo = ((CheckoutMojo) (lookupMojo(""checkout"", getTestFile(""src/test/resources/mojos/checkout/checkoutWithoutConnectionUrl.xml""))));
    try {
        mojo.execute();
        fail(""mojo execution must fail."");
    } catch (MojoExecutionException e) {
        assertTrue(true);
    }
}"
"@Test public void oneFailingSearchTypeReturnsPartialResults() throws Exception {
    final ESGeneratedQueryContext queryContext=this.elasticsearchBackend.generate(searchJob,query,Collections.emptySet());
    when(jestClient.execute(any(),any())).thenReturn(resultFor(resourceFile(""partiallySuccessfulMultiSearchResponse.json"")));
    final QueryResult queryResult=this.elasticsearchBackend.doRun(searchJob,query,queryContext,Collections.emptySet());
    assertThat(queryResult.errors()).hasSize(1);
    final SearchTypeError searchTypeError=(SearchTypeError)new ArrayList<>(queryResult.errors()).get(0);
    assertThat(searchTypeError.description()).isEqualTo(""Unable to perform search query: \n"" + ""\n"" + ""Expected numeric type on field [field1], but got [keyword]."");
    assertThat(searchTypeError.searchTypeId()).isEqualTo(""pivot1"");
    assertThat(queryResult.searchTypes()).containsOnlyKeys(""pivot2"");
    final PivotResult pivot2Result=(PivotResult)queryResult.searchTypes().get(""pivot2"");
    assertThat(pivot2Result.rows().get(0)).isEqualTo(PivotResult.Row.builder().key(ImmutableList.of()).source(""leaf"").addValue(PivotResult.Value.create(Collections.singletonList(""max(field2)""),42.0,true,""row-leaf"")).build());
}"
"@Test public void testGetMap3(){
    Map<String,String> map1=new LinkedHashMap(1);
    Map<String,String> map2=new LinkedHashMap(2);
    map1.put(""key"",""value"");
    map2.put(""key1"",""value1"");
    map2.put(""key2"",""value2"");
    Iterator<Map.Entry<String,String>> iter=map1.entrySet().iterator();
    Assert.assertEquals(iter.next(),CollectionUtils.get(map1,0));
    Iterator<Map.Entry<String,String>> iter2=map2.entrySet().iterator();
    iter2.next();
    Map.Entry<String,String> second=iter2.next();
    Assert.assertEquals(second,CollectionUtils.get(map2,1));
}"
"@Test public void testOneResponse() throws Exception {
    QueryResponse r=new QueryResponse();
    r.setMetric(""sys.cpu.user"");
    r.putTag(""host"",""localhost"");
    r.putTag(""rack"",""r1"");
    r.putDps(""1234567890"",4.5);
    r.putDps(""1234567900"",3.5);
    r.putDps(""1234567910"",2.5);
    String result=JsonUtil.getObjectMapper().writeValueAsString(Collections.singletonList(r));
    String expected=""[{\""metric\"":\""sys.cpu.user\"",\""tags\"":{\""host\"":\""localhost\"",\""rack\"":\""r1\""},\""aggregatedTags\"":[],\""dps\"":{\""1234567890\"":4.5,\""1234567900\"":3.5,\""1234567910\"":2.5}}]"";
    Assert.assertEquals(expected,result);
}"
"@Test
public void testWebHdfsDoAs() throws Exception {
    LOG.info(""START: testWebHdfsDoAs()"");
    ((Log4JLogger) (LOG)).getLogger().setLevel(ALL);
    ((Log4JLogger) (LOG)).getLogger().setLevel(ALL);
    final UserGroupInformation ugi = UserGroupInformation.createRemoteUser(REAL_USER);
    LOG.info(""ugi.getShortUserName()="" + ugi.getShortUserName());
    final WebHdfsFileSystem webhdfs = WebHdfsTestUtil.getWebHdfsFileSystemAs(ugi, config);
    final Path root = new Path(""/"");
    cluster.getFileSystem().setPermission(root, new FsPermission(((short) (0777))));
    {
        final URL url = WebHdfsTestUtil.toUrl(webhdfs, GETHOMEDIRECTORY, root, new DoAsParam(PROXY_USER));
        final HttpURLConnection conn = ((HttpURLConnection) (url.openConnection()));
        final Map<?, ?> m = WebHdfsTestUtil.connectAndGetJson(conn, SC_OK);
        conn.disconnect();
        final Object responsePath = m.get(Path.class.getSimpleName());
        LOG.info(""responsePath="" + responsePath);
        Assert.assertEquals(""/user/"" + PROXY_USER, responsePath);
    }
    {
        final URL url = WebHdfsTestUtil.toUrl(webhdfs, GETHOMEDIRECTORY, root, new DoAsParam(PROXY_USER) {
            @Override
            public String getName() {
                return ""DOas"";
            }
        });
        final HttpURLConnection conn = ((HttpURLConnection) (url.openConnection()));
        final Map<?, ?> m = WebHdfsTestUtil.connectAndGetJson(conn, SC_OK);
        conn.disconnect();
        final Object responsePath = m.get(Path.class.getSimpleName());
        LOG.info(""responsePath="" + responsePath);
        Assert.assertEquals(""/user/"" + PROXY_USER, responsePath);
    }
    final Path f = new Path(""/testWebHdfsDoAs/a.txt"");
    {
        final PutOpParam.Op op = Op.CREATE;
        final URL url = WebHdfsTestUtil.toUrl(webhdfs, op, f, new DoAsParam(PROXY_USER));
        HttpURLConnection conn = ((HttpURLConnection) (url.openConnection()));
        conn = WebHdfsTestUtil.twoStepWrite(webhdfs, op, conn);
        final FSDataOutputStream out = WebHdfsTestUtil.write(webhdfs, op, conn, 4096);
        out.write(""Hello, webhdfs user!"".getBytes());
        out.close();
        final FileStatus status = webhdfs.getFileStatus(f);
        LOG.info(""status.getOwner()="" + status.getOwner());
        Assert.assertEquals(PROXY_USER, status.getOwner());
    }
    {
        final PostOpParam.Op op = Op.APPEND;
        final URL url = WebHdfsTestUtil.toUrl(webhdfs, op, f, new DoAsParam(PROXY_USER));
        HttpURLConnection conn = ((HttpURLConnection) (url.openConnection()));
        conn = WebHdfsTestUtil.twoStepWrite(webhdfs, op, conn);
        final FSDataOutputStream out = WebHdfsTestUtil.write(webhdfs, op, conn, 4096);
        out.write(""\nHello again!"".getBytes());
        out.close();
        final FileStatus status = webhdfs.getFileStatus(f);
        LOG.info(""status.getOwner()="" + status.getOwner());
        LOG.info(""status.getLen()  ="" + status.getLen());
        Assert.assertEquals(PROXY_USER, status.getOwner());
    }
}"
"@Test public void wrapperBytes() throws Exception {
    assertThat(testResult(WrapperBytes.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperBytes.iterations);
    assertEquals(new HashSet<>(asList(Byte.valueOf(""14""),Byte.valueOf(""-15""))),new HashSet<>(WrapperBytes.values.subList(0,2)));
    WrapperBytes.iterations=0;
}"
"@Test public void test_number_formt_tojson(){
    NumBean num=new NumBean();
    num.setNum1(1);
    String a=""{\n"" + ""   \""num1\"": \""01.00\"",\n"" + ""   \""num2\"": \""02.00\""\n""+ ""}"";
    String str=Json.toJson(num);
    assertJsonEqualsNonStrict(a,str);
    System.out.println(str);
}"
"@Test public void testFormatMultipleUTF8(){
    HashMap<String,String> params=new HashMap<String,String>();
    params.put(""a "",""b, "");
    params.put(""c"",""32626&"");
    String s=KeyValueFormatter.format(params,true);
    Assert.assertTrue((""a =b%2C+&c=32626%26"").equals(s) || (""c=32626%26&a =b%2C+"").equals(s));
}"
"@Test
public void testSimpleConsumerEventsWithoutPartition() throws Exception {
    final String topicName = ""persistent"";
    final String subName = ""sub1"";
    final int numMsgs = 100;
    TestConsumerStateEventListener listener1 = new TestConsumerStateEventListener();
    TestConsumerStateEventListener listener2 = new TestConsumerStateEventListener();
    ConsumerBuilder<byte[]> consumerBuilder = pulsarClient.newConsumer().topic(topicName).subscriptionName(subName).acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscriptionType(Failover);
    ConsumerBuilder<byte[]> consumerBulder1 = consumerBuilder.clone().consumerName(""1"").consumerEventListener(listener1).acknowledgmentGroupTime(0, TimeUnit.SECONDS);
    Consumer<byte[]> consumer1 = consumerBulder1.subscribe();
    Consumer<byte[]> consumer2 = consumerBuilder.clone().consumerName(""2"").consumerEventListener(listener2).subscribe();
    verifyConsumerActive(listener1, -1);
    verifyConsumerInactive(listener2, -1);
    PersistentTopic topicRef = ((PersistentTopic) (pulsar.getBrokerService().getTopicReference(topicName).get()));
    PersistentSubscription subRef = topicRef.getSubscription(subName);
    assertNotNull(topicRef);
    assertNotNull(subRef);
    assertTrue(subRef.getDispatcher().isConsumerConnected());
    assertEquals(subRef.getDispatcher().getType(), Failover);
    List<CompletableFuture<MessageId>> futures = Lists.newArrayListWithCapacity(numMsgs);
    Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName).enableBatching(false).messageRoutingMode(SinglePartition).create();
    for (int i = 0; i < numMsgs; i++) {
        String message = ""my-message-"" + i;
        futures.add(producer.sendAsync(message.getBytes()));
    }
    FutureUtil.waitForAll(futures).get();
    futures.clear();
    rolloverPerIntervalStats();
    assertEquals(subRef.getNumberOfEntriesInBacklog(), numMsgs);
    Thread.sleep(ASYNC_EVENT_COMPLETION_WAIT);
    Message<byte[]> msg = null;
    Assert.assertNull(consumer2.receive(1, TimeUnit.SECONDS));
    for (int i = 0; i < numMsgs; i++) {
        msg = consumer1.receive(1, TimeUnit.SECONDS);
        Assert.assertNotNull(msg);
        Assert.assertEquals(new String(msg.getData()), ""my-message-"" + i);
        consumer1.acknowledge(msg);
    }
    rolloverPerIntervalStats();
    Thread.sleep(ASYNC_EVENT_COMPLETION_WAIT);
    assertEquals(subRef.getNumberOfEntriesInBacklog(), 0);
    for (int i = 0; i < numMsgs; i++) {
        String message = ""my-message-"" + i;
        futures.add(producer.sendAsync(message.getBytes()));
    }
    FutureUtil.waitForAll(futures).get();
    futures.clear();
    for (int i = 0; i < 5; i++) {
        msg = consumer1.receive(1, TimeUnit.SECONDS);
        Assert.assertNotNull(msg);
        Assert.assertEquals(new String(msg.getData()), ""my-message-"" + i);
        consumer1.acknowledge(msg);
    }
    for (int i = 5; i < 10; i++) {
        msg = consumer1.receive(1, TimeUnit.SECONDS);
        Assert.assertNotNull(msg);
        Assert.assertEquals(new String(msg.getData()), ""my-message-"" + i);
    }
    consumer1.close();
    Thread.sleep(CONSUMER_ADD_OR_REMOVE_WAIT_TIME);
    verifyConsumerActive(listener2, -1);
    verifyConsumerNotReceiveAnyStateChanges(listener1);
    for (int i = 5; i < numMsgs; i++) {
        msg = consumer2.receive(1, TimeUnit.SECONDS);
        Assert.assertNotNull(msg);
        Assert.assertEquals(new String(msg.getData()), ""my-message-"" + i);
        consumer2.acknowledge(msg);
    }
    Assert.assertNull(consumer2.receive(1, TimeUnit.SECONDS));
    rolloverPerIntervalStats();
    Thread.sleep(ASYNC_EVENT_COMPLETION_WAIT);
    assertEquals(subRef.getNumberOfEntriesInBacklog(), 0);
    for (int i = 0; i < numMsgs; i++) {
        String message = ""my-message-"" + i;
        futures.add(producer.sendAsync(message.getBytes()));
    }
    FutureUtil.waitForAll(futures).get();
    futures.clear();
    for (int i = 0; i < 5; i++) {
        msg = consumer2.receive(1, TimeUnit.SECONDS);
        Assert.assertNotNull(msg);
        Assert.assertEquals(new String(msg.getData()), ""my-message-"" + i);
        consumer2.acknowledge(msg);
    }
    consumer1 = consumerBulder1.subscribe();
    Thread.sleep(CONSUMER_ADD_OR_REMOVE_WAIT_TIME);
    for (int i = 5; i < numMsgs; i++) {
        msg = consumer1.receive(1, TimeUnit.SECONDS);
        Assert.assertNotNull(msg);
        Assert.assertEquals(new String(msg.getData()), ""my-message-"" + i);
        consumer1.acknowledge(msg);
    }
    Assert.assertNull(consumer1.receive(1, TimeUnit.SECONDS));
    rolloverPerIntervalStats();
    Thread.sleep(ASYNC_EVENT_COMPLETION_WAIT);
    assertEquals(subRef.getNumberOfEntriesInBacklog(), 0);
    for (int i = 0; i < numMsgs; i++) {
        String message = ""my-message-"" + i;
        futures.add(producer.sendAsync(message.getBytes()));
    }
    FutureUtil.waitForAll(futures).get();
    futures.clear();
    for (int i = 0; i < 5; i++) {
        msg = consumer1.receive(1, TimeUnit.SECONDS);
        Assert.assertNotNull(msg);
        Assert.assertEquals(new String(msg.getData()), ""my-message-"" + i);
        consumer1.acknowledge(msg);
    }
    TestConsumerStateEventListener listener3 = new TestConsumerStateEventListener();
    Consumer<byte[]> consumer3 = consumerBuilder.clone().consumerName(""3"").consumerEventListener(listener3).subscribe();
    Thread.sleep(CONSUMER_ADD_OR_REMOVE_WAIT_TIME);
    verifyConsumerInactive(listener3, -1);
    Assert.assertNull(consumer3.receive(1, TimeUnit.SECONDS));
    for (int i = 5; i < numMsgs; i++) {
        msg = consumer1.receive(1, TimeUnit.SECONDS);
        Assert.assertNotNull(msg);
        Assert.assertEquals(new String(msg.getData()), ""my-message-"" + i);
        consumer1.acknowledge(msg);
    }
    rolloverPerIntervalStats();
    Thread.sleep(ASYNC_EVENT_COMPLETION_WAIT);
    assertEquals(subRef.getNumberOfEntriesInBacklog(), 0);
    try {
        consumer1.unsubscribe();
        fail(""should fail"");
    } catch (PulsarClientException e) {
    }
    consumer1.close();
    Thread.sleep(CONSUMER_ADD_OR_REMOVE_WAIT_TIME);
    consumer2.close();
    Thread.sleep(CONSUMER_ADD_OR_REMOVE_WAIT_TIME);
    try {
        consumer3.unsubscribe();
    } catch (PulsarClientException e) {
        fail(""Should not fail"", e);
    }
    Thread.sleep(ASYNC_EVENT_COMPLETION_WAIT);
    subRef = topicRef.getSubscription(subName);
    assertNull(subRef);
    producer.close();
    consumer3.close();
    admin.topics().delete(topicName);
}"
"@Test
public void runProducerWithHungConsumer() throws Exception {
    final long origTempUsage = broker.getSystemUsage().getTempUsage().getUsage();
    ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(""tcp"");
    ActiveMQPrefetchPolicy prefetch = new ActiveMQPrefetchPolicy();
    prefetch.setTopicPrefetch(10);
    factory.setPrefetchPolicy(prefetch);
    Connection consumerConnection = factory.createConnection();
    consumerConnection.start();
    Session consumerSession = consumerConnection.createSession(false, AUTO_ACKNOWLEDGE);
    MessageConsumer consumer = consumerSession.createConsumer(destination);
    final Connection producerConnection = factory.createConnection();
    producerConnection.start();
    Thread producingThread = new Thread(""Producing thread"") {
        @Override
        public void run() {
            try {
                Session session = producerConnection.createSession(false, AUTO_ACKNOWLEDGE);
                MessageProducer producer = session.createProducer(destination);
                producer.setDeliveryMode(deliveryMode);
                for (int idx = 0; idx < MESSAGES_COUNT; ++idx) {
                    Message message = session.createTextMessage(new String(buf) + idx);
                    producer.send(message);
                    messagesSent.incrementAndGet();
                    Thread.sleep(10);
                    LOG.info(""Sent Message "" + idx);
                    LOG.info(""Temp Store Usage "" + broker.getSystemUsage().getTempUsage().getUsage());
                }
                producer.close();
                session.close();
            } catch (Throwable ex) {
                ex.printStackTrace();
            }
        }
    };
    producingThread.start();
    int count = 0;
    Message m = null;
    while ((m = consumer.receive(messageReceiveTimeout)) != null) {
        count++;
        LOG.info(((""Recieved Message ("" + count) + ""):"") + m);
        messagesConsumed.incrementAndGet();
        try {
            Thread.sleep(100);
        } catch (Exception e) {
            LOG.info(""error sleeping"");
        }
    }
    LOG.info(""Connection Timeout: Retrying"");
    while ((m = consumer.receive(messageReceiveTimeout)) != null) {
        count++;
        LOG.info(((""Recieved Message ("" + count) + ""):"") + m);
        messagesConsumed.incrementAndGet();
        try {
            Thread.sleep(100);
        } catch (Exception e) {
            LOG.info(""error sleeping"");
        }
    }
    LOG.info(""consumer session closing: consumed count: "" + count);
    consumerSession.close();
    producingThread.join();
    final long tempUsageBySubscription = broker.getSystemUsage().getTempUsage().getUsage();
    LOG.info(((""Orig Usage: "" + origTempUsage) + "", currentUsage: "") + tempUsageBySubscription);
    producerConnection.close();
    consumerConnection.close();
    LOG.info(((""Subscrition Usage: "" + tempUsageBySubscription) + "", endUsage: "") + broker.getSystemUsage().getTempUsage().getUsage());
    assertEquals(""Incorrect number of Messages Sent: "" + messagesSent.get(), messagesSent.get(), MESSAGES_COUNT);
    assertEquals(""Incorrect number of Messages Consumed: "" + messagesConsumed.get(), messagesConsumed.get(), MESSAGES_COUNT);
}"
"@Test public void CustomDataParametersTest(){
    APIContext context=new APIContext(""ACCESS_TOKEN"").enableDebug(true);
    UserData userData=new UserData().email(""abc@eg.com"");
    HashMap<String,String> customProperties=new HashMap<String,String>();
    customProperties.put(""Key1"",""Value1"");
    customProperties.put(""Key2"",""Value2"");
    List<Content> contents=new ArrayList<Content>();
    contents.add(new Content().productId(""1"").brand(""brandA""));
    contents.add(new Content().productId(""2"").brand(""brandB""));
    List<String> contentIds=new ArrayList<String>();
    contentIds.add(""123"");
    contentIds.add(""456"");
    String contentCategory=""content_categoryA"";
    String contentName=""content_nameA"";
    String currency=""USD"";
    CustomData customData=new CustomData().contentIds(contentIds).customProperties(customProperties).contents(contents).contentCategory(contentCategory).contentName(contentName).currency(currency).deliveryCategory(DeliveryCategory.curbside).value(123.45F);
    Event testEvent=new Event();
    testEvent.eventName(""Purchase"").eventTime(System.currentTimeMillis() / 1000L).userData(userData).dataProcessingOptions(new String[]{}).customData(customData);
    EventRequest eventRequest=new EventRequest(""123"",context);
    eventRequest.addDataItem(testEvent);
    String serializedPayload=eventRequest.getSerializedPayload();
    String serializedContents=(new Gson()).toJson(contents);
    String serializedContentIds=(new Gson()).toJson(contentIds);
    Map<String,String> mp=customProperties;
    mp.forEach((key,value) -> Assert.assertTrue(serializedPayload.contains(""\"""" + key + ""\"":""+ ""\""""+ value+ ""\"""")));
    Assert.assertTrue(serializedPayload.contains(serializedContents));
    Assert.assertTrue(serializedPayload.contains(serializedContentIds));
    Assert.assertTrue(serializedPayload.contains(currency.toLowerCase()));
    Assert.assertTrue(serializedPayload.contains(contentCategory));
    Assert.assertTrue(serializedPayload.contains(contentName));
    Assert.assertTrue(serializedPayload.contains(DeliveryCategory.curbside.toString()));
}"
"@Test public void doubleArray(){
    final WithArrays wa=new WithArrays();
    wa.doubleArray=new double[]{1,2};
    final String exp=getClassPrefix(wa) + ""["" + BR+ ""  boolArray=<null>,""+ BR+ ""  charArray=<null>,""+ BR+ ""  doubleArray={""+ BR+ ""    1.0,""+ BR+ ""    2.0""+ BR+ ""  },""+ BR+ ""  intArray=<null>,""+ BR+ ""  longArray=<null>,""+ BR+ ""  stringArray=<null>""+ BR+ ""]"";
    assertEquals(exp,toString(wa));
}"
"@Test public void strings() throws Exception {
    assertThat(testResult(Strings.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),Strings.iterations);
    Strings.iterations=0;
}"
"@Test public void test_AddExtension() throws Exception {
    try {
        getExtensionLoader(AddExt1.class).getExtension(""Manual1"");
        fail();
    }
    catch (  IllegalStateException expected) {
        assertThat(expected.getMessage(),containsString(""No such extension org.apache.dubbo.common.extension.ext8_add.AddExt1 by name Manual""));
    }
    getExtensionLoader(AddExt1.class).addExtension(""Manual1"",AddExt1_ManualAdd1.class);
    AddExt1 ext=getExtensionLoader(AddExt1.class).getExtension(""Manual1"");
    assertThat(ext,instanceOf(AddExt1_ManualAdd1.class));
    assertEquals(""Manual1"",getExtensionLoader(AddExt1.class).getExtensionName(AddExt1_ManualAdd1.class));
    ExtensionLoader.resetExtensionLoader(AddExt1.class);
}"
"@Test public void unboxingAFoo() throws Exception {
    assertThat(testResult(UnboxingAFoo.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),UnboxingAFoo.iterations);
    UnboxingAFoo.iterations=0;
}"
"@Test public void serializeString() throws IOException {
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of("""")),""{\""@type\"":\""string\"",\""@value\"":\""\""}"");
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of(""Test"")),""{\""@type\"":\""string\"",\""@value\"":\""Test\""}"");
}"
"@Test
public void testTimerThreadLeak() throws Exception {
    Tomcat tomcat = getTomcatInstance();
    Context ctx = tomcat.addContext("""", System.getProperty(""java.io.tmpdir""));
    if (ctx instanceof StandardContext) {
        ((StandardContext) (ctx)).setClearReferencesStopThreads(true);
    }
    ExecutorServlet executorServlet = new ExecutorServlet();
    Tomcat.addServlet(ctx, ""taskServlet"", executorServlet);
    ctx.addServletMapping(""/"", ""taskServlet"");
    tomcat.start();
    getUrl((""http://google.com""));
    ctx.stop();
    try {
        Thread.sleep(1000);
    } catch (InterruptedException ie) {
    }
    Assert.assertTrue(executorServlet.tpe.isShutdown());
    Assert.assertTrue(executorServlet.tpe.isTerminated());
}"
"@Test
public void serializeWithTruncateArrayTest() throws IOException {
    final ResponseContext ctx = ResponseContext.createEmpty();
    ctx.put(UNCOVERED_INTERVALS, Arrays.asList(interval(1), interval(2), interval(3), interval(4), interval(5), interval(6)));
    ctx.put(EXTN_STRING_KEY, Strings.repeat(""x"", INTERVAL_LEN * 7));
    final DefaultObjectMapper objectMapper = new DefaultObjectMapper();
    final String fullString = objectMapper.writeValueAsString(ctx.getDelegate());
    final ResponseContext.SerializationResult res1 = ctx.serializeWith(objectMapper, Integer.MAX_VALUE);
    Assert.assertEquals(fullString, res1.getResult());
    final int maxLen = ((((INTERVAL_LEN * 4) + UNCOVERED_INTERVALS.getName().length()) + 4) + TRUNCATED.getName().length()) + 6;
    final ResponseContext.SerializationResult res2 = ctx.serializeWith(objectMapper, maxLen);
    final ResponseContext ctxCopy = ResponseContext.createEmpty();
    ctxCopy.put(UNCOVERED_INTERVALS, Arrays.asList(interval(1), interval(2), interval(3)));
    ctxCopy.put(TRUNCATED, true);
    Assert.assertEquals(ctxCopy.getDelegate(), deserializeContext(res2.getResult(), objectMapper));
}"
"@Test
public void testBind() throws Exception {
    Name name = new CompositeName(""test"");
    final Object value = new Object();
    namingContext.bind(name, value);
    assertEquals(value, namingStore.lookup(name));
    name = new CompositeName(""securitytest"");
    testActionPermission(JndiPermission.ACTION_BIND, namingContext, ""securitytest"", value);
    assertEquals(value, namingStore.lookup(name));
}"
"@Test
public void testWorkflowForkFailure() throws Exception {
    Assert.assertEquals(200, deploy(WorkflowFailureInForkApp.class).getStatusLine().getStatusCode());
    Id.Application appId = Application.from(DEFAULT, NAME);
    Id.Workflow workflowId = Workflow.from(appId, NAME);
    Id.Program firstMRId = Program.from(appId, MAPREDUCE, FIRST_MAPREDUCE_NAME);
    Id.Program secondMRId = Program.from(appId, MAPREDUCE, SECOND_MAPREDUCE_NAME);
    String outputPath = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
    File fileToSync = new File(tmpFolder.newFolder() + ""/sync.file"");
    File fileToWait = new File(tmpFolder.newFolder() + ""/wait.file"");
    startProgram(workflowId, ImmutableMap.of(""inputPath"", createInput(""testWorkflowForkFailureInput""), ""outputPath"", outputPath, ""sync.file"", fileToSync.getAbsolutePath(), ""wait.file"", fileToWait.getAbsolutePath(), (""mapreduce."" + WorkflowFailureInForkApp.SECOND_MAPREDUCE_NAME) + "".throw.exception"", ""true""));
    waitState(workflowId, RUNNING.name());
    waitState(workflowId, STOPPED.name());
    verifyProgramRuns(workflowId, ""failed"");
    List<RunRecord> mapReduceProgramRuns = getProgramRuns(firstMRId, KILLED.name());
    Assert.assertEquals(1, mapReduceProgramRuns.size());
    mapReduceProgramRuns = getProgramRuns(secondMRId, FAILED.name());
    Assert.assertEquals(1, mapReduceProgramRuns.size());
}"
"@Test
public void testAddRemoveRenewAction() throws IOException, InterruptedException {
    TestFileSystem tfs = new TestFileSystem();
    renewer.addRenewAction(tfs);
    for (int i = 0; i < 60; i++) {
        Thread.sleep(RENEW_CYCLE);
        if (tfs.testToken.renewCount > 0) {
            renewer.removeRenewAction(tfs);
            break;
        }
    }
    assertTrue(""Token not renewed even after 1 minute"", tfs.testToken.renewCount > 0);
    assertTrue(""Token not removed"", tfs.testToken.renewCount < MAX_RENEWALS);
    assertTrue(""Token not cancelled"", tfs.testToken.cancelled);
}"
"@Test
public void testHftpCustomDefaultPorts() throws IOException {
    resetFileSystem();
    Configuration conf = new Configuration();
    conf.setInt(""dfs.http.port"", 123);
    conf.setInt(""dfs.https.port"", 456);
    URI uri = URI.create();
    HftpFileSystem fs = ((HftpFileSystem) (FileSystem.get(uri, conf)));
    assertEquals(123, fs.getDefaultPort());
    assertEquals(456, fs.getDefaultSecurePort());
    assertEquals(uri, fs.getUri());
    assertEquals(""127.0.0.1:456"", fs.getCanonicalServiceName());
}"
"@Test
void sendMessageOnMessage() throws Exception {
    final Workflow workflow = SwadlParser.fromYaml(getClass().getResourceAsStream(""/message/send-message-on-message.swadl.yaml""));
    final V4Message message = message(""Hello!"");
    engine.deploy(workflow);
    engine.onEvent(messageReceived(""/message""));
    when(messageService.send(anyString(), any(Message.class))).thenReturn(message);
    verify(messageService, timeout(5000)).send(anyString(), any(Message.class));
    assertThat(workflow).isExecuted().hasOutput(String.format(OUTPUTS_MSG_KEY, ""sendMessage1""), message).hasOutput(String.format(OUTPUTS_MSG_ID_KEY, ""sendMessage1""), message.getMessageId());
}"
"@Test public void primitiveLongs() throws Exception {
    assertThat(testResult(PrimitiveLongs.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveLongs.iterations);
    PrimitiveLongs.iterations=0;
}"
"@Test
public void testReadRandom() throws Exception {
    FileSystem fs = cluster.getFileSystem();
    long tStart = System.currentTimeMillis();
    bench.getConf().setLong(""test.io.skip.size"", 0);
    bench.randomReadTest(fs);
    long execTime = System.currentTimeMillis() - tStart;
    bench.analyzeResult(fs, TestType.TEST_TYPE_READ_RANDOM, execTime);
}"
"@Test
public void testCleanup() throws Exception {
    ObjectStore objStore = new ObjectStore();
    objStore.setConf(metaStore.getConf());
    objStore.deleteRuntimeStats(0);
    objStore.addRuntimeStat(createStat(1));
    Thread.sleep(2000);
    objStore.addRuntimeStat(createStat(2));
    int deleted = objStore.deleteRuntimeStats(1);
    int deleted = objStore.deleteRuntimeStats(5);
    assertEquals(1, deleted);
    List<RuntimeStat> all = getRuntimeStats();
    assertEquals(1, all.size());
    assertEquals(2, all.get(0).getWeight());
}"
"@Test
public void testValidate_badXml() throws IOException, CoreException {
    XmlValidator validator = new XmlValidator();
    validator.setHelper(new AppEngineWebXmlValidator());
    IFile file = createBogusProjectFile();
    byte[] badXml = BAD_XML.getBytes(StandardCharsets.UTF_8);
    validator.validate(file, badXml);
    IMarker[] emptyMarkers =
    ProjectUtils.waitUntilNoMarkersFound(file, PROBLEM, true, DEPTH_ZERO);
    ArrayAssertions.assertIsEmpty(emptyMarkers);
}"
"@Test
public void testLookupWitResolveResult() throws Exception {
    namingStore.bind(new CompositeName(""test/nested""), ""test"");
    final Reference reference = new Reference(String.class.getName(), new StringRefAddr(""blahh"", ""test""), TestObjectFactoryWithNameResolution.class.getName(), null);
    namingStore.bind(new CompositeName(""comp""), reference);
    Object result = namingContext.lookup(new CompositeName(""comp/nested""));
    assertEquals(""test"", result);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, Arrays.asList(new JndiPermission(""test/nested"", ""lookup"")), namingContext, ""comp/nested"");
    assertEquals(""test"", result);
}"
"@Test
public void testJavaContext() throws Exception {
    System.setProperty(Context.INITIAL_CONTEXT_FACTORY, InitialContextFactory.class.getName());
    System.setProperty(Context.URL_PKG_PREFIXES, ""org.jboss.as.naming.interfaces"");
    InitialContext initialContext = new InitialContext();
    Context context = (Context) initialContext.lookup(""java:"");
    assertTrue(context instanceof NamingContext);
}"
"@Test
public void legalToExecuteTwiceCloning_Async() throws Exception {
    server.enqueue(new MockResponse().setBody(""abc""));
    server.enqueue(new MockResponse().setBody(""def""));
    Request request = new Request.Builder().url(server.url(""/"")).build();
    Call call = client.newCall(request);
    call.enqueue(callback);
    Call cloned = call.clone();
    cloned.enqueue(callback);
    callback.await(request.url()).assertBody(""abc"");
    callback.await(request.url()).assertBody(""def"");
}"
"@Test
public void testChangeServiceNotExport() throws RemotingException {
    String result = change.telnet(mockChannel, ""demo"");
    assertEquals(""No such service demo"", result);
}"
"@Test public void wrapperBytes() throws Exception {
    assertThat(testResult(WrapperBytes.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperBytes.iterations);
    assertEquals(new HashSet<>(asList((byte)14,(byte)-15)),new HashSet<>(WrapperBytes.values.subList(0,2)));
    WrapperBytes.iterations=0;
}"
"@Test
public void testDuplicateConcurrentSubscribeCommand() throws Exception {
    resetChannel();
    setChannelConnected();
    CompletableFuture<Topic> delayFuture = new CompletableFuture<>();
    doReturn(delayFuture).when(brokerService).getOrCreateTopic(any(String.class));
    ByteBuf clientCommand =
    Commands.newSubscribe(successTopicName, successSubName, 1, 1, Exclusive, 0, ""test"", 0);
    channel.writeInbound(clientCommand);
    clientCommand =
    Commands.newSubscribe(successTopicName, successSubName, 1, 1, Exclusive, 0, ""test"", 0);
    channel.writeInbound(clientCommand);
    Object response = getResponse();
    assertTrue(response instanceof CommandError, ""Response is not CommandError but "" + response);
    CommandError error = ((CommandError) (response));
    assertEquals(error.getError(), ServiceNotReady);
    channel.finish();
}"
"@Test
public void testLookupEmptyName() throws Exception {
    Object result = namingContext.lookup(new CompositeName());
    assertTrue(result instanceof NamingContext);
    result = namingContext.lookup(new CompositeName(""""));
    assertTrue(result instanceof NamingContext);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, null);
    assertTrue(result instanceof NamingContext);
    result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, """");
    assertTrue(result instanceof NamingContext);
}"
"/**
* Tests add/remove (again).
*/
@Test public void testAddRemove(){
    CollectionValuedMap<Integer,Integer> fooMap=new CollectionValuedMap<>();
    CollectionValuedMap<Integer,Integer> expectedMap=new CollectionValuedMap<>();
    for (int i=0; i < 4; i++) {
        for (int j=0; j < 4; j++) {
            fooMap.add(new Integer(i),new Integer(j));
            if (i != 2) {
                expectedMap.add(new Integer(i),new Integer(j));
            }
        }
    }
    fooMap.remove(new Integer(2));
    Assert.assertEquals(expectedMap,fooMap);
}"
"@Test
public void testLogbackStatusPrinterPrintStreamIsRestoredToSystemOut() throws Exception {
    Field field = StatusPrinter.class.getDeclaredField(""ps"");
    field.setAccessible(true);
    PrintStream out = (PrintStream) field.get(null);
    assertThat(out).isSameAs(System.out);
}"
"@Test
public void testEnumAsEnum() {
    final Settings settings = TestUtils.settings();
    settings.mapEnum = EnumMapping.asEnum;
    final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(AClass.class));
    final String expected = (""interface AClass {\n"" + ((((((((""    direction: Direction;\n"" + ""}\n"") + ""\n"") + ""declare const enum Direction {\n"") + ""    North = \'North\',\n"") + ""    East = \'East\',\n"") + ""    South = \'South\',\n"") + ""    West = \'West\',\n"") + ""}"")).replace(""'"", ""\"""");
    assertEquals(expected.trim(), output.trim());
}"
"@Test public void ctorOnly() throws Exception {
    assertThat(testResult(CtorOnly.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),CtorOnly.iterations);
    assertEquals(new HashSet<>(asList(new CtorOnly.Target(""a""),new CtorOnly.Target(""b""))),new HashSet<>(CtorOnly.values.subList(0,2)));
    CtorOnly.iterations=0;
}"
"@Test
public void assertGetCurrentShardingTotalCountIfNull() {
    assertThat(JobRegistry.getInstance().getCurrentShardingTotalCount(""exist_job_instance""), is(0));
}"
"@Test
public void shouldTogglePrepareForBulkLoadDuringRestoreCalls() throws Exception {
    final List<KeyValue<byte[], byte[]>> entries = new ArrayList<>();
    entries.add(new KeyValue<>(""1"".getBytes(""UTF-8""), ""a"".getBytes(""UTF-8"")));
    entries.add(new KeyValue<>(""2"".getBytes(""UTF-8""), ""b"".getBytes(""UTF-8"")));
    entries.add(new KeyValue<>(""3"".getBytes(""UTF-8""), ""c"".getBytes(""UTF-8"")));
    final AtomicReference<Exception> conditionNotMet = new AtomicReference<>();
    final AtomicInteger conditionCheckCount = new AtomicInteger();
    Thread conditionCheckThread = new Thread(new Runnable() {
        @Override
        public void run() {
            assertRocksDBTurnsOnBulkLoading(conditionCheckCount, conditionNotMet);
            assertRockDBTurnsOffBulkLoad(conditionCheckCount, conditionNotMet);
        }
    });
    subject.init(context, subject);
    conditionCheckThread.start();
    context.restore(subject.name(), entries);
    conditionCheckThread.join(2000);
    assertTrue(conditionNotMet.get() == null);
    assertTrue(conditionCheckCount.get() == 2);
}"
"@Test public void orderingOfStatements(){
    assertThat(testResult(PropertyBasedTests.class),failureCountIs(1));
    assertEquals(expectedStatements,PropertyBasedTests.LOGS);
    PropertyBasedTests.clearLogs();
}"
"@Test public void serializeEnum() throws IOException {
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of(TestEnum.A)),""{\""@type\"":\""string\"",\""@value\"":\""A\""}"");
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of(TestEnum.B)),""{\""@type\"":\""string\"",\""@value\"":\""B\""}"");
}"
"@Test
public void testConcurrentOperations() throws InterruptedException {
    ActionQueue aq = new ActionQueue();
    String[] hosts = new String[]{ ""h0"", ""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"", ""h7"", ""h8"", ""h9"" };
    ActionQueueOperation[] enqueOperators = new ActionQueueOperation[threadCount];
    ActionQueueOperation[] dequeOperators = new ActionQueueOperation[threadCount];
    ActionQueueOperation[] dequeAllOperators = new ActionQueueOperation[threadCount];
    for (int i = 0; i < threadCount; i++) {
        dequeOperators[i] = new ActionQueueOperation(aq, hosts, ActionQueueOperation.OpType.DEQUEUE);
        Thread t = new Thread(dequeOperators[i]);
        t.start();
    }
    for (int i = 0; i < threadCount; i++) {
        enqueOperators[i] = new ActionQueueOperation(aq, hosts, ActionQueueOperation.OpType.ENQUEUE);
        Thread t = new Thread(enqueOperators[i]);
        t.start();
    }
    for (int i = 0; i < threadCount; i++) {
        dequeAllOperators[i] = new ActionQueueOperation(aq, hosts, ActionQueueOperation.OpType.DEQUEUEALL);
        Thread t = new Thread(dequeAllOperators[i]);
        t.start();
    }
    Thread.sleep(100);
    for (int i = 0; i < threadCount; i++) {
        enqueOperators[i].stop();
    }
    boolean allDequeued = false;
    while (!allDequeued) {
        Thread.sleep(10);
        allDequeued = true;
        for (String host : hosts) {
            if (aq.size(host) > 0) {
                allDequeued = false;
                break;
            }
        }
    }
    for (int i = 0; i < threadCount; i++) {
        dequeOperators[i].stop();
        dequeAllOperators[i].stop();
    }
    for (int h = 0; h < hosts.length; h++) {
        long opsEnqueued = 0;
        long opsDequeued = 0;
        for (int i = 0; i < threadCount; i++) {
            opsEnqueued += enqueOperators[i].getOpCounts()[h];
            opsDequeued += dequeOperators[i].getOpCounts()[h];
            opsDequeued += dequeAllOperators[i].getOpCounts()[h];
        }
        assertTrue(opsEnqueued != 0);
        assertEquals(0, aq.size(hosts[h]));
        LOG.info(((((""Host: "" + hosts[h]) + "", opsEnqueued: "") + opsEnqueued) + "", opsDequeued: "") + opsDequeued);
        assertEquals(opsDequeued, opsEnqueued);
    }
}"
"@Test
public void testPerson() {
    final Person p = new Person();
    p.name = ""John Doe"";
    p.age = 33;
    p.smoker = false;
    p.job = new Job();
    p.job.title = ""Manager"";
    final String pBaseStr = (p.getClass().getName() + ""@"") + Integer.toHexString(System.identityHashCode(p));
    final String pJobStr = (p.job.getClass().getName() + ""@"") + Integer.toHexString(System.identityHashCode(p.job));
    assertEquals(((pBaseStr + ""[name=John Doe,age=33,smoker=false,job="") + pJobStr) + ""[title=Manager]]"", new ReflectionToStringBuilder(p, new RecursiveToStringStyle()).toString());
}"
"@Test
public void recurringJobWithErrorShouldStop() throws Exception
{
    RobustJobSchedulerWrapper robustWrapper = new RobustJobSchedulerWrapper( actualScheduler, log );
    AtomicInteger count = new AtomicInteger();
    Error e = new Error();
    JobHandle jobHandle = robustWrapper.scheduleRecurring( ""JobName"", 1, () ->{
        count.incrementAndGet();
        throw e;
    }
    );
    Thread.sleep( 50 );
    assertEventually( ""run count"", count::get, Matchers.equalTo( 1 ), DEFAULT_TIMEOUT_MS , MILLISECONDS );
    robustWrapper.cancelAndWaitTermination( jobHandle );
    verify( log, timeout( DEFAULT_TIMEOUT_MS ).times( 1 ) ).error( ""Uncaught error rethrown"", e );
}"
"@Test
public void testDoNotPurgeRPCTask() throws Exception {
    int RPCTaskNums = 10;
    TaskMonitor tm = TaskMonitor.get();
    for(int i = 0; i < RPCTaskNums; i++) {
        tm.createRPCStatus(""PRCTask"" + i);
    }
    for(int i = 0; i < TaskMonitor.DEFAULT_MAX_TASKS; i++) {
        tm.createStatus(""otherTask"" + i);
    }
    int remainRPCTask = 0;
    for(MonitoredTask task: tm.getTasks()) {
        if(task instanceof MonitoredRPCHandler) {
            remainRPCTask++;
        }
    }
    assertEquals(""RPC Tasks have been purged!"", RPCTaskNums, remainRPCTask);
    tm.shutdown();
}"
"@Test public void testGetMetaAnnotations(){
    List<Annotation> metaAnnotations=getMetaAnnotations(Service.class,a -> isSameType(a,Inherited.class));
    assertEquals(1,metaAnnotations.size());
    assertEquals(Inherited.class,metaAnnotations.get(0).annotationType());
    metaAnnotations=getMetaAnnotations(Service.class);
    HashSet<Object> set1=new HashSet<>();
    metaAnnotations.forEach(t -> set1.add(t.annotationType()));
    HashSet<Object> set2=new HashSet<>();
    set2.add(Inherited.class);
    set2.add(Deprecated.class);
    assertEquals(2,metaAnnotations.size());
    assertEquals(set1,set2);
}"
"@Test
public void testIndependentBranchesCase() {
    graph.add(""a"", ""b"");
    graph.add(""b"", ""c1"");
    graph.add(""b"", ""c2"");
    graph.add(""o"", ""p1"");
    graph.add(""p1"", ""r1"");
    graph.add(""r1"", ""s"");
    graph.add(""o"", ""p2"");
    graph.add(""p2"", ""r2"");
    graph.add(""r2"", ""s2"");
    graph.add(""r2"", ""s3"");
    graph.add(""x"", ""y"");
    graph.computeDependencies();
    List<String> expected =
    Arrays.asList(""a"", ""o"", ""x"", ""b"", ""p1"", ""p2"", ""y"", ""c1"", ""c2"", ""r1"", ""r2"", ""s"", ""s2"", ""s3"");
    Assert.assertEquals(expected, dependencyOrder);
}"
"@Test
public void CustomDataParametersTest() {
    APIContext context = new APIContext(""ACCESS_TOKEN"").enableDebug(true);
    UserData userData = new UserData().email(""abc@eg.com"");
    HashMap<String, String> customProperties = new HashMap<String, String>();
    customProperties.put(""Key1"", ""Value1"");
    customProperties.put(""Key2"", ""Value2"");
    List<Content> contents = new ArrayList<Content>();
    contents.add(new Content().productId(""1"").brand(""brandA""));
    contents.add(new Content().productId(""2"").brand(""brandB""));
    List<String> contentIds = new ArrayList<String>();
    contentIds.add(""123"");
    contentIds.add(""456"");
    String contentCategory = ""content_categoryA"";
    String contentName = ""content_nameA"";
    String currency = ""USD"";
    CustomData customData = new CustomData().contentIds(contentIds).customProperties(customProperties).contents(contents).contentCategory(contentCategory).contentName(contentName).currency(currency).deliveryCategory(curbside).value(123.45F);
    Event testEvent = new Event();
    testEvent.eventName(""Purchase"").eventTime(System.currentTimeMillis() / 1000L).userData(userData).dataProcessingOptions(new String[]{  }).customData(customData);
    EventRequest eventRequest = new EventRequest(""123"", context);
    eventRequest.addDataItem(testEvent);
    String serializedPayload = eventRequest.getSerializedPayload();
    String cpString = new Gson().toJson(customProperties);
    String serializedContents = new Gson().toJson(contents);
    String serializedContentIds = new Gson().toJson(contentIds);
    Assert.assertTrue(serializedPayload.contains(cpString.substring(1, cpString.length() - 1)));
    Assert.assertTrue(serializedPayload.contains(serializedContents));
    Assert.assertTrue(serializedPayload.contains(serializedContentIds));
    Assert.assertTrue(serializedPayload.contains(currency.toLowerCase()));
    Assert.assertTrue(serializedPayload.contains(contentCategory));
    Assert.assertTrue(serializedPayload.contains(contentName));
    Assert.assertTrue(serializedPayload.contains(curbside.toString()));
}"
"@Test
public void test_parseLString() throws Exception {
    DateFormat format = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL, Locale.US);
    try {
        Date date = format.parse(format.format(current).toString());
        assertEquals(current.getDate(), date.getDate());
        assertEquals(current.getDay(), date.getDay());
        assertEquals(current.getMonth(), date.getMonth());
        assertEquals(current.getYear(), date.getYear());
        assertEquals(current.getHours(), date.getHours());
        assertEquals(current.getMinutes(), date.getMinutes());
    } catch(ParseException pe) {
    fail(""ParseException was thrown for current Date.""); }
    try {
        format.parse(""January 16, 1970 8:03:52 PM CET"");
        fail(""ParseException was not thrown."");
    } catch(ParseException pe) { }
}"
"@Test
public void testScanPolicyObserver() throws Exception {
    byte[] tableName = Bytes.toBytes(""testScanPolicyObserver"");
    HTableDescriptor desc = new HTableDescriptor(tableName);
    HColumnDescriptor hcd = new HColumnDescriptor(F).setMaxVersions(10).setTimeToLive(1);
    desc.addFamily(hcd);
    TEST_UTIL.getHBaseAdmin().createTable(desc);
    HTable t = new HTable(new Configuration(TEST_UTIL.getConfiguration()), tableName);
    long now = EnvironmentEdgeManager.currentTimeMillis();
    ZooKeeperWatcher zkw = HConnectionManager.getConnection(TEST_UTIL.getConfiguration()).getZooKeeperWatcher();
    ZooKeeper zk = zkw.getRecoverableZooKeeper().getZooKeeper();
    ZKUtil.createWithParents(zkw, node);
    zk.setData(node, Bytes.toBytes(now - (3600 * 1000)), -1);
    LOG.debug(""Set time: "" + Bytes.toLong(Bytes.toBytes(now - (3600 * 1000))));
    long ts = now - 2000;
    Put p = new Put(R);
    p.add(F, Q, ts, Q);
    t.put(p);
    p = new Put(R);
    p.add(F, Q, ts + 1, Q);
    t.put(p);
    Get g = new Get(R);
    g.setMaxVersions(10);
    Result r = t.get(g);
    assertEquals(2, r.size());
    TEST_UTIL.flush(tableName);
    TEST_UTIL.compact(tableName, true);
    g = new Get(R);
    g.setMaxVersions(10);
    r = t.get(g);
    assertEquals(2, r.size());
    zk.setData(node, Bytes.toBytes(now), -1);
    LOG.debug(""Set time: "" + now);
    TEST_UTIL.compact(tableName, true);
    g = new Get(R);
    g.setMaxVersions(10);
    r = t.get(g);
    assertEquals(0, r.size());
    t.close();
}"
"@Test
public void testSimple() throws Exception {
    Configuration conf = new Configuration();
    MyResourceManager rm = new MyResourceManager(conf);
    rm.start();
    DrainDispatcher dispatcher = ((DrainDispatcher) (rm.getRMContext().getDispatcher()));
    RMApp app = rm.submitApp(1024);
    dispatcher.await();
    MockNM amNodeManager = rm.registerNode(""amNM:1234"", 2048);
    amNodeManager.nodeHeartbeat(true);
    dispatcher.await();
    ApplicationAttemptId appAttemptId = app.getCurrentAppAttempt().getAppAttemptId();
    rm.sendAMLaunched(appAttemptId);
    dispatcher.await();
    JobId jobId = MRBuilderUtils.newJobId(appAttemptId.getApplicationId(), 0);
    Job mockJob = mock(Job.class);
    when(mockJob.getReport()).thenReturn(MRBuilderUtils.newJobReport(jobId, ""job"", ""user"", RUNNING, 0, 0, 0, 0, 0, 0, ""jobfile""));
    MyContainerAllocator allocator = new MyContainerAllocator(rm, conf, appAttemptId, mockJob);
    MockNM nodeManager1 = rm.registerNode(""h1:1234"", 10240);
    MockNM nodeManager2 = rm.registerNode(""h2:1234"", 10240);
    MockNM nodeManager3 = rm.registerNode(""h3:1234"", 10240);
    dispatcher.await();
    ContainerRequestEvent event1 = createReq(jobId, 1, 1024, new String[]{ ""h1"" });
    allocator.sendRequest(event1);
    ContainerRequestEvent event2 = createReq(jobId, 2, 1024, new String[]{ ""h2"" });
    allocator.sendRequest(event2);
    List<TaskAttemptContainerAssignedEvent> assigned = allocator.schedule();
    dispatcher.await();
    Assert.assertEquals(""No of assignments must be 0"", 0, assigned.size());
    ContainerRequestEvent event3 = createReq(jobId, 3, 1024, new String[]{ ""h3"" });
    allocator.sendRequest(event3);
    assigned = allocator.schedule();
    dispatcher.await();
    Assert.assertEquals(""No of assignments must be 0"", 0, assigned.size());
    nodeManager1.nodeHeartbeat(true);
    nodeManager2.nodeHeartbeat(true);
    nodeManager3.nodeHeartbeat(true);
    dispatcher.await();
    assigned = allocator.schedule();
    dispatcher.await();
    checkAssignments(new ContainerRequestEvent[]{ event1, event2, event3 }, assigned, false);
}"
"@Test
public void testVersion2ClientVersion2Server() throws Exception {
    ProtocolSignature.resetCache();
    TestImpl2 impl = new TestImpl2();
    server = new RPC.Builder(conf).setProtocol(TestProtocol2.class).setInstance(impl).setBindAddress(ADDRESS).setPort(0).setNumHandlers(2).setVerbose(false).build();
    server.addProtocol(RPC_WRITABLE, TestProtocol0.class, impl);
    server.start();
    addr = NetUtils.getConnectAddress(server);
    Version2Client client = new Version2Client();
    client.ping();
    assertEquals(""hello"", client.echo(""hello""));
    assertEquals(-3, client.echo(3));
}"
"@Test
public void testCreateWithTwo() {
    AISMessage msg = amf.create(split1, split2);
    assertTrue(msg instanceof AISMessage05);
    assertEquals(5, msg.getMessageType());
}"
"@Test public void testMwDailyDumpFileProcessing() throws IOException {
    Path dmPath=Paths.get(System.getProperty(""user.dir""));
    MockDirectoryManager dm=new MockDirectoryManager(dmPath,true,true);
    setLocalDumpFile(""20140420"",DumpContentType.DAILY,dm);
    DumpProcessingController dpc=new DumpProcessingController(""wikidatawiki"");
    dpc.downloadDirectoryManager=dm;
    dpc.setOfflineMode(true);
    StatisticsMwRevisionProcessor mwrpAllStats=new StatisticsMwRevisionProcessor(""all"",2);
    dpc.registerMwRevisionProcessor(mwrpAllStats,null,false);
    TestMwRevisionProcessor tmrpAll=new TestMwRevisionProcessor();
    dpc.registerMwRevisionProcessor(tmrpAll,null,false);
    TestMwRevisionProcessor tmrpAllCurrent=new TestMwRevisionProcessor();
    dpc.registerMwRevisionProcessor(tmrpAllCurrent,null,true);
    TestMwRevisionProcessor tmrpAllItems=new TestMwRevisionProcessor();
    dpc.registerMwRevisionProcessor(tmrpAllItems,MwRevision.MODEL_WIKIBASE_ITEM,false);
    TestEntityDocumentProcessor edpCurrentCounter=new TestEntityDocumentProcessor();
    dpc.registerEntityDocumentProcessor(edpCurrentCounter,MwRevision.MODEL_WIKIBASE_ITEM,true);
    dpc.registerEntityDocumentProcessor(edpCurrentCounter,MwRevision.MODEL_WIKIBASE_PROPERTY,true);
    TestEntityDocumentProcessor edpAllCounter=new TestEntityDocumentProcessor();
    dpc.registerEntityDocumentProcessor(edpAllCounter,MwRevision.MODEL_WIKIBASE_ITEM,false);
    dpc.registerEntityDocumentProcessor(edpAllCounter,MwRevision.MODEL_WIKIBASE_PROPERTY,false);
    TestMwRevisionProcessor tmrpAllProperties=new TestMwRevisionProcessor();
    dpc.registerMwRevisionProcessor(tmrpAllProperties,MwRevision.MODEL_WIKIBASE_PROPERTY,false);
    TestMwRevisionProcessor tmrpAllLexemes=new TestMwRevisionProcessor();
    dpc.registerMwRevisionProcessor(tmrpAllLexemes,MwRevision.MODEL_WIKIBASE_LEXEME,false);
    dpc.processDump(dpc.getMostRecentDump(DumpContentType.DAILY));
    List<MwRevision> revisionsAllItems=new ArrayList<>();
    revisionsAllItems.add(getItemRevision(4));
    revisionsAllItems.add(getItemRevision(5));
    revisionsAllItems.add(getItemRevision(3));
    revisionsAllItems.add(getItemRevision(2));
    List<MwRevision> revisionsAllProperties=new ArrayList<>();
    revisionsAllProperties.add(getPropertyRevision(4));
    revisionsAllProperties.add(getPropertyRevision(5));
    List<MwRevision> revisionsAllLexemes=new ArrayList<>();
    revisionsAllLexemes.add(getLexemeRevision(9));
    revisionsAllLexemes.add(getLexemeRevision(10));
    List<MwRevision> revisionsAll=new ArrayList<>(revisionsAllItems);
    revisionsAll.add(getPageRevision(1));
    revisionsAll.add(getPageRevision(2));
    revisionsAll.addAll(revisionsAllProperties);
    revisionsAll.addAll(revisionsAllLexemes);
    List<MwRevision> revisionsAllCurrent=new ArrayList<>();
    revisionsAllCurrent.add(getItemRevision(5));
    revisionsAllCurrent.add(getPageRevision(2));
    revisionsAllCurrent.add(getPropertyRevision(5));
    revisionsAllCurrent.add(getLexemeRevision(10));
    assertEquals(""Wikidata Toolkit Test"",tmrpAll.siteName);
    assertEquals(revisionsAll.size(),mwrpAllStats.getTotalRevisionCount());
    assertEquals(revisionsAll.size(),mwrpAllStats.getCurrentRevisionCount());
    assertEqualRevisionLists(revisionsAll,tmrpAll.revisions,""all"");
    assertEqualRevisionLists(revisionsAllItems,tmrpAllItems.revisions,""allitems"");
    assertEqualRevisionLists(revisionsAllCurrent,tmrpAllCurrent.revisions,""allcurrent"");
    assertEqualRevisionLists(revisionsAllProperties,tmrpAllProperties.revisions,""allproperties"");
    assertEqualRevisionLists(revisionsAllLexemes,tmrpAllLexemes.revisions,""alllexemes"");
    assertEquals(revisionsAllItems.size(),edpAllCounter.itemCount);
    assertEquals(revisionsAllProperties.size(),edpAllCounter.propCount);
    assertEquals(1,edpCurrentCounter.itemCount);
    assertEquals(1,edpCurrentCounter.propCount);
}"
"@Test
public void testNoTestClassesInDeploymentAssembly()
throws InvocationTargetException, CoreException {
    CreateAppEngineWtpProject creator = new CreateAppEngineStandardWtpProject(config, adaptable);
    creator.execute(monitor);
    ProjectUtils.waitForProjects(project);
    assertNoTestClassesInDeploymentAssembly();
}
private void assertNoTestClassesInDeploymentAssembly() throws CoreException {
    StructureEdit core = StructureEdit.getStructureEditForRead(project);
    WorkbenchComponent component = core.getComponent();
    assertNotNull(component);
    boolean seenMainSourcePath = false;
    List<ComponentResource> resources = component.getResources();
    for (ComponentResource resource : resources) {
        assertFalse(containsSegment(resource.getSourcePath(), ""test""));
        if (resource.getSourcePath().equals(new Path(""/src/main/java""))
        && resource.getRuntimePath().equals(new Path(""/WEB-INF/classes""))) {
            seenMainSourcePath = true;
        }
    }
    assertTrue(seenMainSourcePath);
}"
"@Test public void findingAnnotationsRecursively(){
    Method method=findMethod(this.getClass(),""withMarker"",String.class);
    List<Annotation> annotations=allAnnotations(method.getParameters()[0]);
    assertEquals(4,annotations.size());
    assertEquals(X.class,annotations.get(0).annotationType());
    assertEquals(Y.class,annotations.get(1).annotationType());
    assertTrue(Z.class.equals(annotations.get(2).annotationType()) || W.class.equals(annotations.get(2).annotationType()));
    if (Z.class.equals(annotations.get(2).annotationType())) {
        assertEquals(W.class,annotations.get(3).annotationType());
    }
    else {
        assertEquals(Z.class,annotations.get(3).annotationType());
    }
}"
"@Test public void test1_2() throws Exception {
    JSONObject json=new JSONObject();
    json.put(""id"",123);
    json.put(""name"",""哈哈哈"");
    ResultActions actions=mockMvc.perform((post(""/fastjson/test1?callback=fnUpdateSome"").characterEncoding(""UTF-8"").content(json.toJSONString()).contentType(MediaType.APPLICATION_JSON)));
    actions.andDo(print());
    actions.andExpect(status().isOk()).andExpect(content().contentType(APPLICATION_JAVASCRIPT));
    String content=actions.andReturn().getResponse().getContentAsString();
    assertTrue(content.equals(""/**/fnUpdateSome({\""name\"":\""哈哈哈\"",\""id\"":123})"") || content.equals(""/**/fnUpdateSome({\""id\"":123,\""name\"":\""哈哈哈\""})""));
}"
"@Test public void wrapperLongs() throws Exception {
    assertThat(testResult(WrapperLongs.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperLongs.iterations);
    WrapperLongs.iterations=0;
}"
"@Test public void trialCountHoldsForEntirePropertyRatherThanIndividualParameters(){
    assertThat(testResult(ForValuesOfMultipleParameters.class),isSuccessful());
    assertEquals(21,ForValuesOfMultipleParameters.iterations);
    ForValuesOfMultipleParameters.iterations=0;
}"
"@Test
public void executeTransactionAsync_callbacksShouldBeClearedBeforeCalling() {
    final AtomicInteger callbackCounter = new AtomicInteger(0);
    final Realm foregroundRealm = looperThread.getRealm();
    foregroundRealm.setAutoRefresh(false);
    foregroundRealm.executeTransactionAsync(new Realm.Transaction() {
        @Override
        public void execute(Realm realm) {
            realm.createObject(AllTypes.class);
        }
    }, new Realm.Transaction.OnSuccess() {
        @Override
        public void onSuccess() {
            assertEquals(0, callbackCounter.getAndIncrement());
            foregroundRealm.beginTransaction();
            foregroundRealm.createObject(AllTypes.class);
            foregroundRealm.commitTransaction();
        }
    });
    foregroundRealm.executeTransactionAsync(new Realm.Transaction() {
        @Override
        public void execute(Realm realm) {
            realm.createObject(AllTypes.class);
            looperThread.postRunnableDelayed(new Runnable() {
                @Override
                public void run() {
                    foregroundRealm.sharedRealm.refresh();
                    foregroundRealm.setAutoRefresh(true);
                }
            }, 50);
        }
    }, new Realm.Transaction.OnSuccess() {
        @Override
        public void onSuccess() {
            assertEquals(1, callbackCounter.getAndIncrement());
            looperThread.testComplete();
        }
    });
}"
"@Test public void primitiveChars() throws Exception {
    assertThat(testResult(PrimitiveChars.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveChars.iterations);
    PrimitiveChars.iterations=0;
}"
"@Test public void testParametersFromOriginalPostRequest() throws IOException {
    TestHttpClient client=createHttpClient();
    HttpResponse result=executePostRequest(client,""/servletContext/dumpRequest"",new BasicNameValuePair(""param1"",""param1Value""),new BasicNameValuePair(""param2"",""param2Value""));
    assertEquals(StatusCodes.OK,result.getStatusLine().getStatusCode());
    String response=HttpClientUtils.readResponse(result);
    assertTrue(response.contains(""param1=param1Value""));
    assertTrue(response.contains(""param2=param2Value""));
    result=executePostRequest(client,""/servletContext/secured/dumpRequest"",new BasicNameValuePair(""securedParam1"",""securedParam1Value""),new BasicNameValuePair(""securedParam2"",""securedParam2Value""));
    assertEquals(StatusCodes.OK,result.getStatusLine().getStatusCode());
    Assert.assertTrue(HttpClientUtils.readResponse(result).startsWith(""j_security_check""));
    result=executePostRequest(client,""/servletContext/j_security_check"",new BasicNameValuePair(""j_username"",""user1""),new BasicNameValuePair(""j_password"",""password1""));
    assertEquals(StatusCodes.OK,result.getStatusLine().getStatusCode());
    response=HttpClientUtils.readResponse(result);
    assertTrue(response.contains(""securedParam1=securedParam1Value""));
    assertTrue(response.contains(""securedParam2=securedParam2Value""));
}"
"@Test public void TestMultiTailedPostDom(){
    Node n1=new Node(1);
    Node n2=new Node(2);
    Node n3=new Node(3);
    Node n4=new Node(4);
    Node n5=new Node(5);
    Node n6=new Node(6);
    n1.addkid(n2).addkid(n3);
    n3.addkid(n4).addkid(n5);
    n4.addkid(n6);
    n5.addkid(n6);
    Graph g=new Graph(n1);
    MHGDominatorsFinder<Node> finder=new MHGDominatorsFinder<Node>(g);
    MHGDominatorTree<Node> tree=new MHGDominatorTree<Node>(finder);
    assertThat(tree.getHeads().size(),is(1));
    DominatorNode<Node> n=tree.getHeads().get(0);
    assertThat(n.getGode().id,is(1));
    Set<Integer> kids=kid_ids(n);
    assertThat(kids.size(),is(2));
    assertThat(kids,containsInAnyOrder(2,3));
    Map<Integer,DominatorNode<Node>> KM=kid_map(n);
    DominatorNode<Node> m=KM.get(2);
    kids=kid_ids(m);
    assertThat(kids.size(),is(0));
    n=KM.get(3);
    kids=kid_ids(n);
    assertThat(kids.size(),is(3));
    assertThat(kids,containsInAnyOrder(4,5,6));
    KM=kid_map(n);
    m=KM.get(4);
    kids=kid_ids(m);
    assertThat(kids.size(),is(0));
    m=KM.get(5);
    kids=kid_ids(m);
    assertThat(kids.size(),is(0));
    m=KM.get(6);
    kids=kid_ids(m);
    assertThat(kids.size(),is(0));
    MHGPostDominatorsFinder<Node> pfinder=new MHGPostDominatorsFinder<Node>(g);
    tree=new MHGDominatorTree<Node>(pfinder);
    Map<Integer,DominatorNode<Node>> heads=new HashMap<Integer,DominatorNode<Node>>();
    for (  DominatorNode<Node> dhead : tree.getHeads()) {
        Node head=dhead.getGode();
        heads.put(head.id,dhead);
    }
    Set<Integer> head_ids=heads.keySet();
    assertThat(head_ids.size(),is(3));
    assertThat(head_ids,containsInAnyOrder(1,2,6));
    m=heads.get(1);
    kids=kid_ids(m);
    assertThat(kids.size(),is(0));
    m=heads.get(2);
    kids=kid_ids(m);
    assertThat(kids.size(),is(0));
    n=heads.get(6);
    kids=kid_ids(n);
    assertThat(kids.size(),is(3));
    assertThat(kids,containsInAnyOrder(3,4,5));
    KM=kid_map(n);
    m=KM.get(3);
    kids=kid_ids(m);
    assertThat(kids.size(),is(0));
    m=KM.get(4);
    kids=kid_ids(m);
    assertThat(kids.size(),is(0));
    m=KM.get(5);
    kids=kid_ids(m);
    assertThat(kids.size(),is(0));
}"
"@Test public void acrossParametersOfSameArrayType() throws Exception {
    assertThat(testResult(ParametersOfSameArrayType.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ParametersOfSameArrayType.iterations);
    ParametersOfSameArrayType.iterations=0;
}"
"@Test public void wrapperIntegers() throws Exception {
    assertThat(testResult(WrapperIntegers.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperIntegers.iterations);
    assertEquals(new HashSet<>(asList(4,5)),new HashSet<>(WrapperIntegers.values.subList(0,2)));
    WrapperIntegers.iterations=0;
}"
"@Test
public void recoverFromCancelReusesConnection() throws Exception {
    CountDownLatch responseDequeuedLatch = new CountDownLatch(1);
    CountDownLatch requestCanceledLatch = new CountDownLatch(1);
    QueueDispatcher dispatcher = new QueueDispatcher() {
        @Override
        public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
            MockResponse response = super.dispatch(request);
            responseDequeuedLatch.countDown();
            requestCanceledLatch.await();
            return response;
        }
    };
    server.setDispatcher(dispatcher);
    dispatcher.enqueueResponse(new MockResponse().setBodyDelay(10, TimeUnit.SECONDS).setBody(""abc""));
    dispatcher.enqueueResponse(new MockResponse().setBody(""def""));
    client = client.newBuilder().dns(new DoubleInetAddressDns()).build();
    callAndCancel(0, responseDequeuedLatch, requestCanceledLatch);
    Call call = client.newCall(new Request.Builder().url(server.url(""/"")).build());
    Response response = call.execute();
    assertThat(response.body().string()).isEqualTo(""def"");
    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
}"
"@Test public void wrapperShorts() throws Exception {
    assertThat(testResult(WrapperShorts.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperShorts.iterations);
    WrapperShorts.iterations=0;
}"
"@Test
public void lastModificationTimeAddCheckpointTest() throws Exception {
    long fileId = mFsMaster.create(new TachyonURI(""/testFile""), CreateOptions.defaults());
    long opTimeMs = System.currentTimeMillis();
    mFsMaster.persistFileInternal(fileId, 1, opTimeMs);
    FileInfo fileInfo = mFsMaster.getFileInfo(fileId);
    Assert.assertEquals(opTimeMs, fileInfo.lastModificationTimeMs);
}"
"@Test(timeout=60000) public void testNfsRenameSingleNN() throws Exception {
    DFSTestUtil.createFile(viewFs,new Path(""/hdfs1/renameSingleNN""),0,(short)1,0);
    HdfsFileStatus fromFileStatus=nn1.getRpcServer().getFileInfo(""/user1"");
    int fromNNId=Nfs3Utils.getNamenodeId(config,hdfs1.getUri());
    FileHandle fromHandle=new FileHandle(fromFileStatus.getFileId(),fromNNId);
    HdfsFileStatus statusBeforeRename=nn1.getRpcServer().getFileInfo(""/user1/renameSingleNN"");
    Assert.assertEquals(statusBeforeRename.isDirectory(),false);
    Path successFilePath=new Path(""/user1/renameSingleNNSucess"");
    hdfs1.delete(successFilePath,false);
    testNfsRename(fromHandle,""renameSingleNN"",fromHandle,""renameSingleNNSucess"",Nfs3Status.NFS3_OK);
    HdfsFileStatus statusAfterRename=nn1.getRpcServer().getFileInfo(""/user1/renameSingleNNSucess"");
    Assert.assertEquals(statusAfterRename.isDirectory(),false);
    statusAfterRename=nn1.getRpcServer().getFileInfo(""/user1/renameSingleNN"");
    Assert.assertEquals(statusAfterRename,null);
}"
"@Test public void expectedOrderingOfMethods() throws Exception {
    assertThat(testResult(Leaf.class),isSuccessful());
    assertEquals(resourceAsString(""trait-property-test-expected.txt""),bytesOut.toString().replaceAll(System.lineSeparator(),""\r\n""));
}"
"@Test public void ctorOnly() throws Exception {
    assertThat(testResult(CtorOnly.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),CtorOnly.iterations);
    assertEquals(new HashSet<>(asList(new CtorOnly.Target(""a""),new CtorOnly.Target(""b""))),new HashSet<>(CtorOnly.values.subList(0,2)));
    CtorOnly.iterations=0;
}"
"@Test public void usesRegularTrialCount() throws Exception {
    assertThat(testResult(EnumTester.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),EnumTester.iterations);
    EnumTester.iterations=0;
}"
"@Test
public void testCheckoutPrepareBuildMultiModuleProject() throws Exception {
    PrepareBuildProjectsTask task = createTask(""src/test-projects/multi-module/pom.xml"", false, false);
    this.prepareBuildQueue.put(task);
    List<Project> projects = getProjectDao().getProjectsInGroup(task.getProjectGroupId());
    assertEquals(""failed to add all projects"", 3, projects.size());
    Project rootProject = getProjectDao().getProjectByName(""multi-module-parent"");
    Project moduleA = getProjectDao().getProjectByName(""module-A"");
    Project moduleB = getProjectDao().getProjectByName(""module-B"");
    while ((!prepareBuildQueue.getQueueSnapshot().isEmpty()) || (prepareBuildTaskQueueExecutor.getCurrentTask() != null)) {
        Thread.sleep(10);
    }
    ProjectScmRoot scmRoot = projectScmRootDao.getProjectScmRoot(task.getProjectScmRootId());
    assertEquals(""Failed to update multi-module project"", UPDATED, scmRoot.getState());
    File workingDir = configurationService.getWorkingDirectory();
    assertTrue(""checkout directory of project 'multi-module-parent' does not exist."", new File(workingDir, Integer.toString(rootProject.getId())).exists());
    assertTrue(""checkout directory of project 'module-A' does not exist."", new File(workingDir, Integer.toString(moduleA.getId())).exists());
    assertTrue(""checkout directory of project 'module-B' does not exist."", new File(workingDir, Integer.toString(moduleB.getId())).exists());
}"
"@Test
public void testNodeMetricsDb() {
    ManualClock clock = new ManualClock();
    NodeMetricsDb db = new NodeMetricsDb();
    List<NodeMetrics.MetricValue> values = new ArrayList<>();
    for (int i = 0; i < 40; i++) {
        values.add(new NodeMetrics.MetricValue(""host0"", ""cpu.util"", clock.instant().getEpochSecond(), 0.9f));
        clock.advance(Duration.ofHours(1));
    }
    db.add(values);
    assertEquals(29, db.getWindow(clock.instant().minus(Duration.ofHours(30)), Resource.cpu,    List.of(""host0"")).measurementCount());
    assertEquals( 0, db.getWindow(clock.instant().minus(Duration.ofHours(30)), Resource.memory, List.of(""host0"")).measurementCount());
    db.gc(clock);
    assertEquals(23, db.getWindow(clock.instant().minus(Duration.ofHours(30)), Resource.cpu,    List.of(""host0"")).measurementCount());
    assertEquals( 0, db.getWindow(clock.instant().minus(Duration.ofHours(30)), Resource.memory, List.of(""host0"")).measurementCount());
}"
"@Test public void testAllowNullSchema() throws JSONException {
    AvroSchema<Foo> avroSchema=AvroSchema.of(SchemaDefinition.<Foo>builder().withPojo(Foo.class).build());
    assertEquals(avroSchema.getSchemaInfo().getType(),SchemaType.AVRO);
    Schema.Parser parser=new Schema.Parser();
    parser.setValidateDefaults(false);
    String schemaJson=new String(avroSchema.getSchemaInfo().getSchema());
    assertJSONEquals(schemaJson,SCHEMA_AVRO_ALLOW_NULL);
    Schema schema=parser.parse(schemaJson);
    for (  String fieldName : FOO_FIELDS) {
        Schema.Field field=schema.getField(fieldName);
        Assert.assertNotNull(field);
        if (field.name().equals(""field4"")) {
            Assert.assertNotNull(field.schema().getTypes().get(1).getField(""field1""));
        }
        if (field.name().equals(""fieldUnableNull"")) {
            Assert.assertNotNull(field.schema().getType());
        }
    }
}"
"@Test public void wrapperShorts() throws Exception {
    assertThat(testResult(WrapperShorts.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperShorts.iterations);
    assertEquals(new HashSet<>(asList(Short.valueOf(""-13""),Short.valueOf(""-14""))),new HashSet<>(WrapperShorts.values.subList(0,2)));
    WrapperShorts.iterations=0;
}"
"@Test
public void testUnbind() throws Exception {
    final Name name = new CompositeName(""test"");
    final Object value = new Object();
    namingStore.bind(name, value);
    namingContext.unbind(name);
    try {
        namingStore.lookup(name);
        fail(""Should have thrown name not found"");
    } catch (NameNotFoundException expect) {}
    testActionPermission(JndiPermission.ACTION_BIND, namingContext, ""test"", value);
    testActionPermission(JndiPermission.ACTION_UNBIND, namingContext, ""test"");
    try {
        namingStore.lookup(name);
        fail(""Should have thrown name not found"");
    } catch (NameNotFoundException expect) {}
}"
"@Test public void favorValueOf() throws Exception {
    assertThat(testResult(FavorValueOf.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),FavorValueOf.iterations);
    assertEquals(new HashSet<>(asList(FavorValueOf.Target.valueOf(""a""),FavorValueOf.Target.valueOf(""b""))),new HashSet<>(FavorValueOf.values.subList(0,2)));
    FavorValueOf.iterations=0;
}"
"@Test
public void testRecordWithJsr310LogicalTypes() throws IOException {
    TestRecordWithJsr310LogicalTypes record = new TestRecordWithJsr310LogicalTypes(
    true,
    34,
    35L,
    3.14F,
    3019.34,
    null,
    java.time.LocalDate.now(),
    java.time.LocalTime.now().truncatedTo(ChronoUnit.MILLIS),
    java.time.Instant.now().truncatedTo(ChronoUnit.MILLIS),
    new BigDecimal(123.45f).setScale(2, BigDecimal.ROUND_HALF_DOWN)
    );
    File data = write(TestRecordWithJsr310LogicalTypes.getClassSchema(), record);
    List<TestRecordWithJsr310LogicalTypes> actual = read(
    TestRecordWithJsr310LogicalTypes.getClassSchema(), data);
    Assert.assertEquals(""Should match written record"", record, actual.get(0));
}"
"@Test
public void canSerializeAdditionalProperties() throws Exception {
    Foo foo = new Foo();
    foo.bar = ""hello.world"";
    foo.baz = new ArrayList<>();
    foo.baz.add(""hello"");
    foo.baz.add(""hello.world"");
    foo.qux = new HashMap<>();
    foo.qux.put(""hello"", ""world"");
    foo.qux.put(""a.b"", ""c.d"");
    foo.qux.put(""bar.a"", ""ttyy"");
    foo.qux.put(""bar.b"", ""uuzz"");
    foo.additionalProperties = new HashMap<>();
    foo.additionalProperties.put(""bar"", ""baz"");
    foo.additionalProperties.put(""a.b"", ""c.d"");
    foo.additionalProperties.put(""properties.bar"", ""barbar"");
    String serialized = new JacksonAdapter().serialize(foo);
    Assert.assertEquals(""{\""$type\"":\""foo\"",\""properties\"":{\""bar\"":\""hello.world\"",\""props\"":{\""baz\"":[\""hello\"",\""hello.world\""],\""q\"":{\""qux\"":{\""hello\"":\""world\"",\""a.b\"":\""c.d\"",\""bar.b\"":\""uuzz\"",\""bar.a\"":\""ttyy\""}}}},\""bar\"":\""baz\"",\""a.b\"":\""c.d\"",\""properties.bar\"":\""barbar\""}"", serialized);
}"
"@Test
public void testIsExpiredTimestampYesterday() {
    LocalDateTime yesterday = LocalDateTime.now().minusDays(1);
    String timestamp = getTimestampFormatter().format(yesterday);
    assertTrue(MavenMetadata.isExpiredTimestamp(timestamp), ""Timestamp should be stale: "" + timestamp);
}"
"@Test public void wrapperBooleans() throws Exception {
    assertThat(testResult(WrapperBooleans.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperBooleans.iterations);
    assertEquals(false,WrapperBooleans.values.get(0));
    assertEquals(new HashSet<>(asList(true,false)),new HashSet<>(WrapperBooleans.values));
    WrapperBooleans.iterations=0;
}"
"public void test_8() throws Exception {
    JSON.defaultTimeZone=TimeZone.getTimeZone(""Asia/Shanghai"");
    DefaultJSONParser parser=new DefaultJSONParser(""\""2011-01-09T13:49:53.254\"""");
    parser.config(Feature.AllowISO8601DateFormat,true);
    Object value=parser.parse();
    Assert.assertEquals(new Date(1294552193254L),value);
}"
"@Test public void testClassFinderDefaultsToOwnPackage() throws Exception {
    ClassFinder allClassesFinder=new ClassFinder(classLoader);
    Set<Class<?>> pkgClasses=allClassesFinder.findClasses(ClassFinder.class.getPackage().getName(),false);
    Set<Class<?>> defaultClasses=allClassesFinder.findClasses(false);
    Object[] pkgClassesArray=pkgClasses.toArray();
    Object[] defaultClassesArray=defaultClasses.toArray();
    assertEquals(pkgClassesArray.length,defaultClassesArray.length);
    assertThat(pkgClassesArray,arrayContainingInAnyOrder(defaultClassesArray));
}"
"@Test public void enums() throws Exception {
    assertThat(testResult(Enums.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),Enums.iterations);
    assertEquals(EnumSet.of(HALF_UP,HALF_EVEN),new HashSet<>(Enums.values.subList(0,2)));
    Enums.iterations=0;
}"
"@Test
public void testRebindReferenceable() throws Exception {
    final Name name = new CompositeName(""test"");
    final TestObjectReferenceable referenceable = new TestObjectReferenceable(""addr"");
    namingContext.bind(name, referenceable);
    TestObjectReferenceable newReferenceable = new TestObjectReferenceable(""newAddr"");
    namingContext.rebind(name, newReferenceable);
    Object result = namingContext.lookup(name);
    assertEquals(newReferenceable.addr, result);
    newReferenceable = new TestObjectReferenceable(""yetAnotherNewAddr"");
    testActionPermission(JndiPermission.ACTION_REBIND, namingContext, ""test"", newReferenceable);
    result = namingContext.lookup(name);
    assertEquals(newReferenceable.addr, result);
}"
"@Test
public void testRebind() throws Exception {
    final Name name = new CompositeName(""test"");
    final Object value = new Object();
    namingStore.bind(name, value);
    Object newValue = new Object();
    namingContext.rebind(name, newValue);
    assertEquals(newValue, namingStore.lookup(name));
    newValue = new Object();
    testActionPermission(JndiPermission.ACTION_REBIND, namingContext, ""test"", newValue);
    assertEquals(newValue, namingStore.lookup(name));
}"
"@Test
public void testBulkUpdateOnTimestampedVersion() {
    TimestampedEntity pc = new TimestampedEntity();
    pc.setName(""Original"");
    EntityManager em = emf.createEntityManager();
    em.getTransaction().begin();
    em.persist(pc);
    em.getTransaction().commit();
    em.getTransaction().begin();
    Timestamp oldVersion = pc.getVersion();
    String jpql = ""UPDATE TimestampedEntity t SET t.name=:newname WHERE t.name=:oldname"";
    em.createQuery(jpql).setParameter(""newname"", ""Updated"").setParameter(""oldname"", ""Original"").executeUpdate();
    em.getTransaction().commit();
    em.getTransaction().begin();
    em.refresh(pc);
    Timestamp newVersion = pc.getVersion();
    assertTrue(newVersion.after(oldVersion));
}"
"@Test
public void testGenerateNewDayPairs() {
    PairCombinations pairs = getPairsList();
    List<Developer> devs = getStandardDevs();
    List<String> tracks = Arrays.asList(""track1"", ""track2"", ""track3"");
    Map<Pair, Integer> pairsWeight = subject.buildPairsWeightFromPastPairing(pairs, devs);
    subject.buildDevelopersPairingDays(pairs, devs);
    DayPairs dayPairs = subject.generateNewDayPairs(tracks, devs, pairs, pairsWeight, getStandardCompanies());
    assertThat(dayPairs.getTracks().size(), is(2));
    assertThat(dayPairs.getTracks(), contains(""track1"", ""track2""));
    assertThat(dayPairs.getPairByTrack(""track1""),
    is(not(new Pair(Arrays.asList(new Developer(""dev1""), new Developer(""dev2""))))));
    assertThat(dayPairs.getPairByTrack(""track2""),
    is(not(new Pair(Arrays.asList(new Developer(""dev3""), new Developer(""dev4""))))));
    boolean trackOneHasContext = dayPairs.getPairByTrack(""track1"").getFirstDev().hasContext() || dayPairs.getPairByTrack(""track1"").getSecondDev().hasContext();
    boolean trackTwoHasContext = dayPairs.getPairByTrack(""track2"").getFirstDev().hasContext() || dayPairs.getPairByTrack(""track2"").getSecondDev().hasContext();
    assertThat(trackOneHasContext, is(true));
    assertThat(trackTwoHasContext, is(true));
}"
"@Test public void primitiveLongs() throws Exception {
    assertThat(testResult(PrimitiveLongs.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveLongs.iterations);
    assertEquals(new HashSet<>(asList(-6L,-7L,-8L)),new HashSet<>(PrimitiveLongs.values.subList(0,3)));
    PrimitiveLongs.iterations=0;
}"
"@Test public void longArray(){
    final WithArrays wa=new WithArrays();
    wa.longArray=new long[]{1L,2L};
    final String exp=getClassPrefix(wa) + ""["" + BR+ ""  boolArray=<null>,""+ BR+ ""  charArray=<null>,""+ BR+ ""  doubleArray=<null>,""+ BR+ ""  intArray=<null>,""+ BR+ ""  longArray={""+ BR+ ""    1,""+ BR+ ""    2""+ BR+ ""  },""+ BR+ ""  stringArray=<null>""+ BR+ ""]"";
    assertEquals(exp,toString(wa));
}"
"@Test
public void testPrematureTimeout() throws Exception {
    final AtomicBoolean failed = new AtomicBoolean(false);
    MockVolt volt = new MockVolt(20000);
    volt.start();
    Distributer dist = new Distributer(false,
    ClientConfig.DEFAULT_PROCEDURE_TIMOUT_NANOS,
    2000,
    false, null);
    dist.addClientStatusListener(new TimeoutMonitorCSL());
    dist.createConnection(""localhost"", """", """", 20000);
    assertTrue(volt.handler != null);
    long start = System.currentTimeMillis();
    while ((System.currentTimeMillis() - start) < 3000) {
        Thread.yield();
    }
    volt.handler.sendResponses.set(false);
    start = System.currentTimeMillis();
    while (!failed.get()) {
        if ((System.currentTimeMillis() - start) > 2000) {
            break;
        } else {
            Thread.yield();
        }
    }
    if ((System.currentTimeMillis() - start) < 2000) {
    fail(""Premature timeout occurred""); }
    dist.shutdown();
    volt.shutdown();
}"
"@Test public void test_AddExtension_Adaptive() throws Exception {
    ExtensionLoader<AddExt2> loader=getExtensionLoader(AddExt2.class);
    loader.addExtension(null,AddExt2_ManualAdaptive.class);
    AddExt2 adaptive=loader.getAdaptiveExtension();
    assertTrue(adaptive instanceof AddExt2_ManualAdaptive);
    ExtensionLoader.resetExtensionLoader(AddExt2.class);
}"
"@Test public void serialize(){
    final LookupCacheKey cacheKey=LookupCacheKey.createFromJSON(""prefix"",""key"");
    final JsonNode node=objectMapper.convertValue(cacheKey,JsonNode.class);
    assertThat(node.isObject()).isTrue();
    assertThat(node.fieldNames()).containsExactlyInAnyOrder(""prefix"",""key"");
    assertThat(node.path(""prefix"").isTextual()).isTrue();
    assertThat(node.path(""prefix"").asText()).isEqualTo(""prefix"");
    assertThat(node.path(""key"").isTextual()).isTrue();
    assertThat(node.path(""key"").asText()).isEqualTo(""key"");
}"
"@Test
public void testHFileLink() throws IOException {
    final String columnFamily = ""f"";
    HRegionInfo hri = new HRegionInfo(Bytes.toBytes(""table-link""));
    Path storedir = new Path(new Path(FSUtils.getRootDir(conf), new Path(hri.getTableNameAsString(), hri.getEncodedName())), columnFamily);
    StoreFile.Writer writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs, 8 * 1024).withOutputDir(storedir).build();
    Path storeFilePath = writer.getPath();
    writeStoreFile(writer);
    writer.close();
    Path dstPath = new Path(FSUtils.getRootDir(conf), new Path(""test-region"", columnFamily));
    HFileLink.create(conf, this.fs, dstPath, hri, storeFilePath.getName());
    Path linkFilePath = new Path(dstPath, HFileLink.createHFileLinkName(hri, storeFilePath.getName()));
    StoreFile hsf = new StoreFile(this.fs, linkFilePath, conf, cacheConf, BloomType.NONE, NoOpDataBlockEncoder.INSTANCE);
    assertTrue(hsf.isLink());
    int count = 1;
    HFileScanner s = hsf.createReader().getScanner(false, false);
    s.seekTo();
    while (s.next()) {
        count++;
    }
    assertEquals(((LAST_CHAR - FIRST_CHAR) + 1) * ((LAST_CHAR - FIRST_CHAR) + 1), count);
}"
"@Test
public void testAdditionalModelTypeAnnotationsSemiColon() throws Exception {
    OpenAPI openAPI = TestUtils.createOpenAPI();
    final AbstractJavaCodegen codegen = new P_AbstractJavaCodegen();
    codegen.additionalProperties().put(ADDITIONAL_MODEL_TYPE_ANNOTATIONS, ""@Foo;@Bar"");
    codegen.processOpts();
    codegen.preprocessOpenAPI(openAPI);
    final List<String> additionalModelTypeAnnotations = new ArrayList<String>();
    additionalModelTypeAnnotations.add(""@Foo"");
    additionalModelTypeAnnotations.add(""@Bar"");
    Assert.assertEquals(codegen.getAdditionalModelTypeAnnotations(), additionalModelTypeAnnotations);
}"
"public void test_multimap() throws Exception {
    Map<String,Integer> map=ImmutableMap.of(""a"",1,""b"",1,""c"",2);
    SetMultimap<String,Integer> multimap=Multimaps.forMap(map);
    Multimap<Integer,String> inverse=Multimaps.invertFrom(multimap,HashMultimap.<Integer,String>create());
    String json=JSON.toJSONString(inverse,SerializerFeature.MapSortField);
    assertTrue(json.equals(""{1:[\""a\"",\""b\""],2:[\""c\""]}"") || json.equals(""{1:[\""b\"",\""a\""],2:[\""c\""]}""));
}"
"public void testForIssue2(){
    String jsonString=""{\""map\"":{\""a\"":[\""1\"",\""2\"",\""3\""],\""b\"":[\""1\""]},\""name\"":\""zhangsan\""}"";
    VO vo=JSON.parseObject(jsonString,VO.class);
    assertEquals(""VO:{name->zhangsan,map->{a=[1, 2, 3], b=[1]}}"",JSON.toJSONString(vo,SerializerFeature.MapSortField));
}"
"@Test
void scanShouldIterateOverAvailableEntries() {
    adapter.put(""1"", object1, COLLECTION_1);
    adapter.put(""2"", object2, COLLECTION_1);
    CloseableIterator<Map.Entry<Object, Object>> iterator = adapter.entries(COLLECTION_1);
    assertThat(iterator.next()).isEqualTo(new AbstractMap.SimpleEntry<>(""1"", object1));
    assertThat(iterator.next()).isEqualTo(new AbstractMap.SimpleEntry<>(""2"", object2));
    assertThat(iterator.hasNext()).isFalse();
}"
"@Test
public void testListBindings() throws Exception {
    bindList();
    NamingEnumeration<Binding> results = namingContext.listBindings(new CompositeName());
    checkListResults(results);
    results = (NamingEnumeration<Binding>) testActionPermission(JndiPermission.ACTION_LIST_BINDINGS, namingContext, null);
    checkListResults(results);
}"
"@Test public void wrapperFloats(){
    assertThat(testResult(WrapperFloats.class),isSuccessful());
    assertEquals(2,WrapperFloats.iterations);
    assertEquals(new HashSet<>(asList(1.7F,-4.14F)),WrapperFloats.testCases);
    WrapperFloats.iterations=0;
}"
"@Test
public void testRefactorXtextGrammarWithoutGeneratedClassifier() throws Exception {
    waitForBuild();
    final XtextEditor editor = openEditor(grammarFile);
    doRefactoring(editor);
    waitForReconciler(editor);
    waitForDisplay();
    waitForBuild();
    checkConsistenceOfGrammar(editor);
}"
"@Test
void close() throws Exception {
    when(webSocketClient.getConnection()).thenReturn(webSocket);
    when(webSocketClient.isOpen()).thenReturn(true);
    webSocketConnection.close();
    Thread.sleep(10);
    verify(webSocket).close();
}"
"@Test public void testPartialRepair() throws InterruptedException {
    Collection<LongTokenRange> ranges=new ArrayList<>();
    LongTokenRange range1=new LongTokenRange(1,2);
    LongTokenRange range2=new LongTokenRange(3,4);
    ranges.add(range1);
    ranges.add(range2);
    final RepairTask repairTask=new RepairTask.Builder().withJMXProxyFactory(jmxProxyFactory).withTableReference(myTableReference).withTokenRanges(ranges).withTableRepairMetrics(myTableRepairMetrics).withRepairHistory(repairHistory).withJobId(jobId).withReplicas(participants).build();
    CountDownLatch cdl=startRepair(repairTask,false);
    Notification notification=new Notification(""progress"",""repair:1"",0,getRepairMessage(range1));
    notification.setUserData(getNotificationData(RepairTask.ProgressEventType.PROGRESS.ordinal(),1,2));
    proxy.notify(notification);
    notification=new Notification(""progress"",""repair:1"",1,getRepairMessage(range2));
    notification.setUserData(getNotificationData(RepairTask.ProgressEventType.PROGRESS.ordinal(),2,2));
    proxy.notify(notification);
    notification=new Notification(""progress"",""repair:1"",2,""Done with repair"");
    notification.setUserData(getNotificationData(RepairTask.ProgressEventType.COMPLETE.ordinal(),2,2));
    proxy.notify(notification);
    cdl.await();
    assertThat(repairTask.getUnknownRanges()).isNull();
    assertThat(repairTask.getCompletedRanges()).containsExactlyInAnyOrderElementsOf(ranges);
    assertThat(proxy.myOptions.get(RepairOptions.RANGES_KEY)).isNotEmpty();
    verify(myTableRepairMetrics).repairTiming(eq(TABLE_REFERENCE),anyLong(),any(TimeUnit.class),eq(true));
    verify(repairSessions.get(range1)).start();
    verify(repairSessions.get(range2)).start();
    verify(repairSessions.get(range1)).finish(eq(RepairStatus.SUCCESS));
    verify(repairSessions.get(range2)).finish(eq(RepairStatus.SUCCESS));
}"
"@Test
public void journalBlockDeletion() throws Exception {
    FileSystem fs = mCluster.getClient();
    BlockMaster blockMaster = mCluster.getLocalAlluxioMaster().getMasterProcess().getMaster(BlockMaster.class);
    AlluxioURI file = new AlluxioURI(""/test"");
    FileSystemTestUtils.createByteFile(fs, file, MUST_CACHE, 10);
    URIStatus status = fs.getStatus(file);
    Long blockId = status.getBlockIds().get(0);
    assertNotNull(blockMaster.getBlockInfo(blockId));
    fs.delete(file);
    WorkerNetAddress workerAddress = mCluster.getWorkerAddress();
    try {
        blockMaster.getBlockInfo(blockId);
        fail(""Expected the block to be deleted"");
    } catch (BlockInfoException e) {
    }
    mCluster.stopMasters();
    mCluster.startMasters();
    AlluxioMasterProcess masterProcess = mCluster.getLocalAlluxioMaster().getMasterProcess();
    try {
        masterProcess.getMaster(BlockMaster.class).getBlockInfo(blockId);
        fail(""Expected the block to be deleted after restart"");
    } catch (BlockInfoException e) {
    }
}"
"@Test
public void testEviction() throws Exception {
    final int CAPACITY = 3;
    PeerCache cache = PeerCache.getInstance(CAPACITY, 100000);
    DatanodeID dnIds[] = new DatanodeID[CAPACITY + 1];
    FakePeer peers[] = new FakePeer[CAPACITY + 1];
    for (int i = 0; i < dnIds.length; ++i) {
        dnIds[i] = new DatanodeID(""192.168.0.1"",
        ""fakehostname_"" + i, ""fake_storage_id_"" + i,
        100, 101, 102);
        peers[i] = new FakePeer(dnIds[i], false);
    }
    for (int i = 0; i < CAPACITY; ++i) {
        cache.put(dnIds[i], peers[i]);
    }
    assertEquals(CAPACITY, cache.size());
    cache.put(dnIds[CAPACITY], peers[CAPACITY]);
    assertEquals(CAPACITY, cache.size());
    assertSame(null, cache.get(dnIds[0], false));
    for (int i = 1; i < CAPACITY; ++i) {
        Peer peer = cache.get(dnIds[i], false);
        assertSame(peers[i], peer);
        assertTrue(!peer.isClosed());
        peer.close();
    }
    assertEquals(1, cache.size());
    cache.close();
}"
"@Test public void wrapperLongs() throws Exception {
    assertThat(testResult(WrapperLongs.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperLongs.iterations);
    assertEquals(new HashSet<>(asList(10L,11L,12L)),new HashSet<>(WrapperLongs.values.subList(0,3)));
    WrapperLongs.iterations=0;
}"
"@Test
public void testPublishFailsForClosedConnection() throws JMSException {
    Connection tempConnection = factory.createConnection();
    Session tempSession = tempConnection.createSession(false, AUTO_ACKNOWLEDGE);
    TemporaryQueue queue = tempSession.createTemporaryQueue();
    Session session = connection.createSession(false, AUTO_ACKNOWLEDGE);
    connection.start();
    MessageProducer producer = session.createProducer(queue);
    producer.setDeliveryMode(NON_PERSISTENT);
    TextMessage message = session.createTextMessage(""First"");
    producer.send(message);
    tempConnection.close();
    try {
        message = session.createTextMessage(""Hello"");
        producer.send(message);
        fail(""Send should fail since temp destination should not exist anymore."");
    } catch (JMSException e) {
        assertTrue(""failed to throw an exception"", true);
    }
}"
"@Test
public void testFireSubTreeEvent() throws Exception {
    final NamingEventCoordinator coordinator = new NamingEventCoordinator();
    final CollectingListener objectListener = new CollectingListener(0);
    coordinator.addListener(""test/path"", EventContext.OBJECT_SCOPE, objectListener);
    final CollectingListener subtreeListener = new CollectingListener(1);
    coordinator.addListener(""test"", EventContext.SUBTREE_SCOPE, subtreeListener);
    final CollectingListener oneLevelListener = new CollectingListener(0);
    coordinator.addListener(""test"", EventContext.ONELEVEL_SCOPE, oneLevelListener);
    coordinator.fireEvent(context, new CompositeName(""test/path""), null, null, NamingEvent.OBJECT_ADDED, ""bind"", EventContext.SUBTREE_SCOPE);
    subtreeListener.latch.await(1, TimeUnit.SECONDS);
    assertTrue(objectListener.capturedEvents.isEmpty());
    assertTrue(oneLevelListener.capturedEvents.isEmpty());
    assertEquals(1, subtreeListener.capturedEvents.size());
}"
"/**
* Binds an entry and then do lookups with several permissions
* @throws Exception
*/
@Test public void testPermissions() throws Exception {
    final NamingContext namingContext=new NamingContext(store,null);
    final String name=""a/b"";
    final Object value=new Object();
    ArrayList<JndiPermission> permissions=new ArrayList<JndiPermission>();
    WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);
    try {
        permissions.add(new JndiPermission(store.getBaseName() + ""/"" + name,""bind,list,listBindings""));
        Name nameObj=new CompositeName(name);
        store.bind(nameObj,value);
        store.lookup(nameObj);
    }
    finally {
        WritableServiceBasedNamingStore.popOwner();
    }
    permissions.set(0,new JndiPermission(store.getBaseName() + ""/"" + name,JndiPermission.ACTION_LOOKUP));
    assertEquals(value,testActionWithPermission(JndiPermission.ACTION_LOOKUP,permissions,namingContext,name));
    permissions.set(0,new JndiPermission(store.getBaseName() + ""/-"",JndiPermission.ACTION_LOOKUP));
    assertEquals(value,testActionWithPermission(JndiPermission.ACTION_LOOKUP,permissions,namingContext,name));
    permissions.set(0,new JndiPermission(store.getBaseName() + ""/a/*"",JndiPermission.ACTION_LOOKUP));
    assertEquals(value,testActionWithPermission(JndiPermission.ACTION_LOOKUP,permissions,namingContext,name));
    permissions.set(0,new JndiPermission(store.getBaseName() + ""/a/-"",JndiPermission.ACTION_LOOKUP));
    assertEquals(value,testActionWithPermission(JndiPermission.ACTION_LOOKUP,permissions,namingContext,name));
    permissions.set(0,new JndiPermission(""<<ALL BINDINGS>>"",JndiPermission.ACTION_LOOKUP));
    assertEquals(value,testActionWithPermission(JndiPermission.ACTION_LOOKUP,permissions,namingContext,name));
    permissions.set(0,new JndiPermission(store.getBaseName() + ""/"" + name,JndiPermission.ACTION_LOOKUP));
    assertEquals(value,testActionWithPermission(JndiPermission.ACTION_LOOKUP,permissions,namingContext,store.getBaseName() + ""/"" + name));
    NamingContext aNamingContext=(NamingContext)namingContext.lookup(""a"");
    permissions.set(0,new JndiPermission(store.getBaseName() + ""/"" + name,JndiPermission.ACTION_LOOKUP));
    assertEquals(value,testActionWithPermission(JndiPermission.ACTION_LOOKUP,permissions,aNamingContext,""b""));
    try {
        testActionWithPermission(JndiPermission.ACTION_LOOKUP,Collections.<JndiPermission>emptyList(),namingContext,name);
        fail(""Should have failed due to missing permission"");
    }
    catch (  AccessControlException e) {
    }
    try {
        permissions.set(0,new JndiPermission(store.getBaseName() + ""/*"",JndiPermission.ACTION_LOOKUP));
        testActionWithPermission(JndiPermission.ACTION_LOOKUP,permissions,namingContext,name);
        fail(""Should have failed due to missing permission"");
    }
    catch (  AccessControlException e) {
    }
    try {
        permissions.set(0,new JndiPermission(name,JndiPermission.ACTION_LOOKUP));
        testActionWithPermission(JndiPermission.ACTION_LOOKUP,permissions,namingContext,name);
        fail(""Should have failed due to missing permission"");
    }
    catch (  AccessControlException e) {
    }
    if (!""java:"".equals(store.getBaseName().toString())) {
        try {
            permissions.set(0,new JndiPermission(""/"" + name,JndiPermission.ACTION_LOOKUP));
            testActionWithPermission(JndiPermission.ACTION_LOOKUP,permissions,namingContext,name);
            fail(""Should have failed due to missing permission"");
        }
        catch (    AccessControlException e) {
        }
        try {
            permissions.set(0,new JndiPermission(""/-"",JndiPermission.ACTION_LOOKUP));
            testActionWithPermission(JndiPermission.ACTION_LOOKUP,permissions,namingContext,name);
            fail(""Should have failed due to missing permission"");
        }
        catch (    AccessControlException e) {
        }
    }
}"
"@Test public void test_replaceExtension_Adaptive() throws Exception {
    ExtensionLoader<AddExt3> loader=getExtensionLoader(AddExt3.class);
    AddExt3 adaptive=loader.getAdaptiveExtension();
    assertFalse(adaptive instanceof AddExt3_ManualAdaptive);
    loader.replaceExtension(null,AddExt3_ManualAdaptive.class);
    adaptive=loader.getAdaptiveExtension();
    assertTrue(adaptive instanceof AddExt3_ManualAdaptive);
    ExtensionLoader.resetExtensionLoader(AddExt3.class);
}"
"@Test public void testAllowNullSchema() throws JSONException {
    JSONSchema<Foo> jsonSchema=JSONSchema.of(SchemaDefinition.<Foo>builder().withPojo(Foo.class).build());
    Assert.assertEquals(jsonSchema.getSchemaInfo().getType(),SchemaType.JSON);
    Schema.Parser parser=new Schema.Parser();
    parser.setValidateDefaults(false);
    String schemaJson=new String(jsonSchema.getSchemaInfo().getSchema());
    assertJSONEqual(schemaJson,SCHEMA_JSON_ALLOW_NULL);
    Schema schema=parser.parse(schemaJson);
    for (  String fieldName : FOO_FIELDS) {
        Schema.Field field=schema.getField(fieldName);
        Assert.assertNotNull(field);
        if (field.name().equals(""field4"")) {
            Assert.assertNotNull(field.schema().getTypes().get(1).getField(""field1""));
        }
        if (field.name().equals(""fieldUnableNull"")) {
            Assert.assertNotNull(field.schema().getType());
        }
    }
}"
"@Test
public void testBus() throws Exception {
    final ToBreakRunner runner = new ToBreakRunner(""dig/circuitBuilder/busTest.dig"", false);
    TruthTable tt = new ModelAnalyser(runner.getModel()).analyse();
    assertEquals(8, tt.getVars().size());
    assertEquals(8, tt.getResultCount());
    ExpressionListenerStore expr = new ExpressionListenerStore(null);
    new ExpressionCreator(tt).create(expr);
    CircuitBuilder circuitBuilder = new CircuitBuilder(runner.getLibrary().getShapeFactory(), tt.getVars()).setModelAnalyzerInfo(tt.getModelAnalyzerInfo());
    new BuilderExpressionCreator(circuitBuilder).create(expr);
    Circuit circuit = circuitBuilder.createCircuit();
    List<VisualElement> in = circuit.getElements(( v) -> v.equalsDescription(In.DESCRIPTION));
    assertEquals(2, in.size());
    checkPin(in.get(0), ""A"", ""1,2,3,4"");
    checkPin(in.get(1), ""B"", ""5,6,7,8"");
    List<VisualElement> out = circuit.getElements(( v) -> v.equalsDescription(Out.DESCRIPTION));
    assertEquals(2, out.size());
    checkPin(out.get(0), ""S"", ""9,10,11,12"");
    checkPin(out.get(1), ""U"", ""13,14,15,16"");
}"
"@Test
public void testRegisterURLSchemeHandler() throws Exception {
    InitialContext ictx = new InitialContext(null);
    try {
        ictx.lookup(""foobar:something"");
        Assert.fail(""Precondition: the foobar: scheme should not yet be registered"");
    } catch (NamingException ne) {
    }
    ObjectFactory tof = new TestObjectFactory();
    InitialContext.addUrlContextFactory(""foobar"", tof);
    String something = (String) ictx.lookup(""foobar:something"");
    Assert.assertTrue(""The object should now be provided by our TestObjectFactory"", something.startsWith(""TestObject:""));
    try {
        InitialContext.removeUrlContextFactory(""foobar:"", new TestObjectFactory());
        Assert.fail(""Should throw an IllegalArgumentException since the associated factory object doesn't match the registration"");
    } catch (IllegalArgumentException iae) {
    }
    Assert.assertEquals(""The foobar: scheme should still be registered"", something, ictx.lookup(""foobar:something""));
    InitialContext.removeUrlContextFactory(""foobar"", tof);
    try {
        ictx.lookup(""foobar:something"");
        Assert.fail(""The foobar: scheme should not be registered any more"");
    } catch (NamingException ne) {
    }
}"
"public void test_f() throws Exception {
    String text=""parent.callback ({'id':1, 'name':'ido)nans'},1,2 );   /**/ "";
    JSONPObject jsonpObject=(JSONPObject)JSON.parseObject(text,JSONPObject.class);
    assertEquals(""parent.callback"",jsonpObject.getFunction());
    assertEquals(3,jsonpObject.getParameters().size());
    JSONObject param=(JSONObject)jsonpObject.getParameters().get(0);
    assertEquals(1,param.get(""id""));
    assertEquals(""ido)nans"",param.get(""name""));
    String json=JSON.toJSONString(jsonpObject,SerializerFeature.BrowserSecure,SerializerFeature.MapSortField);
    assertEquals(""/**/parent.callback({\""id\"":1,\""name\"":\""ido\\u0029nans\""},1,2)"",json);
}"
"@Test
public void testWorkflowTokenPut() throws Exception {
    Assert.assertEquals(200, deploy(WorkflowTokenTestPutApp.class).getStatusLine().getStatusCode());
    Id.Application appId = Id.Application.from(Id.Namespace.DEFAULT, WorkflowTokenTestPutApp.NAME);
    Id.Workflow workflowId = Id.Workflow.from(appId, WorkflowTokenTestPutApp.WorkflowTokenTestPut.NAME);
    Id.Program mapReduceId = Id.Program.from(appId, ProgramType.MAPREDUCE, WorkflowTokenTestPutApp.RecordCounter.NAME);
    Id.Program sparkId = Id.Program.from(appId, ProgramType.SPARK, WorkflowTokenTestPutApp.SparkTestApp.NAME);
    String outputPath = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
    startProgram(workflowId, ImmutableMap.of(""inputPath"", createInputForRecordVerification(""firstInput""),
    ""outputPath"", outputPath, ""put.in.mapper.initialize"", ""true""));
    waitState(workflowId, ProgramRunStatus.RUNNING.name());
    waitState(workflowId, ""STOPPED"");
    List<RunRecord> workflowProgramRuns = getProgramRuns(workflowId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(1, workflowProgramRuns.size());
    List<RunRecord> mapReduceProgramRuns = getProgramRuns(mapReduceId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(1, mapReduceProgramRuns.size());
    outputPath = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
    startProgram(workflowId, ImmutableMap.of(""inputPath"", createInputForRecordVerification(""secondInput""),
    ""outputPath"", outputPath, ""put.in.map"", ""true""));
    waitState(workflowId, ProgramRunStatus.RUNNING.name());
    waitState(workflowId, ""STOPPED"");
    workflowProgramRuns = getProgramRuns(workflowId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(2, workflowProgramRuns.size());
    mapReduceProgramRuns = getProgramRuns(mapReduceId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(2, mapReduceProgramRuns.size());
    outputPath = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
    startProgram(workflowId, ImmutableMap.of(""inputPath"", createInputForRecordVerification(""thirdInput""),
    ""outputPath"", outputPath, ""put.in.reducer.initialize"", ""true""));
    waitState(workflowId, ProgramRunStatus.RUNNING.name());
    waitState(workflowId, ""STOPPED"");
    workflowProgramRuns = getProgramRuns(workflowId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(3, workflowProgramRuns.size());
    mapReduceProgramRuns = getProgramRuns(mapReduceId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(3, mapReduceProgramRuns.size());
    outputPath = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
    startProgram(workflowId, ImmutableMap.of(""inputPath"", createInputForRecordVerification(""fourthInput""),
    ""outputPath"", outputPath, ""put.in.reduce"", ""true""));
    waitState(workflowId, ProgramRunStatus.RUNNING.name());
    waitState(workflowId, ""STOPPED"");
    workflowProgramRuns = getProgramRuns(workflowId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(4, workflowProgramRuns.size());
    mapReduceProgramRuns = getProgramRuns(mapReduceId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(4, mapReduceProgramRuns.size());
    outputPath = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
    startProgram(workflowId, ImmutableMap.of(""inputPath"", createInputForRecordVerification(""fifthInput""),
    ""outputPath"", outputPath, ""closurePutToken"", ""true""));
    waitState(workflowId, ProgramRunStatus.RUNNING.name());
    waitState(workflowId, ""STOPPED"");
    workflowProgramRuns = getProgramRuns(workflowId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(5, workflowProgramRuns.size());
    mapReduceProgramRuns = getProgramRuns(mapReduceId, ProgramRunStatus.COMPLETED.name());
    Assert.assertEquals(1, mapReduceProgramRuns.size());
    List<RunRecord> sparkProgramRuns = getProgramRuns(sparkId, ProgramRunStatus.FAILED.name());
    Assert.assertEquals(1, sparkProgramRuns.size());
    outputPath = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
    startProgram(workflowId, ImmutableMap.of(""inputPath"", createInputForRecordVerification(""sixthInput""),
    ""outputPath"", outputPath));
    waitState(workflowId, ProgramRunStatus.RUNNING.name());
    waitState(workflowId, ""STOPPED"");
    workflowProgramRuns = getProgramRuns(workflowId, ProgramRunStatus.COMPLETED.name());
    Assert.assertEquals(1, workflowProgramRuns.size());
    workflowProgramRuns = getProgramRuns(sparkId, ProgramRunStatus.COMPLETED.name());
    Assert.assertEquals(1, workflowProgramRuns.size());
}"
"@Test
public void testMaxLimits() throws Exception {
    LocalConnFactory connFactory = Mockito.mock(LocalConnFactory.class);
    HttpConnection conn1 = Mockito.mock(HttpConnection.class);
    Mockito.when(connFactory.create(Mockito.eq(""somehost""))).thenReturn(conn1);
    HttpConnection conn2 = Mockito.mock(HttpConnection.class);
    Mockito.when(connFactory.create(Mockito.eq(""otherhost""))).thenReturn(conn2);
    LocalConnPool pool = new LocalConnPool(connFactory, 2, 10);
    pool.setMaxPerRoute(""somehost"", 2);
    pool.setMaxPerRoute(""otherhost"", 1);
    pool.setMaxTotal(3);
    Future<LocalPoolEntry> future1 = pool.lease(""somehost"", null);
    GetPoolEntryThread t1 = new GetPoolEntryThread(future1);
    t1.start();
    Future<LocalPoolEntry> future2 = pool.lease(""somehost"", null);
    GetPoolEntryThread t2 = new GetPoolEntryThread(future2);
    t2.start();
    Future<LocalPoolEntry> future3 = pool.lease(""otherhost"", null);
    GetPoolEntryThread t3 = new GetPoolEntryThread(future3);
    t3.start();
    t1.join(GRACE_PERIOD);
    Assert.assertTrue(future1.isDone());
    LocalPoolEntry entry1 = t1.getEntry();
    Assert.assertNotNull(entry1);
    t2.join(GRACE_PERIOD);
    Assert.assertTrue(future2.isDone());
    LocalPoolEntry entry2 = t2.getEntry();
    Assert.assertNotNull(entry2);
    t3.join(GRACE_PERIOD);
    Assert.assertTrue(future3.isDone());
    LocalPoolEntry entry3 = t3.getEntry();
    Assert.assertNotNull(entry3);
    pool.release(entry1, true);
    pool.release(entry2, true);
    pool.release(entry3, true);
    PoolStats totals = pool.getTotalStats();
    Assert.assertEquals(3, totals.getAvailable());
    Assert.assertEquals(0, totals.getLeased());
    Future<LocalPoolEntry> future4 = pool.lease(""somehost"", null);
    GetPoolEntryThread t4 = new GetPoolEntryThread(future4);
    t4.start();
    Future<LocalPoolEntry> future5 = pool.lease(""somehost"", null);
    GetPoolEntryThread t5 = new GetPoolEntryThread(future5);
    t5.start();
    Future<LocalPoolEntry> future6 = pool.lease(""otherhost"", null);
    GetPoolEntryThread t6 = new GetPoolEntryThread(future6);
    t6.start();
    t4.join(GRACE_PERIOD);
    Assert.assertTrue(future4.isDone());
    LocalPoolEntry entry4 = t4.getEntry();
    Assert.assertNotNull(entry4);
    t5.join(GRACE_PERIOD);
    Assert.assertTrue(future5.isDone());
    LocalPoolEntry entry5 = t5.getEntry();
    Assert.assertNotNull(entry5);
    t6.join(GRACE_PERIOD);
    Assert.assertTrue(future6.isDone());
    LocalPoolEntry entry6 = t6.getEntry();
    Assert.assertNotNull(entry6);
    Future<LocalPoolEntry> future7 = pool.lease(""somehost"", null);
    GetPoolEntryThread t7 = new GetPoolEntryThread(future7);
    t7.start();
    Future<LocalPoolEntry> future8 = pool.lease(""somehost"", null);
    GetPoolEntryThread t8 = new GetPoolEntryThread(future8);
    t8.start();
    Future<LocalPoolEntry> future9 = pool.lease(""otherhost"", null);
    GetPoolEntryThread t9 = new GetPoolEntryThread(future9);
    t9.start();
    Assert.assertFalse(t7.isDone());
    Assert.assertFalse(t8.isDone());
    Assert.assertFalse(t9.isDone());
    Mockito.verify(connFactory, Mockito.times(3)).create(Mockito.any(String.class));
    pool.release(entry4, true);
    pool.release(entry5, false);
    pool.release(entry6, true);
    t7.join();
    Assert.assertTrue(future7.isDone());
    t8.join();
    Assert.assertTrue(future8.isDone());
    t9.join();
    Assert.assertTrue(future9.isDone());
    Mockito.verify(connFactory, Mockito.times(4)).create(Mockito.any(String.class));
}"
"@Test public void primitiveLongs() throws Exception {
    assertThat(testResult(PrimitiveLongs.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveLongs.iterations);
    assertEquals(new HashSet<>(asList(-6L,-7L,-8L)),new HashSet<>(PrimitiveLongs.values.subList(0,3)));
    PrimitiveLongs.iterations=0;
}"
"@SuppressWarnings(""unchecked"") @Test public void testStandardUnionObjectInspector() throws Throwable {
    try {
        ArrayList<ObjectInspector> objectInspectors=new ArrayList<ObjectInspector>();
        objectInspectors.add(PrimitiveObjectInspectorFactory.javaIntObjectInspector);
        objectInspectors.add(PrimitiveObjectInspectorFactory.javaStringObjectInspector);
        objectInspectors.add(PrimitiveObjectInspectorFactory.javaBooleanObjectInspector);
        objectInspectors.add(ObjectInspectorFactory.getStandardListObjectInspector(PrimitiveObjectInspectorFactory.javaIntObjectInspector));
        objectInspectors.add(ObjectInspectorFactory.getStandardMapObjectInspector(PrimitiveObjectInspectorFactory.javaIntObjectInspector,PrimitiveObjectInspectorFactory.javaStringObjectInspector));
        List<String> fieldNames=new ArrayList<String>();
        fieldNames.add(""myDouble"");
        fieldNames.add(""myLong"");
        ArrayList<ObjectInspector> fieldObjectInspectors=new ArrayList<ObjectInspector>();
        fieldObjectInspectors.add(PrimitiveObjectInspectorFactory.javaDoubleObjectInspector);
        fieldObjectInspectors.add(PrimitiveObjectInspectorFactory.javaLongObjectInspector);
        objectInspectors.add(ObjectInspectorFactory.getStandardStructObjectInspector(fieldNames,fieldObjectInspectors));
        StandardUnionObjectInspector uoi1=ObjectInspectorFactory.getStandardUnionObjectInspector(objectInspectors);
        StandardUnionObjectInspector uoi2=ObjectInspectorFactory.getStandardUnionObjectInspector((ArrayList<ObjectInspector>)objectInspectors.clone());
        assertEquals(uoi1,uoi2);
        assertEquals(ObjectInspectorUtils.getObjectInspectorName(uoi1),ObjectInspectorUtils.getObjectInspectorName(uoi2));
        assertTrue(ObjectInspectorUtils.compareTypes(uoi1,uoi2));
        assertFalse(ObjectInspectorUtils.compareSupported(uoi1));
        ArrayList<ObjectInspector> ois=(ArrayList<ObjectInspector>)objectInspectors.clone();
        ois.set(4,PrimitiveObjectInspectorFactory.javaIntObjectInspector);
        assertTrue(ObjectInspectorUtils.compareSupported(ObjectInspectorFactory.getStandardUnionObjectInspector(ois)));
        assertEquals(Category.UNION,uoi1.getCategory());
        List<? extends ObjectInspector> uois=uoi1.getObjectInspectors();
        assertEquals(6,uois.size());
        for (int i=0; i < 6; i++) {
            assertEquals(objectInspectors.get(i),uois.get(i));
        }
        StringBuilder unionTypeName=new StringBuilder();
        unionTypeName.append(""uniontype<"");
        for (int i=0; i < uois.size(); i++) {
            if (i > 0) {
                unionTypeName.append("","");
            }
            unionTypeName.append(uois.get(i).getTypeName());
        }
        unionTypeName.append("">"");
        assertEquals(unionTypeName.toString(),uoi1.getTypeName());
        TypeInfo typeInfo1=TypeInfoUtils.getTypeInfoFromObjectInspector(uoi1);
        assertEquals(Category.UNION,typeInfo1.getCategory());
        assertEquals(UnionTypeInfo.class.getName(),typeInfo1.getClass().getName());
        assertEquals(typeInfo1.getTypeName(),uoi1.getTypeName());
        assertEquals(typeInfo1,TypeInfoUtils.getTypeInfoFromTypeString(uoi1.getTypeName()));
        TypeInfo typeInfo2=TypeInfoUtils.getTypeInfoFromObjectInspector(uoi2);
        assertEquals(typeInfo1,typeInfo2);
        assertEquals(TypeInfoUtils.getStandardJavaObjectInspectorFromTypeInfo(typeInfo1),TypeInfoUtils.getStandardJavaObjectInspectorFromTypeInfo(typeInfo2));
        assertEquals(TypeInfoUtils.getStandardWritableObjectInspectorFromTypeInfo(typeInfo1),TypeInfoUtils.getStandardWritableObjectInspectorFromTypeInfo(typeInfo2));
        assertNull(uoi1.getField(null));
        assertEquals(-1,uoi1.getTag(null));
        UnionObject union=new StandardUnion((byte)0,1);
        assertEquals(0,uoi1.getTag(union));
        assertEquals(1,uoi1.getField(union));
        assertEquals(""{0:1}"",SerDeUtils.getJSONString(union,uoi1));
        assertEquals(0,ObjectInspectorUtils.compare(union,uoi1,new StandardUnion((byte)0,1),uoi2));
        assertTrue(ObjectInspectorUtils.copyToStandardObject(union,uoi1).equals(1));
        union=new StandardUnion((byte)1,""two"");
        assertEquals(1,uoi1.getTag(union));
        assertEquals(""two"",uoi1.getField(union));
        assertEquals(""{1:\""two\""}"",SerDeUtils.getJSONString(union,uoi1));
        assertEquals(0,ObjectInspectorUtils.compare(union,uoi1,new StandardUnion((byte)1,""two""),uoi2));
        assertTrue(ObjectInspectorUtils.copyToStandardObject(union,uoi1).equals(""two""));
        union=new StandardUnion((byte)2,true);
        assertEquals(2,uoi1.getTag(union));
        assertEquals(true,uoi1.getField(union));
        assertEquals(""{2:true}"",SerDeUtils.getJSONString(union,uoi1));
        assertEquals(0,ObjectInspectorUtils.compare(union,uoi1,new StandardUnion((byte)2,true),uoi2));
        assertTrue(ObjectInspectorUtils.copyToStandardObject(union,uoi1).equals(true));
        ArrayList<Integer> iList=new ArrayList<Integer>();
        iList.add(4);
        iList.add(5);
        union=new StandardUnion((byte)3,iList);
        assertEquals(3,uoi1.getTag(union));
        assertEquals(iList,uoi1.getField(union));
        assertEquals(""{3:[4,5]}"",SerDeUtils.getJSONString(union,uoi1));
        assertEquals(0,ObjectInspectorUtils.compare(union,uoi1,new StandardUnion((byte)3,iList.clone()),uoi2));
        assertTrue(ObjectInspectorUtils.copyToStandardObject(union,uoi1).equals(iList));
        HashMap<Integer,String> map=new LinkedHashMap<Integer,String>();
        map.put(6,""six"");
        map.put(7,""seven"");
        map.put(8,""eight"");
        union=new StandardUnion((byte)4,map);
        assertEquals(4,uoi1.getTag(union));
        assertEquals(map,uoi1.getField(union));
        assertEquals(""{4:{6:\""six\"",7:\""seven\"",8:\""eight\""}}"",SerDeUtils.getJSONString(union,uoi1));
        Throwable th=null;
        try {
            ObjectInspectorUtils.compare(union,uoi1,new StandardUnion((byte)4,map.clone()),uoi2,null);
        }
        catch (    Throwable t) {
            th=t;
        }
        assertNotNull(th);
        assertEquals(""Compare on map type not supported!"",th.getMessage());
        assertTrue(ObjectInspectorUtils.copyToStandardObject(union,uoi1).equals(map));
        ArrayList<Object> struct=new ArrayList<Object>(2);
        struct.add(9.0);
        struct.add(10L);
        union=new StandardUnion((byte)5,struct);
        assertEquals(5,uoi1.getTag(union));
        assertEquals(struct,uoi1.getField(union));
        assertEquals(""{5:{\""mydouble\"":9.0,\""mylong\"":10}}"",SerDeUtils.getJSONString(union,uoi1));
        assertEquals(0,ObjectInspectorUtils.compare(union,uoi1,new StandardUnion((byte)5,struct.clone()),uoi2));
        assertTrue(ObjectInspectorUtils.copyToStandardObject(union,uoi1).equals(struct));
    }
    catch (  Throwable e) {
        e.printStackTrace();
        throw e;
    }
}"
"@Test public void primitiveFloats() throws Exception {
    assertThat(testResult(PrimitiveFloats.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveFloats.iterations);
    assertEquals(new HashSet<>(asList(3.3F,-5F)),new HashSet<>(PrimitiveFloats.values.subList(0,2)));
    PrimitiveFloats.iterations=0;
}"
"@Test public void testDubboProtocolWithMina() throws Exception {
    DemoService service=new DemoServiceImpl();
    protocol.export(proxy.getInvoker(service,DemoService.class,URL.valueOf(""dubbo://127.0.0.1:9011/"" + DemoService.class.getName()).addParameter(Constants.SERVER_KEY,""mina"")));
    service=proxy.getProxy(protocol.refer(DemoService.class,URL.valueOf(""dubbo://127.0.0.1:9011/"" + DemoService.class.getName()).addParameter(Constants.CLIENT_KEY,""mina"").addParameter(""timeout"",3000l)));
    for (int i=0; i < 10; i++) {
        assertEquals(service.enumlength(new Type[]{}),Type.Lower);
        assertEquals(service.getSize(null),-1);
        assertEquals(service.getSize(new String[]{"""","""",""""}),3);
    }
    Map<String,String> map=new HashMap<String,String>();
    map.put(""aa"",""bb"");
    for (int i=0; i < 10; i++) {
        Set<String> set=service.keys(map);
        assertEquals(set.size(),1);
        assertEquals(set.iterator().next(),""aa"");
        service.invoke(""dubbo://127.0.0.1:9010/"" + DemoService.class.getName() + """",""invoke"");
    }
    service=proxy.getProxy(protocol.refer(DemoService.class,URL.valueOf(""dubbo://127.0.0.1:9011/"" + DemoService.class.getName() + ""?client=mina"").addParameter(""timeout"",3000l)));
    StringBuffer buf=new StringBuffer();
    for (int i=0; i < 1024 * 32 + 32; i++)   buf.append('A');
    System.out.println(service.stringLength(buf.toString()));
    EchoService echo=proxy.getProxy(protocol.refer(EchoService.class,URL.valueOf(""dubbo://127.0.0.1:9011/"" + DemoService.class.getName() + ""?client=mina"").addParameter(""timeout"",3000l)));
    for (int i=0; i < 10; i++) {
        assertEquals(echo.$echo(buf.toString()),buf.toString());
        assertEquals(echo.$echo(""test""),""test"");
        assertEquals(echo.$echo(""abcdefg""),""abcdefg"");
        assertEquals(echo.$echo(1234),1234);
    }
}"
"@Test public void testAdditionalModelTypeAnnotationsMixed() throws Exception {
    OpenAPI openAPI=TestUtils.createOpenAPI();
    final AbstractJavaCodegen codegen=new P_AbstractJavaCodegen();
    codegen.additionalProperties().put(AbstractJavaCodegen.ADDITIONAL_MODEL_TYPE_ANNOTATIONS,"" \t @Foo;\r\n@Bar  ;\n @Foobar  "");
    codegen.processOpts();
    codegen.preprocessOpenAPI(openAPI);
    final List<String> additionalModelTypeAnnotations=new ArrayList<String>();
    additionalModelTypeAnnotations.add(""@Foo"");
    additionalModelTypeAnnotations.add(""@Bar"");
    additionalModelTypeAnnotations.add(""@Foobar"");
    final List<String> sortedCodegenAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    final List<String> sortedAdditionalModelTypeAnnotations=new ArrayList<>(codegen.getAdditionalModelTypeAnnotations());
    Collections.sort(sortedCodegenAdditionalModelTypeAnnotations);
    Collections.sort(sortedAdditionalModelTypeAnnotations);
    Assert.assertEquals(sortedCodegenAdditionalModelTypeAnnotations,sortedAdditionalModelTypeAnnotations);
}"
"@Test
public void testMatchesSpeedTest() throws Exception {
    int iterations = 15;
    String password = new RandomValueStringGenerator().generate();
    String encodedBcrypt = cachingPasswordEncoder.encode(password);
    long nanoStart = System.nanoTime();
    for (int i = 0; i < iterations; i++) {
        assertTrue(cachingPasswordEncoder.getPasswordEncoder().matches(password, encodedBcrypt));
        long nanoStop = System.nanoTime();
        long bcryptTime = nanoStop - nanoStart;
        nanoStart = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            nanoStop = System.nanoTime();
            long cacheTime = nanoStop - nanoStart;
            assertTrue(bcryptTime > (10 * cacheTime));
        }
    }
}"
"public void test_f() throws Exception {
    String text=""parent.callback ({'id':1, 'name':'idonans'} );   /**/ "";
    JSONPObject jsonpObject=JSON.parseObject(text,JSONPObject.class);
    assertEquals(""parent.callback"",jsonpObject.getFunction());
    assertEquals(1,jsonpObject.getParameters().size());
    JSONObject param=(JSONObject)jsonpObject.getParameters().get(0);
    assertEquals(1,param.get(""id""));
    assertEquals(""idonans"",param.get(""name""));
    String json=JSON.toJSONString(jsonpObject,SerializerFeature.MapSortField);
    assertEquals(""parent.callback({\""id\"":1,\""name\"":\""idonans\""})"",json);
}"
"public void testDefaultShapeOverride() throws Exception {
    ObjectMapper mapper=jsonMapperBuilder().withConfigOverride(Map.Entry.class,o -> o.setFormat(JsonFormat.Value.forShape(JsonFormat.Shape.POJO))).configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY,true).build();
    Map.Entry<String,String> input=new BeanWithMapEntry(""foo"",""bar"").entry;
    assertEquals(aposToQuotes(""{'key':'foo','value':'bar'}""),mapper.writeValueAsString(input));
}"
"@Test public void testSize() throws InterruptedException {
    final InternalThreadLocal<Integer> internalThreadLocal=new InternalThreadLocal<Integer>();
    internalThreadLocal.set(1);
    Assertions.assertEquals(1,InternalThreadLocal.size(),""size method is wrong!"");
    final InternalThreadLocal<String> internalThreadLocalString=new InternalThreadLocal<String>();
    internalThreadLocalString.set(""value"");
    Assertions.assertEquals(2,InternalThreadLocal.size(),""size method is wrong!"");
    InternalThreadLocal.removeAll();
}"
"@Test
public void testQueuePageWithProjectCurrentlyBuilding() throws Exception {
    String M2_PROJ_GRP_NAME = getProperty(""M2_PROJ_GRP_NAME"");
    String M2_PROJ_GRP_ID = getProperty(""M2_PROJ_GRP_ID"");
    String M2_PROJ_GRP_DESCRIPTION = getProperty(""M2_PROJ_GRP_DESCRIPTION"");
    buildProjectForQueuePageTest(M2_PROJ_GRP_NAME, M2_PROJ_GRP_ID, M2_PROJ_GRP_DESCRIPTION, M2_PROJ_GRP_NAME);
    String location = getSelenium().getLocation();
    clickAndWait(""link=Queues"");
    assertPage(""Continuum - Build Queue"");
    assertTextPresent(""Current Build"");
    assertTextPresent(""Build Queue"");
    assertTextPresent(""Current Checkout"");
    assertTextPresent(""Checkout Queue "");
    assertTextPresent(""Current Prepare Build"");
    assertTextPresent(""Prepare Build Queue"");
    assertElementPresent();
    assertTextPresent(M2_PROJ_GRP_NAME);
    getSelenium().open(location);
    waitPage();
    waitForElementPresent();
}"
"@Test public void testKeyValueSchemaInfoToString() throws JSONException {
    String havePrimitiveType=DefaultImplementation.convertKeyValueSchemaInfoDataToString(KeyValueSchemaInfo.decodeKeyValueSchemaInfo(Schema.KeyValue(Schema.AVRO(Foo.class),Schema.STRING).getSchemaInfo()));
    JSONSchemaTest.assertJSONEqual(havePrimitiveType,KEY_VALUE_SCHEMA_INFO_INCLUDE_PRIMITIVE);
    String notHavePrimitiveType=DefaultImplementation.convertKeyValueSchemaInfoDataToString(KeyValueSchemaInfo.decodeKeyValueSchemaInfo(Schema.KeyValue(Schema.AVRO(Foo.class),Schema.AVRO(Foo.class)).getSchemaInfo()));
    JSONSchemaTest.assertJSONEqual(notHavePrimitiveType,KEY_VALUE_SCHEMA_INFO_NOT_INCLUDE_PRIMITIVE);
}"
"@Test
public void playbackRate() throws Exception {
    final int toleranceMs = 1000;
    Future<PlayerResult> setSurfaceFuture = mPlayer.setSurface(
    mActivity.getSurfaceHolder().getSurface());
    Future<PlayerResult> prepareFuture = mPlayer.prepare();
    assertFutureSuccess(setSurfaceFuture);
    assertFutureSuccess(prepareFuture);
    float[] rates = {0.25f, 0.5f, 1.0f, 2.0f};
    for (float playbackRate : rates) {
        Future<PlayerResult> seekFuture = mPlayer.seekTo(0, MediaPlayer.SEEK_PREVIOUS_SYNC);
        Thread.sleep(1000);
        int playTime = 4000;
        int privState = mPlayer.getPlayerState();
        Future<PlayerResult> setParamsFuture = mPlayer.setPlaybackParams(
        new PlaybackParams.Builder().setSpeed(playbackRate).build());
        assertFutureSuccess(seekFuture);
        assertFutureSuccess(setParamsFuture);
        assertEquals(""setPlaybackParams() should not change player state. ""
        + mPlayer.getPlayerState(), privState, mPlayer.getPlayerState());
        Future<PlayerResult> playFuture = mPlayer.play();
        Thread.sleep(playTime);
        PlaybackParams pbp = mPlayer.getPlaybackParams();
        assertEquals(playbackRate, pbp.getSpeed(), FLOAT_TOLERANCE);
        assertEquals(""The player should still be playing"",
        MediaPlayer.PLAYER_STATE_PLAYING, mPlayer.getPlayerState());
        long playedMediaDurationMs = mPlayer.getCurrentPosition();
        long expectedPosition = (long) (playTime * playbackRate);
        int diff = (int) Math.abs(playedMediaDurationMs - expectedPosition);
        if (diff > toleranceMs) {
            fail(""Media player had error in playback rate "" + playbackRate
            + "". expected position after playing "" + playTime
            + "" was "" + expectedPosition + "", but actually "" + playedMediaDurationMs);
        }
        assertFutureSuccess(playFuture);
        assertFutureSuccess(mPlayer.pause());
        pbp = mPlayer.getPlaybackParams();
        assertEquals(""pause() should not change the playback rate property."",
        playbackRate, pbp.getSpeed(), FLOAT_TOLERANCE);
    }
    mPlayer.reset();
}"
"public void test_for_issue() throws Exception {
    DubboResponse resp=new DubboResponse();
    JSONObject obj=new JSONObject();
    obj.put(""key1"",""value1"");
    obj.put(""key2"",""value2"");
    resp.setData(obj);
    String str=JSON.toJSONString(resp,SerializerFeature.MapSortField);
    System.out.println(str);
    DubboResponse resp1=JSON.parseObject(str,DubboResponse.class);
    assertEquals(str,JSON.toJSONString(resp1,SerializerFeature.MapSortField));
    JSONArray arr=new JSONArray();
    arr.add(""key1"");
    arr.add(""key2"");
    resp.setData(arr);
    String str2=JSON.toJSONString(resp,SerializerFeature.MapSortField);
    System.out.println(str2);
    DubboResponse resp2=JSON.parseObject(str2,DubboResponse.class);
    assertEquals(str2,JSON.toJSONString(resp2,SerializerFeature.MapSortField));
}"
"@Test public void shouldRespectTrialCountIfSpecified(){
    assertThat(testResult(ForSpecifiedNumberOfValues.class),isSuccessful());
    assertEquals(5,ForSpecifiedNumberOfValues.iterations);
    ForSpecifiedNumberOfValues.iterations=0;
}"
"@Test
public void testLookupBindingUsingNestedContext() throws Exception {
    final ServiceName bindingName = ServiceName.JBOSS.append(""foo"", ""bar"", ""baz"", ""TestBean"");
    final Object value = new Object();
    bindObject(bindingName, value);
    Object context = store.lookup(new CompositeName(""foo""));
    assertNotNull(context);
    assertTrue(context instanceof Context);
    Object obj = Context.class.cast(context).lookup(new CompositeName(""bar/baz/TestBean""));
    assertNotNull(obj);
    assertEquals(value, obj);
    context = Context.class.cast(context).lookup(new CompositeName(""bar""));
    obj = Context.class.cast(context).lookup(new CompositeName(""baz/TestBean""));
    assertNotNull(obj);
    assertEquals(value, obj);
    context = Context.class.cast(context).lookup(new CompositeName(""baz""));
    obj = Context.class.cast(context).lookup(new CompositeName(""TestBean""));
    assertNotNull(obj);
    assertEquals(value, obj);
}"
"@Test
public void test_for_issue() throws Exception {
    DubboResponse resp = new DubboResponse();
    JSONObject obj = new JSONObject();
    obj.put(""key1"", ""value1"");
    obj.put(""key2"", ""value2"");
    resp.setData(obj);
    String str = JSON.toJSONString(resp);
    System.out.println(str);
    DubboResponse resp1 = JSON.parseObject(str, DubboResponse.class);
    assertEquals(str, JSON.toJSONString(resp1));
    JSONArray arr = new JSONArray();
    arr.add(""key1"");
    arr.add(""key2"");
    resp.setData(arr);
    String str2 = JSON.toJSONString(resp);
    System.out.println(str2);
    DubboResponse resp2 = JSON.parseObject(str2, DubboResponse.class);
    assertEquals(str2, JSON.toJSONString(resp2));
}"
"@Test
public void incrementUpperLimitIfOneMinuteElapsedSinceLastUpdate() throws InterruptedException {
    Clock clock = mock(Clock.class);
    when(clock.getTimeMillis()).thenReturn(0L, TWO_MINUTES_IN_MILLIS, 2 * TWO_MINUTES_IN_MILLIS, 3 * TWO_MINUTES_IN_MILLIS);
    TimestampBoundStore timestampBoundStore = initialTimestampBoundStore();
    PersistentTimestampService persistentTimestampService = PersistentTimestampService.create(timestampBoundStore, clock);
    persistentTimestampService.getFreshTimestamp();
    Thread.sleep(10);
    persistentTimestampService.getFreshTimestamp();
    Thread.sleep(10);
    verify(timestampBoundStore, atLeast(2)).storeUpperLimit(anyLong());
}"
"@Test public void favorValueOf() throws Exception {
    assertThat(testResult(FavorValueOf.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),FavorValueOf.iterations);
    assertEquals(new HashSet<>(asList(FavorValueOf.Target.valueOf(""a""),FavorValueOf.Target.valueOf(""b""))),new HashSet<>(FavorValueOf.values.subList(0,2)));
    FavorValueOf.iterations=0;
}"
"@Test
public void testStreamingPrevValue() throws Exception {
    Process corfuServer = runSinglePersistentServer(corfuSingleNodeHost, corfuStringNodePort);
    runtime = createRuntime(singleNodeEndpoint);
    CorfuStore store = new CorfuStore(runtime);
    String ns = ""test_namespace"";
    String tn = ""tableA"";
    Table<Uuid, SampleTableAMsg, Uuid> table = store.openTable(ns, tn, Uuid.class, SampleTableAMsg.class, Uuid.class, TableOptions.builder().build());
    PrevValueStreamer listenerCommon = new PrevValueStreamer<Uuid, SampleTableAMsg, Uuid>(store, ns, tn);
    store.subscribeListener(listenerCommon, ns, ""sample_streamer_1"", Collections.singletonList(tn));
    final int numRecords = PARAMETERS.NUM_ITERATIONS_LOW;
    for (int i = 0; i < numRecords; i++) {
        try (final TxnContext tx = store.txn(namespace)) {
            Uuid key = Uuid.newBuilder().setLsb(0).setMsb(0).build();
            SampleTableAMsg val = SampleTableAMsg.newBuilder().setPayload(""val"" + i).build();
            tx.putRecord(table, key, val, key);
            tx.commit();
        }
    }
    TimeUnit.MILLISECONDS.sleep(sleepTime);
    assertThat(listenerCommon.getRecordCount()).isEqualTo(numRecords);
    assertThat(shutdownCorfuServer(corfuServer)).isTrue();
}"
"public void test_for_issue(){
    org.json.JSONObject req=new org.json.JSONObject();
    SerializeConfig config=new SerializeConfig();
    config.register(new myModule());
    req.put(""id"",1111);
    req.put(""name"",""name11"");
    String text=JSON.toJSONString(req,SerializerFeature.SortField);
    Assert.assertEquals(""{\""id\"":1111,\""name\"":\""name11\""}"",text);
}"
"@Test
public void testSuccess_multipartTldsWithSharedSuffixes() throws Exception {
    createTlds(""bar.foo.tld"", ""foo.tld"", ""tld"");
    assertCommandAndResponse(""login_valid.xml"", ""login_response.xml"");
    assertCommandAndResponse(
    ""contact_create_sh8013.xml"",
    ImmutableMap.of(),
    ""contact_create_response_sh8013.xml"",
    ImmutableMap.of(""CRDATE"", ""2000-06-01T00:00:00Z""),
    DateTime.parse(""2000-06-01T00:00:00Z""));
    assertCommandAndResponse(
    ""contact_create_jd1234.xml"",
    ""contact_create_response_jd1234.xml"",
    DateTime.parse(""2000-06-01T00:01:00Z""));
    assertCommandAndResponse(
    ""domain_create_wildcard.xml"",
    ImmutableMap.of(""HOSTNAME"", ""example.bar.foo.tld""),
    ""domain_create_response.xml"",
    ImmutableMap.of(
    ""NAME"", ""example.bar.foo.tld"",
    ""CRDATE"", ""2000-06-01T00:02:00.0Z"",
    ""EXDATE"", ""2002-06-01T00:02:00.0Z""),
    DateTime.parse(""2000-06-01T00:02:00Z""));
}"
"@Test
public void testInterruptsOnLFSRead() throws Exception {
    final Ignite ignite = startGrid();
    ignite.active(true);
    final int valLen = 8192;
    final byte[] payload = new byte[valLen];
    final int maxKey = 10000;
    Thread[] workers = new Thread[THREADS_CNT];
    final IgniteCache<Object, Object> cache = ignite.cache(CACHE_NAME);
    for (int i = 0; i < maxKey; i++) {
        cache.put(i, payload);
    }
    final AtomicReference<Throwable> fail = new AtomicReference<>();
    Runnable clo = new Runnable() {
        @Override
        public void run() {
            cache.get(ThreadLocalRandom.current().nextInt(maxKey / 5));
        }
    };
    for (int i = 0; i < workers.length; i++) {
        workers[i] = new Thread(clo);
        workers[i].setName(""reader-"" + i);
        workers[i].setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
            @Override
            public void uncaughtException(Thread t, Throwable e) {
                fail.compareAndSet(null, e);
            }
        });
    }
    for (Thread worker : workers) {
        worker.start();
    }
    for (int i = 0; i < (workers.length / 2); i++) {
        workers[i].interrupt();
    }
    Thread.sleep(3000);
    stop = true;
    for (Thread worker : workers) {
        worker.join();
    }
    Throwable t = fail.get();
    assertNull(t);
    int verifiedKeys = 0;
    for (int i = 0; i < maxKey; i++) {
        byte[] val = ((byte[]) (cache.get(i)));
        if (val != null) {
            assertEquals(""Illegal length"", valLen, val.length);
            verifiedKeys++;
        }
    }
}"
"@Test void writesAndReadsCustomConvertedClass(){
    List<Object> converters=new ArrayList<>();
    converters.add(BigDecimalToStringConverter.INSTANCE);
    converters.add(StringToBigDecimalConverter.INSTANCE);
    CustomConversions customConversions=new CouchbaseCustomConversions(converters);
    converter.setCustomConversions(customConversions);
    converter.afterPropertiesSet();
    ((CouchbaseMappingContext)converter.getMappingContext()).setSimpleTypeHolder(customConversions.getSimpleTypeHolder());
    CouchbaseDocument converted=new CouchbaseDocument();
    final String valueStr=""12.345"";
    final BigDecimal value=new BigDecimal(valueStr);
    final String value2Str=""0.6789"";
    final BigDecimal value2=new BigDecimal(value2Str);
    List<BigDecimal> listOfValues=new ArrayList<>();
    listOfValues.add(value);
    listOfValues.add(value2);
    Map<String,BigDecimal> mapOfValues=new HashMap<>();
    mapOfValues.put(""val1"",value);
    mapOfValues.put(""val2"",value2);
    CustomEntity entity=new CustomEntity(value,listOfValues,mapOfValues);
    converter.write(entity,converted);
    CouchbaseDocument source=new CouchbaseDocument();
    source.put(""_class"",CustomEntity.class.getName());
    source.put(""value"",valueStr);
    CouchbaseList listOfValuesDoc=new CouchbaseList();
    listOfValuesDoc.put(valueStr);
    listOfValuesDoc.put(value2Str);
    source.put(""listOfValues"",listOfValuesDoc);
    CouchbaseDocument mapOfValuesDoc=new CouchbaseDocument();
    mapOfValuesDoc.put(""val1"",valueStr);
    mapOfValuesDoc.put(""val2"",value2Str);
    source.put(""mapOfValues"",mapOfValuesDoc);
    assertThat(valueStr).isEqualTo(((CouchbaseList)converted.getContent().get(""listOfValues"")).get(0));
    assertThat(value2Str).isEqualTo(((CouchbaseList)converted.getContent().get(""listOfValues"")).get(1));
    assertThat(converted.getContent().get(""listOfValues"").toString()).isEqualTo(source.getContent().get(""listOfValues"").toString());
    CouchbaseDocument sourceVals=(CouchbaseDocument)source.getContent().get(""mapOfValues"");
    CouchbaseDocument convertedVals=(CouchbaseDocument)converted.getContent().get(""mapOfValues"");
    assertThat(sourceVals.getContent().get(""val1"").toString()).isEqualTo(convertedVals.getContent().get(""val1"").toString());
    assertThat(sourceVals.getContent().get(""val2"").toString()).isEqualTo(convertedVals.getContent().get(""val2"").toString());
    CustomEntity readConverted=converter.read(CustomEntity.class,source);
    assertThat(readConverted.value).isEqualTo(value);
    assertThat(readConverted.listOfValues.get(0)).isEqualTo(listOfValues.get(0));
    assertThat(readConverted.listOfValues.get(1)).isEqualTo(listOfValues.get(1));
    assertThat(readConverted.mapOfValues.get(""val1"")).isEqualTo(mapOfValues.get(""val1""));
    assertThat(readConverted.mapOfValues.get(""val2"")).isEqualTo(mapOfValues.get(""val2""));
}"
"@Test public void wrapperChars() throws Exception {
    assertThat(testResult(WrapperChars.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),WrapperChars.iterations);
    assertEquals(new HashSet<>(asList('@','#')),new HashSet<>(WrapperChars.values.subList(0,2)));
    WrapperChars.iterations=0;
}"
"@Test
public void regexp_validator() {
    clickThru(""Regexp Demo"");
    String update = SUBMIT;
    type(""zipCode"", ""abc"");
    click(update);
    assertTextPresent(""A zip code consists of five or nine digits"");
    type(""zipCode"", ""12345"");
    clickAndWait(update);
    assertTextPresent(""Zip code: [12345]"");
    type(""zipCode"", ""12345-9876"");
    clickAndWait(update);
    assertTextPresent(""Zip code: [12345-9876]"");
}"
"/**
* Test a class that defines an ivar pointing to itself.  This test was created to show that handling cyclical object resulted in a missing endFieldSeparator call.
*/
@Test public void testSelfInstanceTwoVarsReflectionObjectCycle(){
    final SelfInstanceTwoVarsReflectionTestFixture test=new SelfInstanceTwoVarsReflectionTestFixture();
    assertEquals(this.toBaseString(test) + ""[otherType="" + test.getOtherType().toString()+ "",typeIsSelf=""+ this.toBaseString(test)+ ""]"",test.toString());
}"
"@Test
public void testGetContextTypeLoader() throws Exception {
    SchemaTypeLoader stl = XmlBeans.getContextTypeLoader();
    if (stl == null) {
        fail(""getContextTypeLoader failed"");
    }
    Vector vThreads = new Vector();
    Set STLset = Collections.synchronizedSortedSet(new TreeSet());
    for (int i = 0; i < 10; i++) {
        Thread t = new BogusThread(STLset);
        vThreads.add(t);
        t.start();
    }
    for (int i = 0; i < 10; i++) {
        ((BogusThread) (vThreads.elementAt(i))).join();
    }
    assertEquals(10, STLset.size());
}"
"@Test
private Void returnAny1(Context context) {
    Notifier notifier = testUtilities.rhinoCallConvert(""testAny1ToClientChalk"", Notifier.class, testUtilities.javaToJS(getAddress()));
    boolean notified = notifier.waitForJavascript(1000 * 10);
    assertTrue(notified);
    Integer errorStatus = testUtilities.rhinoEvaluateConvert(""globalErrorStatus"", Integer.class);
    assertNull(errorStatus);
    String errorText = testUtilities.rhinoEvaluateConvert(""globalErrorStatusText"", String.class);
    assertNull(errorText);
    String chalk = ((String) (testUtilities.rhinoEvaluate(""globalResponseObject._any.object._chalk"")));
    assertEquals(""dover"", chalk);
    return null;
}"
"@Test
public void testConsumerClose() throws Exception {
    StubConnection connection1 = createConnection();
    ConnectionInfo connectionInfo1 = createConnectionInfo();
    SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1);
    ProducerInfo producerInfo1 = createProducerInfo(sessionInfo1);
    connection1.send(connectionInfo1);
    connection1.send(sessionInfo1);
    connection1.send(producerInfo1);
    ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination);
    consumerInfo1.setPrefetchSize(100);
    consumerInfo1.setNoLocal(true);
    connection1.request(consumerInfo1);
    StubConnection connection2 = createConnection();
    ConnectionInfo connectionInfo2 = createConnectionInfo();
    SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
    ProducerInfo producerInfo2 = createProducerInfo(sessionInfo2);
    connection2.send(connectionInfo2);
    connection2.send(sessionInfo2);
    connection2.send(producerInfo2);
    connection2.send(createMessage(producerInfo2, destination, deliveryMode));
    connection2.send(createMessage(producerInfo2, destination, deliveryMode));
    connection2.send(createMessage(producerInfo2, destination, deliveryMode));
    connection2.send(createMessage(producerInfo2, destination, deliveryMode));
    for (int i = 0; i < 4; i++) {
        Message m1 = receiveMessage(connection1);
        assertNotNull(m1);
        connection1.send(createAck(consumerInfo1, m1, 1, STANDARD_ACK_TYPE));
    }
    connection1.request(closeConsumerInfo(consumerInfo1));
    connection2.request(createMessage(producerInfo2, destination, deliveryMode));
    assertNull(connection1.getDispatchQueue().poll(MAX_NULL_WAIT, TimeUnit.MILLISECONDS));
}"
"@Test
public void testiParameterized18nWithSpeciali18nPlaceholder() {
    when(ninjaProperties.getStringArray(applicationLanguages)).thenReturn(new String[]{ ""en"", ""de"", ""fr-FR"" });
    Lang lang = new LangImpl(ninjaProperties);
    Messages messages = new MessagesImpl(ninjaProperties, lang);
    Optional<String> language = Optional.absent();
    Optional<String> result = messages.get(""message_with_placeholder_date"", language, new Date(0));
    assertEquals(""that's a date: Jan 1, 1970"", result.get());
    language = Optional.of(""de"");
    result = messages.get(""message_with_placeholder_date"", language, new Date(0));
    assertEquals(""das ist ein datum: 01.01.1970"", result.get());
    language = Optional.of(""fr-FR"");
    result = messages.get(""message_with_placeholder_date"", language, new Date(0));
    assertEquals(""c`est la date: 1 janv. 1970"", result.get());
    language = Optional.of(""en"");
    result = messages.get(""message_with_placeholder_date"", language, new Date(0));
    assertEquals(""that's a date: Jan 1, 1970"", result.get());
}"
"@Test
public void testTopicLevelInActiveTopicApi() throws Exception {
    super.resetConfig();
    conf.setSystemTopicEnabled(true);
    conf.setTopicLevelPoliciesEnabled(true);
    super.baseSetup();
    Thread.sleep(2000);
    final String topicName = ""persistent://prop/ns-abc/testMaxInactiveDuration-"" + UUID.randomUUID().toString();
    admin.topics().createPartitionedTopic(topicName, 3);
    InactiveTopicPolicies inactiveTopicPolicies = admin.topics().getInactiveTopicPolicies(topicName);
    assertNull(inactiveTopicPolicies);
    InactiveTopicPolicies policies = new InactiveTopicPolicies();
    policies.setDeleteWhileInactive(true);
    policies.setInactiveTopicDeleteMode(InactiveTopicDeleteMode.delete_when_no_subscriptions);
    policies.setMaxInactiveDurationSeconds(10);
    admin.topics().setInactiveTopicPolicies(topicName, policies);
    for (int i = 0; i < 50; i++) {
        if (admin.topics().getInactiveTopicPolicies(topicName) != null) {
            break;
        }
        Thread.sleep(100);
    }
    assertEquals(admin.topics().getInactiveTopicPolicies(topicName), policies);
    admin.topics().removeInactiveTopicPolicies(topicName);
    for (int i = 0; i < 50; i++) {
        if (admin.topics().getInactiveTopicPolicies(topicName) == null) {
            break;
        }
        Thread.sleep(100);
    }
    assertNull(admin.topics().getInactiveTopicPolicies(topicName));
    super.internalCleanup();
}"
"@Test
public void should_try_to_verify_correct_number_of_times() {
    Timeout t = new Timeout(10, 50, mode, durationChecker);
    doThrow(error).when(mode).verify(data);
    when(durationChecker.isVerificationStillInProgress(anyLong())).thenReturn(true, true, true, true, true, false);
    try {
        t.verify(data);
        fail();
    } catch (MockitoAssertionError e) {
    }
    verify(mode, times(5)).verify(data);
}"
"@Test
public void testErrorNotGzipped() throws Exception {
    Header[] headers = new Header[2];
    headers[0] = new Header(""Accept"", Constants.MIMETYPE_BINARY);
    headers[1] = new Header(""Accept-Encoding"", ""gzip"");
    Response response = client.get(((((""/"" + TABLE) + ""/"") + ROW_1) + ""/"") + COLUMN_2, headers);
    assertEquals(response.getCode(), 404);
    String contentEncoding = response.getHeader(""Content-Encoding"");
    assertTrue((contentEncoding == null) || (!contentEncoding.contains(""gzip"")));
    response = client.get(""/"" + TABLE, headers);
    assertEquals(response.getCode(), 405);
    contentEncoding = response.getHeader(""Content-Encoding"");
    assertTrue((contentEncoding == null) || (!contentEncoding.contains(""gzip"")));
}"
"@Test
void shouldCompleteLogWhenCancelledByClient(SessionProtocol protocol) {
    final ClientFactory factory = ClientFactory.builder().build();
    final WebClient client = WebClient.builder(server.uri(protocol)).factory(factory).build();
    final CompletableFuture<AggregatedHttpResponse> responseFuture = client.get(""/reset"").aggregate();
    await().untilAtomic(ctxRef, Matchers.notNullValue());
    factory.close();
    final RequestLog log = ctxRef.get().log().whenComplete().join();
    if (protocol.isMultiplex()) {
        assertThat(log.responseCause()).isInstanceOf(ClosedStreamException.class).hasMessageContaining(""received a RST_STREAM frame: CANCEL"");
        assertThatThrownBy(responseFuture::join).isInstanceOf(CompletionException.class).hasCauseInstanceOf(ClosedStreamException.class);
    } else {
        assertThat(log.responseCause()).isInstanceOf(ClosedSessionException.class);
        assertThatThrownBy(responseFuture::join).isInstanceOf(CompletionException.class).hasCauseInstanceOf(ClosedSessionException.class);
    }
}"
"@Test
public void testBind() throws Exception {
    final Name name = new CompositeName(""test"");
    final Object value = new Object();
    WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);
    try {
        store.bind(name, value);
    } finally {
        WritableServiceBasedNamingStore.popOwner();
    }
    assertEquals(value, store.lookup(name));
}"
"@Test public void testDuplicateArrayList(){
    A a=new A();
    a.list1=new ArrayList<String>();
    a.list1.add(""aaa"");
    a.list2=new ArrayList<String>();
    a.list2.add(""aaa"");
    String json=Json.toJson(a,JsonFormat.compact().setQuoteName(false));
    String exp=""{list1:[\""aaa\""],list2:[\""aaa\""]}"";
    assertJsonEqualsNonStrict(exp,json);
}"
"@Test
@LargeTest
public void testTimer_withListenerAndCleanUp() throws InterruptedException {
    TestTimeLimitExceededListener listenerSpy = spy(mListener);
    mWorkTimer.startTimer(WORKSPEC_ID_1, 0, listenerSpy);
    Thread.sleep(10);
    verify(listenerSpy, times(1)).onTimeLimitExceeded(WORKSPEC_ID_1);
    assertThat(mWorkTimer.getTimerMap().size(), is(0));
    assertThat(mWorkTimer.getListeners().size(), is(0));
}"
"@Test public void primitiveBytes() throws Exception {
    assertThat(testResult(PrimitiveBytes.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveBytes.iterations);
    assertEquals(new HashSet<>(asList((byte)12,(byte)-13)),new HashSet<>(PrimitiveBytes.values.subList(0,2)));
    PrimitiveBytes.iterations=0;
}"
"@Test
void testBytes() throws InterruptedException {
    final CountDownLatch countDownLatch = new CountDownLatch(1);
    final Metrics metrics = new Metrics();
    final LongAdder longAdder = new LongAdder();
    final long input = 100;
    final int loopCount = 10000;
    Thread adder = new Thread(() -> {
        try {
            countDownLatch.await();
        } catch (InterruptedException ignore) {
        }
        for (int i = 0; i < loopCount; ++i) {
            metrics.addBytes(input);
        }
    });
    Thread getter = new Thread(() -> {
        try {
            countDownLatch.await();
        } catch (InterruptedException ignore) {
        }
        for (int i = 0; i < loopCount; ++i) {
            longAdder.add(metrics.bytesThenReset());
        }
    });
    adder.start();
    getter.start();
    countDownLatch.countDown();
    adder.join();
    longAdder.add(metrics.bytesThenReset());
    Assertions.assertEquals(loopCount * input, longAdder.sum());
}"
"@Test
public void findingAnnotationsRecursively() {
    Method method = findMethod(this.getClass(), ""withMarker"", String.class);
    List<Annotation> annotations = allAnnotations(method.getParameters()[0]);
    assertEquals(4, annotations.size());
    assertEquals(X.class, annotations.get(0).annotationType());
    assertEquals(Y.class, annotations.get(1).annotationType());
    assertEquals(Z.class, annotations.get(2).annotationType());
    assertEquals(W.class, annotations.get(3).annotationType());
}"
"@Test
public void testWritesWhileScanning() throws IOException, InterruptedException {
    byte[] tableName = Bytes.toBytes(""testWritesWhileScanning"");
    int testCount = 100;
    int numRows = 1;
    int numFamilies = 10;
    int numQualifiers = 100;
    int flushInterval = 7;
    int compactInterval = 5 * flushInterval;
    byte[][] families = new byte[numFamilies][];
    for (int i = 0; i < numFamilies; i++) {
        families[i] = Bytes.toBytes(""family"" + i);
    }
    byte[][] qualifiers = new byte[numQualifiers][];
    for (int i = 0; i < numQualifiers; i++) {
        qualifiers[i] = Bytes.toBytes(""qual"" + i);
    }
    String method = ""testWritesWhileScanning"";
    initHRegion(tableName, method, families);
    PutThread putThread = new PutThread(numRows, families, qualifiers);
    putThread.start();
    FlushThread flushThread = new FlushThread();
    flushThread.start();
    Scan scan = new Scan(Bytes.toBytes(""row0""), Bytes.toBytes(""row1""));
    int expectedCount = numFamilies * numQualifiers;
    List<KeyValue> res = new ArrayList<KeyValue>();
    long prevTimestamp = 0L;
    for (int i = 0; i < testCount; i++) {
        if ((i != 0) && ((i % compactInterval) == 0)) {
            region.compactStores(true);
        }
        if ((i != 0) && ((i % flushInterval) == 0)) {
            flushThread.flush();
        }
        boolean previousEmpty = res.isEmpty();
        res.clear();
        InternalScanner scanner = region.getScanner(scan);
        while (scanner.next(res));
        if (((!res.isEmpty()) || (!previousEmpty)) || (i > compactInterval)) {
            assertEquals(""i="" + i, expectedCount, res.size());
            long timestamp = res.get(0).getTimestamp();
            assertTrue(((""Timestamps were broke: "" + timestamp) + "" prev: "") + prevTimestamp, timestamp >= prevTimestamp);
            prevTimestamp = timestamp;
        }
    }
    putThread.done();
    region.flushcache();
    putThread.join();
    putThread.checkNoError();
    flushThread.done();
    flushThread.join();
    flushThread.checkNoError();
}"
"@Test public void testLogicDeleteSql(){
    String wherePKColumns=SqlHelper.wherePKColumns(User.class);
    Assert.assertEquals(""<where> AND id = #{id} AND is_valid = 1</where>"",wherePKColumns);
    String whereAllIfColumns=SqlHelper.whereAllIfColumns(User.class,false);
    Assert.assertEquals(""<where><if test=\""id != null\""> AND id = #{id}</if><if test=\""username != null\""> AND username = #{username}</if> AND is_valid = 1</where>"",whereAllIfColumns);
    String isLogicDeletedColumn=SqlHelper.whereLogicDelete(User.class,true);
    Assert.assertEquals("" AND is_valid = 0"",isLogicDeletedColumn);
    String notLogicDeletedColumn=SqlHelper.whereLogicDelete(User.class,false);
    Assert.assertEquals("" AND is_valid = 1"",notLogicDeletedColumn);
    String updateSetColumns=SqlHelper.updateSetColumns(User.class,null,false,false);
    Assert.assertEquals(""<set>is_valid = 1,username = #{username},</set>"",updateSetColumns);
}"
"@Test
public void testReadBackward() throws Exception {
    FileSystem fs = cluster.getFileSystem();
    long tStart = System.currentTimeMillis();
    bench.getConf().setLong(""test.io.skip.size"", -DEFAULT_BUFFER_SIZE);
    bench.randomReadTest(fs);
    long execTime = System.currentTimeMillis() - tStart;
    bench.analyzeResult(fs, TestType.TEST_TYPE_READ_BACKWARD, execTime);
}"
"@Test
public void testChecksumReconnection() throws Exception {
    final String topicName = ""persistent"";
    ProducerImpl<byte[]> prod = ((ProducerImpl<byte[]>) (pulsarClient.newProducer().topic(topicName).enableBatching(false).messageRoutingMode(SinglePartition).create()));
    ProducerImpl<byte[]> producer = spy(prod);
    doReturn(producer.brokerChecksumSupportedVersion() + 1).when(producer).brokerChecksumSupportedVersion();
    doAnswer(( invocationOnMock) -> prod.getState()).when(producer).getState();
    doAnswer(( invocationOnMock) -> prod.getClientCnx()).when(producer).getClientCnx();
    doAnswer(( invocationOnMock) -> prod.cnx()).when(producer).cnx();
    Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(topicName).subscriptionName(""my-sub"").subscribe();
    stopBroker();
    ((PulsarClientImpl) (pulsarClient)).timer().stop();
    ClientCnx mockClientCnx = spy(new ClientCnx(new ClientConfigurationData(), ((PulsarClientImpl) (pulsarClient)).eventLoopGroup()));
    doReturn(producer.brokerChecksumSupportedVersion() - 1).when(mockClientCnx).getRemoteEndpointProtocolVersion();
    prod.setClientCnx(mockClientCnx);
    CompletableFuture<MessageId> future1 = producer.sendAsync(""message-1"".getBytes());
    byte[] a2 = ""message-2"".getBytes();
    TypedMessageBuilder<byte[]> msg2 = producer.newMessage().value(a2);
    CompletableFuture<MessageId> future2 = msg2.sendAsync();
    ((TypedMessageBuilderImpl<byte[]>) (msg2)).getContent().put(a2.length - 1, ((byte) ('3')));
    prod.setClientCnx(null);
    startBroker();
    prod.grabCnx();
    try {
        future1.get(10, TimeUnit.SECONDS);
        future2.get(10, TimeUnit.SECONDS);
    } catch (Exception e) {
        e.printStackTrace();
        fail(""Broker shouldn't verify checksum for corrupted message and it shouldn't fail"");
    }
    ((ConsumerImpl<byte[]>) (consumer)).grabCnx();
    Message<byte[]> msg = consumer.receive(1, TimeUnit.SECONDS);
    assertEquals(new String(msg.getData()), ""message-1"");
    msg = consumer.receive(1, TimeUnit.SECONDS);
    assertEquals(new String(msg.getData()), ""message-3"");
}"
"public void testDynamicAttributesSupport() throws Exception {
    File file=new File(FreeMarkerResultTest.class.getResource(""dynaAttributes.ftl"").toURI());
    EasyMock.expect(servletContext.getRealPath(""/tutorial/org/apache/struts2/views/freemarker/dynaAttributes.ftl"")).andReturn(file.getAbsolutePath());
    file=new File(ClassLoaderUtil.getResource(""template/simple/text.ftl"",getClass()).toURI());
    EasyMock.expect(servletContext.getRealPath(""/template/simple/text.ftl"")).andReturn(file.getAbsolutePath());
    file=new File(ClassLoaderUtil.getResource(""template/simple/css.ftl"",getClass()).toURI());
    EasyMock.expect(servletContext.getRealPath(""/template/simple/css.ftl"")).andReturn(file.getAbsolutePath());
    EasyMock.expect(servletContext.getRealPath(""/template/~~~simple/css.ftl"")).andReturn(file.getAbsolutePath());
    file=new File(ClassLoaderUtil.getResource(""template/simple/scripting-events.ftl"",getClass()).toURI());
    EasyMock.expect(servletContext.getRealPath(""/template/simple/scripting-events.ftl"")).andReturn(file.getAbsolutePath());
    EasyMock.expect(servletContext.getRealPath(""/template/~~~simple/scripting-events.ftl"")).andReturn(file.getAbsolutePath());
    file=new File(ClassLoaderUtil.getResource(""template/simple/common-attributes.ftl"",getClass()).toURI());
    EasyMock.expect(servletContext.getRealPath(""/template/simple/common-attributes.ftl"")).andReturn(file.getAbsolutePath());
    EasyMock.expect(servletContext.getRealPath(""/template/~~~simple/common-attributes.ftl"")).andReturn(file.getAbsolutePath());
    file=new File(ClassLoaderUtil.getResource(""template/simple/dynamic-attributes.ftl"",getClass()).toURI());
    EasyMock.expect(servletContext.getRealPath(""/template/simple/dynamic-attributes.ftl"")).andReturn(file.getAbsolutePath());
    EasyMock.expect(servletContext.getRealPath(""/template/~~~simple/dynamic-attributes.ftl"")).andReturn(file.getAbsolutePath());
    EasyMock.replay(servletContext);
    init();
    request.setRequestURI(""/tutorial/test6.action"");
    ActionMapping mapping=container.getInstance(ActionMapper.class).getMapping(request,configurationManager);
    dispatcher.serviceAction(request,response,mapping);
    String result=stringWriter.toString();
    assertThat(result,allOf(startsWith(""<input type=\""text\"" name=\""test\"" value=\""\"" id=\""test\""""),containsString(""foo=\""bar\""""),containsString(""placeholder=\""input\""""),endsWith(""<input type=\""text\"" name=\""test\"" value=\""\"" id=\""test\"" break=\""true\""/>"" + ""<input type=\""text\"" name=\""required\"" value=\""\"" id=\""required\"" required=\""true\""/>"")));
}"
"@Test public void testSerialize() throws SerializationException {
    GetUserIdSerializableRequest request=new GetUserIdSerializableRequest();
    request.setOperation(InstantAccessOperationValue.GETUSERID);
    request.setInfoField1(""nobody@amazon.com"");
    request.setInfoField2(""AMZN"");
    String requestString=serializer.encode(request);
    requestString=requestString.replace(""{"","""").replace(""}"","""").replace(""\"""","""");
    HashMap<String,String> requestMap=new HashMap<String,String>();
    String[] pairs=requestString.split("","");
    for (int i=0; i < pairs.length; i++) {
        String pair=pairs[i];
        String[] keyValue=pair.split("":"");
        requestMap.put(keyValue[0],keyValue[1]);
    }
    HashMap<String,String> expected=new HashMap<String,String>();
    expected.put(""operation"",""GetUserId"");
    expected.put(""infoField1"",""nobody@amazon.com"");
    expected.put(""infoField2"",""AMZN"");
    assertEquals(requestMap,expected);
}"
"@Test
public void getFieldNamesTest() {
    List<String> names = EnumUtil.getFieldNames(TestEnum.class);
    Assert.assertEquals(CollUtil.newArrayList(""type"", ""name""), names);
}"
"@Test
public void testWatch() throws Exception {
    final JsonArray operationTypes = new JsonArray(Arrays.asList(""insert"", ""update"", ""replace"", ""delete""));
    final JsonObject match = new JsonObject().put(""operationType"", new JsonObject().put(""$in"", operationTypes));
    final JsonArray pipeline = new JsonArray().add(new JsonObject().put(""$match"", match));
    final JsonObject fields = new JsonObject().put(""operationType"", true).put(""namespaceDocument"", true).put(""destinationNamespaceDocument"", true).put(""documentKey"", true).put(""updateDescription"", true).put(""fullDocument"", true);
    pipeline.add(new JsonObject().put(""$project"", fields));
    final String collection = randomCollection();
    final JsonObject doc = createDoc();
    final CountDownLatch latch = new CountDownLatch(4);
    final AtomicReference<ReadStream<ChangeStreamDocument<JsonObject>>> streamReference = new AtomicReference<>();
    mongoClient.createCollection(collection, onSuccess(( res) -> {
        ReadStream<ChangeStreamDocument<JsonObject>> stream = mongoClient.watch(collection, pipeline, true, 1).handler(( changeStreamDocument) -> {
            OperationType operationType = changeStreamDocument.getOperationType();
            assertNotNull(operationType);
            JsonObject fullDocument = changeStreamDocument.getFullDocument();
            switch (operationType.getValue()) {
                case ""insert"" :
                assertNotNull(fullDocument);
                assertNotNull(fullDocument.getString(MongoClientUpdateResult.ID_FIELD));
                assertEquals(""bar"", fullDocument.getString(""foo""));
                break;
                case ""update"" :
                assertNotNull(fullDocument);
                assertEquals(""updatedValue"", fullDocument.getString(""fieldToUpdate""));
                break;
                case ""replace"" :
                assertNotNull(fullDocument);
                assertEquals(""replacedValue"", fullDocument.getString(""fieldToReplace""));
                break;
                case ""delete"" :
                assertNull(fullDocument);
                break;
                default :
            }
            latch.countDown();
            if (latch.getCount() == 1) {
                mongoClient.removeDocuments(collection, new JsonObject());
            }
        }).endHandler(( v) -> assertEquals(0, latch.getCount())).exceptionHandler(this::fail).fetch(1);
        streamReference.set(stream);
        vertx.setTimer(50, ( v) -> {
            mongoClient.insert(collection, doc).compose(( idString) -> {
                doc.put(MongoClientUpdateResult.ID_FIELD, idString);
                doc.put(""fieldToUpdate"", ""updatedValue"");
                final JsonObject query = new JsonObject().put(MongoClientUpdateResult.ID_FIELD, idString);
                final JsonObject updateField = new JsonObject().put(""fieldToUpdate"", ""updatedValue"");
                return CompositeFuture.all(mongoClient.updateCollection(collection, query, new JsonObject().put(""$set"", updateField)), mongoClient.save(collection, doc.put(""fieldToReplace"", ""replacedValue"")));
            });
        });
    }));
    awaitLatch(latch);
    streamReference.get().handler(null);
}"
"@Test
public void test() throws Exception {
    captureErr();
    new Thread(this::startServer).start();
    Ignite client = startGrid(getConfiguration(""client"").setClientMode(true));
    IgniteServices services = client.services();
    SimpleService srvc = services.serviceProxy(""service"", SimpleService.class, false);
    Thread.sleep(1000);
    srvc.isWorking();
    assertFalse(getErr().contains(""Cache is not configured:""));
}"
"@Test
public void testCwdContents() throws Exception {
    dirString = Path.CUR_DIR;
    item = new PathData(dirString, conf);
    PathData[] items = item.getDirectoryContents();
    assertEquals(sortedString(""d1"", ""d2""), sortedString(items));
}"
"@Test public void testInvokeException(){
    Invoker<AccessLogFilterTest> invoker=new MyInvoker<AccessLogFilterTest>(null);
    Invocation invocation=new MockInvocation();
    LogUtil.start();
    accessLogFilter.invoke(invoker,invocation);
    assertEquals(1,LogUtil.findMessage(""Exception in AccessLogFilter of service""));
    LogUtil.stop();
    DubboAppender.clear();
}"
"@Test public void testReflectionHashCodeExcludeFields(){
    final TestObjectWithMultipleFields x=new TestObjectWithMultipleFields(1,2,3);
    assertEquals(((17 * 37 + 1) * 37 + 3) * 37 + 2,HashCodeBuilder.reflectionHashCode(x));
    assertEquals(((17 * 37 + 1) * 37 + 3) * 37 + 2,HashCodeBuilder.reflectionHashCode(x,(String[])null));
    assertEquals(((17 * 37 + 1) * 37 + 3) * 37 + 2,HashCodeBuilder.reflectionHashCode(x));
    assertEquals(((17 * 37 + 1) * 37 + 3) * 37 + 2,HashCodeBuilder.reflectionHashCode(x,""xxx""));
    assertEquals((17 * 37 + 1) * 37 + 3,HashCodeBuilder.reflectionHashCode(x,""two""));
    assertEquals((17 * 37 + 1) * 37 + 2,HashCodeBuilder.reflectionHashCode(x,""three""));
    assertEquals(17 * 37 + 1,HashCodeBuilder.reflectionHashCode(x,""two"",""three""));
    assertEquals(17,HashCodeBuilder.reflectionHashCode(x,""one"",""two"",""three""));
    assertEquals(17,HashCodeBuilder.reflectionHashCode(x,""one"",""two"",""three"",""xxx""));
}"
"@Test
public void testConsumerBacklogEvictionTimeQuotaWithEmptyLedger() throws Exception {
    assertEquals(admin.namespaces().getBacklogQuotaMap(""prop/ns-quota""), Maps.newHashMap());
    admin.namespaces().setBacklogQuota(""prop/ns-quota"", BacklogQuota.builder().limitTime(TIME_TO_CHECK_BACKLOG_QUOTA).retentionPolicy(consumer_backlog_eviction).build(), message_age);
    PulsarClient client = PulsarClient.builder().serviceUrl(adminUrl.toString()).statsInterval(0, TimeUnit.SECONDS).build();
    final String topic = ""persistent"";
    final String subName = ""c1"";
    Consumer<byte[]> consumer = client.newConsumer().topic(topic).subscriptionName(subName).subscribe();
    Producer<byte[]> producer = createProducer(client, topic);
    producer.send(new byte[1024]);
    consumer.receive();
    admin.topics().unload(topic);
    PersistentTopicInternalStats internalStats = admin.topics().getInternalStats(topic);
    assertEquals(internalStats.ledgers.size(), 2);
    assertEquals(internalStats.ledgers.get(1).entries, 0);
    TopicStats stats = admin.topics().getStats(topic);
    assertEquals(stats.getSubscriptions().get(subName).getMsgBacklog(), 1);
    TimeUnit.SECONDS.sleep(TIME_TO_CHECK_BACKLOG_QUOTA);
    Awaitility.await().pollInterval(Duration.ofSeconds(1)).atMost(Duration.ofSeconds(TIME_TO_CHECK_BACKLOG_QUOTA)).untilAsserted(() -> {
        rolloverStats();
        PersistentTopicInternalStats latestInternalStats = admin.topics().getInternalStats(topic);
        assertEquals(latestInternalStats.ledgers.size(), 2);
        assertEquals(latestInternalStats.ledgers.get(1).entries, 0);
        TopicStats latestStats = admin.topics().getStats(topic);
        assertEquals(latestStats.getSubscriptions().get(subName).getMsgBacklog(), 0);
    });
    client.close();
}"
"@Test public void primitiveLongs(){
    assertThat(testResult(PrimitiveLongs.class),isSuccessful());
    assertEquals(3,PrimitiveLongs.iterations);
    assertEquals(new HashSet<>(asList(-6L,-7L,-8L)),PrimitiveLongs.testCases);
    PrimitiveLongs.iterations=0;
}"
"public void test_for_issue() throws Exception {
    ParserConfig config=new ParserConfig();
    String json=""{\""k\"":1,\""v\"":\""A\""}"";
    {
        Map.Entry entry=JSON.parseObject(json,Map.Entry.class,config);
        Object key=entry.getKey();
        Object value=entry.getValue();
        assertTrue(key.equals(""v"") || key.equals(""k""));
        if (key.equals(""v"")) {
            assertEquals(""A"",value);
        }
        else {
            assertEquals(1,value);
        }
    }
    config.putDeserializer(Map.Entry.class,new ObjectDeserializer(){
        public <T>T deserialze(    DefaultJSONParser parser,    Type type,    Object fieldName){
            JSONObject object=parser.parseObject();
            Object k=object.get(""k"");
            Object v=object.get(""v"");
            return (T)Collections.singletonMap(k,v).entrySet().iterator().next();
        }
        public int getFastMatchToken(){
            return 0;
        }
    }
    );
    Map.Entry entry=JSON.parseObject(json,Map.Entry.class,config);
    assertEquals(1,entry.getKey());
    assertEquals(""A"",entry.getValue());
}"
"public void test_for_issue(){
    VO vo=new VO();
    vo.id=123;
    vo.location=new Location(127,37);
    Object obj=JSON.toJSON(vo);
    String text=JSON.toJSONString(obj,SerializerFeature.MapSortField);
    assertEquals(""{\""id\"":123,\""latitude\"":37,\""longitude\"":127}"",text);
}"
"@Test
public void testWsSubprotocols() throws Exception {
    Tomcat tomcat = getTomcatInstance();
    Context ctx = tomcat.addContext("""", System.getProperty(""java.io.tmpdir""));
    ctx.addApplicationListener(new ApplicationListener(Config.class.getName(), false));
    Tomcat.addServlet(ctx, ""default"", new DefaultServlet());
    ctx.addServletMapping(""/"", ""default"");
    tomcat.start();
    WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer();
    tomcat.start();
    Session wsSession = wsContainer.connectToServer(TesterProgrammaticEndpoint.class, Builder.create().preferredSubprotocols(Arrays.asList(""sp3"")).build(), new URI((""ws"")));
    Assert.assertTrue(wsSession.isOpen());
    if (wsSession.getNegotiatedSubprotocol() != null) {
        Assert.assertTrue(wsSession.getNegotiatedSubprotocol().isEmpty());
    }
    wsSession.close();
    wsSession = wsContainer.connectToServer(TesterProgrammaticEndpoint.class, Builder.create().preferredSubprotocols(Arrays.asList(""sp2"")).build(), new URI((""ws"")));
    Assert.assertTrue(wsSession.isOpen());
    Assert.assertEquals(""sp2"", wsSession.getNegotiatedSubprotocol());
    Assert.assertArrayEquals(new String[]{ ""sp1"", ""sp2"" }, SubProtocolsEndpoint.subprotocols.toArray(new String[2]));
    wsSession.close();
}"
"@Test public void primitiveFloats() throws Exception {
    assertThat(testResult(PrimitiveFloats.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveFloats.iterations);
    PrimitiveFloats.iterations=0;
}"
"@Test
public void testRead() throws Exception {
    FileSystem fs = cluster.getFileSystem();
    long tStart = System.currentTimeMillis();
    bench.readTest(fs);
    long execTime = System.currentTimeMillis() - tStart;
    bench.analyzeResult(fs, TestType.TEST_TYPE_READ, execTime);
}"
"@Test
public void testBacklogLimiter() {
    long duration = runWithRate(2 * RateLimiting.DEFAULT_MAX_PARALLELISM,-1.0 , new DelayFn<Integer>());
    Assert.assertThat(duration,greaterThan(2 * DelayFn.DELAY_MS));
}"
"@Test
public void testList() throws Exception {
    bindList();
    NamingEnumeration<NameClassPair> results = namingContext.list(new CompositeName());
    checkListResults(results);
    results = (NamingEnumeration<NameClassPair>) testActionPermission(JndiPermission.ACTION_LIST, namingContext, null);
    checkListResults(results);
}"
"@Test
void validUsage() throws Exception {
    assertThat(stopWatch.isRunning()).isFalse();
    stopWatch.start(name1);
    Thread.sleep(duration1);
    assertThat(stopWatch.isRunning()).isTrue();
    assertThat(stopWatch.currentTaskName()).isEqualTo(name1);
    stopWatch.stop();
    assertThat(stopWatch.isRunning()).isFalse();
    assertThat(stopWatch.getLastTaskTimeNanos())
    .as(""last task time in nanoseconds for task #2"")
    .isGreaterThanOrEqualTo(millisToNanos(duration2))
    .isLessThanOrEqualTo(millisToNanos(duration2 + fudgeFactor));
    assertThat(stopWatch.getTotalTimeMillis())
    .as(""total time in milliseconds for tasks #1 and #2"")
    .isGreaterThanOrEqualTo(duration1 + duration2 - fudgeFactor)
    .isLessThanOrEqualTo(duration1 + duration2 + fudgeFactor);
    assertThat(stopWatch.getTotalTimeSeconds())
    .as(""total time in seconds for task #2"")
    .isGreaterThanOrEqualTo((duration1 + duration2 - fudgeFactor) / 1000.0)
    .isLessThanOrEqualTo((duration1 + duration2 + fudgeFactor) / 1000.0);
    assertThat(stopWatch.getTaskCount()).isEqualTo(2);
    assertThat(stopWatch.prettyPrint()).contains(name1, name2);
    assertThat(stopWatch.getTaskInfo()).extracting(TaskInfo::getTaskName).containsExactly(name1, name2);
    assertThat(stopWatch.toString()).contains(ID, name1, name2);
    assertThat(stopWatch.getId()).isEqualTo(ID);
}"
"@Test public void acrossParametersOfSameType() throws Exception {
    assertThat(testResult(ParametersOfSameType.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),ParametersOfSameType.iterations);
    ParametersOfSameType.iterations=0;
}"
"@Test
public void testSessionCreated() throws Exception {
    final Semaphore semaphore = new Semaphore(0);
    final StringBuffer stringBuffer = new StringBuffer();
    VmPipeAcceptor vmPipeAcceptor = new VmPipeAcceptor();
    final VmPipeAddress vmPipeAddress = new VmPipeAddress(12345);
    vmPipeAcceptor.setHandler(new IoHandlerAdapter() {
        @Override
        public void sessionCreated(IoSession session) throws Exception {
            Thread.sleep(1000);
            stringBuffer.append(""A"");
        }
        @Override
        public void sessionOpened(IoSession session) throws Exception {
            stringBuffer.append(""B"");
        }
        @Override
        public void messageReceived(IoSession session, Object message) throws Exception {
            stringBuffer.append(""C"");
        }
        @Override
        public void sessionClosed(IoSession session) throws Exception {
            stringBuffer.append(""D"");
            semaphore.release();
        }
    });
    vmPipeAcceptor.bind(vmPipeAddress);
    final VmPipeConnector vmPipeConnector = new VmPipeConnector();
    vmPipeConnector.getFilterChain().addLast(""executor"", new ExecutorFilter());
    vmPipeConnector.setHandler(new IoHandlerAdapter() {
        @Override
        public void sessionOpened(IoSession session) throws Exception {
            session.write(IoBuffer.wrap(new byte[1]));
        }
    });
    ConnectFuture connectFuture = vmPipeConnector.connect(vmPipeAddress);
    connectFuture.awaitUninterruptibly();
    connectFuture.getSession().close();
    semaphore.tryAcquire(1, TimeUnit.SECONDS);
    vmPipeAcceptor.unbind(vmPipeAddress);
    Assert.assertEquals(""ABCD"", stringBuffer.toString());
}"
"@Test public void manyParameters(){
    assertThat(testResult(ManyParameters.class),isSuccessful());
    assertEquals(10,ManyParameters.iterations);
    assertEquals(new HashSet<>(asList(-1,-2,-4)),new HashSet<>(ManyParameters.firstValues.subList(0,3)));
    assertEquals(new HashSet<>(asList('r','y')),new HashSet<>(ManyParameters.secondValues.subList(0,2)));
    ManyParameters.iterations=0;
}"
"@Test public void primitiveFloats() throws Exception {
    assertThat(testResult(PrimitiveFloats.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveFloats.iterations);
    assertEquals(new HashSet<>(asList(3.3F,-5F)),new HashSet<>(PrimitiveFloats.values.subList(0,2)));
    PrimitiveFloats.iterations=0;
}"
"@Test
public void testSerialize() throws SerializationException {
    GetUserIdSerializableRequest request = new GetUserIdSerializableRequest();
    request.setOperation(GETUSERID);
    request.setInfoField1(""nobody@amazon.com"");
    request.setInfoField2(""AMZN"");
    String requestString = serializer.encode(request);
    assertEquals(""{\""operation\"":\""GetUserId\"",\""infoField1\"":\""nobody@amazon.com\"",\""infoField2\"":\""AMZN\""}"", requestString);
}"
"@Test
public void testALSInputProducer() throws Exception {
    Map<String, Object> overlayConfig = new HashMap<>();
    overlayConfig.put(""oryx.serving.application-resources"", ""\""com.cloudera.oryx.app.serving,com.cloudera.oryx.app.serving.als\"""");
    overlayConfig.put(""oryx.serving.model-manager-class"", ALSServingModelManager.class.getName());
    Config config = ConfigUtils.overlayOn(overlayConfig, getConfig());
    startMessaging();
    startServer(config);
    @SuppressWarnings(""unchecked"")
    TopicProducer<String, String> inputProducer = ((TopicProducer<String, String>) (getServingLayer().getContext().getServletContext().getAttribute(INPUT_PRODUCER_KEY)));
    String[] inputs = new String[]{ ""abc,123,1.5"", ""xyz,234,-0.5"", ""AB,10,0"" };
    List<Pair<String, String>> keyMessages;
    try (final CloseableIterator<Pair<String, String>> data = new ConsumeData(INPUT_TOPIC, getZKPort()).iterator()) {
        log.info(""Starting consumer thread"");
        ConsumeTopicRunnable consumeInput = new ConsumeTopicRunnable(data);
        new Thread(consumeInput).start();
        Thread.sleep(3000);
        for (String input : inputs) {
            inputProducer.send("""", input);
        }
        Thread.sleep(1000);
        keyMessages = consumeInput.getKeyMessages();
    }
    for (int i = 0; i < keyMessages.size(); i++) {
        Pair<String, String> keyMessage = keyMessages.get(i);
        assertEquals("""", keyMessage.getFirst());
        assertEquals(inputs[i], keyMessage.getSecond());
    }
    assertEquals(inputs.length, keyMessages.size());
}"
"@Test
void logWithExtras() {
    Instant start = Instant.now();
    List<LogData> logDataList = logExporter.getFinishedLogItems();
    assertThat(logDataList).hasSize(1);
    LogData logData = logDataList.get(0);
    assertThat(logData.getResource()).isEqualTo(resource);
    assertThat(logData.getInstrumentationLibraryInfo()).isEqualTo(instrumentationLibraryInfo);
    assertThat(logData.getBody().asString()).isEqualTo(""log message 1"");
    assertThat(logData.getEpochNanos()).isGreaterThanOrEqualTo(TimeUnit.MILLISECONDS.toNanos(start.toEpochMilli())).isLessThanOrEqualTo(TimeUnit.MILLISECONDS.toNanos(Instant.now().toEpochMilli()));
    assertThat(logData.getSeverity()).isEqualTo(INFO);
    assertThat(logData.getSeverityText()).isEqualTo(""INFO"");
    assertThat(logData.getAttributes().size()).isEqualTo(3);
    assertThat(logData.getAttributes().get(EXCEPTION_TYPE)).isEqualTo(IllegalStateException.class.getName());
    assertThat(logData.getAttributes().get(EXCEPTION_MESSAGE)).isEqualTo(""Error!"");
    assertThat(logData.getAttributes().get(EXCEPTION_STACKTRACE)).contains(""logWithExtras"");
}"
"@Test public void test2_2() throws Exception {
    String jsonStr=""[{\""name\"":\""p1\"",\""sonList\"":[{\""name\"":\""s1\""}]},{\""name\"":\""p2\"",\""sonList\"":[{\""name\"":\""s2\""},{\""name\"":\""s3\""}]}]"";
    ResultActions actions=mockMvc.perform((post(""/fastjson/test2?jsonp=fnUpdateSome"").characterEncoding(""UTF-8"").content(jsonStr).contentType(MediaType.APPLICATION_JSON)));
    actions.andDo(print());
    actions.andExpect(status().isOk()).andExpect(content().contentType(APPLICATION_JAVASCRIPT));
    String content=actions.andReturn().getResponse().getContentAsString();
    assertTrue(content.equals(""/**/fnUpdateSome({\""p1\"":1,\""p2\"":2})"") || content.equals(""/**/fnUpdateSome({\""p2\"":2,\""p1\"":1})""));
}"
"@Test public void testNotAllowNullSchema() throws JSONException {
    JSONSchema<Foo> jsonSchema=JSONSchema.of(SchemaDefinition.<Foo>builder().withPojo(Foo.class).withAlwaysAllowNull(false).build());
    Assert.assertEquals(jsonSchema.getSchemaInfo().getType(),SchemaType.JSON);
    Schema.Parser parser=new Schema.Parser();
    String schemaJson=new String(jsonSchema.getSchemaInfo().getSchema());
    assertJSONEqual(schemaJson,SCHEMA_JSON_NOT_ALLOW_NULL);
    Schema schema=parser.parse(schemaJson);
    for (  String fieldName : FOO_FIELDS) {
        Schema.Field field=schema.getField(fieldName);
        Assert.assertNotNull(field);
        if (field.name().equals(""field4"")) {
            Assert.assertNotNull(field.schema().getTypes().get(1).getField(""field1""));
        }
        if (field.name().equals(""fieldUnableNull"")) {
            Assert.assertNotNull(field.schema().getType());
        }
    }
}"
"@Test public void testFormatMultiple(){
    HashMap<String,String> params=new HashMap<String,String>();
    params.put(""a"",""b"");
    params.put(""a"",""b"");
    params.put(""b"",""c"");
    String s=KeyValueFormatter.format(params,true);
    Assert.assertTrue((""a=b&b=c"").equals(s) || (""b=c&a=b"").equals(s));
}"
"@Test public void primitiveShorts() throws Exception {
    assertThat(testResult(PrimitiveShorts.class),isSuccessful());
    assertEquals(defaultPropertyTrialCount(),PrimitiveShorts.iterations);
    assertEquals(new HashSet<>(asList(Short.valueOf(""9""),Short.valueOf(""8""))),new HashSet<>(PrimitiveShorts.values.subList(0,2)));
    PrimitiveShorts.iterations=0;
}"
"@Test
public void testSystemMetadataRetrieval() throws Exception {
    appClient.deploy(DEFAULT, createAppJarFile(AllProgramsApp.class));
    Id.Stream streamId = Stream.from(DEFAULT, STREAM_NAME);
    Set<String> streamSystemTags = getTags(streamId, SYSTEM);
    Assert.assertEquals(ImmutableSet.of(STREAM_NAME), streamSystemTags);
    Map<String, String> streamSystemProperties = getProperties(streamId, SYSTEM);
    final String creationTime = ""creation-time"";
    String description = ""description"";
    String schema = ""schema"";
    String ttl = ""ttl"";
    Assert.assertTrue(""Expected creation time to exist but it does not"", streamSystemProperties.containsKey(creationTime));
    long createTime = Long.parseLong(streamSystemProperties.get(creationTime));
    Assert.assertTrue(""Stream create time should be within the last hour - "" + createTime, createTime > (System.currentTimeMillis() - TimeUnit.HOURS.toMillis(1)));
    Assert.assertEquals(ImmutableMap.of(schema, Schema.recordOf(""stringBody"", Field.of(""body"", Schema.of(STRING))).toString(), ttl, String.valueOf(Long.MAX_VALUE), description, ""test stream"", creationTime, String.valueOf(createTime)), streamSystemProperties);
    long newTtl = 100000L;
    streamClient.setStreamProperties(streamId, new StreamProperties(newTtl, null, null));
    streamSystemProperties = getProperties(streamId, SYSTEM);
    Assert.assertEquals(ImmutableMap.of(schema, Schema.recordOf(""stringBody"", Field.of(""body"", Schema.of(STRING))).toString(), ttl, String.valueOf(newTtl * 1000), description, ""test stream"", creationTime, String.valueOf(createTime)), streamSystemProperties);
    Set<MetadataRecord> streamSystemMetadata = getMetadata(streamId, SYSTEM);
    Assert.assertEquals(ImmutableSet.of(new MetadataRecord(streamId, MetadataScope.SYSTEM, streamSystemProperties, streamSystemTags)), streamSystemMetadata);
    Id.Stream.View view = View.from(streamId, ""view"");
    Schema viewSchema = Schema.recordOf(""record"", Field.of(""viewBody"", Schema.nullableOf(Schema.of(BYTES))));
    streamViewClient.createOrUpdate(view, new ViewSpecification(new FormatSpecification(""format"", viewSchema)));
    Set<String> viewSystemTags = getTags(view, SYSTEM);
    Assert.assertEquals(ImmutableSet.of(""view"", STREAM_NAME), viewSystemTags);
    Map<String, String> viewSystemProperties = getProperties(view, SYSTEM);
    Assert.assertEquals(viewSchema.toString(), viewSystemProperties.get(schema));
    ImmutableSet<String> viewUserTags = ImmutableSet.of(""viewTag"");
    addTags(view, viewUserTags);
    Assert.assertEquals(ImmutableSet.of(new MetadataRecord(view, MetadataScope.USER, ImmutableMap.<String, String>of(), viewUserTags), new MetadataRecord(view, MetadataScope.SYSTEM, viewSystemProperties, viewSystemTags)), getMetadata(view));
    Id.DatasetInstance datasetInstance = DatasetInstance.from(DEFAULT, DATASET_NAME);
    Set<String> dsSystemTags = getTags(datasetInstance, SYSTEM);
    Assert.assertEquals(ImmutableSet.of(DATASET_NAME, BATCH_TAG, EXPLORE_TAG), dsSystemTags);
    Map<String, String> dsSystemProperties = getProperties(datasetInstance, SYSTEM);
    Assert.assertTrue(""Expected creation time to exist but it does not"", dsSystemProperties.containsKey(creationTime));
    createTime = Long.parseLong(dsSystemProperties.get(creationTime));
    Assert.assertTrue(""Dataset create time should be within the last hour - "" + createTime, createTime > (System.currentTimeMillis() - TimeUnit.HOURS.toMillis(1)));
    Assert.assertEquals(ImmutableMap.of(""type"", KeyValueTable.class.getName(), description, ""test dataset"", creationTime, String.valueOf(createTime)), dsSystemProperties);
    datasetClient.update(datasetInstance, ImmutableMap.of(PROPERTY_TTL, ""100000""));
    dsSystemProperties = getProperties(datasetInstance, SYSTEM);
    Assert.assertEquals(ImmutableMap.of(""type"", KeyValueTable.class.getName(), description, ""test dataset"", ttl, ""100000"", creationTime, String.valueOf(createTime)), dsSystemProperties);
    Id.Artifact artifactId = getArtifactId();
    Assert.assertEquals(ImmutableSet.of(new MetadataRecord(artifactId, MetadataScope.SYSTEM, ImmutableMap.<String, String>of(), ImmutableSet.of(AllProgramsApp.class.getSimpleName()))), getMetadata(artifactId, SYSTEM));
    Id.Application app = Application.from(DEFAULT, NAME);
    Assert.assertEquals(ImmutableMap.builder().put((FLOW.getPrettyName() + MetadataDataset.KEYVALUE_SEPARATOR) + NoOpFlow.NAME, NAME).put((MAPREDUCE.getPrettyName() + MetadataDataset.KEYVALUE_SEPARATOR) + NoOpMR.NAME, NAME).put((MAPREDUCE.getPrettyName() + MetadataDataset.KEYVALUE_SEPARATOR) + NoOpMR2.NAME, NAME).put((SERVICE.getPrettyName() + MetadataDataset.KEYVALUE_SEPARATOR) + NoOpService.NAME, NAME).put((SPARK.getPrettyName() + MetadataDataset.KEYVALUE_SEPARATOR) + NoOpSpark.NAME, NAME).put((WORKER.getPrettyName() + MetadataDataset.KEYVALUE_SEPARATOR) + NoOpWorker.NAME, NAME).put((WORKFLOW.getPrettyName() + MetadataDataset.KEYVALUE_SEPARATOR) + NoOpWorkflow.NAME, NAME).put((""schedule"" + MetadataDataset.KEYVALUE_SEPARATOR) + AllProgramsApp.SCHEDULE_NAME, (AllProgramsApp.SCHEDULE_NAME + MetadataDataset.KEYVALUE_SEPARATOR) + AllProgramsApp.SCHEDULE_DESCRIPTION).build(), getProperties(app, SYSTEM));
    Assert.assertEquals(ImmutableSet.of(AllProgramsApp.class.getSimpleName(), NAME), getTags(app, SYSTEM));
    assertProgramSystemMetadata(Program.from(app, FLOW, NAME), ""Realtime"");
    assertProgramSystemMetadata(Program.from(app, WORKER, NAME), ""Realtime"");
    assertProgramSystemMetadata(Program.from(app, SERVICE, NAME), ""Realtime"");
    assertProgramSystemMetadata(Program.from(app, MAPREDUCE, NAME), ""Batch"");
    assertProgramSystemMetadata(Program.from(app, SPARK, NAME), ""Batch"");
    assertProgramSystemMetadata(Program.from(app, WORKFLOW, NAME), ""Batch"");
}"
"@Test public void serializeInteger() throws IOException {
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of(1)),""{\""@type\"":\""integer\"",\""@value\"":1}"");
    assertJsonEqualsNonStrict(objectMapper.writeValueAsString(ValueReference.of(42)),""{\""@type\"":\""integer\"",\""@value\"":42}"");
}"
"@Test
public void excerpt() throws Exception {
    Session session = getAdminSession();
    QueryManager qm = session.getWorkspace().getQueryManager();
    Node testRootNode = session.getRootNode().addNode(""testroot"");
    Node n1 = testRootNode.addNode(""node1"");
    n1.setProperty(""text"", ""hello world"");
    n1.setProperty(""desc"", ""description"");
    Node n2 = testRootNode.addNode(""node2"");
    n2.setProperty(""text"", ""Hello World"");
    n2.setProperty(""desc"", ""Description"");
    session.save();
    Query q;
    RowIterator it;
    Row row;
    String s;
    String xpath = """";
    q = qm.createQuery(xpath, ""xpath"");
    it = q.execute().getRows();
    row = it.nextRow();
    s = row.getValue(""rep:excerpt(.)"").getString();
    assertTrue(s, s.indexOf(""<strong>hello</strong> world"") >= 0);
    assertTrue(s, s.indexOf(""description"") >= 0);
    row = it.nextRow();
    s = row.getValue(""rep:excerpt(.)"").getString();
    assertTrue(s, s.indexOf(""Hello World"") >= 0);
    assertTrue(s, s.indexOf(""Description"") >= 0);
    xpath = """";
    q = qm.createQuery(xpath, ""xpath"");
    it = q.execute().getRows();
    row = it.nextRow();
    s = row.getValue(""rep:excerpt(text)"").getString();
    assertTrue(s, s.indexOf(""<strong>hello</strong> world"") >= 0);
    assertTrue(s, s.indexOf(""description"") < 0);
    row = it.nextRow();
    s = row.getValue(""rep:excerpt(text)"").getString();
    assertTrue(s, s.indexOf(""Hello World"") >= 0);
    assertTrue(s, s.indexOf(""Description"") < 0);
}"
"@Test
public void testMonitor() throws IOException, InterruptedException {
    monitor.setScanInterval(5);
    assertTrue(monitor.getEntries().isEmpty());
    File fooFile = touchFile(""foo"", ""foo1"");
    Thread.sleep(MONITOR_CHECK_DELAY);
    Collection<TestInstance> entries = monitor.getEntries();
    assertEquals(1, entries.size());
    TestInstance[] entryArray = new TestInstance[1];
    entryArray = entries.toArray(entryArray);
    TestInstance fooInst = entryArray[0];
    assertEquals(""foo1"", fooInst.getMessage());
    touchFile(""bar"", ""bar1"");
    Thread.sleep(MONITOR_CHECK_DELAY);
    entries = monitor.getEntries();
    assertEquals(2, entries.size());
    TestInstance fooCheck = monitor.get(""foo"");
    TestUtil.testArray(entryNames(entries), new String[]{ ""foo1"", ""bar1"" });
    assertEquals(fooCheck, fooInst);
    touchFile(""foo"", ""foo2"");
    Thread.sleep(MONITOR_CHECK_DELAY);
    entries = monitor.getEntries();
    assertEquals(2, entries.size());
    TestUtil.testArray(entryNames(entries), new String[]{ ""foo2"", ""bar1"" });
    fooCheck = monitor.get(""foo"");
    assertNotSame(fooInst, fooCheck);
    assertEquals(""foo2"", fooCheck.getMessage());
    fooFile.delete();
    Thread.sleep(MONITOR_CHECK_DELAY);
    entries = monitor.getEntries();
    assertEquals(1, entries.size());
    TestUtil.testArray(entryNames(entries), new String[]{ ""bar1"" });
}"
"@Test
public void testFromDbField() throws Exception {
    Field[] fields = Foo.class.getDeclaredFields();
    assertTrue(fields.length >= 1);
    DatabaseFieldConfig config = DatabaseFieldConfig.fromField(databaseType, ""foo"", fields[0]);
    assertNotNull(config);
    assertTrue(config.isCanBeNull());
    assertEquals(fields[0].getName(), config.getFieldName());
}"
