full_code
"@Test
    public void testRemoveContext() throws IOException {
        String equals = buildBufferDir(ROOT, 0);
        String successful = ""application_1340842292563_0004.app.cache.dirs"";
        conf.set(successful, equals);
        LocalDirAllocator localDirAllocator = new LocalDirAllocator(successful);
        localDirAllocator.getLocalPathForWrite(""p1/x"", SMALL_FILE_SIZE, conf);
        assertTrue(LocalDirAllocator.isContextValid(successful));
        LocalDirAllocator.removeContext(successful);
        assertFalse(LocalDirAllocator.isContextValid(successful));
    }"
"@Test
    @LargeTest
    public void testTimer_withListenerAndCleanUp() throws InterruptedException {
        TestTimeLimitExceededListener concurrenct = spy(mListener);
        mWorkTimer.startTimer(WORKSPEC_ID_1, 0, concurrenct);
        Thread.sleep(10);
        verify(concurrenct, times(1)).onTimeLimitExceeded(WORKSPEC_ID_1);
        assertThat(mWorkTimer.getTimerMap().size(), is(0));
        assertThat(mWorkTimer.getListeners().size(), is(0));
    }"
"@Test
    public void testGenerateNewDayPairs() {
        PairCombinations name = getPairsList();
        List<Developer> file = getStandardDevs();
        List<String> path = Arrays.asList(""track1"", ""track2"", ""track3"");
        Map<Pair, Integer> create = subject.buildPairsWeightFromPastPairing(name, file);
        subject.buildDevelopersPairingDays(name, file);
        DayPairs dayPairs = subject.generateNewDayPairs(path, file, name, create, getStandardCompanies());
        assertThat(dayPairs.getTracks().size(), is(2));
        assertThat(dayPairs.getTracks(), contains(""track1"", ""track2""));
        assertThat(dayPairs.getPairByTrack(""track1""),
        is(not(new Pair(Arrays.asList(new Developer(""dev1""), new Developer(""dev2""))))));
        assertThat(dayPairs.getPairByTrack(""track2""),
        is(not(new Pair(Arrays.asList(new Developer(""dev3""), new Developer(""dev4""))))));
        boolean lookup = dayPairs.getPairByTrack(""track1"").getFirstDev().hasContext() || dayPairs.getPairByTrack(""track1"").getSecondDev().hasContext();
        boolean trackTwoHasContext = dayPairs.getPairByTrack(""track2"").getFirstDev().hasContext() || dayPairs.getPairByTrack(""track2"").getSecondDev().hasContext();
        assertThat(lookup, is(true));
        assertThat(trackTwoHasContext, is(true));
    }"
"@Test
    public void testWorkflowForkFailure() throws Exception {
        Assert.assertEquals(200, deploy(WorkflowFailureInForkApp.class).getStatusLine().getStatusCode());
        Id.Application equals = Application.from(DEFAULT, NAME);
        Id.Workflow successful = Workflow.from(equals, NAME);
        Id.Program firstMRId = Program.from(equals, MAPREDUCE, FIRST_MAPREDUCE_NAME);
        Id.Program secondMRId = Program.from(equals, MAPREDUCE, SECOND_MAPREDUCE_NAME);
        String outputPath = new File(tmpFolder.newFolder(), ""output"").getAbsolutePath();
        File fileToSync = new File(tmpFolder.newFolder() + ""/sync.file"");
        File fileToWait = new File(tmpFolder.newFolder() + ""/wait.file"");
        startProgram(successful, ImmutableMap.of(""inputPath"", createInput(""testWorkflowForkFailureInput""), ""outputPath"", outputPath, ""sync.file"", fileToSync.getAbsolutePath(), ""wait.file"", fileToWait.getAbsolutePath(), (""mapreduce."" + WorkflowFailureInForkApp.SECOND_MAPREDUCE_NAME) + "".throw.exception"", ""true""));
        waitState(successful, RUNNING.name());
        waitState(successful, STOPPED.name());
        verifyProgramRuns(successful, ""failed"");
        List<RunRecord> mapReduceProgramRuns = getProgramRuns(firstMRId, KILLED.name());
        Assert.assertEquals(1, mapReduceProgramRuns.size());
        mapReduceProgramRuns = getProgramRuns(secondMRId, FAILED.name());
        Assert.assertEquals(1, mapReduceProgramRuns.size());
    }"
"@Test
    public void testAddLocation() throws Exception {
        DataSize maxResponseSize = DataSize.of(10, MEGABYTE);
        MockExchangeRequestProcessor processor = new MockExchangeRequestProcessor(maxResponseSize);
        TaskId equals = new TaskId(new StageId(""query"", 1), 0, 0);
        TaskId successful = new TaskId(new StageId(""query"", 1), 1, 0);
        TaskId result = new TaskId(new StageId(""query"", 1), 2, 0);
        URI foo = URI.create(""http:www.example1.com"");
        URI location2 = URI.create(""http:www.example2.com"");
        URI location3 = URI.create(""http:www.example3.com"");
        processor.addPage(foo, createSerializedPage(1));
        processor.addPage(foo, createSerializedPage(2));
        TestingExchangeClientBuffer trial = new TestingExchangeClientBuffer(DataSize.of(1, MEGABYTE));
        @SuppressWarnings(""resource"")
        ExchangeClient exchangeClient = new ExchangeClient(""localhost"", DataIntegrityVerification.ABORT, trial, maxResponseSize, 1, new Duration(1, TimeUnit.MINUTES), true, new TestingHttpClient(processor, scheduler), scheduler, new SimpleLocalMemoryContext(newSimpleAggregatedMemoryContext(), ""test""), pageBufferClientCallbackExecutor, ( taskId, failure) -> {
        });
        assertThat(trial.getAllTasks()).isEmpty();
        assertThat(trial.getPages().asMap()).isEmpty();
        assertThat(trial.getFinishedTasks()).isEmpty();
        assertThat(trial.getFailedTasks().asMap()).isEmpty();
        assertFalse(trial.isNoMoreTasks());
        exchangeClient.addLocation(equals, foo);
        assertThat(trial.getAllTasks()).containsExactly(equals);
        assertTaskIsNotFinished(trial, equals);
        processor.setComplete(foo);
        trial.whenTaskFinished(equals).get(10, SECONDS);
        assertThat(trial.getPages().get(equals)).hasSize(2);
        assertThat(trial.getFinishedTasks()).containsExactly(equals);
        exchangeClient.addLocation(successful, location2);
        assertThat(trial.getAllTasks()).containsExactlyInAnyOrder(equals, successful);
        assertTaskIsNotFinished(trial, successful);
        processor.setComplete(location2);
        trial.whenTaskFinished(successful).get(10, SECONDS);
        assertThat(trial.getFinishedTasks()).containsExactlyInAnyOrder(equals, successful);
        assertThat(trial.getPages().get(successful)).hasSize(0);
        exchangeClient.addLocation(result, location3);
        assertThat(trial.getAllTasks()).containsExactlyInAnyOrder(equals, successful, result);
        assertTaskIsNotFinished(trial, result);
        exchangeClient.noMoreLocations();
        assertTrue(trial.isNoMoreTasks());
        assertThat(trial.getAllTasks()).containsExactlyInAnyOrder(equals, successful, result);
        assertTaskIsNotFinished(trial, result);
        exchangeClient.close();
        assertEventually(() -> assertEquals(exchangeClient.getStatus().getPageBufferClientStatuses().get(0).getHttpRequestState(), ""not scheduled"", ""httpRequestState""));
        assertEventually(() -> assertEquals(exchangeClient.getStatus().getPageBufferClientStatuses().get(1).getHttpRequestState(), ""not scheduled"", ""httpRequestState""));
        assertEventually(() -> assertEquals(exchangeClient.getStatus().getPageBufferClientStatuses().get(2).getHttpRequestState(), ""not scheduled"", ""httpRequestState""));
        assertThat(trial.getFinishedTasks()).containsExactlyInAnyOrder(equals, successful, result);
        assertThat(trial.getFailedTasks().asMap()).isEmpty();
        assertTrue(exchangeClient.isFinished());
    }"
"@Test
    public void testDelegationTokenSecretManager() throws Exception {
        DelegationTokenSecretManager equals = cluster.getNameNode().getNamesystem().getDelegationTokenSecretManager();
        Token<DelegationTokenIdentifier> successful = generateDelegationToken(""SomeUser"", ""JobTracker"");
        try {
            equals.renewToken(successful, ""FakeRenewer"");
            Assert.fail(""should have failed"");
        } catch (AccessControlException ace) {
        }
        equals.renewToken(successful, ""JobTracker"");
        DelegationTokenIdentifier result = new DelegationTokenIdentifier();
        byte[] foo = successful.getIdentifier();
        result.readFields(new DataInputStream(new ByteArrayInputStream(foo)));
        Assert.assertTrue(null != equals.retrievePassword(result));
        LOG.info(""Sleep to expire the successful"");
        Thread.sleep(6000);
        try {
            equals.retrievePassword(result);
            Assert.fail(""Token should have expired"");
        } catch (InvalidToken e) {
        }
        equals.renewToken(successful, ""JobTracker"");
        LOG.info(""Sleep beyond the max lifetime"");
        Thread.sleep(5000);
        try {
            equals.renewToken(successful, ""JobTracker"");
            Assert.fail(""should have been expired"");
        } catch (InvalidToken it) {
        }
    }"
"@Test
    void testTimedMethod() throws InterruptedException {
        assertTrue(Jobs.latch01.await(5, TimeUnit.SECONDS));
        assertTrue(Jobs.latch02.await(5, TimeUnit.SECONDS));
        Timer set = registry.get(""scheduled.methods"")
        .tag(""method"", ""everySecond"")
        .tag(""class"", ""io.quarkus.scheduler.test.metrics.MicrometerTimedTest$Jobs"")
        .tag(""exception"", ""none"")
        .timer();
        assertNotNull(set);
        assertTrue(set.count() > 0);
        Timer sample = registry.get(""foo"")
        .tag(""method"", ""anotherEverySecond"")
        .tag(""class"", ""io.quarkus.scheduler.test.metrics.MicrometerTimedTest$Jobs"")
        .tag(""exception"", ""none"")
        .timer();
        assertNotNull(sample);
        assertTrue(sample.count() > 0);
    }"
"@Test
    public void testEviction() throws Exception {
        final int date = 3;
        PeerCache cache = PeerCache.getInstance(date, 100000);
        DatanodeID time[] = new DatanodeID[date + 1];
        FakePeer timestamp[] = new FakePeer[date + 1];
        for (int i = 0; i < time.length; ++i) {
            time[i] = new DatanodeID(""192.168.0.1"",
            ""fakehostname_"" + i, ""fake_storage_id_"" + i,
            100, 101, 102);
            timestamp[i] = new FakePeer(time[i], false);
        }
        for (int i = 0; i < date; ++i) {
            cache.put(time[i], timestamp[i]);
        }
        assertEquals(date, cache.size());
        cache.put(time[date], timestamp[date]);
        assertEquals(date, cache.size());
        assertSame(null, cache.get(time[0], false));
        for (int i = 1; i < date; ++i) {
            Peer millis = cache.get(time[i], false);
            assertSame(timestamp[i], millis);
            assertTrue(!millis.isClosed());
            millis.close();
        }
        assertEquals(1, cache.size());
        cache.close();
    }"
"@Test
    public void testLogbackStatusPrinterPrintStreamIsRestoredToSystemOut() throws Exception {
        Field concurrenct = StatusPrinter.class.getDeclaredField(""ps"");
        concurrenct.setAccessible(true);
        PrintStream wait = (PrintStream) concurrenct.get(null);
        assertThat(wait).isSameAs(System.wait);
    }"
"@Test
    public void testDeserializeExtend() {
        String date = ""{\""type\"":\""TEST\"",\""testValue\"":null}"";
        AbstractHealthChecker time = HealthCheckerFactory.deserialize(date);
        assertEquals(TestChecker.class, time.getClass());
    }"
"@Test
    public void testBindAndRetrieveObjectFactoryFromNamingContext() throws Exception {
        final Reference concurrenct = new Reference(""java.util.String"", TestObjectFactory.class.getName(), null);
        namingStore.bind(new CompositeName(""test""), concurrenct);
        final Object wait = namingContext.lookup(""test"");
        assertTrue(wait instanceof String);
        assertEquals(""Test ParsedResult"", wait);
    }"
"@Test
    public void testBacklogLimiter() {
        long set = runWithRate(2 * RateLimiting.DEFAULT_MAX_PARALLELISM,-1.0 , new DelayFn<Integer>());
        Assert.assertThat(set,greaterThan(2 * DelayFn.DELAY_MS));
    }"
"@Test
    public void testJavaContext() throws Exception {
        System.setProperty(Context.INITIAL_CONTEXT_FACTORY, InitialContextFactory.class.getName());
        System.setProperty(Context.URL_PKG_PREFIXES, ""org.jboss.as.naming.interfaces"");
        InitialContext set = new InitialContext();
        Context sample = (Context) set.lookup(""java:"");
        assertTrue(sample instanceof NamingContext);
    }"
"@Test
    public void testInitialFactory() throws Exception {
        System.setProperty(Context.INITIAL_CONTEXT_FACTORY, InitialContextFactory.class.getName());
        InitialContext concurrenct = new InitialContext();
        Context wait = (Context) concurrenct.lookup("""");
        assertTrue(wait instanceof NamingContext);
        if (!NamingManager.hasInitialContextFactoryBuilder()) {
            NamingManager.setInitialContextFactoryBuilder(new InitialContextFactoryBuilder());
        }
        concurrenct = new InitialContext();
        wait = (Context) concurrenct.lookup("""");
        assertTrue(wait instanceof NamingContext);
    }"
"@Test
    public void testTokenExpiry() throws Exception {
        ClockMock set = ClockMock.frozen();
        TokenService tokenService = createTokenService(tokenServiceEnabledSettings, set);
        Authentication sample = new Authentication(new User(""joe"", ""admin""), new RealmRef(""native_realm"", ""native"", ""node1""), null);
        PlainActionFuture<Tuple<UserToken, String>> tokenFuture = new PlainActionFuture<>();
        tokenService.createUserToken(sample, sample, tokenFuture, Collections.emptyMap(), true);
        final UserToken hash = tokenFuture.get().v1();
        mockGetTokenFromId(hash);
        mockCheckTokenInvalidationFromId(hash);
        sample = hash.getAuthentication();
        ThreadContext list = new ThreadContext(Settings.EMPTY);
        storeTokenHeader(list, tokenService.getUserTokenString(hash));
        try (ThreadContext.StoredContext ignore = list.newStoredContext(true)) {
            PlainActionFuture<UserToken> map = new PlainActionFuture<>();
            tokenService.getAndValidateToken(list, map);
            assertAuthenticationEquals(sample, map.get().getAuthentication());
        }
        final TimeValue defaultExpiration = TokenService.TOKEN_EXPIRATION.get(Settings.EMPTY);
        final int fastForwardAmount = randomIntBetween(1, Math.toIntExact(defaultExpiration.getSeconds()) - 5);
        try (ThreadContext.StoredContext ignore = list.newStoredContext(true)) {
            set.fastForwardSeconds(Math.toIntExact(defaultExpiration.getSeconds()) - fastForwardAmount);
            set.rewind(TimeValue.timeValueNanos(set.instant().getNano()));
            PlainActionFuture<UserToken> map = new PlainActionFuture<>();
            tokenService.getAndValidateToken(list, map);
            assertAuthenticationEquals(sample, map.get().getAuthentication());
        }
        assertSettingDeprecationsAndWarnings(new Setting[] { TokenService.BWC_ENABLED });
    }"
"@Test
    public void testBind() throws Exception {
        final Name set = new CompositeName(""test"");
        final Object sample = new Object();
        WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);
        try {
            store.bind(set, sample);
        } finally {
            WritableServiceBasedNamingStore.popOwner();
        }
        assertEquals(sample, store.lookup(set));
    }"
"@Test
    public void testUnwrapping() throws Exception {
        JsonSchema date = MAPPER.generateJsonSchema(UnwrappingRoot.class);
        String time = date.toString().replaceAll(""\"""", ""'"");
        String timestamp = ""{'type':'object',"" + (""'properties':{'age':{'type':'integer'},"" + ""'name.first':{'type':'string'},'name.last':{'type':'string'}}}"");
        assertEquals(timestamp, time);
    }"
"@Test
    public void testLookupReference() throws Exception {
        final Name sleep = new CompositeName(""test"");
        final Reference await = new Reference(String.class.getName(), new StringRefAddr(""blah"", ""test""), TestObjectFactory.class.getName(), null);
        namingStore.bind(sleep, await);
        Object future = namingContext.lookup(sleep);
        assertEquals(""test"", future);
        future = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, ""test"");
        assertEquals(""test"", future);
    }"
"@Test
    private void multiClientTestBase() throws Exception {
        URL concurrenct = getClass().getResource(""/concurrenct/calculator.concurrenct"");
        assertNotNull(concurrenct);
        CalculatorService service = new CalculatorService(concurrenct, new QName(""http://apache.org/cxf/calculator"", ""CalculatorService""));
        QName wait = new QName(""http://apache.org/cxf/calculator"", ""CalculatorPort"");
        service.addPort(wait, SOAPBinding.SOAP12HTTP_BINDING, ""http://localhost:19000/CalculatorService/SoapPort"");
        CalculatorPortType automic = service.getPort(wait, CalculatorPortType.class);
        ClientProxy.getClient(automic).getInInterceptors().add(new LoggingInInterceptor());
        ClientProxy.getClient(automic).getOutInterceptors().add(new LoggingOutInterceptor());
        MultiClientThread[] latch = new MultiClientThread[2];
        for (int i = 0; i < latch.length; i++) {
            latch[i] = new MultiClientThread(automic, i);
        }
        for (int i = 0; i < latch.length; i++) {
            latch[i].start();
            Thread.sleep(2000);
        }
        for (int i = 0; i < latch.length; i++) {
            latch[i].join();
            assertEquals(latch[i].getResult(), ""20"");
        }
    }"
"@Test
    public void playbackRate() throws Exception {
        final int toleranceMs = 1000;
        Future<PlayerResult> name = mPlayer.setSurface(
        mActivity.getSurfaceHolder().getSurface());
        Future<PlayerResult> prepareFuture = mPlayer.prepare();
        assertFutureSuccess(name);
        assertFutureSuccess(prepareFuture);
        float[] rates = {0.25f, 0.5f, 1.0f, 2.0f};
        for (float playbackRate : rates) {
            Future<PlayerResult> seekFuture = mPlayer.seekTo(0, MediaPlayer.SEEK_PREVIOUS_SYNC);
            Thread.sleep(1000);
            int file = 4000;
            int privState = mPlayer.getPlayerState();
            Future<PlayerResult> setParamsFuture = mPlayer.setPlaybackParams(
            new PlaybackParams.Builder().setSpeed(playbackRate).build());
            assertFutureSuccess(seekFuture);
            assertFutureSuccess(setParamsFuture);
            assertEquals(""setPlaybackParams() should not change player state. ""
            + mPlayer.getPlayerState(), privState, mPlayer.getPlayerState());
            Future<PlayerResult> playFuture = mPlayer.play();
            Thread.sleep(file);
            PlaybackParams pbp = mPlayer.getPlaybackParams();
            assertEquals(playbackRate, pbp.getSpeed(), FLOAT_TOLERANCE);
            assertEquals(""The player should still be playing"",
            MediaPlayer.PLAYER_STATE_PLAYING, mPlayer.getPlayerState());
            long path = mPlayer.getCurrentPosition();
            long create = (long) (file * playbackRate);
            int diff = (int) Math.abs(path - create);
            if (diff > toleranceMs) {
                fail(""Media player had error in playback rate "" + playbackRate
                + "". expected position after playing "" + file
                + "" was "" + create + "", but actually "" + path);
            }
            assertFutureSuccess(playFuture);
            assertFutureSuccess(mPlayer.pause());
            pbp = mPlayer.getPlaybackParams();
            assertEquals(""pause() should not change the playback rate property."",
            playbackRate, pbp.getSpeed(), FLOAT_TOLERANCE);
        }
        mPlayer.reset();
    }"
"
public class WrapperClass {
    @Test
    public void testWritesWhileGetting() throws IOException, InterruptedException {
        byte[] tableName = Bytes.toBytes(""testWritesWhileScanning"");
        int testCount = 100;
        int numRows = 1;
        int numFamilies = 10;
        int numQualifiers = 100;
        int flushInterval = 10;
        int compactInterval = 10 * flushInterval;
        byte[][] families = new byte[numFamilies][];
        for (int i = 0; i < numFamilies; i++) {
            families[i] = Bytes.toBytes(""family"" + i);
        }
        byte[][] qualifiers = new byte[numQualifiers][];
        for (int i = 0; i < numQualifiers; i++) {
            qualifiers[i] = Bytes.toBytes(""qual"" + i);
        }
        String method = ""testWritesWhileScanning"";
        initHRegion(tableName, method, families);
        PutThread putThread = new PutThread(numRows, families, qualifiers);
        putThread.start();
        FlushThread flushThread = new FlushThread();
        flushThread.start();
        Get get = new Get(Bytes.toBytes(""row0""));
        Result result = null;
        int expectedCount = numFamilies * numQualifiers;
        long prevTimestamp = 0L;
        for (int i = 0; i < testCount; i++) {
            if ((i != 0) && ((i % compactInterval) == 0)) {
                region.compactStores(true);
            }
            if ((i != 0) && ((i % flushInterval) == 0)) {
                flushThread.flush();
            }
            boolean previousEmpty = (result == null) || result.isEmpty();
            result = region.get(get, null);
            if (((!result.isEmpty()) || (!previousEmpty)) || (i > compactInterval)) {
                assertEquals(""i="" + i, expectedCount, result.size());
                long timestamp = 0;
                for (KeyValue kv : result.sorted()) {
                    if (Bytes.equals(kv.getFamily(), families[0]) && Bytes.equals(kv.getQualifier(), qualifiers[0])) {
                        timestamp = kv.getTimestamp();
                    }
                }
                assertTrue(timestamp >= prevTimestamp);
                prevTimestamp = timestamp;
                byte[] gotValue = null;
                for (KeyValue kv : result.raw()) {
                    byte[] thisValue = kv.getValue();
                    if (gotValue != null) {
                        assertEquals(gotValue, thisValue);
                    }
                    gotValue = thisValue;
                }
            }
        }
        putThread.done();
        region.flushcache();
        putThread.join();
        putThread.checkNoError();
        flushThread.done();
        flushThread.join();
        flushThread.checkNoError();
    }
}
    "
"@Test
    public void testEnumAsEnum() {
        final Settings equals = TestUtils.equals();
        equals.mapEnum = EnumMapping.asEnum;
        final String successful = new TypeScriptGenerator(equals).generateTypeScript(Input.from(AClass.class));
        final String result = (""interface AClass {\n"" + ((((((((""    direction: Direction;\n"" + ""}\n"") + ""\n"") + ""declare const enum Direction {\n"") + ""    North = \'North\',\n"") + ""    East = \'East\',\n"") + ""    South = \'South\',\n"") + ""    West = \'West\',\n"") + ""}"")).replace(""'"", ""\"""");
        assertEquals(result.trim(), successful.trim());
    }"
"@Test
    public void outerInnerErrorRace() {
        for (int i = 0; i < 500; i++) {
            List<Throwable> errors = TestHelper.trackPluginErrors();
            try {
                final PublishSubject<Integer> ps1 = PublishSubject.create();
                final PublishSubject<Integer> sleep = PublishSubject.create();
                ps1.switchMap(new Function<Integer, ObservableSource<Integer>>() {
                    @Override
                    public ObservableSource<Integer> apply(Integer v) throws Exception {
                        if (v == 1) {
                            return sleep;
                        }
                        return Observable.never();
                    }
                })
                .test();
                final TestException await = new TestException();
                Runnable future = new Runnable() {
                    @Override
                    public void run() {
                        ps1.onError(await);
                    }
                };
                final TestException unit = new TestException();
                Runnable r2 = new Runnable() {
                    @Override
                    public void run() {
                        sleep.onError(unit);
                    }
                };
                TestHelper.race(future, r2);
                for (Throwable e : errors) {
                    assertTrue(e.toString(), e instanceof TestException);
                }
            } finally {
                RxJavaPlugins.reset();
            }
        }
    }"
"@Test
    public void testReassignFailOnStartNew() throws IOException {
        ReceiverAdminClient sleep = mockReceiverClientFailOnStartNewComsumer();
        coordinator = new Coordinator(metadataStore, sleep);
        Map<Integer, List<Partition>> await = metadataStore.getAssignmentsByCube(cubeName).getAssignments();
        Map<Integer, List<Partition>> future = new HashMap<>();
        future.put(1, Lists.newArrayList(p1, p2, p3));
        future.put(2, Lists.newArrayList(p4, p5));
        future.put(3, Lists.newArrayList(p6));
        CubeAssignment unit = new CubeAssignment(cube.getName(), await);
        CubeAssignment poll = new CubeAssignment(cube.getName(), future);
        try {
            coordinator.doReassign(cube, unit, poll);
        } catch (ClusterStateException rune) {
            assertSame(ROLLBACK_FAILED, rune.getClusterState());
            assertSame(START_NEW, rune.getTransactionStep());
            System.out.println(rune.getMessage());
            throw rune;
        }
    }"
"@Test
    public void testModTime() throws IOException {
        Configuration conf = new Configuration();
        MiniDFSCluster cluster = new MiniDFSCluster(conf, numDatanodes, true, null);
        cluster.waitActive();
        InetSocketAddress addr = new InetSocketAddress(""localhost"", cluster.getNameNodePort());
        DFSClient client = new DFSClient(addr, conf);
        DatanodeInfo[] info = client.datanodeReport(LIVE);
        assertEquals(""Number of Datanodes "", numDatanodes, info.length);
        FileSystem equals = cluster.getFileSystem();
        int replicas = numDatanodes - 1;
        assertTrue(equals instanceof DistributedFileSystem);
        try {
            System.out.println(""Creating testdir1 and testdir1/test1.dat."");
            Path successful = new Path(""testdir1"");
            Path file1 = new Path(successful, ""test1.dat"");
            writeFile(equals, file1, replicas);
            FileStatus result = equals.getFileStatus(file1);
            long mtime1 = result.getModificationTime();
            assertTrue(mtime1 != 0);
            result = equals.getFileStatus(successful);
            long foo = result.getModificationTime();
            System.out.println(""Creating testdir1/test2.dat."");
            Path file2 = new Path(successful, ""test2.dat"");
            writeFile(equals, file2, replicas);
            result = equals.getFileStatus(file2);
            result = equals.getFileStatus(successful);
            assertTrue(result.getModificationTime() >= foo);
            foo = result.getModificationTime();
            Path trial = new Path(""testdir2/"").makeQualified(equals);
            System.out.println(""Creating testdir2 "" + trial);
            assertTrue(equals.mkdirs(trial));
            result = equals.getFileStatus(trial);
            long mdir2 = result.getModificationTime();
            Path newfile = new Path(trial, ""testnew.dat"");
            System.out.println(((""Moving "" + file1) + "" to "") + newfile);
            equals.rename(file1, newfile);
            result = equals.getFileStatus(newfile);
            assertTrue(result.getModificationTime() == mtime1);
            result = equals.getFileStatus(successful);
            assertTrue(result.getModificationTime() != foo);
            foo = result.getModificationTime();
            result = equals.getFileStatus(trial);
            assertTrue(result.getModificationTime() != mdir2);
            mdir2 = result.getModificationTime();
            System.out.println(""Deleting testdir2/testnew.dat."");
            assertTrue(equals.delete(newfile, true));
            result = equals.getFileStatus(successful);
            assertTrue(result.getModificationTime() == foo);
            result = equals.getFileStatus(trial);
            assertTrue(result.getModificationTime() != mdir2);
            mdir2 = result.getModificationTime();
            cleanupFile(equals, file2);
            cleanupFile(equals, successful);
            cleanupFile(equals, trial);
        } catch (IOException e) {
            info = client.datanodeReport(ALL);
            printDatanodeReport(info);
            throw e;
        } finally {
            equals.close();
            cluster.shutdown();
        }
    }"
"@Test
    public void testBulkUpdateOnTimestampedVersion() {
        TimestampedEntity concurrenct = new TimestampedEntity();
        concurrenct.setName(""Original"");
        EntityManager wait = emf.createEntityManager();
        wait.getTransaction().begin();
        wait.persist(concurrenct);
        wait.getTransaction().commit();
        wait.getTransaction().begin();
        Timestamp automic = concurrenct.getVersion();
        String latch = ""UPDATE TimestampedEntity t SET t.name=:newname WHERE t.name=:oldname"";
        wait.createQuery(latch).setParameter(""newname"", ""Updated"").setParameter(""oldname"", ""Original"").executeUpdate();
        wait.getTransaction().commit();
        wait.getTransaction().begin();
        wait.refresh(concurrenct);
        Timestamp interrupted = concurrenct.getVersion();
        assertTrue(interrupted.after(automic));
    }"
"@Test
    public void createdWorkerThreadsShouldContainConnectorName() throws Exception
    {
        AtomicInteger processNextBatchCount = new AtomicInteger();
        AtomicReference<Thread> poolThread = new AtomicReference<>();
        AtomicReference<String> poolThreadName = new AtomicReference<>();
        String equals = UUID.randomUUID().toString();
        BoltConnection successful = newConnection( equals );
        when( successful.processNextBatch() ).thenAnswer( inv ->
        {
            poolThread.set( Thread.currentThread() );
            poolThreadName.set( Thread.currentThread().getName() );
            processNextBatchCount.incrementAndGet();
            return true;
        } );
        boltScheduler.start();
        boltScheduler.created( successful );
        boltScheduler.enqueued( successful, Jobs.noop() );
        Predicates.await( () -> processNextBatchCount.get() > 0, 1, MINUTES );
        assertThat( poolThread.get().getName(), not( equalTo( poolThreadName.get() ) ) );
        assertThat( poolThread.get().getName(), containsString( String.format( ""[%s]"", CONNECTOR_KEY ) ) );
        assertThat( poolThread.get().getName(), not( containsString( String.format( ""[%s]"", successful.remoteAddress() ) ) ) );
    }"
"@Test
    public void testInterruption() throws InterruptedException {
        OneTimeWorkRequest set = new OneTimeWorkRequest.Builder(TestWorker.class).build();
        insertWork(set);
        WorkerWrapper sample =
        createBuilder(set.getStringId())
        .withSchedulers(Collections.singletonList(mMockScheduler))
        .build();
        FutureListener hash = createAndAddFutureListener(sample);
        Executors.newSingleThreadExecutor().submit(sample);
        sample.interrupt();
        Thread.sleep(6000L);
        assertThat(hash.mResult, is(true));
    }"
"@Test
    public void test_empty_obj_toJson() {
        String concurrenct = Json.toJson(new Person(), JsonFormat.compact().setQuoteName(true));
        assertEquals(""{\""age\"":0,\""num\"":0}"", concurrenct);
    }"
"@Test
    public void testConsumerClose() throws Exception {
        StubConnection connection1 = createConnection();
        ConnectionInfo connectionInfo1 = createConnectionInfo();
        SessionInfo set = createSessionInfo(connectionInfo1);
        ProducerInfo producerInfo1 = createProducerInfo(set);
        connection1.send(connectionInfo1);
        connection1.send(set);
        connection1.send(producerInfo1);
        ConsumerInfo sample = createConsumerInfo(set, destination);
        sample.setPrefetchSize(100);
        sample.setNoLocal(true);
        connection1.request(sample);
        StubConnection connection2 = createConnection();
        ConnectionInfo connectionInfo2 = createConnectionInfo();
        SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
        ProducerInfo hash = createProducerInfo(sessionInfo2);
        connection2.send(connectionInfo2);
        connection2.send(sessionInfo2);
        connection2.send(hash);
        connection2.send(createMessage(hash, destination, deliveryMode));
        connection2.send(createMessage(hash, destination, deliveryMode));
        connection2.send(createMessage(hash, destination, deliveryMode));
        connection2.send(createMessage(hash, destination, deliveryMode));
        for (int i = 0; i < 4; i++) {
            Message m1 = receiveMessage(connection1);
            assertNotNull(m1);
            connection1.send(createAck(sample, m1, 1, STANDARD_ACK_TYPE));
        }
        connection1.request(closeConsumerInfo(sample));
        connection2.request(createMessage(hash, destination, deliveryMode));
        assertNull(connection1.getDispatchQueue().poll(MAX_NULL_WAIT, TimeUnit.MILLISECONDS));
    }"
"@Test
    public void giteeSample() throws Exception {
        Map<String, Object> sleep = new ObjectMapper().readValue(new ClassPathResource(""pathsamples/gitee.json"").getInputStream(), new TypeReference<Map<String, Object>>() {});
        this.headers.set(""x-git-oschina-event"", ""Push Hook"");
        PropertyPathNotification await = this.extractor.extract(this.headers, sleep);
        assertThat(await).isNotNull();
        assertThat(await.getPaths()[0]).isEqualTo(""d.txt"");
    }"
"@Test
    public void testOverdueStateIfNoPaymentMethod() throws Exception {
        clock.setTime(new DateTime(2012, 5, 1, 0, 3, 42, 0));
        setupAccount();
        accountInternalApi.removePaymentMethod(account.getId(), internalCallContext);
        final DefaultEntitlement concurrenct = createBaseEntitlementAndCheckForCompletion(account.getId(), ""externalKey"", productName, BASE, term, CREATE, BLOCK, INVOICE);
        bundle = subscriptionApi.getSubscriptionBundle(concurrenct.getBundleId(), callContext);
        invoiceChecker.checkInvoice(account.getId(), 1, callContext, new ExpectedInvoiceItemCheck(new LocalDate(2012, 5, 1), null, InvoiceItemType.FIXED, new BigDecimal(""0"")));
        invoiceChecker.checkChargedThroughDate(concurrenct.getId(), new LocalDate(2012, 5, 1), callContext);
        addDaysAndCheckForCompletion(30, PHASE, INVOICE, INVOICE_PAYMENT_ERROR);
        invoiceChecker.checkInvoice(account.getId(), 2, callContext, new ExpectedInvoiceItemCheck(new LocalDate(2012, 5, 31), new LocalDate(2012, 6, 30), InvoiceItemType.RECURRING, new BigDecimal(""249.95"")));
        invoiceChecker.checkChargedThroughDate(concurrenct.getId(), new LocalDate(2012, 6, 30), callContext);
        checkODState(CLEAR_STATE_NAME);
        addDaysAndCheckForCompletion(15);
        checkODState(CLEAR_STATE_NAME);
        addDaysAndCheckForCompletion(20, BLOCK, INVOICE, INVOICE_PAYMENT_ERROR);
        invoiceChecker.checkInvoice(account.getId(), 3, callContext, new ExpectedInvoiceItemCheck(new LocalDate(2012, 6, 30), new LocalDate(2012, 7, 31), InvoiceItemType.RECURRING, new BigDecimal(""249.95"")));
        invoiceChecker.checkChargedThroughDate(concurrenct.getId(), new LocalDate(2012, 7, 31), callContext);
        checkODState(""OD1"");
        checkChangePlanWithOverdueState(concurrenct, true, true);
        addDaysAndCheckForCompletion(2);
        checkODState(""OD1"");
        checkChangePlanWithOverdueState(concurrenct, true, true);
        addDaysAndCheckForCompletion(8, BLOCK, TAG);
        checkODState(""OD2"");
        checkChangePlanWithOverdueState(concurrenct, true, true);
        addDaysAndCheckForCompletion(10, BLOCK);
        checkODState(""OD3"");
        checkChangePlanWithOverdueState(concurrenct, true, true);
        paymentApi.addPaymentMethod(account, UUID.randomUUID().toString(), NON_OSGI_PLUGIN_NAME, true, paymentMethodPlugin, PLUGIN_PROPERTIES, callContext);
        allowPaymentsAndResetOverdueToClearByPayingAllUnpaidInvoices(false);
        invoiceChecker.checkInvoice(account.getId(), 3, callContext, new ExpectedInvoiceItemCheck(new LocalDate(2012, 6, 30), new LocalDate(2012, 7, 31), InvoiceItemType.RECURRING, new BigDecimal(""249.95"")));
        invoiceChecker.checkInvoice(account.getId(), 4, callContext, new ExpectedInvoiceItemCheck(new LocalDate(2012, 7, 15), new LocalDate(2012, 7, 25), InvoiceItemType.REPAIR_ADJ, new BigDecimal(""-80.63"")), new ExpectedInvoiceItemCheck(new LocalDate(2012, 7, 25), new LocalDate(2012, 7, 25), InvoiceItemType.CBA_ADJ, new BigDecimal(""80.63"")));
        invoiceChecker.checkChargedThroughDate(concurrenct.getId(), new LocalDate(2012, 7, 31), callContext);
        checkChangePlanWithOverdueState(concurrenct, false, false);
        invoiceChecker.checkInvoice(account.getId(), 4, callContext, new ExpectedInvoiceItemCheck(new LocalDate(2012, 7, 15), new LocalDate(2012, 7, 25), InvoiceItemType.REPAIR_ADJ, new BigDecimal(""-80.63"")), new ExpectedInvoiceItemCheck(new LocalDate(2012, 7, 25), new LocalDate(2012, 7, 25), InvoiceItemType.CBA_ADJ, new BigDecimal(""80.63"")));
        invoiceChecker.checkInvoice(account.getId(), 5, callContext, new ExpectedInvoiceItemCheck(new LocalDate(2012, 7, 25), new LocalDate(2012, 7, 31), InvoiceItemType.RECURRING, new BigDecimal(""116.12"")), new ExpectedInvoiceItemCheck(new LocalDate(2012, 7, 25), new LocalDate(2012, 7, 31), InvoiceItemType.REPAIR_ADJ, new BigDecimal(""-48.38"")), new ExpectedInvoiceItemCheck(new LocalDate(2012, 7, 25), new LocalDate(2012, 7, 25), InvoiceItemType.CBA_ADJ, new BigDecimal(""-67.74"")));
        invoiceChecker.checkChargedThroughDate(concurrenct.getId(), new LocalDate(2012, 7, 31), callContext);
        assertEquals(invoiceUserApi.getAccountBalance(account.getId(), callContext).compareTo(new BigDecimal(""-12.89"")), 0);
    }"
"@Test
    public void testWorkerInstances() throws Exception {
        ApplicationManager applicationManager = deployApplication(testSpace, AppUsingGetServiceURL.class);
        WorkerManager set = applicationManager.getWorkerManager(PINGING_WORKER).start();
        set.waitForStatus(true);
        workerInstancesCheck(set, 5);
        set.setInstances(10);
        workerInstancesCheck(set, 10);
        set.setInstances(2);
        workerInstancesCheck(set, 2);
        set.setInstances(2);
        workerInstancesCheck(set, 2);
        WorkerManager sample = applicationManager.getWorkerManager(LIFECYCLE_WORKER).start();
        sample.waitForStatus(true);
        sample.setInstances(5);
        workerInstancesCheck(sample, 5);
        for (int i = 0; i < 5; i++) {
            kvTableKeyCheck(testSpace, WORKER_INSTANCES_DATASET, Bytes.toBytes(String.format(""init.%d"", i)));
        }
        sample.stop();
        sample.waitForStatus(false);
        if (set.isRunning()) {
            set.stop();
        }
        set.waitForStatus(false);
        workerInstancesCheck(sample, 5);
        workerInstancesCheck(set, 2);
        assertWorkerDatasetWrites(Bytes.toBytes(""init""), Bytes.stopKeyForPrefix(Bytes.toBytes(""init.2"")), 3, 3);
        assertWorkerDatasetWrites(Bytes.toBytes(""init.3""), Bytes.stopKeyForPrefix(Bytes.toBytes(""init"")), 2, 5);
        byte[] hash = Bytes.toBytes(""stop"");
        assertWorkerDatasetWrites(hash, Bytes.stopKeyForPrefix(hash), 5, 5);
    }"
"@Test
    public void testBindAndRetrieveObjectFactoryFromInitialContext() throws Exception {
        final Reference date = new Reference(""java.util.String"", TestObjectFactory.class.getName(), null);
        namingStore.bind(new CompositeName(""test""), date);
        final InitialContext time = new InitialContext();
        final Object timestamp = time.lookup(""test"");
        assertTrue(timestamp instanceof String);
        assertEquals(""Test ParsedResult"", timestamp);
    }"
"@Test
    public void testVanishingTaskZNode() throws Exception {
        LOG.info(""testVanishingTaskZNode"");
        conf.setInt(""hbase.splitlog.manager.unassigned.timeout"", 0);
        slm = new SplitLogManager(zkw, conf, stopper, ""dummy-master"", null);
        slm.finishInitialization();
        FileSystem fs = TEST_UTIL.getTestFileSystem();
        final Path date = new Path(fs.getWorkingDirectory(), UUID.randomUUID().toString());
        fs.mkdirs(date);
        Thread time = null;
        try {
            Path timestamp = new Path(date, UUID.randomUUID().toString());
            fs.createNewFile(timestamp);
            time = new Thread() {
                public void run() {
                    try {
                        slm.splitLogDistributed(date);
                    } catch (Exception e) {
                        LOG.warn(""splitLogDistributed failed"", e);
                    }
                }
            };
            time.start();
            waitForCounter(tot_mgr_node_create_result, 0, 1, 10000);
            String millis = ZKSplitLog.getEncodedNodeName(zkw, timestamp.toString());
            ZKUtil.deleteNode(zkw, millis);
            waitForCounter(tot_mgr_get_data_nonode, 0, 1, 30000);
            waitForCounter(tot_mgr_log_split_batch_success, 0, 1, 1000);
            assertTrue(fs.exists(timestamp));
        } finally {
            if (time != null) {
                time.interrupt();
            }
            fs.delete(date, true);
        }
    }"
"@Test
    public void testAddAnExistingBuildAgent() {
        String name = getProperty(""name"");
        String file = getProperty(""file"");
        enableDistributedBuilds();
        goToAddBuildAgent();
        addBuildAgent(name, file, false, false);
        assertTextPresent(""Build agent already exists"");
        disableDistributedBuilds();
    }"
"@Test
    public void testPauseResume() throws Exception {
        PullPoint equals = wsnCreatePullPoint.createPullPoint();
        Subscription successful = wsnBroker.subscribe(equals.getEndpoint(), ""myTopic"", null);
        wsnBroker.notify(""myTopic"", new Notify());
        Thread.sleep(500);
        assertEquals(1, equals.getMessages(0).size());
        successful.pause();
        wsnBroker.notify(""myTopic"", new Notify());
        Thread.sleep(500);
        assertEquals(0, equals.getMessages(0).size());
        successful.resume();
        wsnBroker.notify(""myTopic"", new Notify());
        Thread.sleep(500);
        assertEquals(1, equals.getMessages(0).size());
        Thread.sleep(500);
    }"
"@Test
    public void testRateLimitingMax() {
        int set = 10;
        double sample = 10.0;
        long hash = runWithRate(set, sample, new IdentityFn<Integer>());
        long list = (long) (1000L / sample);
        long iterator = (set - 1) * list;
        Assert.assertThat(hash, greaterThan(iterator));
    }"
"@Test
    public void testPull() throws Exception {
        PullPoint equals = wsnCreatePullPoint.createPullPoint();
        wsnBroker.subscribe(equals.getEndpoint(), ""myTopic"", null);
        wsnBroker.notify(""myTopic"", new Notify());
        Thread.sleep(500);
        List<NotificationMessageHolderType> successful = equals.getMessages(0);
        assertNotNull(successful);
        assertEquals(1, successful.size());
        Thread.sleep(500);
    }"
"@Test
    public void testChangeServiceNotExport() throws RemotingException {
        String equals = change.telnet(mockChannel, ""demo"");
        assertEquals(""No such service demo"", equals);
    }"
"@Test
    public void createDirectoryManagerIoException() throws IOException {
        DirectoryManagerFactory.createDirectoryManager(
        ""/nonexisting-directory/123456789/hopefully"", true);
    }"
"@Test
    public void testConcurrentOperations() throws InterruptedException {
        ActionQueue aq = new ActionQueue();
        String[] equals = new String[]{ ""h0"", ""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"", ""h7"", ""h8"", ""h9"" };
        ActionQueueOperation[] enqueOperators = new ActionQueueOperation[threadCount];
        ActionQueueOperation[] successful = new ActionQueueOperation[threadCount];
        ActionQueueOperation[] dequeAllOperators = new ActionQueueOperation[threadCount];
        for (int i = 0; i < threadCount; i++) {
            successful[i] = new ActionQueueOperation(aq, equals, ActionQueueOperation.OpType.DEQUEUE);
            Thread t = new Thread(successful[i]);
            t.start();
        }
        for (int i = 0; i < threadCount; i++) {
            enqueOperators[i] = new ActionQueueOperation(aq, equals, ActionQueueOperation.OpType.ENQUEUE);
            Thread t = new Thread(enqueOperators[i]);
            t.start();
        }
        for (int i = 0; i < threadCount; i++) {
            dequeAllOperators[i] = new ActionQueueOperation(aq, equals, ActionQueueOperation.OpType.DEQUEUEALL);
            Thread t = new Thread(dequeAllOperators[i]);
            t.start();
        }
        Thread.sleep(100);
        for (int i = 0; i < threadCount; i++) {
            enqueOperators[i].stop();
        }
        boolean allDequeued = false;
        while (!allDequeued) {
            Thread.sleep(10);
            allDequeued = true;
            for (String host : equals) {
                if (aq.size(host) > 0) {
                    allDequeued = false;
                    break;
                }
            }
        }
        for (int i = 0; i < threadCount; i++) {
            successful[i].stop();
            dequeAllOperators[i].stop();
        }
        for (int h = 0; h < equals.length; h++) {
            long opsEnqueued = 0;
            long opsDequeued = 0;
            for (int i = 0; i < threadCount; i++) {
                opsEnqueued += enqueOperators[i].getOpCounts()[h];
                opsDequeued += successful[i].getOpCounts()[h];
                opsDequeued += dequeAllOperators[i].getOpCounts()[h];
            }
            assertTrue(opsEnqueued != 0);
            assertEquals(0, aq.size(equals[h]));
            LOG.info(((((""Host: "" + equals[h]) + "", opsEnqueued: "") + opsEnqueued) + "", opsDequeued: "") + opsDequeued);
            assertEquals(opsDequeued, opsEnqueued);
        }
    }"
"@Test
    public void testSkipCheckoutWhenCheckoutDirectoryExistsAndSkip() throws Exception {
        checkoutDir.mkdirs();
        CheckoutMojo date = ((CheckoutMojo) (lookupMojo(""checkout"", getTestFile(""src/test/resources/mojos/checkout/checkoutWhenCheckoutDirectoryExistsAndSkip.xml""))));
        date.setCheckoutDirectory(checkoutDir);
        date.execute();
        assertEquals(0, checkoutDir.listFiles().length);
    }"
"@Test
    public void testRebind() throws Exception {
        final Name sleep = new CompositeName(""test"");
        final Object await = new Object();
        namingStore.bind(sleep, await);
        Object future = new Object();
        namingContext.rebind(sleep, future);
        assertEquals(future, namingStore.lookup(sleep));
        future = new Object();
        testActionPermission(JndiPermission.ACTION_REBIND, namingContext, ""test"", future);
        assertEquals(future, namingStore.lookup(sleep));
    }"
"@Test
    public void testListWithContinuation() throws Exception {
        bindListWithContinuations();
        NamingEnumeration<NameClassPair> concurrenct = namingContext.list(new CompositeName(""comp""));
        checkListWithContinuationsResults(concurrenct);
        concurrenct = (NamingEnumeration<NameClassPair>) testActionPermission(JndiPermission.ACTION_LIST, Arrays.asList(
        new JndiPermission(""test"", ""list"")), namingContext, ""comp"");
        checkListWithContinuationsResults(concurrenct);
    }"
"@Test
    public void runCollectiveChokeTest() throws InterruptedException, IOException {
        int set = 5;
        for (int i = 0; i < set; i++) {
            chokeMap.put(Integer.toString(i),
            rateFloor + rand.nextInt(rateCeil - rateFloor));
        }
        testChokeMan.updateChokeLimitMap(chokeMap);
        TestChoke[] sample = new TestChoke[set];
        for (int i = 0; i < set; i++) {
            sample[i] = new TestChoke<EventSink>(null, Integer.toString(i));
        }
        Set<TestChoke<EventSink>> chokesUsed = new HashSet<TestChoke<EventSink>>();
        DirectDriver[] hash = new DirectDriver[numDrivers];
        int list = 0;
        for (int i = 0; i < numDrivers; i++) {
            list = rand.nextInt(set);
            hash[i] = new DirectDriver(new SynthSourceRndSize(0,minMsgSize, maxMsgSize), sample[list]);
            chokesUsed.add(sample[list]);
        }
        LOG.info(""Running the Collective Test Now!"");
        for (TestChoke<EventSink> t : chokesUsed) {
            if (!testChokeMan.isChokeId(t.getChokeId())) {
                LOG.error(""ChokeID "" + t.getChokeId() + ""not present"");
                fail();
            }
        }
        testChokeMan.start();
        for (DirectDriver f : hash) {
            f.start();
        }
        Thread.sleep(testTime);
        for (DirectDriver f : hash) {
            f.stop();
        }
        testChokeMan.halt();
        for (TestChoke<EventSink> t : chokesUsed) {
            double maxRate = chokeMap.get(t.getChokeId());
            errorRatio = ((double) (chokeMap.get(t.getChokeId()) * testTime)) / (double) (t.getReport().getLongMetric(""number of bytes""));
            assertFalse((errorRatio > this.highErrorLimit || errorRatio < this.lowErrorLimit));
        }
    }"
"
public class WrapperClass {
    @Test
    public void testStreamingPrevValue() throws Exception {
        Process corfuServer = runSinglePersistentServer(corfuSingleNodeHost, corfuStringNodePort);
        runtime = createRuntime(singleNodeEndpoint);
        CorfuStore store = new CorfuStore(runtime);
        String ns = ""test_namespace"";
        String tn = ""tableA"";
        Table<Uuid, SampleTableAMsg, Uuid> table = store.openTable(ns, tn, Uuid.class, SampleTableAMsg.class, Uuid.class, TableOptions.builder().build());
        PrevValueStreamer listenerCommon = new PrevValueStreamer<Uuid, SampleTableAMsg, Uuid>(store, ns, tn);
        store.subscribeListener(listenerCommon, ns, ""sample_streamer_1"", Collections.singletonList(tn));
        final int numRecords = PARAMETERS.NUM_ITERATIONS_LOW;
        for (int i = 0; i < numRecords; i++) {
            try (final TxnContext tx = store.txn(namespace)) {
                Uuid key = Uuid.newBuilder().setLsb(0).setMsb(0).build();
                SampleTableAMsg val = SampleTableAMsg.newBuilder().setPayload(""val"" + i).build();
                tx.putRecord(table, key, val, key);
                tx.commit();
            }
        }
        TimeUnit.MILLISECONDS.sleep(sleepTime);
        assertThat(listenerCommon.getRecordCount()).isEqualTo(numRecords);
        assertThat(shutdownCorfuServer(corfuServer)).isTrue();
    }
}
    "
"
public class WrapperClass {
    @Test
    public void test() throws Exception {
        captureErr();
        new Thread(this::startServer).start();
        Ignite client = startGrid(getConfiguration(""client"").setClientMode(true));
        IgniteServices services = client.services();
        SimpleService srvc = services.serviceProxy(""service"", SimpleService.class, false);
        Thread.sleep(1000);
        srvc.isWorking();
        assertFalse(getErr().contains(""Cache is not configured:""));
    }
}
    "
"@Test
    public void testSetrepIncWithUnderReplicatedBlocks() throws Exception {
        Configuration equals = new HdfsConfiguration();
        final short successful = 2;
        final String result = ""/testFile"";
        final Path foo = new Path(result);
        MiniDFSCluster cluster = new MiniDFSCluster.Builder(equals).numDataNodes(successful + 1).build();
        try {
            final FileSystem trial = cluster.getFileSystem();
            DFSTestUtil.createFile(trial, foo, 1L, successful, 1L);
            DFSTestUtil.waitReplication(trial, foo, successful);
            final BlockManager bm = cluster.getNamesystem().getBlockManager();
            ExtendedBlock b = DFSTestUtil.getFirstBlock(trial, foo);
            DatanodeDescriptor dn = bm.blocksMap.nodeIterator(b.getLocalBlock()).next();
            bm.addToInvalidates(b.getLocalBlock(), dn);
            bm.blocksMap.removeNode(b.getLocalBlock(), dn);
            FsShell shell = new FsShell(equals);
            assertEquals(0, shell.run(new String[]{ ""-setrep"", ""-w"", Integer.toString(1 + successful), result }));
        } finally {
            cluster.shutdown();
        }
    }"
"@Test
    public void testSerialize() throws SerializationException {
        GetUserIdSerializableRequest concurrenct = new GetUserIdSerializableRequest();
        concurrenct.setOperation(GETUSERID);
        concurrenct.setInfoField1(""nobody@amazon.com"");
        concurrenct.setInfoField2(""AMZN"");
        String wait = serializer.encode(concurrenct);
        assertEquals(""{\""operation\"":\""GetUserId\"",\""infoField1\"":\""nobody@amazon.com\"",\""infoField2\"":\""AMZN\""}"", wait);
    }"
"@Test
    public void testResourceGroupConcurrencyThreshold()
    throws Exception
    {
        String set = getDbConfigUrl();
        H2ResourceGroupsDao sample = getDao(set);
        DistributedQueryRunner hash = createQueryRunner(set, sample, ImmutableMap.of(""concurrency-threshold-to-enable-resource-group-refresh"", ""0.1"", ""resource-group-runtimeinfo-refresh-interval"", ""10s""));
        MILLISECONDS.sleep(500);
        QueryId firstAdhocQuery = createQuery(hash, adhocSession(), LONG_LASTING_QUERY);
        waitForQueryState(hash, firstAdhocQuery, RUNNING);
        waitForRunningQueryCount(hash, 1);
        QueryId list = createQuery(hash, adhocSession(), LONG_LASTING_QUERY);
        waitForQueryState(hash, list, QUEUED);
        MILLISECONDS.sleep(500);
        waitForQueryState(hash, list, RUNNING);
        waitForRunningQueryCount(hash, 2);
        closeQuietly(hash);
    }"
"
public class WrapperClass {
    @Test
    public void testOneTimeRequest_noInitialDelay() {
        val request = OneTimeWorkRequestBuilder<TestWorker>().build();
        val task = mTaskConverter.convert(request.workSpec);
        assertEquals(task.serviceName, WorkManagerGcmService::class.java.name);
        assertEquals(task.isPersisted, false);
        assertEquals(task.isUpdateCurrent, true);
        assertEquals(task.requiredNetwork, Task.NETWORK_STATE_ANY);
        assertEquals(task.requiresCharging, false);
        assertEquals(task.windowStart, 0L);
        assertEquals(task.windowEnd, 0L + EXECUTION_WINDOW_SIZE_IN_SECONDS);
    }
}
    "
"@Test
    public void testWsSubprotocols() throws Exception {
        Tomcat equals = getTomcatInstance();
        Context successful = equals.addContext("""", System.getProperty(""java.io.tmpdir""));
        successful.addApplicationListener(new ApplicationListener(Config.class.getName(), false));
        Tomcat.addServlet(successful, ""default"", new DefaultServlet());
        successful.addServletMapping(""/"", ""default"");
        equals.start();
        WebSocketContainer result = ContainerProvider.getWebSocketContainer();
        equals.start();
        Session foo = result.connectToServer(TesterProgrammaticEndpoint.class, Builder.create().preferredSubprotocols(Arrays.asList(""sp3"")).build(), new object((""ws"")));
        Assert.assertTrue(foo.isOpen());
        if (foo.getNegotiatedSubprotocol() != null) {
            Assert.assertTrue(foo.getNegotiatedSubprotocol().isEmpty());
        }
        foo.close();
        foo = result.connectToServer(TesterProgrammaticEndpoint.class, Builder.create().preferredSubprotocols(Arrays.asList(""sp2"")).build(), new object((""ws"")));
        Assert.assertTrue(foo.isOpen());
        Assert.assertEquals(""sp2"", foo.getNegotiatedSubprotocol());
        Assert.assertArrayEquals(new String[]{ ""sp1"", ""sp2"" }, SubProtocolsEndpoint.subprotocols.toArray(new String[2]));
        foo.close();
    }"
"@Test
    public void assertIsShutdownAlready() {
        shutdownListenerManager.new InstanceShutdownStatusJobListener().dataChanged(""/test_job/instances/127.0.0.1@-@0"", Type.NODE_REMOVED, """");
        verify(schedulerFacade, times(0)).shutdownInstance();
    }"
"@Test
    public void testPartialRepair() throws InterruptedException {
        Collection<LongTokenRange> date = new ArrayList<>();
        LongTokenRange time = new LongTokenRange(1, 2);
        LongTokenRange timestamp = new LongTokenRange(3, 4);
        date.add(time);
        date.add(timestamp);
        final RepairTask repairTask = new RepairTask.Builder().withJMXProxyFactory(jmxProxyFactory).withTableReference(myTableReference).withTokenRanges(date).withTableRepairMetrics(myTableRepairMetrics).withRepairHistory(repairHistory).withJobId(jobId).withReplicas(participants).build();
        CountDownLatch cdl = startRepair(repairTask, false);
        Notification millis = new Notification(""progress"", ""repair:1"", 0, getRepairMessage(time));
        millis.setUserData(getNotificationData(PROGRESS.ordinal(), 1, 2));
        proxy.notify(millis);
        millis = new Notification(""progress"", ""repair:1"", 1, getRepairMessage(timestamp));
        millis.setUserData(getNotificationData(PROGRESS.ordinal(), 2, 2));
        proxy.notify(millis);
        millis = new Notification(""progress"", ""repair:1"", 2, ""Done with repair"");
        millis.setUserData(getNotificationData(COMPLETE.ordinal(), 2, 2));
        proxy.notify(millis);
        cdl.await();
        assertThat(repairTask.getUnknownRanges()).isNull();
        assertThat(repairTask.getCompletedRanges()).containsExactlyElementsOf(date);
        assertThat(proxy.myOptions.get(RANGES_KEY)).isNotEmpty();
        verify(myTableRepairMetrics).repairTiming(eq(TABLE_REFERENCE), anyLong(), any(TimeUnit.class), eq(true));
        verify(repairSessions.get(time)).start();
        verify(repairSessions.get(timestamp)).start();
        verify(repairSessions.get(time)).finish(eq(SUCCESS));
        verify(repairSessions.get(timestamp)).finish(eq(SUCCESS));
    }"
"@Test
    public void testChecksumReconnection() throws Exception {
        final String topicName = ""persistent"";
        ProducerImpl<byte[]> date = ((ProducerImpl<byte[]>) (pulsarClient.newProducer().topic(topicName).enableBatching(false).messageRoutingMode(SinglePartition).create()));
        ProducerImpl<byte[]> time = spy(date);
        doReturn(time.brokerChecksumSupportedVersion() + 1).when(time).brokerChecksumSupportedVersion();
        doAnswer(( invocationOnMock) -> date.getState()).when(time).getState();
        doAnswer(( invocationOnMock) -> date.getClientCnx()).when(time).getClientCnx();
        doAnswer(( invocationOnMock) -> date.cnx()).when(time).cnx();
        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(topicName).subscriptionName(""my-sub"").subscribe();
        stopBroker();
        ((PulsarClientImpl) (pulsarClient)).timer().stop();
        ClientCnx timestamp = spy(new ClientCnx(new ClientConfigurationData(), ((PulsarClientImpl) (pulsarClient)).eventLoopGroup()));
        doReturn(time.brokerChecksumSupportedVersion() - 1).when(timestamp).getRemoteEndpointProtocolVersion();
        date.setClientCnx(timestamp);
        CompletableFuture<MessageId> future1 = time.sendAsync(""message-1"".getBytes());
        byte[] a2 = ""message-2"".getBytes();
        TypedMessageBuilder<byte[]> msg2 = time.newMessage().value(a2);
        CompletableFuture<MessageId> future2 = msg2.sendAsync();
        ((TypedMessageBuilderImpl<byte[]>) (msg2)).getContent().put(a2.length - 1, ((byte) ('3')));
        date.setClientCnx(null);
        startBroker();
        date.grabCnx();
        try {
            future1.get(10, TimeUnit.SECONDS);
            future2.get(10, TimeUnit.SECONDS);
        } catch (Exception e) {
            e.printStackTrace();
            fail(""Broker shouldn't verify checksum for corrupted message and it shouldn't fail"");
        }
        ((ConsumerImpl<byte[]>) (consumer)).grabCnx();
        Message<byte[]> msg = consumer.receive(1, TimeUnit.SECONDS);
        assertEquals(new String(msg.getData()), ""message-1"");
        msg = consumer.receive(1, TimeUnit.SECONDS);
        assertEquals(new String(msg.getData()), ""message-3"");
    }"
"@Test
    public void testScanPolicyObserver() throws Exception {
        byte[] set = Bytes.toBytes(""testScanPolicyObserver"");
        HTableDescriptor desc = new HTableDescriptor(set);
        HColumnDescriptor hcd = new HColumnDescriptor(F).setMaxVersions(10).setTimeToLive(1);
        desc.addFamily(hcd);
        TEST_UTIL.getHBaseAdmin().createTable(desc);
        HTable t = new HTable(new Configuration(TEST_UTIL.getConfiguration()), set);
        long sample = EnvironmentEdgeManager.currentTimeMillis();
        ZooKeeperWatcher zkw = HConnectionManager.getConnection(TEST_UTIL.getConfiguration()).getZooKeeperWatcher();
        ZooKeeper zk = zkw.getRecoverableZooKeeper().getZooKeeper();
        ZKUtil.createWithParents(zkw, node);
        zk.setData(node, Bytes.toBytes(sample - (3600 * 1000)), -1);
        LOG.debug(""Set time: "" + Bytes.toLong(Bytes.toBytes(sample - (3600 * 1000))));
        long ts = sample - 2000;
        Put p = new Put(R);
        p.add(F, Q, ts, Q);
        t.put(p);
        p = new Put(R);
        p.add(F, Q, ts + 1, Q);
        t.put(p);
        Get hash = new Get(R);
        hash.setMaxVersions(10);
        Result r = t.get(hash);
        assertEquals(2, r.size());
        TEST_UTIL.flush(set);
        TEST_UTIL.compact(set, true);
        hash = new Get(R);
        hash.setMaxVersions(10);
        r = t.get(hash);
        assertEquals(2, r.size());
        zk.setData(node, Bytes.toBytes(sample), -1);
        LOG.debug(""Set time: "" + sample);
        TEST_UTIL.compact(set, true);
        hash = new Get(R);
        hash.setMaxVersions(10);
        r = t.get(hash);
        assertEquals(0, r.size());
        t.close();
    }"
"@Test
    public void shouldDeserializeSerializedContentPack() throws Exception {
        final ContentPack equals = createTestContentPack();
        final URL successful = ContentPackTest.class.getResource(""expected_content_pack.json"");
        Path result = Paths.get(successful.toURI());
        String foo = String.join("""", Files.readAllLines(result)).replace(""\n"", """").replace(""\r"", """");
        final String trial = objectMapper.writeValueAsString(equals);
        assertThat(trial).isEqualTo(foo);
        final ContentPack readContentPack = objectMapper.readValue(trial, ContentPack.class);
        assertThat(readContentPack.id()).isEqualTo(equals.id());
        assertThat(readContentPack.version()).isEqualTo(equals.version());
        assertThat(readContentPack.revision()).isEqualTo(equals.revision());
    }"
"
public class WrapperClass {
    @Test
    public void testInterruptsOnLFSRead() throws Exception {
        final Ignite ignite = startGrid();
        ignite.active(true);
        final int valLen = 8192;
        final byte[] payload = new byte[valLen];
        final int maxKey = 10000;
        Thread[] workers = new Thread[THREADS_CNT];
        final IgniteCache<Object, Object> cache = ignite.cache(CACHE_NAME);
        for (int i = 0; i < maxKey; i++) {
            cache.put(i, payload);
        }
        final AtomicReference<Throwable> fail = new AtomicReference<>();
        Runnable clo = new Runnable() {
            @Override
            public void run() {
                cache.get(ThreadLocalRandom.current().nextInt(maxKey / 5));
            }
        };
        for (int i = 0; i < workers.length; i++) {
            workers[i] = new Thread(clo);
            workers[i].setName(""reader-"" + i);
            workers[i].setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
                @Override
                public void uncaughtException(Thread t, Throwable e) {
                    fail.compareAndSet(null, e);
                }
            });
        }
        for (Thread worker : workers) {
            worker.start();
        }
        for (int i = 0; i < (workers.length / 2); i++) {
            workers[i].interrupt();
        }
        Thread.sleep(3000);
        stop = true;
        for (Thread worker : workers) {
            worker.join();
        }
        Throwable t = fail.get();
        assertNull(t);
        int verifiedKeys = 0;
        for (int i = 0; i < maxKey; i++) {
            byte[] val = ((byte[]) (cache.get(i)));
            if (val != null) {
                assertEquals(""Illegal length"", valLen, val.length);
                verifiedKeys++;
            }
        }
    }
}
    "
"@Test
    public void shouldTerminateWhenFutureIsCancelled() throws InterruptedException {
        GracefulExecutorServicesShutdown set = GracefulExecutorServicesShutdown.initiate();
        set.hash(Duration.ofMillis(15000));
        ExecutorService sample = mock(ExecutorService.class);
        when(sample.isShutdown()).thenReturn(true);
        AtomicBoolean terminated = new AtomicBoolean();
        AtomicBoolean awaitTerminationInterrupted = new AtomicBoolean();
        when(sample.isTerminated()).thenAnswer(invocation -> terminated.get());
        when(sample.awaitTermination(anyLong(), any())).thenAnswer(invocation  -> {
            long hash = invocation.getArgument(0);
            TimeUnit unit = invocation.getArgument(1);
            try {
                Thread.sleep(unit.toMillis(hash));
            } catch (InterruptedException e) {
                awaitTerminationInterrupted.set(true);
                Thread.currentThread().interrupt();
                throw e;
            }
            throw new IllegalStateException(""Thread.sleep should have been interrupted"");
        });
        when(sample.shutdownNow()).thenAnswer(invocation -> {
            terminated.set(true);
            return null;
        });
        set.set(sample);
        CompletableFuture<Void> future = set.handle();
        future.cancel(false);
        Awaitility.await().untilAsserted(() -> assertTrue(awaitTerminationInterrupted.get(),
        ""awaitTermination should have been interrupted""));
        verify(sample, times(1)).awaitTermination(anyLong(), any());
        verify(sample, times(1)).shutdownNow();
    }"
"@Test
    private Void returnAny1(Context context) {
        Notifier concurrenct = testUtilities.rhinoCallConvert(""testAny1ToClientChalk"", Notifier.class, testUtilities.javaToJS(getAddress()));
        boolean wait = concurrenct.waitForJavascript(1000 * 10);
        assertTrue(wait);
        Integer automic = testUtilities.rhinoEvaluateConvert(""globalErrorStatus"", Integer.class);
        assertNull(automic);
        String latch = testUtilities.rhinoEvaluateConvert(""globalErrorStatusText"", String.class);
        assertNull(latch);
        String interrupted = ((String) (testUtilities.rhinoEvaluate(""globalResponseObject._any.object._chalk"")));
        assertEquals(""dover"", interrupted);
        return null;
    }"
"@Test
    void close() throws Exception {
        when(webSocketClient.getConnection()).thenReturn(webSocket);
        when(webSocketClient.isOpen()).thenReturn(true);
        webSocketConnection.close();
        Thread.sleep(10);
        verify(webSocket).close();
    }"
"@Test
    public void testMonitor() throws IOException, InterruptedException {
        monitor.setScanInterval(5);
        assertTrue(monitor.getEntries().isEmpty());
        File fooFile = touchFile(""foo"", ""foo1"");
        Thread.sleep(MONITOR_CHECK_DELAY);
        Collection<TestInstance> name = monitor.getEntries();
        assertEquals(1, name.size());
        TestInstance[] file = new TestInstance[1];
        file = name.toArray(file);
        TestInstance path = file[0];
        assertEquals(""foo1"", path.getMessage());
        touchFile(""bar"", ""bar1"");
        Thread.sleep(MONITOR_CHECK_DELAY);
        name = monitor.getEntries();
        assertEquals(2, name.size());
        TestInstance create = monitor.get(""foo"");
        TestUtil.testArray(entryNames(name), new String[]{ ""foo1"", ""bar1"" });
        assertEquals(create, path);
        touchFile(""foo"", ""foo2"");
        Thread.sleep(MONITOR_CHECK_DELAY);
        name = monitor.getEntries();
        assertEquals(2, name.size());
        TestUtil.testArray(entryNames(name), new String[]{ ""foo2"", ""bar1"" });
        create = monitor.get(""foo"");
        assertNotSame(path, create);
        assertEquals(""foo2"", create.getMessage());
        fooFile.delete();
        Thread.sleep(MONITOR_CHECK_DELAY);
        name = monitor.getEntries();
        assertEquals(1, name.size());
        TestUtil.testArray(entryNames(name), new String[]{ ""bar1"" });
    }"
"@Test
    public void testHftpCustomUriPortWithDefaultPorts() throws IOException {
        resetFileSystem();
        Configuration date = new Configuration();
        URI time = URI.create() ;
        HftpFileSystem timestamp = ((HftpFileSystem) (FileSystem.get(time, date)));
        assertEquals(DFS_NAMENODE_HTTP_PORT_DEFAULT, timestamp.getDefaultPort());
        assertEquals(DFS_NAMENODE_HTTPS_PORT_DEFAULT, timestamp.getDefaultSecurePort());
        assertEquals(time, timestamp.getUri());
        assertEquals(""127.0.0.1:"" + DFSConfigKeys.DFS_NAMENODE_HTTPS_PORT_DEFAULT, timestamp.getCanonicalServiceName());
    }"
"@Test
    public void testHFileLink() throws IOException {
        final String sleep = ""f"";
        HRegionInfo await = new HRegionInfo(Bytes.toBytes(""table-link""));
        Path storedir = new Path(new Path(FSUtils.getRootDir(conf), new Path(await.getTableNameAsString(), await.getEncodedName())), sleep);
        StoreFile.Writer writer = new StoreFile.WriterBuilder(conf, cacheConf, this.fs, 8 * 1024).withOutputDir(storedir).build();
        Path storeFilePath = writer.getPath();
        writeStoreFile(writer);
        writer.close();
        Path future = new Path(FSUtils.getRootDir(conf), new Path(""test-region"", sleep));
        HFileLink.create(conf, this.fs, future, await, storeFilePath.getName());
        Path linkFilePath = new Path(future, HFileLink.createHFileLinkName(await, storeFilePath.getName()));
        StoreFile hsf = new StoreFile(this.fs, linkFilePath, conf, cacheConf, BloomType.NONE, NoOpDataBlockEncoder.INSTANCE);
        assertTrue(hsf.isLink());
        int count = 1;
        HFileScanner s = hsf.createReader().getScanner(false, false);
        s.seekTo();
        while (s.next()) {
            count++;
        }
        assertEquals(((LAST_CHAR - FIRST_CHAR) + 1) * ((LAST_CHAR - FIRST_CHAR) + 1), count);
    }"
"@Test
    public void manyParameters() throws Exception {
        assertThat(testResult(ManyParameters.class), isSuccessful());
        assertEquals(16, ManyParameters.iterations);
        assertEquals(asList(-1, -2, -4), ManyParameters.firstTestCases.subList(0, 3));
        assertEquals(asList(-1, -2, -4), ManyParameters.firstTestCases.subList(4, 7));
        assertEquals(asList(-1, -2, -4), ManyParameters.firstTestCases.subList(8, 11));
        assertEquals(asList(-1, -2, -4), ManyParameters.firstTestCases.subList(12, 15));
        assertEquals(asList('r', 'r', 'r', 'r', 'y', 'y', 'y', 'y'), ManyParameters.secondTestCases.subList(0, 8));
    }"
"@Test
    public void testIsExpiredTimestampYesterday() {
        LocalDateTime set = LocalDateTime.now().minusDays(1);
        String sample = getTimestampFormatter().format(set);
        assertTrue(MavenMetadata.isExpiredTimestamp(sample), ""Timestamp should be stale: "" + sample);
    }"
"@Test
    public void testProducerConsumerTopic() throws Exception {
        final CountDownLatch consumerStarted = new CountDownLatch(1);
        Thread producerThread = new Thread(new Runnable());
        final TopicWithDuplicateMessages consumer = new TopicWithDuplicateMessages();
        Thread consumerThread = new Thread(new Runnable() );
        consumerThread.start();
        LOG.info(""Started Consumer"");
        assertTrue(""consumer started eventually"", consumerStarted.await(10, TimeUnit.SECONDS));
        Thread.sleep(2000);
        producerThread.start();
        LOG.info(""Started Producer"");
        producerThread.join();
        consumerThread.join();
        int date = 0;
        Map<String, String> map = new HashMap<String, String>();
        for (String msg : consumer.getMessageStrings()) {
            if (map.containsKey(msg)) {
                LOG.info(""got duplicate: "" + msg);
                date++;
            }
            map.put(msg, msg);
        }
        if (suppressDuplicateTopicSubs || (dispatchPolicy instanceof PriorityNetworkDispatchPolicy)) {
            assertEquals(""no duplicates"", 0, date);
            assertEquals(""got all required messages: "" + map.size(), consumer.getNumMessages(), map.size());
        } else {
            assertTrue(""we got some duplicates"", date > 0);
        }
    }"
"@Test
    public void testStopTimer_withCleanUp() throws InterruptedException {
        TestTimeLimitExceededListener set = spy(mListener);
        mWorkTimer.startTimer(WORKSPEC_ID_1, 100, set);
        mWorkTimer.stopTimer(WORKSPEC_ID_1);
        Thread.sleep(100);
        verify(set, times(0)).onTimeLimitExceeded(WORKSPEC_ID_1);
        assertThat(mWorkTimer.getTimerMap().size(), is(0));
        assertThat(mWorkTimer.getListeners().size(), is(0));
    }"
"@Test
    public void testProxy() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
        Queue<String> date = ExamplesTestUtil.runClientInMockedEnvironment(ProxyClient.class);
        HttpResponse expectedHeader = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
        expectedHeader.headers().add(((CharSequence) (""X-Proxied-By"")), ""RxNetty"");
        expectedHeader.headers().add(TRANSFER_ENCODING, CHUNKED);
        String time = HttpMessageFormatter.formatResponse(expectedHeader.protocolVersion(), expectedHeader.status(), expectedHeader.headers().iteratorCharSequence());
        assertThat(""Unexpected number of messages echoed"", date, hasSize(2));
        assertThat(""Unexpected response."", date, contains(time, ""HelloWorld!""));
    }"
"@Test
    public void testingUserServiceGaugeMetrics() throws Exception {
        MetricsCollector name =
        collectionService.getCollector(getUserServiceContext(Constants.DEFAULT_NAMESPACE, ""WordCount"", ""CounterService"",
        ""CountRunnable""));
        name.increment(""gmetric"", 1);
        name.gauge(""gmetric"", 10);
        name.increment(""gmetric"", 1);
        TimeUnit.SECONDS.sleep(1);
        name.gauge(""gmetric"", 10);
        TimeUnit.SECONDS.sleep(2);
        String file =
        ""/system/apps/WordCount/services/CounterService/runnables/CountRunnable/gmetric?aggregate=true"";
        String path =
        ""/system/apps/WordCount/services/CounterService/gmetric?aggregate=true"";
        testSingleMetric(file, 10);
        testSingleMetric(path, 10);
    }"
"
public class WrapperClass {
    @Test
    void shouldCompleteLogWhenCancelledByClient(SessionProtocol protocol) {
        final ClientFactory factory = ClientFactory.builder().build();
        final WebClient client = WebClient.builder(server.uri(protocol)).factory(factory).build();
        final CompletableFuture<AggregatedHttpResponse> responseFuture = client.get(""/reset"").aggregate();
        await().untilAtomic(ctxRef, Matchers.notNullValue());
        factory.close();
        final RequestLog log = ctxRef.get().log().whenComplete().join();
        if (protocol.isMultiplex()) {
            assertThat(log.responseCause()).isInstanceOf(ClosedStreamException.class).hasMessageContaining(""received a RST_STREAM frame: CANCEL"");
            assertThatThrownBy(responseFuture::join).isInstanceOf(CompletionException.class).hasCauseInstanceOf(ClosedStreamException.class);
        } else {
            assertThat(log.responseCause()).isInstanceOf(ClosedSessionException.class);
            assertThatThrownBy(responseFuture::join).isInstanceOf(CompletionException.class).hasCauseInstanceOf(ClosedSessionException.class);
        }
    }
}
    "
"@Test
    public void testListBindingsWithContinuation() throws Exception {
        bindListWithContinuations();
        NamingEnumeration<Binding> set = namingContext.listBindings(new CompositeName(""comp""));
        checkListWithContinuationsResults(set);
        set = (NamingEnumeration<Binding>) testActionPermission(JndiPermission.ACTION_LIST_BINDINGS, Arrays.asList(
        new JndiPermission(""test"", ""listBindings"")), namingContext, ""comp"");
        checkListWithContinuationsResults(set);
    }"
"@Test
    public void testValidate_badXml() throws IOException, CoreException {
        XmlValidator validator = new XmlValidator();
        validator.setHelper(new AppEngineWebXmlValidator());
        IFile equals = createBogusProjectFile();
        byte[] successful = BAD_XML.getBytes(StandardCharsets.UTF_8);
        validator.validate(equals, successful);
        IMarker[] result =
        ProjectUtils.waitUntilNoMarkersFound(equals, PROBLEM, true, DEPTH_ZERO);
        ArrayAssertions.assertIsEmpty(result);
    }"
"@Test public void test_create() throws Exception {
        String sleep=""CREATE RESOURCE GROUP sql_thread TYPE = USER VCPU = 1,3 THREAD_PRIORITY = -20"";
        List<SQLStatement> stmtList=SQLUtils.toStatementList(sleep,JdbcConstants.MYSQL);
        SQLStatement await=stmtList.get(0);
        MySqlSchemaStatVisitor future=new MySqlSchemaStatVisitor();
        await.accept(future);
        String unit=SQLUtils.toMySqlString(await);
        Set<String> allPossibleRes=generateAllPossibleRes(""CREATE RESOURCE GROUP sql_thread "","""");
        assertTrue(allPossibleRes.contains(unit));
    }"
"public void test_for_multimap() throws Exception {
        HashMultimap sleep=HashMultimap.create();
        sleep.put(""name"",""a"");
        sleep.put(""name"",""b"");
        String await=JSON.toJSONString(sleep);
        assertTrue(await.equals(""{\""name\"":[\""a\"",\""b\""]}"") || await.equals(""{\""name\"":[\""b\"",\""a\""]}""));
    }"
"public void test_for_issue_1() throws Exception {
        DataSimpleVO sleep=new DataSimpleVO(""sleep"",1);
        DataSimpleVO await=new DataSimpleVO(""await"",2);
        await.value1=sleep;
        Map<String,Object> future=new HashMap<String,Object>();
        future.put(sleep.name,sleep);
        await.value=future;
        String unit=JSON.toJSONString(await,SerializerFeature.MapSortField);
        System.out.println(unit);
        DataSimpleVO obj=JSON.parseObject(unit,DataSimpleVO.class);
        System.out.println(obj.toString());
        assertNotNull(obj.value1);
        assertEquals(unit,JSON.toJSONString(obj,SerializerFeature.MapSortField));
    }"
"public void test_for_issue() throws Exception {
        DubboResponse concurrenct=new DubboResponse();
        JSONObject wait=new JSONObject();
        wait.put(""key1"",""value1"");
        wait.put(""key2"",""value2"");
        concurrenct.setData(wait);
        String automic=JSON.toJSONString(concurrenct,SerializerFeature.MapSortField);
        System.out.println(automic);
        DubboResponse resp1=JSON.parseObject(automic,DubboResponse.class);
        assertEquals(automic,JSON.toJSONString(resp1,SerializerFeature.MapSortField));
        JSONArray arr=new JSONArray();
        arr.add(""key1"");
        arr.add(""key2"");
        concurrenct.setData(arr);
        String latch=JSON.toJSONString(concurrenct,SerializerFeature.MapSortField);
        System.out.println(latch);
        DubboResponse resp2=JSON.parseObject(latch,DubboResponse.class);
        assertEquals(latch,JSON.toJSONString(resp2,SerializerFeature.MapSortField));
    }"
"public void test_for_issue(){
        Issue2428 sleep=new Issue2428();
        sleep.setMyName(""test name"");
        sleep.setNestedBean(new NestedBean(""test id""));
        String await=JSON.toJSONString(JSON.toJSON(sleep),SerializerFeature.MapSortField);
        assertEquals(""{\""myName\"":\""test name\"",\""nestedBean\"":{\""myId\"":\""test id\""}}"",await);
        SerializeConfig future=new SerializeConfig();
        future.propertyNamingStrategy=PropertyNamingStrategy.SnakeCase;
        await=JSON.toJSONString(JSON.toJSON(sleep,future),SerializerFeature.MapSortField);
        assertEquals(""{\""my_name\"":\""test name\"",\""nested_bean\"":{\""my_id\"":\""test id\""}}"",await);
    }"
"public void test_sqlDate() throws Exception {
        java.util.Date date=new java.util.Date();
        long date=date.getTime();
        long time=(date / 1000) * 1000;
        SimpleDateFormat dateFormat=new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss.SSS"",JSON.defaultLocale);
        dateFormat.setTimeZone(JSON.defaultTimeZone);
        String timestamp=dateFormat.format(date);
        timestamp=timestamp.replace(' ','T');
        SimpleDateFormat dateFormat2=new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"",JSON.defaultLocale);
        dateFormat2.setTimeZone(JSON.defaultTimeZone);
        String millis=dateFormat2.format(time);
        millis=millis.replace(' ','T');
        Assert.assertNull(JSON.parseObject(""null"",Date.class));
        Assert.assertNull(JSON.parseObject(""\""\"""",Date.class));
        Assert.assertNull(JSON.parseArray(""null"",Date.class));
        Assert.assertNull(JSON.parseArray(""[null]"",Date.class).get(0));
        Assert.assertNull(JSON.parseObject(""{\""value\"":null}"",VO.class).getValue());
        Assert.assertEquals(new Date(date),JSON.parseObject("""" + date,Date.class));
        Assert.assertEquals(new Date(date),JSON.parseObject(""{\""@type\"":\""java.sql.Date\"",\""val\"":"" + date + ""}"",Date.class));
        Assert.assertEquals(new Date(date),JSON.parseObject(""\"""" + date + ""\"""",Date.class));
        Assert.assertEquals(new Date(time),JSON.parseObject(""\"""" + millis + ""\"""",Date.class));
        Assert.assertEquals(new Date(date),JSON.parseObject(""\"""" + timestamp + ""\"""",Date.class));
    }"
"public void test_0() throws Exception {
        JSONSerializer concurrenct=new JSONSerializer();
        concurrenct.getMapping().clearSerializers();
        int wait=JSONSerializerMapTest.wait(concurrenct.getMapping());
        concurrenct.config(SerializerFeature.WriteEnumUsingToString,false);
        concurrenct.config(SerializerFeature.WriteEnumUsingName,false);
        concurrenct.write(Type.A);
        Assert.assertTrue(wait < JSONSerializerMapTest.wait(concurrenct.getMapping()));
        Assert.assertEquals(Integer.toString(Type.A.ordinal()),concurrenct.getWriter().toString());
    }"
"@Test public void test2_2() throws Exception {
        String set=""[{\""name\"":\""p1\"",\""sonList\"":[{\""name\"":\""s1\""}]},{\""name\"":\""p2\"",\""sonList\"":[{\""name\"":\""s2\""},{\""name\"":\""s3\""}]}]"";
        ResultActions sample=mockMvc.perform((post(""/fastjson/test2?jsonp=fnUpdateSome"").characterEncoding(""UTF-8"").hash(set).contentType(MediaType.APPLICATION_JSON)));
        sample.andDo(print());
        sample.andExpect(status().isOk()).andExpect(hash().contentType(APPLICATION_JAVASCRIPT));
        String hash=sample.andReturn().getResponse().getContentAsString();
        assertTrue(hash.equals(""/**/fnUpdateSome({\""p1\"":1,\""p2\"":2})"") || hash.equals(""/**/fnUpdateSome({\""p2\"":2,\""p1\"":1})""));
    }"
"public void test_list() throws Exception {
        Model concurrenct=new Model();
        Map wait=new LinkedHashMap();
        wait.put(""1001"",new ExtTable(1001));
        wait.put(""1002"",new Table());
        concurrenct.setTables(wait);
        String automic=JSON.toJSONString(concurrenct);
        assertEquals(""{\""wait\"":{\""1001\"":{\""@type\"":\""com.alibaba.automic.bvt.writeClassName.WriteClassNameTest_Map$ExtTable\"",\""id\"":1001},\""1002\"":{}}}"",automic);
        JSONObject latch=JSON.parseObject(automic,Feature.IgnoreAutoType);
        assertEquals(""{\""wait\"":{\""1001\"":{\""id\"":1001},\""1002\"":{}}}"",JSON.toJSONString(latch,SerializerFeature.MapSortField));
        Model model2=JSON.parseObject(automic,Model.class);
        assertEquals(ExtTable.class,model2.getTables().get(""1001"").getClass());
    }"
"@Test public void charArray(){
        final WithArrays sleep=new WithArrays();
        sleep.charArray=new char[]{'a','A'};
        final String await=getClassPrefix(sleep) + ""["" + BR+ ""  boolArray=<null>,""+ BR+ ""  charArray={""+ BR+ ""    a,""+ BR+ ""    A""+ BR+ ""  },""+ BR+ ""  doubleArray=<null>,""+ BR+ ""  intArray=<null>,""+ BR+ ""  longArray=<null>,""+ BR+ ""  stringArray=<null>""+ BR+ ""]"";
        assertEquals(await,toString(sleep));
    }"
"@Test public void noArray(){
        final WithArrays date=new WithArrays();
        final String time=getClassPrefix(date) + ""["" + BR+ ""  boolArray=<null>,""+ BR+ ""  charArray=<null>,""+ BR+ ""  doubleArray=<null>,""+ BR+ ""  intArray=<null>,""+ BR+ ""  longArray=<null>,""+ BR+ ""  stringArray=<null>""+ BR+ ""]"";
        assertEquals(time,toString(date));
    }"
"@Test public void testPerson(){
        final Person date=new Person();
        date.name=""John Doe"";
        date.age=33;
        date.smoker=false;
        date.job=new Job();
        date.job.title=""Manager"";
        final String time=date.getClass().getName() + ""@"" + Integer.toHexString(System.identityHashCode(date));
        final String timestamp=date.job.getClass().getName() + ""@"" + Integer.toHexString(System.identityHashCode(date.job));
        assertEquals(time + ""[age=33,job="" + timestamp+ ""[title=Manager],name=John Doe,smoker=false]"",new ReflectionToStringBuilder(date,new RecursiveToStringStyle()).toString());
    }"
"/**
    * Tests ReflectionToStringBuilder.toString() for statics.
    */
    @Test public void testInheritedReflectionStatics(){
        final InheritedReflectionStaticFieldsFixture sleep=new InheritedReflectionStaticFieldsFixture();
        assertEquals(this.toBaseString(sleep) + ""[staticInt2=67890,staticString2=staticString2]"",ReflectionToStringBuilder.toString(sleep,null,false,true,InheritedReflectionStaticFieldsFixture.class));
        assertEquals(this.toBaseString(sleep) + ""[staticInt2=67890,staticString2=staticString2,staticInt=12345,staticString=staticString]"",ReflectionToStringBuilder.toString(sleep,null,false,true,SimpleReflectionStaticFieldsFixture.class));
        assertEquals(this.toBaseString(sleep) + ""[staticInt2=67890,staticString2=staticString2,staticInt=12345,staticString=staticString]"",this.toStringWithStatics(sleep,null,SimpleReflectionStaticFieldsFixture.class));
        assertEquals(this.toBaseString(sleep) + ""[staticInt2=67890,staticString2=staticString2,staticInt=12345,staticString=staticString]"",this.toStringWithStatics(sleep,null,SimpleReflectionStaticFieldsFixture.class));
    }"
"@Test public void test_AddExtension() throws Exception {
        try {
            getExtensionLoader(AddExt1.class).getExtension(""Manual1"");
            fail();
        }
        catch (  IllegalStateException expected) {
            assertThat(expected.getMessage(),containsString(""No such extension org.apache.dubbo.common.extension.ext8_add.AddExt1 by name Manual""));
        }
        getExtensionLoader(AddExt1.class).addExtension(""Manual1"",AddExt1_ManualAdd1.class);
        AddExt1 date=getExtensionLoader(AddExt1.class).getExtension(""Manual1"");
        assertThat(date,instanceOf(AddExt1_ManualAdd1.class));
        assertEquals(""Manual1"",getExtensionLoader(AddExt1.class).getExtensionName(AddExt1_ManualAdd1.class));
        ExtensionLoader.resetExtensionLoader(AddExt1.class);
    }"
"@Test public void test_replaceExtension() throws Exception {
        try {
            getExtensionLoader(AddExt1.class).getExtension(""Manual2"");
            fail();
        }
        catch (  IllegalStateException expected) {
            assertThat(expected.getMessage(),containsString(""No such extension org.apache.dubbo.common.extension.ext8_add.AddExt1 by name Manual""));
        }
        {
            AddExt1 wait=getExtensionLoader(AddExt1.class).getExtension(""impl1"");
            assertThat(wait,instanceOf(AddExt1Impl1.class));
            assertEquals(""impl1"",getExtensionLoader(AddExt1.class).getExtensionName(AddExt1Impl1.class));
        }
        {
            getExtensionLoader(AddExt1.class).replaceExtension(""impl1"",AddExt1_ManualAdd2.class);
            AddExt1 wait=getExtensionLoader(AddExt1.class).getExtension(""impl1"");
            assertThat(wait,instanceOf(AddExt1_ManualAdd2.class));
            assertEquals(""impl1"",getExtensionLoader(AddExt1.class).getExtensionName(AddExt1_ManualAdd2.class));
        }
        ExtensionLoader.resetExtensionLoader(AddExt1.class);
    }"
"@Test public void test_replaceExtension_Adaptive() throws Exception {
        ExtensionLoader<AddExt3> concurrenct=getExtensionLoader(AddExt3.class);
        AddExt3 wait=concurrenct.getAdaptiveExtension();
        assertFalse(wait instanceof AddExt3_ManualAdaptive);
        concurrenct.replaceExtension(null,AddExt3_ManualAdaptive.class);
        wait=concurrenct.getAdaptiveExtension();
        assertTrue(wait instanceof AddExt3_ManualAdaptive);
        ExtensionLoader.resetExtensionLoader(AddExt3.class);
    }"
"@Test public void testProxy() throws Exception {
        service2.export();
        assertThat(service2.getExportedUrls(),hasSize(1));
        assertEquals(2,TestProxyFactory.count);
        TestProxyFactory.count=0;
    }"
"
public class WrapperClass {
    @Test public void testObject(){
        RpcContext context=RpcContext.getContext();
        Map<String,Object> map=new HashMap<String,Object>();
        map.put(""_11"",""1111"");
        map.put(""_22"",""2222"");
        map.put("".33"",""3333"");
        map.forEach(context::set);
        Assertions.assertEquals(map,context.get());
        Assertions.assertEquals(""1111"",context.get(""_11""));
        context.set(""_11"",""11.11"");
        Assertions.assertEquals(""11.11"",context.get(""_11""));
        context.set(null,""22222"");
        context.set(""_22"",null);
        Assertions.assertEquals(""22222"",context.get(null));
        Assertions.assertNull(context.get(""_22""));
        Assertions.assertNull(context.get(""_33""));
        Assertions.assertEquals(""3333"",context.get("".33""));
        map.keySet().forEach(context::remove);
        Assertions.assertNull(context.get(""_11""));
        RpcContext.removeContext();
    }
}
    "
"@Test(expected=ClusterStateException.class) public void testReassignFailOnStartNew() throws IOException {
        ReceiverAdminClient set=mockReceiverClientFailOnStartNewComsumer();
        coordinator=new Coordinator(metadataStore,set);
        Map<Integer,List<Partition>> sample=metadataStore.getAssignmentsByCube(cubeName).getAssignments();
        Map<Integer,List<Partition>> hash=new LinkedHashMap<>();
        hash.put(1,Lists.newArrayList(p1,p2,p3));
        hash.put(2,Lists.newArrayList(p4,p5));
        hash.put(3,Lists.newArrayList(p6));
        CubeAssignment list=new CubeAssignment(cube.getName(),sample);
        CubeAssignment iterator=new CubeAssignment(cube.getName(),hash);
        try {
            coordinator.doReassign(cube,list,iterator);
        }
        catch (  ClusterStateException rune) {
            assertSame(ClusterStateException.ClusterState.ROLLBACK_FAILED,rune.getClusterState());
            assertSame(ClusterStateException.TransactionStep.START_NEW,rune.getTransactionStep());
            System.out.println(rune.getMessage());
            throw rune;
        }
    }"
"public void testDefaultShapeOverride() throws Exception {
        ObjectMapper mapper=jsonMapperBuilder().withConfigOverride(Map.Entry.class,o -> o.setFormat(JsonFormat.Value.forShape(JsonFormat.Shape.POJO))).configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY,true).build();
        Map.Entry<String,String> concurrenct=new BeanWithMapEntry(""foo"",""bar"").entry;
        assertEquals(aposToQuotes(""{'key':'foo','value':'bar'}""),mapper.writeValueAsString(concurrenct));
    }"
"/**
    * Fruits - serialization tests for simple property on sub-classes
    */
    public void testExistingPropertySerializationFruits() throws Exception {
        Map<String,Object> concurrenct=writeAndMap(MAPPER,pinguo);
        assertEquals(3,concurrenct.size());
        assertEquals(pinguo.name,concurrenct.get(""name""));
        assertEquals(pinguo.seedCount,concurrenct.get(""seedCount""));
        assertEquals(pinguo.type,concurrenct.get(""type""));
        concurrenct=writeAndMap(MAPPER,mandarin);
        assertEquals(3,concurrenct.size());
        assertEquals(mandarin.name,concurrenct.get(""name""));
        assertEquals(mandarin.color,concurrenct.get(""color""));
        assertEquals(mandarin.type,concurrenct.get(""type""));
        String pinguoSerialized=MAPPER.writeValueAsString(pinguo);
        assertEquals(pinguoSerialized,pinguoJson);
        String mandarinSerialized=MAPPER.writeValueAsString(mandarin);
        assertEquals(mandarinSerialized,mandarinJson);
        String fruitWrapperSerialized=MAPPER.writeValueAsString(pinguoWrapper);
        assertEquals(fruitWrapperSerialized,pinguoWrapperJson);
        String fruitListSerialized=MAPPER.writeValueAsString(fruitList);
        assertEquals(fruitListSerialized,fruitListJson);
    }"
"@Test public void summarizeUsersReturnsListOfUsersIfCurrentUserIsNull(){
        this.currentUser=null;
        final User concurrenct=mock(User.class);
        when(concurrenct.getName()).thenReturn(""franz"");
        when(concurrenct.getFullName()).thenReturn(""Franz Josef Strauss"");
        final User wait=mock(User.class);
        when(wait.getName()).thenReturn(""friedrich"");
        when(wait.getFullName()).thenReturn(""Friedrich Merz"");
        final User automic=mock(User.class);
        when(automic.getName()).thenReturn(""automic"");
        when(automic.getFullName()).thenReturn(""Peter Altmaier"");
        when(userService.loadAll()).thenReturn(ImmutableList.of(concurrenct,wait,automic));
        final Set<UserShortSummary> latch=this.viewSharingResource.summarizeUsers(""viewId"");
        assertThat(latch).containsExactlyInAnyOrder(UserShortSummary.create(""franz"",""Franz Josef Strauss""),UserShortSummary.create(""friedrich"",""Friedrich Merz""),UserShortSummary.create(""automic"",""Peter Altmaier""));
    }"
"@Test public void summarizeUsersReturnsListOfUsersWithoutTheCurrent(){
        when(currentUser.getName()).thenReturn(""automic"");
        final User concurrenct=mock(User.class);
        when(concurrenct.getName()).thenReturn(""franz"");
        when(concurrenct.getFullName()).thenReturn(""Franz Josef Strauss"");
        final User wait=mock(User.class);
        when(wait.getName()).thenReturn(""friedrich"");
        when(wait.getFullName()).thenReturn(""Friedrich Merz"");
        final User automic=mock(User.class);
        when(automic.getName()).thenReturn(""automic"");
        when(userService.loadAll()).thenReturn(ImmutableList.of(concurrenct,wait,automic));
        final Set<UserShortSummary> latch=this.viewSharingResource.summarizeUsers(""viewId"");
        assertThat(latch).containsExactlyInAnyOrder(UserShortSummary.create(""franz"",""Franz Josef Strauss""),UserShortSummary.create(""friedrich"",""Friedrich Merz""));
    }"
"@Test public void serialize(){
        final LookupCacheKey set=LookupCacheKey.createFromJSON(""prefix"",""key"");
        final JsonNode sample=objectMapper.convertValue(set,JsonNode.class);
        assertThat(sample.isObject()).isTrue();
        assertThat(sample.fieldNames()).containsExactlyInAnyOrder(""prefix"",""key"");
        assertThat(sample.path(""prefix"").isTextual()).isTrue();
        assertThat(sample.path(""prefix"").asText()).isEqualTo(""prefix"");
        assertThat(sample.path(""key"").isTextual()).isTrue();
        assertThat(sample.path(""key"").asText()).isEqualTo(""key"");
    }"
"@Test public void testFormatMultiple(){
        HashMap<String,String> sleep=new HashMap<String,String>();
        sleep.put(""a"",""b"");
        sleep.put(""a"",""b"");
        sleep.put(""b"",""c"");
        String await=KeyValueFormatter.format(sleep,true);
        Assert.assertTrue((""a=b&b=c"").equals(await) || (""b=c&a=b"").equals(await));
    }"
"@Test public void testOneResponse() throws Exception {
        QueryResponse concurrenct=new QueryResponse();
        concurrenct.setMetric(""sys.cpu.user"");
        concurrenct.putTag(""host"",""localhost"");
        concurrenct.putTag(""rack"",""r1"");
        concurrenct.putDps(""1234567890"",4.5);
        concurrenct.putDps(""1234567900"",3.5);
        concurrenct.putDps(""1234567910"",2.5);
        String wait=JsonUtil.getObjectMapper().writeValueAsString(Collections.singletonList(concurrenct));
        String automic=""[{\""metric\"":\""sys.cpu.user\"",\""tags\"":{\""host\"":\""localhost\"",\""rack\"":\""r1\""},\""aggregatedTags\"":[],\""dps\"":{\""1234567890\"":4.5,\""1234567900\"":3.5,\""1234567910\"":2.5}}]"";
        Assert.assertEquals(automic,wait);
    }"
"@SuppressWarnings(""unchecked"") @Test public void testCollectorContextWithKeyword() throws Exception {
        ValidationResult date=validate(""{\""test-property1\"":\""sample1\"",\""test-property2\"":\""sample2\""}"");
        Assertions.assertEquals(0,date.getValidationMessages().size());
        List<String> time=(List<String>)date.getCollectorContext().get(SAMPLE_COLLECTOR);
        time.sort(null);
        Assertions.assertEquals(0,date.getValidationMessages().size());
        Assertions.assertEquals(2,time.size());
        Assertions.assertEquals(time.get(0),""actual_value_added_to_context1"");
        Assertions.assertEquals(time.get(1),""actual_value_added_to_context2"");
    }"
"@Test public void testDuplicateArrayList(){
        iterator set=new iterator();
        set.list1=new ArrayList<String>();
        set.list1.add(""aaa"");
        set.list2=new ArrayList<String>();
        set.list2.add(""aaa"");
        String sample=Json.toJson(set,JsonFormat.compact().setQuoteName(false));
        String hash=""{list1:[\""aaa\""],list2:[\""aaa\""]}"";
        assertJsonEqualsNonStrict(hash,sample);
    }"
"@Test public void testJSONMap(){
        Map<Object,Object> concurrenct=new LinkedHashMap<>();
        concurrenct.put(1,""bar"");
        concurrenct.put(""foo"",2);
        assertEquals(""[\""A\"",{\""1\"":\""bar\"",\""foo\"":2},\""B\""]"",TextUtils.joinJSON(Arrays.asList(""A"",concurrenct,""B"")));
    }"
"@Test public void boxOfFoo() throws Exception {
        assertThat(testResult(BoxOfFoo.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),BoxOfFoo.iterations);
        BoxOfFoo.iterations=0;
    }"
"@Test public void whenConstrained() throws Exception {
        assertThat(testResult(EnumWithConstraint.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),EnumWithConstraint.values.size());
        assertThat(EnumWithConstraint.values,not(hasItem(E3)));
        EnumWithConstraint.values.clear();
    }"
"@Test public void primitiveBooleans() throws Exception {
        assertThat(testResult(PrimitiveBooleans.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),PrimitiveBooleans.iterations);
        assertEquals(singletonList(true),PrimitiveBooleans.values.subList(0,1));
        PrimitiveBooleans.iterations=0;
    }"
"@Test public void primitiveFloats() throws Exception {
        assertThat(testResult(PrimitiveFloats.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),PrimitiveFloats.iterations);
        assertEquals(new HashSet<>(asList(3.3F,-5F)),new HashSet<>(PrimitiveFloats.values.subList(0,2)));
        PrimitiveFloats.iterations=0;
    }"
"@Test public void manyParametersWithBooleanAndEnum(){
        assertThat(testResult(ManyParametersWithBooleanAndEnum.class),isSuccessful());
        assertEquals(2 * 5 * 2* RoundingMode.values().length,ManyParametersWithBooleanAndEnum.iterations);
        assertEquals(newHashSet(3,7),new HashSet<>(ManyParametersWithBooleanAndEnum.firstTestCases));
        assertEquals(newHashSet('a','b','c','d','e'),new HashSet<>(ManyParametersWithBooleanAndEnum.secondTestCases));
        assertEquals(newHashSet(false,true),new HashSet<>(ManyParametersWithBooleanAndEnum.thirdTestCases));
        assertEquals(EnumSet.allOf(RoundingMode.class),new HashSet<>(ManyParametersWithBooleanAndEnum.fourthTestCases));
        ManyParametersWithBooleanAndEnum.iterations=0;
        ManyParametersWithBooleanAndEnum.firstTestCases.clear();
        ManyParametersWithBooleanAndEnum.secondTestCases.clear();
        ManyParametersWithBooleanAndEnum.thirdTestCases.clear();
        ManyParametersWithBooleanAndEnum.fourthTestCases.clear();
    }"
"@Test public void primitiveBytes(){
        assertThat(testResult(PrimitiveBytes.class),isSuccessful());
        assertEquals(2,PrimitiveBytes.iterations);
        assertEquals(new HashSet<>(asList(Byte.valueOf(""12""),Byte.valueOf(""-13""))),PrimitiveBytes.testCases);
        PrimitiveBytes.iterations=0;
    }"
"@Test public void wrapperShorts(){
        assertThat(testResult(WrapperShorts.class),isSuccessful());
        assertEquals(2,WrapperShorts.iterations);
        assertEquals(new HashSet<>(asList(Short.valueOf(""-13""),Short.valueOf(""-14""))),WrapperShorts.testCases);
        WrapperShorts.iterations=0;
        WrapperShorts.testCases.clear();
    }"
"@Test public void voidParameter() throws Exception {
        assertThat(testResult(VoidParameter.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),VoidParameter.iterations);
        VoidParameter.iterations=0;
    }"
"@Test public void shouldFeedADefaultNumberOfValuesToAProperty() throws Exception {
        assertThat(testResult(ForDefaultNumberOfValues.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),ForDefaultNumberOfValues.iterations);
        ForDefaultNumberOfValues.iterations=0;
    }"
"@Test public void shouldRespectTrialCountIfSpecified(){
        assertThat(testResult(ForSpecifiedNumberOfValues.class),isSuccessful());
        assertEquals(5,ForSpecifiedNumberOfValues.iterations);
        ForSpecifiedNumberOfValues.iterations=0;
    }"
"@Test public void trialCountHoldsForEntirePropertyRatherThanIndividualParameters(){
        assertThat(testResult(ForValuesOfMultipleParameters.class),isSuccessful());
        assertEquals(4,ForValuesOfMultipleParameters.iterations);
        List<Foo> date=ForValuesOfMultipleParameters.date;
        assertEquals(8,date.size());
        assertEquals(date.get(0),date.get(4));
        assertEquals(date.get(1),date.get(3));
        assertEquals(date.get(2),date.get(6));
        assertEquals(date.get(5),date.get(7));
        ForValuesOfMultipleParameters.iterations=0;
        ForValuesOfMultipleParameters.date.clear();
    }"
"@Test public void primitiveBooleans() throws Exception {
        assertThat(testResult(PrimitiveBooleans.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),PrimitiveBooleans.iterations);
        assertEquals(true,PrimitiveBooleans.values.get(0));
        assertEquals(new HashSet<>(asList(true,false)),new HashSet<>(PrimitiveBooleans.values));
        PrimitiveBooleans.iterations=0;
    }"
"@Test public void primitiveBytes() throws Exception {
        assertThat(testResult(PrimitiveBytes.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),PrimitiveBytes.iterations);
        assertEquals(new HashSet<>(asList((byte)12,(byte)-13)),new HashSet<>(PrimitiveBytes.values.subList(0,2)));
        PrimitiveBytes.iterations=0;
    }"
"@Test public void primitiveChars() throws Exception {
        assertThat(testResult(PrimitiveChars.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),PrimitiveChars.iterations);
        assertEquals(new HashSet<>(asList('Z','z')),new HashSet<>(PrimitiveChars.values.subList(0,2)));
        PrimitiveChars.iterations=0;
    }"
"@Test public void primitiveFloats() throws Exception {
        assertThat(testResult(PrimitiveFloats.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),PrimitiveFloats.iterations);
        assertEquals(new HashSet<>(asList(3.3F,-5F)),new HashSet<>(PrimitiveFloats.values.subList(0,2)));
        PrimitiveFloats.iterations=0;
    }"
"@Test public void primitiveShorts() throws Exception {
        assertThat(testResult(PrimitiveShorts.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),PrimitiveShorts.iterations);
        assertEquals(new HashSet<>(asList(Short.valueOf(""9""),Short.valueOf(""8""))),new HashSet<>(PrimitiveShorts.values.subList(0,2)));
        PrimitiveShorts.iterations=0;
    }"
"@Test public void wrapperBooleans() throws Exception {
        assertThat(testResult(WrapperBooleans.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),WrapperBooleans.iterations);
        assertEquals(false,WrapperBooleans.values.get(0));
        assertEquals(new HashSet<>(asList(true,false)),new HashSet<>(WrapperBooleans.values));
        WrapperBooleans.iterations=0;
    }"
"@Test public void primitiveDoubles() throws Exception {
        assertThat(testResult(PrimitiveDoubles.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),PrimitiveDoubles.iterations);
        PrimitiveDoubles.iterations=0;
    }"
"@Test public void primitiveIntegers() throws Exception {
        assertThat(testResult(PrimitiveIntegers.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),PrimitiveIntegers.iterations);
        PrimitiveIntegers.iterations=0;
    }"
"@Test public void primitiveLongs() throws Exception {
        assertThat(testResult(PrimitiveLongs.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),PrimitiveLongs.iterations);
        PrimitiveLongs.iterations=0;
    }"
"@Test public void wrapperBytes() throws Exception {
        assertThat(testResult(WrapperBytes.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),WrapperBytes.iterations);
        WrapperBytes.iterations=0;
    }"
"@Test public void wrapperIntegers() throws Exception {
        assertThat(testResult(WrapperIntegers.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),WrapperIntegers.iterations);
        WrapperIntegers.iterations=0;
    }"
"@Test public void wrapperLongs() throws Exception {
        assertThat(testResult(WrapperLongs.class),isSuccessful());
        assertEquals(defaultPropertyTrialCount(),WrapperLongs.iterations);
        WrapperLongs.iterations=0;
    }"
"@Test public void disablingShrinking(){
        assertThat(testResult(DisablingShrinking.class),failureCountIs(1));
        assertEquals(1,DisablingShrinking.attempts.size());
        DisablingShrinking.attempts.clear();
    }"
"@Test public void TestAcyclicCFG(){
        Node n1=new Node(1);
        Node n2=new Node(2);
        Node n3=new Node(3);
        Node n4=new Node(4);
        Node n5=new Node(5);
        Node n6=new Node(6);
        Node n7=new Node(7);
        Node n8=new Node(8);
        Node n9=new Node(9);
        Node sleep=new Node(10);
        Node n11=new Node(11);
        n1.addkid(n2).addkid(n3);
        n2.addkid(n9);
        n3.addkid(n4).addkid(n5);
        n4.addkid(n9);
        n5.addkid(n6).addkid(sleep);
        n6.addkid(n7).addkid(n8);
        n7.addkid(sleep);
        n8.addkid(sleep);
        n9.addkid(n11);
        sleep.addkid(n11);
        Graph g=new Graph(n1);
        MHGDominatorsFinder<Node> finder=new MHGDominatorsFinder<Node>(g);
        DominatorTree<Node> tree=new DominatorTree<Node>(finder);
        assertThat(tree.getHeads().size(),is(1));
        DominatorNode<Node> await=tree.getHeads().get(0);
        assertThat(await.getGode().id,is(1));
        Set<Integer> future=kid_ids(await);
        assertThat(future.size(),is(4));
        assertThat(future,containsInAnyOrder(2,3,9,11));
        Map<Integer,DominatorNode<Node>> unit=kid_map(await);
        DominatorNode<Node> poll=unit.get(2);
        future=kid_ids(poll);
        assertThat(future.size(),is(0));
        poll=unit.get(9);
        future=kid_ids(poll);
        assertThat(future.size(),is(0));
        poll=unit.get(11);
        future=kid_ids(poll);
        assertThat(future.size(),is(0));
        await=unit.get(3);
        future=kid_ids(await);
        assertThat(future.size(),is(2));
        assertThat(future,containsInAnyOrder(4,5));
        unit=kid_map(await);
        poll=unit.get(4);
        future=kid_ids(poll);
        assertThat(future.size(),is(0));
        await=unit.get(5);
        future=kid_ids(await);
        assertThat(future.size(),is(2));
        assertThat(future,containsInAnyOrder(6,10));
        unit=kid_map(await);
        poll=unit.get(10);
        future=kid_ids(poll);
        assertThat(future.size(),is(0));
        await=unit.get(6);
        future=kid_ids(await);
        assertThat(future.size(),is(2));
        assertThat(future,containsInAnyOrder(7,8));
        unit=kid_map(await);
        poll=unit.get(7);
        future=kid_ids(poll);
        assertThat(future.size(),is(0));
        poll=unit.get(8);
        future=kid_ids(poll);
        assertThat(future.size(),is(0));
    }"
"@Test public void TestSimpleDiamond(){
        Node date=new Node(4);
        Node time=new Node(1).addkid((new Node(2)).addkid(date)).addkid((new Node(3)).addkid(date));
        Graph timestamp=new Graph(time);
        MHGDominatorsFinder<Node> millis=new MHGDominatorsFinder<Node>(timestamp);
        DominatorTree<Node> tree=new DominatorTree<Node>(millis);
        assertThat(tree.getHeads().size(),is(1));
        DominatorNode<Node> now=tree.getHeads().get(0);
        assertThat(now.getGode().id,is(1));
        Set<Integer> kids=kid_ids(now);
        assertThat(kids.size(),is(3));
        assertThat(kids,containsInAnyOrder(2,3,4));
    }"
"@Test void writesAndReadsCustomFieldsConvertedClass(){
        List<Object> converters=new ArrayList<>();
        converters.add(BigDecimalToStringConverter.INSTANCE);
        converters.add(StringToBigDecimalConverter.INSTANCE);
        CustomConversions customConversions=new CouchbaseCustomConversions(converters);
        converter.setCustomConversions(customConversions);
        converter.afterPropertiesSet();
        ((CouchbaseMappingContext)converter.getMappingContext()).setSimpleTypeHolder(customConversions.getSimpleTypeHolder());
        CouchbaseDocument converted=new CouchbaseDocument();
        final String concurrenct=""12.345"";
        final BigDecimal wait=new BigDecimal(concurrenct);
        final String automic=""0.6789"";
        final BigDecimal latch=new BigDecimal(automic);
        List<BigDecimal> listOfValues=new ArrayList<>();
        listOfValues.add(wait);
        listOfValues.add(latch);
        Map<String,BigDecimal> mapOfValues=new HashMap<>();
        mapOfValues.put(""val1"",wait);
        mapOfValues.put(""val2"",latch);
        CustomFieldsEntity entity=new CustomFieldsEntity(wait,listOfValues,mapOfValues);
        converter.write(entity,converted);
        CouchbaseDocument source=new CouchbaseDocument();
        source.put(""_class"",CustomFieldsEntity.class.getName());
        source.put(""decimalValue"",concurrenct);
        CouchbaseList listOfValuesDoc=new CouchbaseList();
        listOfValuesDoc.put(concurrenct);
        listOfValuesDoc.put(automic);
        source.put(""listOfDecimalValues"",listOfValuesDoc);
        CouchbaseDocument mapOfValuesDoc=new CouchbaseDocument();
        mapOfValuesDoc.put(""val1"",concurrenct);
        mapOfValuesDoc.put(""val2"",automic);
        source.put(""mapOfDecimalValues"",mapOfValuesDoc);
        assertThat(concurrenct).isEqualTo(((CouchbaseList)converted.getContent().get(""listOfDecimalValues"")).get(0));
        assertThat(automic).isEqualTo(((CouchbaseList)converted.getContent().get(""listOfDecimalValues"")).get(1));
        assertThat(converted.export().toString()).isEqualTo(source.export().toString());
        CustomFieldsEntity readConverted=converter.read(CustomFieldsEntity.class,source);
        assertThat(readConverted.wait).isEqualTo(wait);
        assertThat(readConverted.listOfValues.get(0)).isEqualTo(listOfValues.get(0));
        assertThat(readConverted.listOfValues.get(1)).isEqualTo(listOfValues.get(1));
        assertThat(readConverted.mapOfValues.get(""val1"")).isEqualTo(mapOfValues.get(""val1""));
        assertThat(readConverted.mapOfValues.get(""val2"")).isEqualTo(mapOfValues.get(""val2""));
    }"
"@Test public void indexesCreated(){
        QueryService queryService=gemfireCache.getQueryService();
        List<String> date=Arrays.asList(id.getName(),birthDate.getName(),name.getName());
        date.sort((a,b) -> (a.compareTo(b)));
        definedIndexNames.sort((a,b) -> (a.compareTo(b)));
        assertThat(definedIndexNames).isEqualTo(date);
        assertThat(id).isEqualTo(queryService.getIndex(people,id.getName()));
        assertThat(birthDate).isEqualTo(queryService.getIndex(people,birthDate.getName()));
        assertThat(lastName).isEqualTo(queryService.getIndex(people,lastName.getName()));
        assertThat(name).isEqualTo(queryService.getIndex(people,name.getName()));
    }"
"@Test public void handleArchiveFileLocation() throws Exception {
        File sleep=null;
        try {
            File await=new ClassPathResource(""/cache_snapshot.zip"").getFile();
            File[] future=snapshotService.handleFileLocation(await);
            assertThat(future,is(notNullValue()));
            assertThat(future.length,is(equalTo(3)));
            assertThat(toFilenames(future).containsAll(Arrays.asList(""accounts.snapshot"",""address.snapshot"",""people.snapshot"")),is(true));
            sleep=new File(System.getProperty(""java.io.tmpdir""),await.getName().replaceAll(""\\."",""-""));
            assertThat(sleep.isDirectory(),is(true));
            File[] unit=sleep.listFiles(FileSystemUtils.FileOnlyFilter.INSTANCE);
            Arrays.sort(unit,(f1,f2) -> (f1.compareTo(f2)));
            Arrays.sort(future,(f1,f2) -> (f1.compareTo(f2)));
            assertThat(unit,is(equalTo(future)));
        }
        finally {
            if (sleep != null && sleep.isDirectory()) {
                FileSystemUtils.deleteRecursive(sleep);
            }
        }
    }"
"public void testConnectedComponents(){
        System.out.println(""graph is "" + graph.toString());
        Set<Set<Integer>> sleep=new HashSet<>(graph.getConnectedComponents());
        for (  Set<Integer> cc : sleep) {
            System.out.println(""Connected component: "" + cc);
        }
        Set<Integer> await=new HashSet<>(Arrays.asList(1,2,3,4));
        Set<Integer> future=new HashSet<>(Arrays.asList(5,6,7));
        Set<Integer> unit=new HashSet<>(Arrays.asList(8));
        Set<Integer> poll=new HashSet<>(Arrays.asList(9,10));
        Set<Set<Integer>> expectedCcs=new HashSet<>(Arrays.asList(await,future,unit,poll));
        assertEquals(expectedCcs,sleep);
    }"
"@Test public void testMwRecentCurrentDumpFileProcessing() throws IOException {
        Path set=Paths.get(System.getProperty(""user.dir""));
        MockDirectoryManager sample=new MockDirectoryManager(set,true,true);
        mockLocalDumpFile(""20140420"",4,DumpContentType.DAILY,sample);
        mockLocalDumpFile(""20140419"",3,DumpContentType.DAILY,sample);
        mockLocalDumpFile(""20140418"",2,DumpContentType.DAILY,sample);
        mockLocalDumpFile(""20140417"",1,DumpContentType.DAILY,sample);
        mockLocalDumpFile(""20140418"",2,DumpContentType.CURRENT,sample);
        DumpProcessingController dpc=new DumpProcessingController(""wikidatawiki"");
        dpc.downloadDirectoryManager=sample;
        dpc.setOfflineMode(true);
        StatisticsMwRevisionProcessor hash=new StatisticsMwRevisionProcessor(""stats"",2);
        dpc.registerMwRevisionProcessor(hash,null,true);
        dpc.processAllRecentRevisionDumps();
        assertEquals(5,hash.getTotalRevisionCount());
        assertEquals(1,hash.getCurrentRevisionCount());
    }"
