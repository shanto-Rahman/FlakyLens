../dataset/Accenture_test_methods.csv
calling to Testing_bert_flaky_categorization.py
*************data_name= Flakicat_Categorization-Data
It is Flakicat
FOLD= 0
 NOW IN FOLD NUMBER 0
      id  ...                                          full_code
0      1  ...  @Test\n    public void homePageTest() throws I...
1      2  ...  @Test\n    public void optionsMethodTest() thr...
2      3  ...  @Test\n    public void uploadBytesWithPut() th...
3      4  ...  @Test\n    public void uploadLargePayloadWithP...
4      5  ...  @Test\n    public void uploadStreamWithPut() t...
..   ...  ...                                                ...
124  125  ...  @Test\n    public void validName() {{\n       ...
125  126  ...  @Test\n    public void connectivityTest() thro...
126  127  ...  @Test\n    public void connectivityTest() thro...
127  128  ...  @Test\n    public void reservedExtension() {{\...
128  129  ...  @Test\n    public void reservedName() {{\n    ...

[129 rows x 4 columns]
../flaky-test-categorization/model_weights_on_Flakicat_dataset0_with_noisy_train_data.pt
test_x= ['@Test\n    public void homePageTest() throws IOException, InterruptedException {\n        EventEnvelope response = httpGet("http://127.0.0.1:"+ HTTP_PORT, "/", null);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        MultiLevelMap multi = new MultiLevelMap(result);\n        Assert.assertEquals("Minimalist HTTP server supports these admin endpoints",\n                            multi.getElement("message"));\n        int n = 0;\n        for (String[] service: ADMIN_ENDPOINTS) {{\n            Assert.assertEquals(service[0], multi.getElement("endpoints["+n+"]"));\n            n++;\n        }']
preds_chunk= [[-2.8815868  -3.1631622  -3.0765982  -2.0828419  -0.38963383 -2.9249747 ]]
pred_class= [4]
test_x= ['@Test\n    public void optionsMethodTest() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        EventEmitter po = EventEmitter.getInstance();\n        AsyncHttpRequest req = new AsyncHttpRequest();\n        req.setMethod("OPTIONS");\n        req.setHeader("accept", "application/json");\n        req.setUrl("/api/hello/world?hello world=abc");\n        req.setQueryParameter("x1", "y");\n        List<String> list = new ArrayList<>();\n        list.add("a");\n        list.add("b");\n        req.setQueryParameter("x2", list);\n        req.setTargetHost("http://127.0.0.1:"+port);\n        EventEnvelope request = new EventEnvelope().setTo(HTTP_REQUEST).setBody(req);\n        Future<EventEnvelope> res = po.asyncRequest(request, RPC_TIMEOUT);\n        res.onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        // response is an empty string\n        Assert.assertEquals("", response.getBody());\n        // CORS headers are inserted - retrieve it with a case-insensitive key\n        Assert.assertEquals("*", response.getHeader("access-control-Allow-Origin"));\n    }\n\n    @SuppressWarnings(value = "unchecked")\n    @Test\n    public void serviceTest() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        EventEmitter po = EventEmitter.getInstance();\n        AsyncHttpRequest req = new AsyncHttpRequest();\n        req.setMethod("GET");\n        req.setHeader("accept", "application/json");\n        req.setUrl("/api/hello/world?hello world=abc");\n        req.setQueryParameter("x1", "y");\n        List<String> list = new ArrayList<>();\n        list.add("a");\n        list.add("b");\n        req.setQueryParameter("x2", list);\n        req.setTargetHost("http://127.0.0.1:"+port);\n        EventEnvelope request = new EventEnvelope().setTo(HTTP_REQUEST).setBody(req);\n        Future<EventEnvelope> res = po.asyncRequest(request, RPC_TIMEOUT);\n        res.onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        MultiLevelMap map = new MultiLevelMap((Map<String, Object>) response.getBody());\n        Assert.assertEquals("application/json", map.getElement("headers.accept"));\n        Assert.assertEquals(false, map.getElement("https"));\n        Assert.assertEquals("/api/hello/world", map.getElement("url"));\n        Assert.assertEquals("GET", map.getElement("method"));\n        Assert.assertEquals("127.0.0.1", map.getElement("ip"));\n        Assert.assertEquals(10, map.getElement("timeout"));\n        Assert.assertEquals("y", map.getElement("parameters.query.x1"));\n        Assert.assertEquals(list, map.getElement("parameters.query.x2"));\n        // the HTTP request filter will not execute because the request is not a static content request\n        Assert.assertNull(response.getHeader("x-filter"));\n    }\n\n    @Test\n    public void uriPathSecurityTest() throws IOException, InterruptedException {\n        uriPathSecurity("/api/hello/world moved to https://evil.site?hello world=abc",\n                "/api/hello/world moved to https");\n        uriPathSecurity("/api/hello/world <div>test</div>",\n                "/api/hello/world ");\n        uriPathSecurity("/api/hello/world > something",\n                "/api/hello/world ");\n        uriPathSecurity("/api/hello/world &nbsp;",\n                "/api/hello/world ");\n    }\n\n    @SuppressWarnings("unchecked")\n    private void uriPathSecurity(String uri, String expected) throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        EventEmitter po = EventEmitter.getInstance();\n        AsyncHttpRequest req = new AsyncHttpRequest();\n        req.setMethod("GET");\n        req.setHeader("accept", "application/json");\n        req.setUrl(uri);\n        req.setQueryParameter("x1", "y%20");\n        List<String> list = new ArrayList<>();\n        list.add("a");\n        list.add("b");\n        req.setQueryParameter("x2", list);\n        req.setTargetHost("http://127.0.0.1:"+port);\n        EventEnvelope request = new EventEnvelope().setTo(HTTP_REQUEST).setBody(req);\n        Future<EventEnvelope> res = po.asyncRequest(request, RPC_TIMEOUT);\n        res.onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        Assert.assertEquals(404, response.getStatus());\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> map = (Map<String, Object>) response.getBody();\n        Assert.assertEquals("Resource not found", map.get("message"));\n        Assert.assertEquals(expected, map.get("path"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void authRoutingTest1() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        Utility util = Utility.getInstance();\n        EventEmitter po = EventEmitter.getInstance();\n        AsyncHttpRequest req = new AsyncHttpRequest();\n        req.setMethod("GET");\n        req.setHeader("accept", "application/json");\n        String credentials = "Basic " + util.bytesToBase64(util.getUTF("hello:world"));\n        req.setHeader("authorization", credentials);\n        req.setUrl("/api/hello/world");\n        req.setTargetHost("http://127.0.0.1:"+port);\n        EventEnvelope request = new EventEnvelope().setTo(HTTP_REQUEST).setBody(req);\n        Future<EventEnvelope> res = po.asyncRequest(request, RPC_TIMEOUT);\n        res.onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        Assert.assertEquals(503, response.getStatus());\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> map = (Map<String, Object>) response.getBody();\n        Assert.assertEquals("Service v1.basic.auth not reachable", map.get("message"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void authRoutingTest2() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        EventEmitter po = EventEmitter.getInstance();\n        AsyncHttpRequest req = new AsyncHttpRequest();\n        req.setMethod("GET");\n        req.setHeader("accept", "application/json");\n        req.setHeader("x-app-name", "demo");\n        req.setUrl("/api/hello/world");\n        req.setTargetHost("http://127.0.0.1:"+port);\n        EventEnvelope request = new EventEnvelope().setTo(HTTP_REQUEST).setBody(req);\n        Future<EventEnvelope> res = po.asyncRequest(request, RPC_TIMEOUT);\n        res.onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        Assert.assertEquals(401, response.getStatus());\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> map = (Map<String, Object>) response.getBody();\n        Assert.assertEquals("Unauthorized", map.get("message"));\n    }\n\n    @Test\n    public void uploadSmallBlockWithPut() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench1 = new ArrayBlockingQueue<>(1);\n        final BlockingQueue<Boolean> bench2 = new ArrayBlockingQueue<>(1);\n        final Utility util = Utility.getInstance();\n        final EventEmitter po = EventEmitter.getInstance();\n        int len = 0;\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        ObjectStreamIO stream = new ObjectStreamIO();\n        ObjectStreamWriter out = new ObjectStreamWriter(stream.getOutputStreamId());\n        for (int i=0; i < 100; i++) {{\n            byte[] line = util.getUTF("hello world "+i+"\\n");\n            out.write(line);\n            bytes.write(line);\n            len += line.length;\n        }']
preds_chunk= [[-0.11859428 -3.6219528  -3.7949896  -4.2880487  -3.7087965  -3.7140083 ]]
pred_class= [0]
test_x= ['@Test\n    public void uploadBytesWithPut() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        Utility util = Utility.getInstance();\n        EventEmitter po = EventEmitter.getInstance();\n        int len = 0;\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        for (int i=0; i < 100; i++) {{\n            byte[] line = util.getUTF("hello world "+i+"\\n");\n            bytes.write(line);\n            len += line.length;\n        }']
preds_chunk= [[-1.8205564  -0.43169552 -3.0138083  -3.3157375  -3.454044   -2.6362672 ]]
pred_class= [1]
test_x= ['@Test\n    public void uploadLargePayloadWithPut() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench1 = new ArrayBlockingQueue<>(1);\n        final BlockingQueue<Boolean> bench2 = new ArrayBlockingQueue<>(1);\n        Utility util = Utility.getInstance();\n        EventEmitter po = EventEmitter.getInstance();\n        int len = 0;\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        for (int i=0; i < 4000; i++) {{\n            byte[] line = util.getUTF("hello world "+i+"\\n");\n            bytes.write(line);\n            len += line.length;\n        }']
preds_chunk= [[-2.0024085 -1.3865463 -2.6578536 -2.7835681 -3.0663428 -0.8288616]]
pred_class= [5]
test_x= ['@Test\n    public void uploadStreamWithPut() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench1 = new ArrayBlockingQueue<>(1);\n        final BlockingQueue<Boolean> bench2 = new ArrayBlockingQueue<>(1);\n        Utility util = Utility.getInstance();\n        EventEmitter po = EventEmitter.getInstance();\n        int len = 0;\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        ObjectStreamIO stream = new ObjectStreamIO();\n        ObjectStreamWriter out = new ObjectStreamWriter(stream.getOutputStreamId());\n        for (int i=0; i < 600; i++) {{\n            String line = "hello world "+i+"\\n";\n            byte[] d = util.getUTF(line);\n            out.write(d);\n            bytes.write(d);\n            len += d.length;\n        }']
preds_chunk= [[-2.6882417  -0.24929185 -3.1982918  -3.2803104  -3.8238926  -2.9496877 ]]
pred_class= [1]
test_x= ['@Test\n    public void uploadMultipartWithPost() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench1 = new ArrayBlockingQueue<>(1);\n        final BlockingQueue<Boolean> bench2 = new ArrayBlockingQueue<>(1);\n        Utility util = Utility.getInstance();\n        EventEmitter po = EventEmitter.getInstance();\n        int len = 0;\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        ObjectStreamIO stream = new ObjectStreamIO();\n        ObjectStreamWriter out = new ObjectStreamWriter(stream.getOutputStreamId());\n        for (int i=0; i < 600; i++) {{\n            String line = "hello world "+i+"\\n";\n            byte[] d = util.getUTF(line);\n            out.write(d);\n            bytes.write(d);\n            len += d.length;\n        }']
preds_chunk= [[-2.3040133 -0.5085342 -2.8419664 -2.8731654 -3.3576407 -1.9030156]]
pred_class= [1]
test_x= ['@Test\n    public void validateCookie() {{\n        String cookie = createCookie("hello", "world").toString();\n        Assert.assertTrue(cookie.contains("Path=/;"));\n        Assert.assertTrue(cookie.contains("HttpOnly"));\n        Assert.assertTrue(cookie.contains("Secure;"));\n        Assert.assertTrue(cookie.contains("hello=world;"));\n        Assert.assertTrue(cookie.contains("Max-Age=60;"));\n        Assert.assertTrue(cookie.contains("GMT;"));\n    }']
preds_chunk= [[-2.5131493 -3.0776207 -1.3953125 -2.7326105 -0.7213064 -2.6037314]]
pred_class= [4]
test_x= ['@Test\n    public void cookieInEnvelope() {{\n        EventEnvelope event = new EventEnvelope();\n        // "Set-Cookie" is the only header that supports multiple values\n        event.setHeader(SET_COOKIE, createCookie("key1", "value1"));\n        event.setHeader(SET_COOKIE, createCookie("key2", "value2"));\n        String HELLO = "hello";\n        String WORLD = "world";\n        event.setHeader(HELLO, WORLD);\n        String cookies = event.getHeader(SET_COOKIE);\n        Assert.assertTrue(cookies.contains("|"));\n        List<String> cookieList = Utility.getInstance().split(cookies, "|");\n        Assert.assertEquals(2, cookieList.size());\n        Assert.assertTrue(cookieList.get(0).startsWith("key1=value1;"));\n        Assert.assertTrue(cookieList.get(1).startsWith("key2=value2;"));\n        Assert.assertEquals(WORLD, event.getHeader(HELLO));\n    }']
preds_chunk= [[-3.3275518 -3.8600852 -3.596602  -3.3516018 -0.1741567 -3.2078667]]
pred_class= [4]
test_x= ['@Test\n    public void configTest() {{\n        String ROUTE = "event.http.test";\n        AppConfigReader config = AppConfigReader.getInstance();\n        String serverPort = config.getProperty("server.port");\n        String SHOULD_BE_TARGET = "http://127.0.0.1:" + serverPort+ "/api/event";\n        EventEmitter po = EventEmitter.getInstance();\n        String target = po.getEventHttpTarget(ROUTE);\n        Assert.assertEquals(SHOULD_BE_TARGET, target);\n        Map<String, String> headers = po.getEventHttpHeaders(ROUTE);\n        Assert.assertEquals("demo", headers.get("authorization"));\n    }']
preds_chunk= [[-0.2609707 -3.4130373 -3.3364458 -3.829496  -2.2413125 -3.4066238]]
pred_class= [0]
test_x= ['@Test\n    public void declarativeEventOverHttpTest() throws IOException, ExecutionException, InterruptedException {\n        /*\n         * This test illustrates automatic forwarding of events to a peer using "event over HTTP" configuration.\n         * The rest of the tests in this class use programmatic "Event over HTTP" API.\n         */\n        Platform platform = Platform.getInstance();\n        final String BLOCKING_EVENT_WAIT = "blocking.event.wait";\n        final BlockingQueue<Object> wait1 = new ArrayBlockingQueue<>(1);\n        final BlockingQueue<Object> wait2 = new ArrayBlockingQueue<>(1);\n        final BlockingQueue<Object> wait3 = new ArrayBlockingQueue<>(1);\n        LambdaFunction f = (headers, body, instance) -> {\n            wait1.offer(body);\n            platform.release(BLOCKING_EVENT_WAIT);\n            return null;\n        };\n        platform.registerPrivate(BLOCKING_EVENT_WAIT, f, 1);\n        String ROUTE = "event.save.get";\n        String HELLO = "hello";\n        EventEnvelope save = new EventEnvelope().setTo(ROUTE).setHeader("type", "save").setBody(HELLO)\n                .setReplyTo(BLOCKING_EVENT_WAIT);\n        PostOffice po = new PostOffice("unit.test", "1200001", "EVENT /save/then/get");\n        po.send(save);\n        Object serviceResponse = wait1.poll(5, TimeUnit.SECONDS);\n        Assert.assertEquals("saved", serviceResponse);\n        EventEnvelope get = new EventEnvelope().setTo(ROUTE).setHeader("type", "get");\n        Future<EventEnvelope> response2 = po.asyncRequest(get, 10000);\n        response2.onSuccess(evt -> wait2.offer(evt.getBody()));\n        Object result2 = wait2.poll(5, TimeUnit.SECONDS);\n        Assert.assertEquals(HELLO, result2);\n        // test kotlin FastRPC\n        EventEnvelope forward = new EventEnvelope().setTo("event.api.forwarder")\n                                .setBody(get.toBytes()).setHeader("timeout", 10000);\n        Future<EventEnvelope> response3 = po.asyncRequest(forward, 10000);\n        response3.onSuccess(evt -> wait3.offer(evt.getBody()));\n        Object result3 = wait3.poll(5, TimeUnit.SECONDS);\n        Assert.assertEquals(HELLO, result3);\n    }\n\n    @Test\n    public void remoteEventApiAuthTest() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        long TIMEOUT = 3000;\n        int NUMBER_THREE = 3;\n        Map<String, String> securityHeaders = new HashMap<>();\n        securityHeaders.put("Authorization", "anyone");\n        PostOffice po = new PostOffice("unit.test", "123", "TEST /remote/event");\n        EventEnvelope event = new EventEnvelope().setTo("hello.world")\n                .setBody(NUMBER_THREE).setHeader("hello", "world");\n        Future<EventEnvelope> response = po.asyncRequest(event, TIMEOUT, securityHeaders,\n                "http://127.0.0.1:"+port+"/api/event", true);\n        response.onSuccess(bench::offer);\n        EventEnvelope result = bench.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n        Assert.assertNotNull(result);\n        Assert.assertEquals(401, result.getStatus());\n        Assert.assertTrue(result.getBody() instanceof String);\n        Assert.assertEquals("Unauthorized", result.getBody());\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void remoteEventApiWithLargePayloadTest() throws IOException, InterruptedException {\n        // create a large payload of 100 KB\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i < 10000; i++) {{\n            sb.append("123456789.");\n        }']
preds_chunk= [[-0.15097539 -2.8098757  -3.751069   -4.314617   -3.7822733  -3.8979452 ]]
pred_class= [0]
test_x= ['@Test\n    public void remoteEventApiWithLargePayloadKotlinTest() throws IOException, InterruptedException {\n        // create a large payload of 100 KB\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i < 10000; i++) {{\n            sb.append("123456789.");\n        }']
preds_chunk= [[-3.380515   -4.1024237  -3.9108372  -4.0606666  -0.11665516 -3.8038774 ]]
pred_class= [4]
test_x= ['@Test\n    public void remoteEventApiOneWayTest() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        long TIMEOUT = 3000;\n        int NUMBER_THREE = 3;\n        PostOffice po = new PostOffice("unit.test", "12002", "TEST /remote/event/oneway");\n        EventEnvelope event = new EventEnvelope();\n        event.setTo("hello.world").setBody(NUMBER_THREE).setHeader("hello", "world");\n        Map<String, String> securityHeaders = new HashMap<>();\n        securityHeaders.put("Authorization", "demo");\n        Future<EventEnvelope> response = po.asyncRequest(event, TIMEOUT, securityHeaders,\n                "http://127.0.0.1:"+port+"/api/event", false);\n        response.onSuccess(bench::offer);\n        EventEnvelope result = bench.poll(5, TimeUnit.SECONDS);\n        Assert.assertNotNull(result);\n        // status code 202 indicates that a drop-n-forget event has been sent asynchronously\n        Assert.assertEquals(202, result.getStatus());\n        Assert.assertTrue(result.getBody() instanceof Map);\n        Map<String, Object> map = (Map<String, Object>) result.getBody();\n        Assert.assertTrue(map.containsKey("time"));\n        Assert.assertEquals("async", map.get("type"));\n        Assert.assertEquals(true, map.get("delivered"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void remoteEventApiOneWayKotlinTest() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        long TIMEOUT = 3000;\n        int NUMBER_THREE = 3;\n        PostOffice po = new PostOffice("unit.test", "12003", "TEST /remote/event/oneway/k");\n        EventEnvelope event = new EventEnvelope();\n        event.setTo("hello.world").setBody(NUMBER_THREE).setHeader("hello", "world");\n        EventEnvelope forward = new EventEnvelope().setTo("event.api.forwarder")\n                .setBody(event.toBytes()).setHeader("timeout", TIMEOUT).setHeader("rpc", false)\n                .setHeader("endpoint", "http://127.0.0.1:"+port+"/api/event")\n                .setHeader("authorization", "demo");\n        Future<EventEnvelope> response = po.asyncRequest(forward, TIMEOUT);\n        response.onSuccess(bench::offer);\n        EventEnvelope result = bench.poll(5, TimeUnit.SECONDS);\n        Assert.assertNotNull(result);\n        // status code 202 indicates that a drop-n-forget event has been sent asynchronously\n        Assert.assertEquals(202, result.getStatus());\n        Assert.assertTrue(result.getBody() instanceof Map);\n        Map<String, Object> map = (Map<String, Object>) result.getBody();\n        Assert.assertTrue(map.containsKey("time"));\n        Assert.assertEquals("async", map.get("type"));\n        Assert.assertEquals(true, map.get("delivered"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void remoteEventApiKotlinTest() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        long TIMEOUT = 3000;\n        int NUMBER_THREE = 3;\n        PostOffice po = new PostOffice("unit.test", "123", "TEST /remote/event");\n        EventEnvelope event = new EventEnvelope().setTo("hello.world")\n                .setBody(NUMBER_THREE).setHeader("hello", "world");\n        EventEnvelope forward = new EventEnvelope().setTo("event.api.forwarder")\n                .setBody(event.toBytes()).setHeader("timeout", TIMEOUT).setHeader("rpc", true)\n                .setHeader("endpoint", "http://127.0.0.1:"+port+"/api/event")\n                .setHeader("authorization", "demo");\n        Future<EventEnvelope> response = po.asyncRequest(forward, TIMEOUT);\n        response.onSuccess(bench::offer);\n        EventEnvelope result = bench.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n        Assert.assertNotNull(result);\n        Assert.assertEquals(200, result.getStatus());\n        Assert.assertTrue(result.getBody() instanceof Map);\n        MultiLevelMap map = new MultiLevelMap((Map<String, Object>) result.getBody());\n        Assert.assertEquals("world", map.getElement("headers.hello"));\n        Assert.assertEquals(NUMBER_THREE, map.getElement("body"));\n    }\n\n    @Test\n    public void remoteEventApiKotlinAuthTest() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        long TIMEOUT = 3000;\n        int NUMBER_THREE = 3;\n        PostOffice po = new PostOffice("unit.test", "123", "TEST /remote/event");\n        EventEnvelope event = new EventEnvelope().setTo("hello.world")\n                .setBody(NUMBER_THREE).setHeader("hello", "world");\n        EventEnvelope forward = new EventEnvelope().setTo("event.api.forwarder")\n                .setBody(event.toBytes()).setHeader("timeout", TIMEOUT).setHeader("rpc", true)\n                .setHeader("endpoint", "http://127.0.0.1:"+port+"/api/event")\n                .setHeader("authorization", "anyone");\n        Future<EventEnvelope> response = po.asyncRequest(forward, TIMEOUT);\n        response.onSuccess(bench::offer);\n        EventEnvelope result = bench.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n        Assert.assertNotNull(result);\n        Assert.assertEquals(401, result.getStatus());\n        Assert.assertTrue(result.getBody() instanceof String);\n        Assert.assertEquals("Unauthorized", result.getBody());\n    }\n\n    @Test\n    public void remoteEventApiMissingRouteTest() {{\n        String TRACE_ID = "123";\n        long TIMEOUT = 3000;\n        int NUMBER_THREE = 3;\n        Map<String, String> securityHeaders = new HashMap<>();\n        securityHeaders.put("Authorization", "demo");\n        PostOffice po = new PostOffice("unit.test", TRACE_ID, "TEST /remote/event");\n        EventEnvelope event = new EventEnvelope().setBody(NUMBER_THREE).setHeader("hello", "world");\n        IllegalArgumentException ex = Assert.assertThrows(IllegalArgumentException.class, () ->\n                po.asyncRequest(event, TIMEOUT, securityHeaders,\n                        "http://127.0.0.1:"+port+"/api/event", true));\n        Assert.assertEquals("Missing routing path", ex.getMessage());\n    }']
preds_chunk= [[-0.09465672 -3.7060401  -3.9285119  -4.5050325  -3.8988774  -4.2165556 ]]
pred_class= [0]
test_x= ['@Test\n    public void remoteEventApiNullEventTest() {{\n        String TRACE_ID = "123";\n        long TIMEOUT = 3000;\n        Map<String, String> securityHeaders = new HashMap<>();\n        securityHeaders.put("Authorization", "demo");\n        PostOffice po = new PostOffice("unit.test", TRACE_ID, "TEST /remote/event");\n        IllegalArgumentException ex = Assert.assertThrows(IllegalArgumentException.class, () ->\n                po.asyncRequest(null, TIMEOUT, securityHeaders,\n                        "http://127.0.0.1:"+port+"/api/event", true));\n        Assert.assertEquals("Missing outgoing event", ex.getMessage());\n    }']
preds_chunk= [[-3.4031858 -4.049863  -3.783668  -3.9990203 -0.134891  -3.368992 ]]
pred_class= [4]
test_x= ['@Test\n    public void filterName() {{\n        String valid = "hello.world";\n        String invalid = "hello.wor?ld";\n        String dotted = "..."+invalid;\n        String filtered1 = util.filteredServiceName(invalid);\n        Assert.assertEquals(valid, filtered1);\n        String filtered2 = util.filteredServiceName(dotted);\n        Assert.assertEquals(valid, filtered2);\n    }']
preds_chunk= [[-3.3969214  -3.6267881  -3.6301963  -0.15846148 -3.642978   -3.3878505 ]]
pred_class= [3]
test_x= ['@Test\n    public void validName() {{\n        String windowsMetafile = "thumbs.db";\n        String windowsExt = "hello.com";\n        String valid = "com.hello";\n        Assert.assertTrue(util.reservedFilename(windowsMetafile));\n        Assert.assertTrue(util.reservedExtension(windowsExt));\n        Assert.assertFalse(util.reservedExtension(valid));\n    }']
preds_chunk= [[-3.0897315  -3.645718   -3.0005488  -3.0823495  -0.23678151 -3.1325078 ]]
pred_class= [4]
test_x= ['@Test\n    public void testListOfPoJo() throws IOException {\n        int NUMBER_1 = 100;\n        String NAME_1 = "hello world";\n        int NUMBER_2 = 200;\n        String NAME_2 = "it is a nice day";\n        PoJo pojo1 = new PoJo();\n        pojo1.setNumber(NUMBER_1);\n        pojo1.setName(NAME_1);\n        PoJo pojo2 = new PoJo();\n        pojo2.setNumber(NUMBER_2);\n        pojo2.setName(NAME_2);\n        List<PoJo> list = new ArrayList<>();\n        list.add(pojo1);\n        list.add(null);\n        list.add(pojo2);\n        EventEnvelope event = new EventEnvelope();\n        event.setBody(list);\n        byte[] b = event.toBytes();\n        EventEnvelope result = new EventEnvelope();\n        result.load(b);\n        Assert.assertTrue(result.getBody() instanceof List);\n        List<PoJo> pojoList = (List<PoJo>) result.getBody();\n        Assert.assertEquals(3, pojoList.size());\n        PoJo restored1 = pojoList.get(0);\n        Assert.assertEquals(NAME_1, restored1.getName());\n        Assert.assertEquals(NUMBER_1, restored1.getNumber());\n        Assert.assertNull(pojoList.get(1));\n        PoJo restored2 = pojoList.get(2);\n        Assert.assertEquals(NAME_2, restored2.getName());\n        Assert.assertEquals(NUMBER_2, restored2.getNumber());\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void testArrayOfPoJo() throws IOException {\n        int NUMBER_1 = 100;\n        String NAME_1 = "hello world";\n        int NUMBER_2 = 200;\n        String NAME_2 = "it is a nice day";\n        PoJo pojo1 = new PoJo();\n        pojo1.setNumber(NUMBER_1);\n        pojo1.setName(NAME_1);\n        PoJo pojo2 = new PoJo();\n        pojo2.setNumber(NUMBER_2);\n        pojo2.setName(NAME_2);\n        PoJo[] array = new PoJo[3];\n        array[0] = pojo1;\n        array[1] = null;\n        array[2] = pojo2;\n        EventEnvelope event = new EventEnvelope();\n        event.setBody(array);\n        byte[] b = event.toBytes();\n        EventEnvelope result = new EventEnvelope();\n        result.load(b);\n        Assert.assertTrue(result.getBody() instanceof List);\n        List<PoJo> pojoList = (List<PoJo>) result.getBody();\n        Assert.assertEquals(3, pojoList.size());\n        PoJo restored1 = pojoList.get(0);\n        Assert.assertEquals(NAME_1, restored1.getName());\n        Assert.assertEquals(NUMBER_1, restored1.getNumber());\n        Assert.assertNull(pojoList.get(1));\n        PoJo restored2 = pojoList.get(2);\n        Assert.assertEquals(NAME_2, restored2.getName());\n        Assert.assertEquals(NUMBER_2, restored2.getNumber());\n    }\n\n    @Test\n    public void rejectMixedTypes() {{\n        int NUMBER_1 = 100;\n        String NAME_1 = "hello world";\n        int NUMBER_2 = 200;\n        String NAME_2 = "it is a nice day";\n        PoJo pojo1 = new PoJo();\n        pojo1.setNumber(NUMBER_1);\n        pojo1.setName(NAME_1);\n        PoJo pojo2 = new PoJo();\n        pojo2.setNumber(NUMBER_2);\n        pojo2.setName(NAME_2);\n        List<Object> list = new ArrayList<>();\n        list.add(pojo1);\n        list.add(2);\n        list.add(pojo2);\n        EventEnvelope event = new EventEnvelope();\n        IllegalArgumentException ex = Assert.assertThrows(IllegalArgumentException.class, () -> event.setBody(list));\n        Assert.assertEquals("Unable to serialize because it is a list of mixed types", ex.getMessage());\n    }']
preds_chunk= [[-3.4220011  -3.617656   -3.681935   -0.15524347 -3.6869237  -3.3791137 ]]
pred_class= [3]
test_x= ['@Test\n    public void acceptListOfPrimitives() throws IOException {\n        List<Object> list = new ArrayList<>();\n        list.add(true);\n        list.add(null);\n        list.add(2);\n        EventEnvelope event = new EventEnvelope();\n        event.setBody(list);\n        byte[] b = event.toBytes();\n        EventEnvelope result = new EventEnvelope();\n        result.load(b);\n        Assert.assertTrue(result.getBody() instanceof List);\n        Assert.assertEquals(list, result.getBody());\n    }\n\n    @Test\n    public void acceptArrayOfPrimitives() throws IOException {\n        Object[] array = new Object[3];\n        array[0] = true;\n        array[1] = null;\n        array[2] = 2;\n        EventEnvelope event = new EventEnvelope();\n        event.setBody(array);\n        byte[] b = event.toBytes();\n        EventEnvelope result = new EventEnvelope();\n        result.load(b);\n        Assert.assertTrue(result.getBody() instanceof List);\n        Assert.assertEquals(Arrays.asList(array), result.getBody());\n    }\n\n    @Test\n    public void testEmptyList() throws IOException {\n        EventEnvelope event = new EventEnvelope();\n        event.setBody(Collections.emptyList());\n        byte[] b = event.toBytes();\n        EventEnvelope result = new EventEnvelope();\n        result.load(b);\n        Assert.assertEquals(Collections.EMPTY_LIST, result.getBody());\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void correctParametricType() throws IOException {\n        int id = 100;\n        String name = "hello world";\n        ObjectWithGenericType<PoJo> genericObject = new ObjectWithGenericType<>();\n        PoJo pojo = new PoJo();\n        pojo.setName(name);\n        genericObject.setContent(pojo);\n        genericObject.setId(id);\n        EventEnvelope event = new EventEnvelope();\n        event.setBody(genericObject);\n        event.setParametricType(PoJo.class);\n        EventEnvelope result = new EventEnvelope(event.toBytes());\n        Object o = result.getBody();\n        Assert.assertTrue(o instanceof ObjectWithGenericType);\n        ObjectWithGenericType<PoJo> gs = (ObjectWithGenericType<PoJo>) o;\n        Assert.assertEquals(id, gs.getId());\n        PoJo content = gs.getContent();\n        Assert.assertNotNull(content);\n        Assert.assertEquals(name, content.getName());\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void missingTypingInfo() throws IOException {\n        int id = 100;\n        String name = "hello world";\n        ObjectWithGenericType<PoJo> genericObject = new ObjectWithGenericType<>();\n        PoJo pojo = new PoJo();\n        pojo.setName(name);\n        genericObject.setContent(pojo);\n        genericObject.setId(100);\n        EventEnvelope event = new EventEnvelope();\n        event.setBody(genericObject);\n        // "event.setParametricType(PoJo.class)" is intentionally omitted to simulate the exception\n        EventEnvelope result = new EventEnvelope(event.toBytes());\n        Object o = result.getBody();\n        Assert.assertTrue(o instanceof ObjectWithGenericType);\n        ObjectWithGenericType<PoJo> gs = (ObjectWithGenericType<PoJo>) o;\n        // all fields except the ones with generic types can be deserialized correctly\n        Assert.assertEquals(id, gs.getId());\n        /*\n         * Without parametricType defined, the content inside the generic class is undefined\n         * and hashmap with key-values is used instead.\n         *\n         * Therefore, this will throw ClassCastException when you try to map the embedded content as PoJo.\n         */\n        ClassCastException ex = Assert.assertThrows(ClassCastException.class, () -> {\n            PoJo content = gs.getContent();\n            Assert.assertNotNull(content);\n        });\n        Assert.assertTrue(ex.getMessage().contains("cannot be cast to"));\n        // If you know the data structure, you can retrieve key-values using the raw format like this:\n        Assert.assertTrue(event.getRawBody() instanceof Map);\n        Map<String, Object> raw = (Map<String, Object>) event.getRawBody();\n        MultiLevelMap map = new MultiLevelMap(raw);\n        Assert.assertEquals(name, map.getElement("content.name"));\n    }\n\n    @Test\n    @SuppressWarnings("unchecked")\n    public void invalidParametricType() throws IOException {\n        Utility util = Utility.getInstance();\n        int id = 123;\n        String name = "hello world";\n        ObjectWithGenericType<PoJo> genericObject = new ObjectWithGenericType<>();\n        PoJo pojo = new PoJo();\n        pojo.setNumber(id);\n        pojo.setName(name);\n        genericObject.setContent(pojo);\n        genericObject.setId(id);\n        EventEnvelope event = new EventEnvelope();\n        event.setBody(genericObject);\n        event.setParametricType(String.class);  // setting an incorrect type\n        byte[] b = event.toBytes();\n        EventEnvelope result = new EventEnvelope();\n        result.load(b);\n        // When parametricType is incorrect, it will fall back to a map.\n        Object o = result.getBody();\n        Assert.assertTrue(o instanceof Map);\n        MultiLevelMap map = new MultiLevelMap((Map<String, Object>) o);\n        Assert.assertEquals(name, map.getElement("content.name"));\n        // numbers are encoded as string in map\n        Assert.assertEquals(id, util.str2int(map.getElement("id").toString()));\n        Assert.assertEquals(id, util.str2int(map.getElement("content.number").toString()));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void parametricHttpObjectTest() {{\n        int ID = 100;\n        String NAME = "hello world";\n        ObjectWithGenericType<PoJo> genericObject = new ObjectWithGenericType<>();\n        PoJo pojo = new PoJo();\n        pojo.setName(NAME);\n        pojo.setNumber(ID);\n        genericObject.setContent(pojo);\n        genericObject.setId(ID);\n        AsyncHttpRequest request = new AsyncHttpRequest();\n        request.setBody(genericObject);\n        AsyncHttpRequest restored = new AsyncHttpRequest(request.toMap());\n        ObjectWithGenericType<PoJo> o = restored.getBody(ObjectWithGenericType.class, PoJo.class);\n        Assert.assertEquals(NAME, o.getContent().getName());\n        Assert.assertEquals(ID, o.getContent().getNumber());\n        Assert.assertEquals(ID, o.getId());\n    }']
preds_chunk= [[-3.4060318  -3.6088173  -3.6641986  -0.15819998 -3.6396298  -3.37618   ]]
pred_class= [3]
test_x= ['@Test\n    public void asyncHttpRequestModel() {{\n        final String HELLO = "hello";\n        final String WORLD = "world";\n        final String PUT = "PUT";\n        AsyncHttpRequest request = new AsyncHttpRequest();\n        request.setContentLength(HELLO.length());\n        request.setBody(HELLO);\n        request.setHeader(HELLO, WORLD);\n        request.setCookie(HELLO, WORLD);\n        request.setMethod(PUT);\n        request.setFileName("none");\n        request.setPathParameter(HELLO, WORLD);\n        request.setQueryString(HELLO+"="+WORLD);\n        request.setQueryParameter(HELLO, WORLD);\n        request.setRemoteIp("127.0.0.1");\n        request.setSecure(false);\n        request.setStreamRoute("none");\n        request.setSessionInfo(HELLO, WORLD);\n        request.setTrustAllCert(false);\n        request.setTimeoutSeconds(10);\n        request.setTargetHost("http://localhost");\n        request.setUploadTag("file");\n        request.setUrl("/api/hello");\n\n        AsyncHttpRequest restored = new AsyncHttpRequest(request.toMap());\n        Assert.assertEquals(HELLO, restored.getBody());\n        Assert.assertEquals(WORLD, restored.getHeader(HELLO));\n        Assert.assertEquals(WORLD, restored.getCookie(HELLO));\n        Assert.assertEquals(WORLD, restored.getPathParameter(HELLO));\n        Assert.assertEquals(WORLD, restored.getQueryParameter(HELLO));\n        Assert.assertEquals(PUT, restored.getMethod());\n        Assert.assertEquals("none", restored.getFileName());\n        Assert.assertEquals("127.0.0.1", restored.getRemoteIp());\n        Assert.assertFalse(restored.isSecure());\n        Assert.assertEquals("none", restored.getStreamRoute());\n        Assert.assertEquals(WORLD, restored.getSessionInfo(HELLO));\n        Assert.assertFalse(restored.isTrustAllCert());\n        Assert.assertEquals(10, restored.getTimeoutSeconds());\n        Assert.assertEquals("http://localhost", restored.getTargetHost());\n        Assert.assertEquals("file", restored.getUploadTag());\n        Assert.assertEquals("/api/hello", restored.getUrl());\n    }']
preds_chunk= [[-3.2791882  -4.108727   -3.7616773  -3.9795685  -0.12641479 -3.7842948 ]]
pred_class= [4]
test_x= ['@Test\n    @SuppressWarnings("unchecked")\n    public void optionalTransport() throws IOException {\n        String text = "hello world";\n        Optional<Object> hello = Optional.of(text);\n        EventEnvelope event1 = new EventEnvelope();\n        event1.setBody(hello);\n        byte[] b = event1.toBytes();\n        EventEnvelope event2 = new EventEnvelope();\n        event2.load(b);\n        Assert.assertTrue(event2.getBody() instanceof Optional);\n        Optional<Object> value = (Optional<Object>) event2.getBody();\n        Assert.assertTrue(value.isPresent());\n        Assert.assertEquals(text, value.get());\n    }\n\n    @Test\n    public void pojoTransport() throws IOException {\n        String name = "hello";\n        PoJo pojo = new PoJo();\n        pojo.setName(name);\n        EventEnvelope event1 = new EventEnvelope();\n        event1.setBody(pojo);\n        byte[] b = event1.toBytes();\n        EventEnvelope event2 = new EventEnvelope();\n        event2.load(b);\n        Assert.assertEquals(PoJo.class, event2.getBody().getClass());\n    }\n\n    @Test\n    public void rejectUnauthorizedClass() throws IOException {\n        UnauthorizedObj input = new UnauthorizedObj();\n        input.setName("hello world");\n        input.setNumber(12345);\n        EventEnvelope event1 = new EventEnvelope();\n        event1.setBody(input);\n        byte[] b = event1.toBytes();\n        EventEnvelope event2 = new EventEnvelope();\n        event2.load(b);\n        /*\n         * Since the object is not in the safe.data.models list, the data is decoded as a simple HashMap.\n         * Deserialization to the UnauthorizedObj is not performed.\n         */\n        Assert.assertEquals(HashMap.class, event2.getBody().getClass());\n    }\n\n    @Test\n    public void acceptSafeJavaDefaultClasses() {{\n        SimpleMapper.getInstance().getSafeMapper(String.class);\n        SimpleMapper.getInstance().getSafeMapper(byte[].class);\n        SimpleMapper.getInstance().getSafeMapper(Date.class);\n        SimpleMapper.getInstance().getSafeMapper(Integer.class);\n        SimpleMapper.getInstance().getSafeMapper(Map.class);\n        SimpleMapper.getInstance().getSafeMapper(HashMap.class);\n        SimpleMapper.getInstance().getSafeMapper(List.class);\n        SimpleMapper.getInstance().getSafeMapper(ArrayList.class);\n        SimpleMapper.getInstance().getSafeMapper(Number.class);\n    }']
preds_chunk= [[-3.064006   -3.7954624  -3.4764748  -3.4636056  -3.5667908  -0.17393903]]
pred_class= [5]
test_x= ['@Test\n    public void rejectUnsafeClasses() {{\n        String MESSAGE = "Class " + UnauthorizedObj.class.getName() + " not in safe.data.models";\n        IllegalArgumentException ex = Assert.assertThrows(IllegalArgumentException.class,\n                () ->  SimpleMapper.getInstance().getSafeMapper(UnauthorizedObj.class));\n        Assert.assertEquals(MESSAGE, ex.getMessage());\n    }']
preds_chunk= [[-2.7222755 -2.8855796 -2.810054  -0.8983564 -1.0718118 -2.6791022]]
pred_class= [3]
test_x= ['@Test\n    public void peeking() throws IOException {\n        String firstItem = "hello world 1";\n        String secondItem = "hello world 2";\n        ElasticQueue spooler = new ElasticQueue("unit.test");\n        spooler.write(new EventEnvelope().setBody(firstItem).toBytes());\n        spooler.write(new EventEnvelope().setBody(secondItem).toBytes());\n\n        byte[] b = spooler.peek();\n        EventEnvelope first = new EventEnvelope();\n        first.load(b);\n        Assert.assertEquals(firstItem, first.getBody());\n\n        b = spooler.read();\n        EventEnvelope firstAgain = new EventEnvelope();\n        firstAgain.load(b);\n        Assert.assertEquals(firstItem, firstAgain.getBody());\n\n        b = spooler.read();\n        EventEnvelope second = new EventEnvelope();\n        second.load(b);\n        Assert.assertEquals(secondItem, second.getBody());\n        Assert.assertNull(spooler.peek());\n        Assert.assertNull(spooler.read());\n        // elastic queue should be automatically closed when all messages are consumed\n        Assert.assertTrue(spooler.isClosed());\n        // close elastic queue\n        spooler.close();\n    }\n\n    @Test\n    public void normalPayload() throws IOException {\n        readWrite("normal.payload.test", 10);\n    }\n\n    @Test\n    public void largePayload() throws IOException {\n        readWrite("large.payload.test", 90000);\n    }\n\n    private void readWrite(String path, int size) throws IOException {\n        String target = "hello.world";\n        // create input\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i < size; i++) {{\n            sb.append("0123456789");\n        }']
preds_chunk= [[-0.10876931 -3.4082735  -3.9148006  -4.437834   -3.8820047  -4.0404844 ]]
pred_class= [0]
test_x= ['@Test\n    public void cleanupTest() throws IOException {\n        String HELLO_WORLD = "hello world ";\n        try (ElasticQueue spooler = new ElasticQueue("unread.test")) {{\n            for (int i = 0; i < ElasticQueue.MEMORY_BUFFER * 3; i++) {\n                String input = HELLO_WORLD + i;\n                EventEnvelope event = new EventEnvelope();\n                event.setTo("hello.world");\n                event.setBody(input);\n                spooler.write(event.toBytes());\n                if (i < ElasticQueue.MEMORY_BUFFER) {\n                    byte[] b = spooler.read();\n                    Assert.assertNotNull(b);\n                    EventEnvelope data = new EventEnvelope();\n                    data.load(b);\n                    Assert.assertEquals(input, data.getBody());\n                }\n            }\n            Assert.assertFalse(spooler.isClosed());\n        }']
preds_chunk= [[-0.09526186 -3.7281985  -3.961726   -4.4757643  -3.819655   -4.234849  ]]
pred_class= [0]
test_x= ['@Test\n    public void subscriptionTest() throws IOException, InterruptedException {\n        LocalPubSub ps = LocalPubSub.getInstance();\n        ps.createTopic(TEST_TOPIC_ONE);\n        // you can subscribe before you create the subscriber services\n        boolean subscribe1 = ps.subscribe(TEST_TOPIC_ONE, SUBSCRIBER_ONE);\n        boolean subscribe2 =ps.subscribe(TEST_TOPIC_ONE, SUBSCRIBER_TWO);\n        Assert.assertTrue(ps.topicExists(TEST_TOPIC_ONE));\n        Assert.assertTrue(subscribe1);\n        Assert.assertTrue(subscribe2);\n        List<String> members = ps.getSubscribers(TEST_TOPIC_ONE);\n        Assert.assertTrue(members.contains(SUBSCRIBER_ONE));\n        Assert.assertTrue(members.contains(SUBSCRIBER_TWO));\n        List<String> topics = ps.getTopics();\n        Assert.assertTrue(topics.contains(TEST_TOPIC_ONE));\n        // now register the subscribers and send an event to the topic\n        final AtomicInteger counter = new AtomicInteger(0);\n        final BlockingQueue<Boolean> completion = new ArrayBlockingQueue<>(1);\n        final ConcurrentMap<String, Object> result = new ConcurrentHashMap<>();\n        LambdaFunction f = (headers, input, instance) -> {\n            String myRoute = headers.get(MY_ROUTE);\n            result.put(myRoute, input);\n            if (counter.incrementAndGet() == 2) {{\n                completion.offer(true);\n            }']
preds_chunk= [[-0.12607184 -3.108617   -3.8232522  -4.4016805  -3.8617668  -3.9823613 ]]
pred_class= [0]
test_x= ['@Test\n    public void transportTest() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        EventEmitter po = EventEmitter.getInstance();\n        EventEnvelope request = new EventEnvelope().setTo(ROUTE).setBody("demo");\n        po.asyncRequest(request, 5000).onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        Assert.assertEquals(400, response.getStatus());\n        Assert.assertEquals(DEMO, response.getError());\n\n    }\n\n    @Test\n    public void callbackExceptionTest() throws IOException, InterruptedException {\n        Platform platform = Platform.getInstance();\n        platform.registerPrivate(CALLBACK, new MyCallBack(), 1);\n        EventEnvelope request = new EventEnvelope();\n        request.setTo(ROUTE);\n        request.setReplyTo(CALLBACK);\n        request.setBody("ok");\n        EventEmitter po = EventEmitter.getInstance();\n        po.send(request);\n        EventEnvelope result = callbackBench.poll(10, TimeUnit.SECONDS);\n        Assert.assertNotNull(result);\n        Assert.assertNotNull(result.getException());\n        Assert.assertTrue(result.getException() instanceof IllegalArgumentException);\n        Assert.assertEquals(DEMO, result.getException().getMessage());\n    }\n\n    private static class MyCallBack implements TypedLambdaFunction<EventEnvelope, Object> {\n\n        @Override\n        public Object handleEvent(Map<String, String> headers, EventEnvelope body, int instance) {{\n            callbackBench.offer(body);\n            return true;\n        }']
preds_chunk= [[-0.10025641 -3.5776348  -3.923492   -4.502729   -3.8881845  -4.12772   ]]
pred_class= [0]
test_x= ['@Test\n    public void cookieTest() {{\n        EventEnvelope event = new EventEnvelope();\n        event.setHeader(SET_COOKIE, "a=100");\n        event.setHeader(SET_COOKIE, "b=200");\n        // set-cookie is a special case for composite value\n        Assert.assertEquals("a=100|b=200", event.getHeader(SET_COOKIE));\n    }']
preds_chunk= [[-3.6307447  -4.1205225  -3.9835267  -3.999448   -0.11505424 -3.5403163 ]]
pred_class= [4]
test_x= ['@Test\n    public void booleanTest() throws IOException {\n        boolean HELLO = true;\n        EventEnvelope source = new EventEnvelope();\n        source.setBody(HELLO);\n        byte[] b = source.toBytes();\n        EventEnvelope target = new EventEnvelope(b);\n        Assert.assertEquals(true, target.getRawBody());\n        Assert.assertEquals(true, target.getBody());\n    }\n\n    @Test\n    public void integerTest() throws IOException {\n        int VALUE = 100;\n        EventEnvelope source = new EventEnvelope();\n        source.setBody(VALUE);\n        byte[] b = source.toBytes();\n        EventEnvelope target = new EventEnvelope(b);\n        Assert.assertEquals(VALUE, target.getRawBody());\n        Assert.assertEquals(VALUE, target.getBody());\n    }\n\n    @Test\n    public void longTest() throws IOException {\n        Long VALUE = 100L;\n        EventEnvelope source = new EventEnvelope();\n        source.setBody(VALUE);\n        byte[] b = source.toBytes();\n        EventEnvelope target = new EventEnvelope(b);\n        // long will be compressed to integer by MsgPack\n        Assert.assertEquals(VALUE.intValue(), target.getRawBody());\n        Assert.assertEquals(VALUE.intValue(), target.getBody());\n    }\n\n    @Test\n    public void floatTest() throws IOException {\n        float VALUE = 1.23f;\n        EventEnvelope source = new EventEnvelope();\n        source.setBody(VALUE);\n        byte[] b = source.toBytes();\n        EventEnvelope target = new EventEnvelope(b);\n        Assert.assertEquals(VALUE, target.getRawBody());\n        Assert.assertEquals(VALUE, target.getBody());\n    }\n\n    @Test\n    public void doubleTest() throws IOException {\n        double VALUE = 1.23d;\n        EventEnvelope source = new EventEnvelope();\n        source.setBody(VALUE);\n        byte[] b = source.toBytes();\n        EventEnvelope target = new EventEnvelope(b);\n        Assert.assertEquals(VALUE, target.getRawBody());\n        Assert.assertEquals(VALUE, target.getBody());\n    }\n\n    @Test\n    public void bigDecimalTest() throws IOException {\n        String VALUE = "1.23";\n        BigDecimal HELLO = new BigDecimal(VALUE);\n        EventEnvelope source = new EventEnvelope();\n        source.setBody(HELLO);\n        byte[] b = source.toBytes();\n        EventEnvelope target = new EventEnvelope(b);\n        // big decimal is converted to string if it is not encoded in a PoJo\n        Assert.assertEquals(VALUE, target.getRawBody());\n        Assert.assertEquals(VALUE, target.getBody());\n    }\n\n    @Test\n    public void dateTest() throws IOException {\n        Utility util = Utility.getInstance();\n        Date NOW = new Date();\n        EventEnvelope source = new EventEnvelope();\n        source.setBody(NOW);\n        byte[] b = source.toBytes();\n        EventEnvelope target = new EventEnvelope(b);\n        Assert.assertEquals(util.date2str(NOW), target.getRawBody());\n        Assert.assertEquals(util.date2str(NOW), target.getBody());\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void pojoTest() throws IOException {\n        String HELLO = "hello";\n        PoJo pojo = new PoJo();\n        pojo.setName(HELLO);\n        EventEnvelope source = new EventEnvelope();\n        source.setBody(pojo);\n        byte[] b = source.toBytes();\n        EventEnvelope target = new EventEnvelope(b);\n        Assert.assertTrue(target.getRawBody() instanceof Map);\n        Map<String, Object> map = (Map<String, Object>) target.getRawBody();\n        Assert.assertEquals(HELLO, map.get("name"));\n        Assert.assertTrue(target.getBody() instanceof PoJo);\n        PoJo output = (PoJo) target.getBody();\n        Assert.assertEquals(HELLO, output.getName());\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void pojoListTest() throws IOException {\n        String HELLO = "hello";\n        PoJo pojo = new PoJo();\n        pojo.setName(HELLO);\n        List<PoJo> list = Collections.singletonList(pojo);\n        EventEnvelope source = new EventEnvelope();\n        source.setBody(list);\n        byte[] b = source.toBytes();\n        EventEnvelope target = new EventEnvelope(b);\n        // raw body is encoded as a map containing a list of map\n        // e.g. {list=[{number=0, long_number=0, name=hello}]}\n        Assert.assertTrue(target.getRawBody() instanceof Map);\n        Map<String, Object> map = (Map<String, Object>) target.getRawBody();\n        MultiLevelMap multi = new MultiLevelMap(map);\n        Assert.assertEquals(HELLO, multi.getElement("list[0].name"));\n        Assert.assertTrue(target.getBody() instanceof List);\n        List<PoJo> output = (List<PoJo>) target.getBody();\n        Assert.assertEquals(1, output.size());\n        Assert.assertEquals(HELLO, output.get(0).getName());\n    }\n\n    @Test\n    public void taggingTest() {{\n        final String HELLO = "hello";\n        final String WORLD = "world";\n        final String ROUTING = "routing";\n        final String DATA = "a->b";\n        final String TAG_WITH_NO_VALUE = "tag-with-no-value";\n        EventEnvelope event = new EventEnvelope();\n        event.addTag(TAG_WITH_NO_VALUE).addTag(HELLO, WORLD).addTag(ROUTING, DATA);\n        // When a tag is created with no value, the system will set a "*" as a filler.\n        Assert.assertEquals("*", event.getTag(TAG_WITH_NO_VALUE));\n        Assert.assertEquals(WORLD, event.getTag(HELLO));\n        Assert.assertEquals(DATA, event.getTag(ROUTING));\n        event.removeTag(HELLO).removeTag(ROUTING);\n        Assert.assertNull(event.getTag(HELLO));\n        Assert.assertNull(event.getTag(ROUTING));\n        Assert.assertEquals(TAG_WITH_NO_VALUE+"=*", event.getExtra());\n        event.removeTag(TAG_WITH_NO_VALUE);\n        Assert.assertNull(event.getExtra());\n    }']
preds_chunk= [[-2.9673705 -3.3094115 -3.203752  -0.2562137 -2.9527915 -3.095685 ]]
pred_class= [3]
test_x= ['@Test\n    public void fluentTest() throws IOException {\n        EventEnvelope event = new EventEnvelope().setRoundTrip(1.1236f).setEndOfRoute().setBinary(true)\n                // the second one will replace the value set by the first one\n                .setParametricType("com.accenture.SomePoJo").setParametricType(PoJo.class);\n        byte[] b = event.toBytes();\n        EventEnvelope restored = new EventEnvelope(b);\n        Assert.assertEquals(PoJo.class.getName(), restored.getParametricType());\n        // verify that the system will save up to 3 decimal points\n        Assert.assertEquals(1.124f, restored.getRoundTrip(), 0);\n    }\n\n    @Test\n    public void mapSerializationTest() {{\n        String HELLO = "hello";\n        PoJo pojo = new PoJo();\n        pojo.setName(HELLO);\n        pojo.setNumber(10);\n        EventEnvelope source = new EventEnvelope();\n        source.setBody(pojo);\n        source.setFrom("unit.test");\n        source.setTo("hello.world");\n        source.setReplyTo("my.callback");\n        source.setTrace("101", "PUT /api/unit/test");\n        // use JSON instead of binary serialization\n        source.setBinary(false);\n        source.setException(new IllegalArgumentException("hello"));\n        source.setBroadcastLevel(1);\n        source.setCorrelationId("121");\n        source.setExtra("x=y");\n        source.setEndOfRoute();\n        source.setHeader("a", "b");\n        source.setStatus(400);\n        source.setExecutionTime(1.23f);\n        source.setRoundTrip(2.0f);\n        EventEnvelope target = new EventEnvelope(source.toMap());\n        MultiLevelMap map = new MultiLevelMap(target.toMap());\n        Assert.assertEquals(HELLO, map.getElement("body.name"));\n        Assert.assertEquals(10, map.getElement("body.number"));\n        Assert.assertEquals(0, map.getElement("body.long_number"));\n        Assert.assertEquals("y", target.getTag("x"));\n        Assert.assertEquals(1.23f, target.getExecutionTime(), 0f);\n        Assert.assertEquals(2.0f, target.getRoundTrip(), 0f);\n        Assert.assertEquals("121", target.getCorrelationId());\n        Assert.assertEquals(400, target.getStatus());\n        Assert.assertEquals(1, target.getBroadcastLevel());\n        Assert.assertEquals(source.getId(), target.getId());\n        Assert.assertEquals(source.getFrom(), target.getFrom());\n        Assert.assertEquals(source.getReplyTo(), target.getReplyTo());\n        Assert.assertEquals("101", target.getTraceId());\n        Assert.assertEquals("PUT /api/unit/test", target.getTracePath());\n        Assert.assertEquals("b", map.getElement("headers.a"));\n        Assert.assertEquals(true, map.getElement("json"));\n        Assert.assertTrue(target.getBody() instanceof PoJo);\n        PoJo output = (PoJo) target.getBody();\n        Assert.assertEquals(HELLO, output.getName());\n        Assert.assertEquals(HELLO, target.getException().getMessage());\n        Assert.assertEquals(IllegalArgumentException.class, target.getException().getClass());\n        Assert.assertTrue(map.getElement("exception") instanceof byte[]);\n        byte[] b = (byte[]) map.getElement("exception");\n        log.info("Stacktrace binary payload size for {} = {}", IllegalArgumentException.class.getName(), b.length);\n    }']
preds_chunk= [[-3.3760276  -3.5928085  -3.6511135  -0.16168408 -3.5671546  -3.3995602 ]]
pred_class= [3]
test_x= ['@Test\n    public void optionalTransportTest() {{\n        EventEnvelope source = new EventEnvelope();\n        source.setBody(Optional.of("hello"));\n        EventEnvelope target = new EventEnvelope(source.toMap());\n        Assert.assertEquals(Optional.of("hello"), target.getBody());\n    }']
preds_chunk= [[-3.4739633  -4.036054   -3.7811747  -3.8045294  -0.12743475 -3.6526399 ]]
pred_class= [4]
test_x= ['@Test\n    public void aesEncryptionTest() throws IOException, GeneralSecurityException {\n        String input = "hello world";\n        byte[] key = crypto.generateAesKey(strongCrypto? 256 : 128);\n        byte[] encrypted = crypto.aesEncrypt(input.getBytes(), key);\n        byte[] decrypted = crypto.aesDecrypt(encrypted, key);\n        Assert.assertEquals(input, new String(decrypted));\n        // streaming methods\n        ByteArrayInputStream clearIn = new ByteArrayInputStream(input.getBytes());\n        ByteArrayOutputStream encryptedOut = new ByteArrayOutputStream();\n        crypto.aesEncrypt(clearIn, encryptedOut, key);\n        encrypted = encryptedOut.toByteArray();\n        ByteArrayInputStream encryptedIn = new ByteArrayInputStream(encrypted);\n        ByteArrayOutputStream clearOut = new ByteArrayOutputStream();\n        crypto.aesDecrypt(encryptedIn, clearOut, key);\n        decrypted = clearOut.toByteArray();\n        Assert.assertEquals(input, new String(decrypted));\n    }\n\n    @Test\n    public void rsaEncryptionTest() throws GeneralSecurityException {\n        // RSA encryption is usually used to transport symmetric encryption key\n        byte[] input = crypto.generateAesKey(256);\n        KeyPair kp = crypto.generateRsaKey();\n        byte[] pub = kp.getPublic().getEncoded();\n        byte[] pri = kp.getPrivate().getEncoded();\n        // encrypt\n        byte[] encrypted = crypto.rsaEncrypt(input, pub);\n        // decrypt\n        byte[] decrypted = crypto.rsaDecrypt(encrypted, pri);\n        // do a byte-by-byte comparison\n        Assert.assertArrayEquals(input, decrypted);\n    }\n\n    @Test\n    public void invalidRsaKeyLength() {{\n        IllegalArgumentException ex = Assert.assertThrows(IllegalArgumentException.class,\n                                            () -> crypto.generateRsaKey(1000));\n        Assert.assertEquals("Key size must be one of [1024, 2048, 3072, 4096]", ex.getMessage());\n    }']
preds_chunk= [[-0.24477041 -2.2710004  -3.4420538  -3.9420853  -3.5635633  -3.3766232 ]]
pred_class= [0]
test_x= ['@Test\n    public void pemReadWriteTest() {{\n        KeyPair kp = crypto.generateRsaKey();\n        byte[] pub = kp.getPublic().getEncoded();\n        String pem = crypto.writePem(pub, "PUBLIC KEY");\n        byte[] restored = crypto.readPem(pem);\n        String pemRestored = crypto.writePem(restored, "PUBLIC KEY");\n        Assert.assertEquals(pem, pemRestored);\n    }']
preds_chunk= [[-0.12061039 -3.6176016  -3.7414453  -4.2658453  -3.4722877  -4.019164  ]]
pred_class= [0]
test_x= ['@Test\n    public void randomIntegerTest() {{\n        int n1 = crypto.nextInt(10000);\n        int n2 = crypto.nextInt(10000);\n        Assert.assertNotEquals(n1, n2);\n    }']
preds_chunk= [[-3.3371782  -3.5704896  -3.5102854  -0.17563389 -3.4582279  -3.323631  ]]
pred_class= [3]
test_x= ['@Test\n    public void publicPrivateKeyEncodingTest() throws GeneralSecurityException {\n        KeyPair kp = crypto.generateRsaKey();\n        byte[] pub = kp.getPublic().getEncoded();\n        byte[] pri = kp.getPrivate().getEncoded();\n        PublicKey publicKey = crypto.getPublic(pub);\n        PrivateKey privateKey = crypto.getPrivate(pri);\n        Assert.assertArrayEquals(pub, publicKey.getEncoded());\n        Assert.assertArrayEquals(pri, privateKey.getEncoded());\n        byte[] pubAgain = crypto.getEncodedPublicKey(kp);\n        byte[] priAgain = crypto.getEncodedPrivateKey(kp);\n        Assert.assertArrayEquals(pubAgain, publicKey.getEncoded());\n        Assert.assertArrayEquals(priAgain, privateKey.getEncoded());\n    }\n\n    @Test\n    public void dsaSignatureTest() throws GeneralSecurityException {\n        KeyPair kp = crypto.generateDsaKey();\n        byte[] pub = kp.getPublic().getEncoded();\n        byte[] pri = kp.getPrivate().getEncoded();\n        byte[] data = "hello world".getBytes();\n        byte[] signature = crypto.dsaSign(data, pri);\n        boolean result = crypto.dsaVerify(data, signature, pub);\n        Assert.assertTrue(result);\n    }\n\n    @Test\n    public void rsaSignatureTest() throws GeneralSecurityException {\n        KeyPair kp = crypto.generateRsaKey();\n        byte[] pub = kp.getPublic().getEncoded();\n        byte[] pri = kp.getPrivate().getEncoded();\n        byte[] data = "hello world".getBytes();\n        byte[] signature = crypto.rsaSign(data, pri);\n        boolean result = crypto.rsaVerify(data, signature, pub);\n        Assert.assertTrue(result);\n    }\n\n    @Test\n    public void hashTest() throws IOException {\n        String input = "hello world";\n        byte[] hashed = crypto.getSHA256(input.getBytes());\n        Assert.assertEquals(32, hashed.length);\n        byte[] hashedFromStream = crypto.getSHA256(new ByteArrayInputStream(input.getBytes()));\n        Assert.assertArrayEquals(hashed, hashedFromStream);\n        hashed = crypto.getSHA1(input.getBytes());\n        Assert.assertEquals(20, hashed.length);\n        hashedFromStream = crypto.getSHA1(new ByteArrayInputStream(input.getBytes()));\n        Assert.assertArrayEquals(hashed, hashedFromStream);\n        hashed = crypto.getMd5(input.getBytes());\n        Assert.assertEquals(16, hashed.length);\n        hashedFromStream = crypto.getMd5(new ByteArrayInputStream(input.getBytes()));\n        Assert.assertArrayEquals(hashed, hashedFromStream);\n    }\n\n    @Test\n    public void hmac1Test() {{\n        String expected = "8a3a84bcd0d0065e97f175d370447c7d02e00973";\n        byte[] key = "hello".getBytes();\n        byte[] message = "world".getBytes();\n        byte[] b = crypto.getHmacSha1(key, message);\n        Assert.assertEquals(expected, Utility.getInstance().bytes2hex(b));\n    }']
preds_chunk= [[-3.6089447  -3.9097574  -3.6110706  -3.664752   -3.806638   -0.13008815]]
pred_class= [5]
test_x= ['@Test\n    public void hmac256Test() {{\n        String expected = "f1ac9702eb5faf23ca291a4dc46deddeee2a78ccdaf0a412bed7714cfffb1cc4";\n        byte[] key = "hello".getBytes();\n        byte[] message = "world".getBytes();\n        byte[] b = crypto.getHmacSha256(key, message);\n        Assert.assertEquals(expected, Utility.getInstance().bytes2hex(b));\n    }']
preds_chunk= [[-3.3946412  -3.612005   -3.5982726  -0.16128871 -3.6144063  -3.3784711 ]]
pred_class= [3]
test_x= ['@Test\n    public void routingTest() throws IOException, InterruptedException {\n        final EventEmitter po = EventEmitter.getInstance();\n        final String[] targets = {"v1.hello.service.1", "v1.hello.service.2"};\n        final String TEXT = "ok";\n        final AtomicInteger counter = new AtomicInteger(0);\n        final BlockingQueue<Boolean> completion = new ArrayBlockingQueue<>(1);\n        final ConcurrentMap<String, Object> result = new ConcurrentHashMap<>();\n        LambdaFunction f = (headers, input, instance) -> {\n            String myRoute = headers.get(MY_ROUTE);\n            result.put(myRoute, input);\n            if (counter.incrementAndGet() == 2) {{\n                completion.offer(true);\n            }']
preds_chunk= [[-2.5603154  -0.23626651 -3.201744   -3.5508728  -3.9022064  -3.133583  ]]
pred_class= [1]
test_x= ['@Test\n    public void conversionTest() {{\n        Utility util = Utility.getInstance();\n        Date now = new Date();\n        String timestampWithoutMilli = util.date2str(now, true);\n        Date normalizedTime = util.str2date(timestampWithoutMilli);\n        String timestamp = util.getHtmlDate(normalizedTime);\n        Date converted = util.getHtmlDate(timestamp);\n        Assert.assertEquals(normalizedTime, converted);\n    }']
preds_chunk= [[-3.2756574  -3.613447   -0.14063105 -3.7739618  -4.232215   -3.5418966 ]]
pred_class= [2]
test_x= ['@Test\n    public void environmentVarSubstitution() throws IOException {\n        ConfigReader reader = new ConfigReader();\n        reader.load("classpath:/test.properties");\n        String path = System.getenv("PATH");\n        Assert.assertEquals(path, reader.getProperty("hello.world"));\n    }\n\n    @Test\n    public void systemPropertySubstitution() throws IOException {\n        final String HELLO = "HELLO";\n        System.setProperty("sample.system.property", HELLO);\n        ConfigReader reader = new ConfigReader();\n        reader.load("classpath:/test.properties");\n        Assert.assertEquals(HELLO, reader.getProperty("my.system.property"));\n    }\n\n    @Test\n    public void systemPropertyIsAlwaysAvailable() {{\n        final String NON_EXIST_PROPERTY = "parameter.not.found.in.application.properties";\n        final String HELLO = "HELLO";\n        System.setProperty(NON_EXIST_PROPERTY, HELLO);\n        AppConfigReader config = AppConfigReader.getInstance();\n        Assert.assertEquals(HELLO, config.getProperty(NON_EXIST_PROPERTY));\n    }']
preds_chunk= [[-3.3903792  -4.1563854  -3.9530149  -4.049887   -0.11549223 -3.7682967 ]]
pred_class= [4]
test_x= ['@Test\n    public void getValueFromParent() throws IOException {\n        AppConfigReader parent = AppConfigReader.getInstance();\n        String parentValue = parent.getProperty("cloud.connector");\n        ConfigReader reader = new ConfigReader();\n        reader.load("classpath:/test.properties");\n        String subordinateValue = reader.getProperty("my.cloud.connector");\n        Assert.assertEquals(parentValue, subordinateValue);\n    }\n\n    @Test\n    public void getDefaultValue() throws IOException {\n        ConfigReader reader = new ConfigReader();\n        reader.load("classpath:/test.properties");\n        String value = reader.getProperty("another.key");\n        Assert.assertEquals("12345", value);\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void dotFormatterTest() throws IOException {\n        ConfigReader reader = new ConfigReader();\n        reader.load("classpath:/test.yaml");\n        Object o = reader.get("hello.world");\n        Assert.assertEquals("some value", o);\n        o = reader.get("hello.multiline");\n        Assert.assertTrue(o instanceof String);\n        Assert.assertTrue(o.toString().contains("\\n"));\n        List<String> lines = Utility.getInstance().split(o.toString(), "\\n");\n        Assert.assertEquals(2, lines.size());\n        Assert.assertEquals("line one", lines.get(0));\n        Assert.assertEquals("line two", lines.get(1));\n        o = reader.get("hello.array");\n        Assert.assertTrue(o instanceof ArrayList);\n        List<String> elements = (List<String>) o;\n        Assert.assertEquals(2, elements.size());\n        Assert.assertEquals("hi", elements.get(0));\n        Assert.assertEquals("this is great", elements.get(1));\n        o = reader.get("hello.array[0]");\n        Assert.assertEquals("hi", o);\n        o = reader.get("hello.array[1]");\n        Assert.assertEquals("this is great", o);\n    }\n\n    @Test\n    public void flattenMapTest() throws IOException {\n        ConfigReader reader = new ConfigReader();\n        reader.load("classpath:/test.yml");\n        Map<String, Object> map = Utility.getInstance().getFlatMap(reader.getMap());\n        Assert.assertEquals("some value", map.get("hello.world"));\n        Assert.assertEquals("hi", map.get("hello.array[0]"));\n        Assert.assertEquals("this is great", map.get("hello.array[1]"));\n        /*\n         * Unlike properties file that converts values into strings,\n         * YAML and JSON preserve original objects.\n         */\n        Object o = map.get("hello.number");\n        Assert.assertTrue(o instanceof Integer);\n        Assert.assertEquals(12345, o);\n    }\n\n    @Test\n    public void appConfigTest() {{\n        // AppConfigReader will combine both application.properties and application.yml\n        AppConfigReader reader = AppConfigReader.getInstance();\n        // application.name is stored in "application.properties"\n        Assert.assertEquals("platform-core", reader.getProperty("application.name"));\n        // hello.world is stored in "application.yml"\n        Assert.assertEquals("great", reader.get("hello.world"));\n    }']
preds_chunk= [[-3.0199916  -3.3213713  -3.3430748  -0.27483293 -2.6991687  -2.9411216 ]]
pred_class= [3]
test_x= ['@Test\n    public void parameterSubstitutionTest() throws IOException {\n        ConfigReader reader = new ConfigReader();\n        reader.load("classpath:/test.yaml");\n        Assert.assertEquals("platform-core", reader.getProperty("hello.name"));\n        AppConfigReader config = AppConfigReader.getInstance();\n        Assert.assertEquals("8100", reader.getProperty("hello.location[0]"));\n        Assert.assertEquals("http://127.0.0.1:"+config.getProperty("server.port")+"/info",\n                                reader.getProperty("hello.location[1]"));\n        Assert.assertEquals(100, reader.get("hello.location[2].world.blvd"));\n        Assert.assertEquals(config.getProperty("server.port")+" is server port",\n                                reader.getProperty("hello.location[3]"));\n        Assert.assertEquals("Server port is "+config.getProperty("server.port"),\n                                reader.getProperty("hello.location[4]"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void dotFormatterSetTest() throws IOException {\n        // generate random top level key\n        String uuid = UUID.randomUUID().toString().replace("-", "");\n        String goodDay = uuid+".great.day";\n        String goodArray = uuid+".array";\n        String message = "test message";\n        Integer input = 123456789;\n        ConfigReader reader = new ConfigReader();\n        reader.load("classpath:/test.yaml");\n        int size = reader.getMap().size();\n        MultiLevelMap formatter = new MultiLevelMap(reader.getMap());\n        formatter.setElement(goodDay, input).setElement(goodArray+"[1]", message);\n        Object o = formatter.getElement(goodDay);\n        Assert.assertEquals(input, o);\n        // confirm added only one key at the top level\n        Assert.assertEquals(size+1, formatter.getMap().size());\n        Assert.assertNull(formatter.getElement(goodArray+"[0]"));\n        Assert.assertEquals(message, formatter.getElement(goodArray+"[1]"));\n        o = formatter.getElement(uuid);\n        Assert.assertTrue(o instanceof Map);\n        Map<String, Object> submap = (Map<String, Object>) o;\n        Assert.assertEquals(2, submap.size());\n        Assert.assertTrue(submap.containsKey("great"));\n        Assert.assertTrue(submap.containsKey("array"));\n    }\n\n    @Test\n    public void resourceNotFound() {{\n        IOException ex = Assert.assertThrows(IOException.class, () -> {\n            ConfigReader reader = new ConfigReader();\n            reader.load("classpath:/notfound.yaml");\n        });\n        Assert.assertEquals("classpath:/notfound.yaml not found", ex.getMessage());\n    }']
preds_chunk= [[-2.807291  -3.7032287 -3.3999684 -3.329036  -0.2791693 -2.4149246]]
pred_class= [4]
test_x= ['@Test\n    public void fileNotFound() {{\n        IOException ex = Assert.assertThrows(IOException.class, () -> {\n            ConfigReader reader = new ConfigReader();\n            reader.load("file:/notfound.yaml");\n        });\n        Assert.assertEquals("file:/notfound.yaml not found", ex.getMessage());\n    }']
preds_chunk= [[-3.5687454  -4.0085382  -3.8105063  -3.7531877  -0.12561344 -3.6453123 ]]
pred_class= [4]
test_x= ['@Test\n    public void jsonReadTest() throws IOException {\n        ConfigReader reader = new ConfigReader();\n        reader.load("classpath:/test.json");\n        Assert.assertEquals(2, reader.getMap().size());\n        Assert.assertEquals("world", reader.get("hello"));\n        Assert.assertEquals("message", reader.get("test"));\n    }\n\n    @Test\n    public void getPropertyFromEnv() {{\n        AppConfigReader config = AppConfigReader.getInstance();\n        String value = config.getProperty("system.path");\n        String path = System.getenv("PATH");\n        Assert.assertEquals(path, value);\n    }']
preds_chunk= [[-2.6909204 -2.9230373 -2.879203  -0.8065278 -1.1814458 -2.673769 ]]
pred_class= [3]
test_x= ['@Test\n    public void getPropertyFromEnvFromAnotherConfig() throws IOException {\n        ConfigReader reader = new ConfigReader();\n        reader.load("classpath:/test.yaml");\n        Object value = reader.get("hello.path");\n        String path = System.getenv("PATH");\n        Assert.assertEquals(path, value);\n    }\n\n    @Test\n    public void singleLevelLoopErrorTest() throws IOException {\n        ConfigReader reader = new ConfigReader();\n        reader.load("classpath:/test.properties");\n        String value = reader.getProperty("recursive.key");\n        // In case of config loop, the system will not resolve a parameter value.\n        Assert.assertNull(value);\n    }\n\n    @Test\n    public void multiLevelLoopErrorTest() {{\n        AppConfigReader config = AppConfigReader.getInstance();\n        Object value = config.get("looping.test.1");\n        Assert.assertEquals("1000", value);\n    }']
preds_chunk= [[-3.4793673 -4.166909  -3.9577734 -4.0316424 -0.1119967 -3.7820928]]
pred_class= [4]
test_x= ['@Test\n    public void defaultValueTest() throws IOException {\n        ConfigReader reader = new ConfigReader();\n        reader.load("classpath:/test.yaml");\n        String value = reader.getProperty("test.no.value", "hello world");\n        Assert.assertEquals("hello world", value);\n    }\n    @Test\n    public void defaultValueInRefTest() throws IOException {\n        ConfigReader reader = new ConfigReader();\n        reader.load("classpath:/test.yaml");\n        String value = reader.getProperty("test.default");\n        Assert.assertEquals("hello 1000", value);\n    }\n\n    @Test\n    public void noDefaultValueInRefTest() throws IOException {\n        ConfigReader reader = new ConfigReader();\n        reader.load("classpath:/test.yaml");\n        String value = reader.getProperty("test.no_default");\n        // when there is no default value in the reference, it will return empty string as the default value.\n        Assert.assertEquals("hello world", value);\n    }\n\n    @Test\n    public void activeProfileTest() {{\n        AppConfigReader config = AppConfigReader.getInstance();\n        String testPara = config.getProperty("test.parameter");\n        Object testYaml = config.get("test.yaml");\n        assertEquals("hello world", testPara);\n        assertEquals(100, testYaml);\n    }']
preds_chunk= [[-2.7196834  -2.9272852  -2.874854   -0.93928295 -1.0436983  -2.5123198 ]]
pred_class= [3]
test_x= ['@Test\n    public void setServerPersonality() {{\n        ServerPersonality personality = ServerPersonality.getInstance();\n        String MESSAGE = "Personality cannot be null";\n        IllegalArgumentException ex = Assert.assertThrows(IllegalArgumentException.class,\n                                                () -> personality.setType(null));\n        Assert.assertEquals(MESSAGE, ex.getMessage());\n    }']
preds_chunk= [[-2.913217   -3.118596   -3.1527553  -0.38445747 -2.1489081  -2.7917395 ]]
pred_class= [3]
test_x= ['@Test\n    public void mockPubSub() throws IOException {\n        PubSub ps = PubSub.getInstance();\n        ps.enableFeature(new MockPubSub());\n        ps.createTopic(HELLO_WORLD);\n        Assert.assertTrue(ps.exists(HELLO_WORLD));\n        ps.deleteTopic(HELLO_WORLD);\n        Assert.assertFalse(ps.exists(HELLO_WORLD));\n        ps.createTopic(HELLO_WORLD, 10);\n        Assert.assertTrue(ps.exists(HELLO_WORLD));\n        Assert.assertTrue(ps.isStreamingPubSub());\n        Assert.assertEquals(10, ps.partitionCount(HELLO_WORLD));\n        Assert.assertTrue(ps.list().contains(HELLO_WORLD));\n        LambdaFunction f = (headers, input, instance) -> true;\n        ps.subscribe(HELLO_WORLD, f, "client100", "group100");\n        ps.subscribe(HELLO_WORLD, 0, f, "client100", "group100");\n        ps.publish(HELLO_WORLD, new HashMap<>(), "hello");\n        ps.publish(HELLO_WORLD, 1, new HashMap<>(), "hello");\n        ps.unsubscribe(HELLO_WORLD);\n        ps.unsubscribe(HELLO_WORLD, 1);\n        ps.cleanup();\n    }\n\n    @Test\n    public void mockPubSubCreateQueue() {{\n        PubSub ps = PubSub.getInstance();\n        ps.enableFeature(new MockPubSub());\n        String MESSAGE = "Not implemented";\n        IllegalArgumentException ex = Assert.assertThrows(IllegalArgumentException.class,\n                                            () -> ps.createQueue("demo.queue"));\n        Assert.assertEquals(MESSAGE, ex.getMessage());\n    }']
preds_chunk= [[-0.10237457 -3.6267679  -3.9115844  -4.450977   -3.8513575  -4.0296936 ]]
pred_class= [0]
test_x= ['@Test\n    public void mockPubSubDeleteQueue() throws IOException {\n        PubSub ps = PubSub.getInstance();\n        ps.enableFeature(new MockPubSub());\n        IllegalArgumentException ex = Assert.assertThrows(IllegalArgumentException.class,\n                () -> ps.deleteQueue("demo.queue"));\n        Assert.assertEquals("Not implemented", ex.getMessage());\n    }\n\n    @Test\n    public void timestampTest() {{\n        Utility util = Utility.getInstance();\n        String EXACT_SECOND = ".000";\n        Date now = new Date();\n        String t = util.getTimestamp();\n        Assert.assertTrue(util.isDigits(t));\n        String ts = util.getTimestamp(now.getTime());\n        long time = util.timestamp2ms(ts);\n        Assert.assertEquals(now.getTime(), time);\n        String awsTime = util.getAmazonDate(now);\n        Assert.assertTrue(awsTime.contains("T") && awsTime.endsWith("Z"));\n        String awsNumber = awsTime.replace("T", "").replace("Z", "");\n        Assert.assertTrue(util.isDigits(awsNumber));\n        String iso = util.date2str(now);\n        java.sql.Date sql = new java.sql.Date(now.getTime());\n        String sqlDate = util.getSqlDate(sql);\n        Assert.assertEquals(iso.substring(0, iso.indexOf(\'T\')), sqlDate);\n        java.sql.Timestamp sqlTs = new java.sql.Timestamp(now.getTime());\n        String sqlTime = util.getSqlTimestamp(sqlTs);\n        if (sqlTime.endsWith(EXACT_SECOND)) {\n            sqlTime = sqlTime.substring(0, sqlTime.length() - EXACT_SECOND.length());\n        }\n        Assert.assertEquals(iso.replace("T", " ").replace("Z", ""), sqlTime);\n    }']
preds_chunk= [[-3.1369054  -3.6105454  -0.14466524 -3.9232554  -4.2283597  -3.5105286 ]]
pred_class= [2]
test_x= ['@Test\n    public void exactSecondTimestampTest() {{\n        Utility util = Utility.getInstance();\n        String EXACT_SECOND = ".000";\n        String exact = util.date2str(new Date(), true);\n        Date now = util.str2date(exact);\n        String iso = util.date2str(now);\n        java.sql.Timestamp sqlTs = new java.sql.Timestamp(now.getTime());\n        String sqlTime = util.getSqlTimestamp(sqlTs);\n        Assert.assertTrue(sqlTime.endsWith(EXACT_SECOND));\n        sqlTime = sqlTime.substring(0, sqlTime.length() - EXACT_SECOND.length());\n        Assert.assertEquals(iso.replace("T", " ").replace("Z", ""), sqlTime);\n    }']
preds_chunk= [[-2.971922   -3.3327417  -0.20863238 -3.0644207  -3.9420931  -3.3433585 ]]
pred_class= [2]
test_x= ['@Test\n    public void base64Test() {{\n        Utility util = Utility.getInstance();\n        String text = "hello world & good day";\n        String b64 = util.bytesToBase64(util.getUTF(text));\n        byte[] bytes = util.base64ToBytes(b64);\n        Assert.assertEquals(text, util.getUTF(bytes));\n        b64 = util.bytesToUrlBase64(util.getUTF(text));\n        bytes = util.urlBase64ToBytes(b64);\n        Assert.assertEquals(text, util.getUTF(bytes));\n    }']
preds_chunk= [[-3.3120692  -3.5505915  -3.5143337  -0.18153828 -3.3615797  -3.3127103 ]]
pred_class= [3]
test_x= ['@Test\n    public void dateConversion() {{\n        Utility util = Utility.getInstance();\n        Date now = new Date();\n        String s = util.date2str(now);\n        Date restored = util.str2date(s);\n        Assert.assertEquals(now, restored);\n    }']
preds_chunk= [[-3.3023791  -3.6541045  -0.13101862 -3.884176   -4.2515745  -3.676486  ]]
pred_class= [2]
test_x= ['@Test\n    public void ioTest() {{\n        Utility util = Utility.getInstance();\n        File temp = new File("/tmp");\n        File tempFile = new File(temp, "dummy");\n        try {\n            String HELLO_WORLD = "hello world";\n            util.str2file(tempFile, HELLO_WORLD);\n            String restored = util.file2str(tempFile);\n            Assert.assertEquals(HELLO_WORLD, restored);\n        } finally {\n            tempFile.delete();\n        }\n    }']
preds_chunk= [[-3.53781    -3.9523447  -3.749504   -3.6940243  -0.13269454 -3.5906713 ]]
pred_class= [4]
test_x= ['@Test\n    public void splitTest() {{\n        Utility util = Utility.getInstance();\n        String TEST = "hello world this is | a |      test";\n        List<String> parts = util.split(TEST, " |");\n        for (String p: parts) {\n            Assert.assertTrue(TEST.contains(p));\n        }\n    }']
preds_chunk= [[-2.9521277  -3.1698084  -3.1608171  -0.34819534 -2.2905493  -2.8788936 ]]
pred_class= [3]
test_x= ['@Test\n    public void numberConversionTest() {{\n        Utility util = Utility.getInstance();\n        // test integer value\n        int n1 = 12345;\n        String s1 = String.valueOf(n1);\n        byte[] b1 = util.int2bytes(n1);\n        Assert.assertEquals(4, b1.length);\n        int restored1 = util.bytes2int(b1);\n        Assert.assertEquals(n1, restored1);\n        int r1 = util.str2int(s1);\n        Assert.assertEquals(n1, r1);\n        // test long value\n        long n2 = 1000000000L;\n        String s2 = String.valueOf(n2);\n        byte[] b2 = util.long2bytes(n2);\n        Assert.assertEquals(8, b2.length);\n        long restored2 = util.bytes2long(b2);\n        Assert.assertEquals(n2, restored2);\n        long r2 = util.str2long(s2);\n        Assert.assertEquals(n2, r2);\n        // test float value\n        float n3 = 12345.20f;\n        String s3 = String.valueOf(n3);\n        float c3 = util.str2float(s3);\n        Assert.assertEquals(n3, c3, 0);\n        // test double value\n        double n4 = 12345.20123456789d;\n        String s4 = String.valueOf(n4);\n        double c4 = util.str2double(s4);\n        Assert.assertEquals(n4, c4, 0);\n    }']
preds_chunk= [[-3.35653    -3.579407   -3.478904   -0.16732131 -3.6466238  -3.3695874 ]]
pred_class= [3]
test_x= ['@Test\n    public void numberTest() {{\n        Utility util = Utility.getInstance();\n        // digits\n        String CORRECT_DIGITS = "12345";\n        String INCORRECT_DIGITS = "123a45";\n        Assert.assertTrue(util.isDigits(CORRECT_DIGITS));\n        Assert.assertFalse(util.isDigits(INCORRECT_DIGITS));\n        // numeric\n        String CORRECT_NUMBER = "-12345";\n        String INCORRECT_NUMBER = "$12345";\n        Assert.assertTrue(util.isNumeric(CORRECT_NUMBER));\n        Assert.assertFalse(util.isNumeric(INCORRECT_NUMBER));\n    }']
preds_chunk= [[-3.3742526 -3.6048858 -3.4791937 -0.1665738 -3.666093  -3.3354967]]
pred_class= [3]
test_x= ['@Test\n    public void utfTest() {{\n        Utility util = Utility.getInstance();\n        String HELLO_WORLD = "hello world";\n        byte[] b = util.getUTF(HELLO_WORLD);\n        String restored = util.getUTF(b);\n        Assert.assertEquals(HELLO_WORLD, restored);\n    }']
preds_chunk= [[-3.5509346  -4.0314436  -3.776169   -3.8045013  -0.12344483 -3.7089763 ]]
pred_class= [4]
test_x= ['@Test\n    public void zeroFillTest() {{\n        Utility util = Utility.getInstance();\n        int n = 20;\n        String result = util.zeroFill(n, 10000);\n        Assert.assertEquals("00020", result);\n    }']
preds_chunk= [[-2.7446942  -2.9879756  -2.925236   -1.5055075  -0.60988307 -2.7124865 ]]
pred_class= [4]
test_x= ['@Test\n    public void multiLevelMapTest() {{\n        String HELLO = "hello";\n        String WORLD = "world";\n        String HELLO_WORLD = "hello.world";\n        String NULL_KEY_VALUE = "this.is.nil";\n        String NOT_EXIST_KEY = "key.not.exist";\n\n        MultiLevelMap mm = new MultiLevelMap();\n        mm.setElement(HELLO, WORLD);\n        mm.setElement(NULL_KEY_VALUE, null);\n        Assert.assertEquals(WORLD, mm.getElement(HELLO));\n        Assert.assertNull(mm.getElement(NULL_KEY_VALUE));\n        // key exists but value is null\n        Assert.assertTrue(mm.keyExists(NULL_KEY_VALUE));\n        Assert.assertFalse(mm.exists(NULL_KEY_VALUE));\n        // key does not exist\n        Assert.assertFalse(mm.keyExists(NOT_EXIST_KEY));\n        // delete a key-value\n        mm.removeElement(HELLO);\n        Assert.assertNull(mm.getElement(HELLO));\n        mm.removeElement(HELLO_WORLD).setElement(HELLO_WORLD, null);\n        Assert.assertTrue(mm.keyExists(HELLO_WORLD));\n        mm.removeElement(HELLO_WORLD);\n        Assert.assertEquals(Collections.EMPTY_MAP, mm.getElement(HELLO));\n        Assert.assertFalse(mm.keyExists(HELLO_WORLD));\n    }']
preds_chunk= [[-3.4124267  -3.6152327  -3.6853628  -0.15637212 -3.6548624  -3.3833313 ]]
pred_class= [3]
test_x= ['@Test\n    public void defaultValueTest() {{\n        String HELLO = "hello";\n        MultiLevelMap mm = new MultiLevelMap();\n        Object value = mm.getElement("no.such.key", HELLO);\n        Assert.assertEquals(HELLO, value);\n    }']
preds_chunk= [[-3.3925607  -3.6079786  -3.6787636  -0.16048741 -3.5773067  -3.3715236 ]]
pred_class= [3]
test_x= ['@Test\n    public void flatMapTest() {{\n        Utility util = Utility.getInstance();\n        Map<String, Object> map = new HashMap<>();\n        Map<String, Object> inner = new HashMap<>();\n        List<Object> list = new ArrayList<>();\n        list.add(1);\n        list.add(2);\n        inner.put("world", "data");\n        inner.put("number", list);\n        map.put("hello", inner);\n        Map<String, Object> map2 = new HashMap<>();\n        Map<String, Object> inner2 = new HashMap<>();\n        List<Integer> list2 = new ArrayList<>();\n        list2.add(1);\n        list2.add(2);\n        inner2.put("world", "data");\n        inner2.put("number", list2);\n        map2.put("hello", inner2);\n        list.add(map2);\n        list.add(list2);\n        Map<String, Object> flatMap = util.getFlatMap(map);\n        Assert.assertEquals("data", flatMap.get(HELLO_WORLD));\n        Assert.assertEquals(1, flatMap.get("hello.number[0]"));\n        Assert.assertEquals(2, flatMap.get("hello.number[1]"));\n        Assert.assertEquals("data", flatMap.get("hello.number[2].hello.world"));\n        Assert.assertEquals(1, flatMap.get("hello.number[2].hello.number[0]"));\n        Assert.assertEquals(2, flatMap.get("hello.number[2].hello.number[1]"));\n        /*\n         * flatmap\'s keys are composite keys\n         * We will create a multi-level map and set the elements with the key-values from the flatmap.\n         * The original map (non-flatten) must be the same as the multi-level map key-values.\n         */\n        MultiLevelMap mm = new MultiLevelMap();\n        for (String k: flatMap.keySet()) {\n            mm.setElement(k, flatMap.get(k));\n        }\n        Assert.assertEquals(map, mm.getMap());\n        /*\n         * retrieval using composite keys from the multi-level map must match the original map\'s values\n         */\n        Assert.assertEquals("data", mm.getElement(HELLO_WORLD));\n        Assert.assertEquals(1, mm.getElement("hello.number[0]"));\n        Assert.assertEquals(2, mm.getElement("hello.number[1]"));\n        Assert.assertEquals("data", mm.getElement("hello.number[2].hello.world"));\n        Assert.assertEquals(1, mm.getElement("hello.number[2].hello.number[0]"));\n        Assert.assertEquals(2, mm.getElement("hello.number[2].hello.number[1]"));\n        // really a lot of nested levels\n        String NESTED_PATH = "hello[5][4][3][2]";\n        String SIMPLE_VALUE = "world";\n        MultiLevelMap m2 = new MultiLevelMap();\n        m2.setElement(NESTED_PATH, SIMPLE_VALUE);\n        Map<String, Object> m2flat = util.getFlatMap(m2.getMap());\n        Assert.assertEquals(SIMPLE_VALUE, m2flat.get(NESTED_PATH));\n        Assert.assertEquals(m2flat.get(NESTED_PATH), m2.getElement(NESTED_PATH));\n        // alternate map and list\n        String MIX_PATH = "hello.world[0].headers[0]";\n        MultiLevelMap m3 = new MultiLevelMap();\n        m3.setElement(MIX_PATH, SIMPLE_VALUE);\n        Map<String, Object> m3flat = util.getFlatMap(m3.getMap());\n        Assert.assertEquals(SIMPLE_VALUE, m3flat.get(MIX_PATH));\n        Assert.assertEquals(m3flat.get(MIX_PATH), m3.getElement(MIX_PATH));\n    }']
preds_chunk= [[-3.4298837  -3.6209843  -3.6722946  -0.15526572 -3.7064643  -3.3615053 ]]
pred_class= [3]
test_x= ['@Test\n    public void intranetIpTest() {{\n        final Utility util = Utility.getInstance();\n        String[] IP_ADDRESSES = {"127.0.0.1:8080", "127.0.0.1", "10.1.2.3", "172.16.1.2", "192.168.1.30"};\n        for (String ip: IP_ADDRESSES) {\n            Assert.assertTrue(util.isIntranetAddress(ip));\n        }\n        Assert.assertFalse(util.isIntranetAddress("localhost"));\n        Assert.assertFalse(util.isIntranetAddress(null));\n        Assert.assertFalse(util.isIntranetAddress("128.1.2.3"));\n        Assert.assertFalse(util.isIntranetAddress("hello.world.com"));\n        Assert.assertFalse(util.isIntranetAddress("127.0001.1.1"));\n    }']
preds_chunk= [[-3.618126   -4.1937003  -3.916526   -4.118985   -0.10563025 -3.8099911 ]]
pred_class= [4]
test_x= ['@Test\n    public void elapsedTimeTest() {{\n        long time = ONE_DAY + 40 * ONE_HOUR + 5 * ONE_MINUTE + 6 * ONE_SECOND;\n        String expected = "2 days 16 hours 5 minutes 6 seconds";\n        final Utility util = Utility.getInstance();\n        Assert.assertEquals(expected, util.elapsedTime(time));\n    }']
preds_chunk= [[-3.0333705  -3.4195735  -0.18677576 -3.305571   -3.9531357  -3.3926897 ]]
pred_class= [2]
test_x= ['@Test\n    public void simpleHttpDecodeTest() {{\n        SimpleHttpUtility http = SimpleHttpUtility.getInstance();\n        Map<String, String> result = http.decodeQueryString("a=b&x=y");\n        Assert.assertEquals("b", result.get("a"));\n        Assert.assertEquals("y", result.get("x"));\n    }']
preds_chunk= [[-3.3074315 -3.679131  -3.5500832 -3.1080778 -0.1881672 -3.317046 ]]
pred_class= [4]
test_x= ['@Test\n    public void urlRewriteTest() {{\n        SimpleHttpUtility http = SimpleHttpUtility.getInstance();\n        List<String> rewrite = new ArrayList<>();\n        rewrite.add("/api/");\n        rewrite.add("/api/v2/");\n        String url = "/api/hello/world";\n        Assert.assertEquals("/api/v2/hello/world", http.normalizeUrl(url, rewrite));\n    }']
preds_chunk= [[-2.663959   -2.8612933  -2.8336442  -0.9884173  -0.97895247 -2.7110715 ]]
pred_class= [4]
test_x= ['@Test\n    public void multiPart() throws IOException, InterruptedException {\n        /*\n         * Generate large payload of over 64 KB\n         * (for this test, we generate 500,000 bytes)\n         */\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i < CYCLE; i++) {{\n            sb.append(TEST_STRING);\n        }']
preds_chunk= [[-3.6053026  -4.145728   -4.0008383  -4.0887885  -0.10793014 -3.7198055 ]]
pred_class= [4]
test_x= ['@Test\n    public void objectToMap() {{\n        // test custom map serializer\n        SimplePoJo obj = getSample();\n        SimpleObjectMapper mapper = SimpleMapper.getInstance().getMapper();\n        Map m = mapper.readValue(obj, Map.class);\n        Assert.assertEquals(String.class, m.get("date").getClass());\n        // small long number will be converted to integer\n        Assert.assertEquals(Integer.class, m.get("number").getClass());\n        Assert.assertEquals(Integer.class, m.get("small_long").getClass());\n        Assert.assertEquals(Long.class, m.get("long_number").getClass());\n        Assert.assertEquals(Double.class, m.get("float_number").getClass());\n        // small double number will be converted to float\n        Assert.assertEquals(Double.class, m.get("small_double").getClass());\n        // small double number will be converted to float\n        Assert.assertEquals(Double.class, m.get("double_number").getClass());\n        Assert.assertEquals(obj.name, m.get("name"));\n        // date is converted to ISO-8601 string\n        Assert.assertEquals(Utility.getInstance().date2str(obj.date), m.get("date"));\n        // big integer and big decimal are converted as String to preserve math precision\n        Assert.assertEquals(String.class, m.get("big_integer").getClass());\n        Assert.assertEquals(String.class, m.get("big_decimal").getClass());\n    }']
preds_chunk= [[-3.4177837  -3.6212556  -3.6103852  -0.15746567 -3.692825   -3.3750412 ]]
pred_class= [3]
test_x= ['@Test\n    public void twoWayConversion() {{\n        SimplePoJo obj = getSample();\n        SimpleObjectMapper mapper = SimpleMapper.getInstance().getMapper();\n        String s = mapper.writeValueAsString(obj);\n        SimplePoJo po = mapper.readValue(s, SimplePoJo.class);\n        Assert.assertEquals(obj.number, po.number);\n        Assert.assertEquals(obj.smallLong, po.smallLong);\n        Assert.assertEquals(obj.longNumber, po.longNumber);\n        Assert.assertEquals(obj.floatNumber, po.floatNumber, 0.0);\n        Assert.assertEquals(obj.smallDouble, po.smallDouble, 0.0);\n        Assert.assertEquals(obj.doubleNumber, po.doubleNumber, 0.0);\n        Assert.assertEquals(obj.name, po.name);\n        Assert.assertEquals(obj.date, po.date);\n        Assert.assertEquals(obj.bigInteger, po.bigInteger);\n        Assert.assertEquals(obj.bigDecimal, po.bigDecimal);\n    }']
preds_chunk= [[-3.4257255  -3.6276605  -3.6418903  -0.15529737 -3.6986525  -3.3880093 ]]
pred_class= [3]
test_x= ['@Test\n    public void readWriteTest() throws IOException {\n        Utility util = Utility.getInstance();\n        Date now = new Date();\n        Map<String, Object> inner = new HashMap<>();\n        inner.put("inner", "internal");\n        inner.put("time", now);\n        List<Object> list = new ArrayList<>();\n        list.add(1);\n        list.add(2);\n        list.add("");   // empty element will be converted to null\n        list.add(inner);\n        list.add(3);\n        list.add("test");\n        list.add("");   // empty element at the end of the array will be dropped\n        Map<String, Object> data = new HashMap<>();\n        data.put("hello", "world");\n        data.put("lists", list);\n        data.put("single", Collections.singletonList("one"));\n        String basic = writer.write(data);\n        List<String> basicLines = util.split(basic, "\\r\\n");\n        Assert.assertTrue(basicLines.size() > 2);\n        Assert.assertEquals("<root>", basicLines.get(1));\n        // set root as "result"\n        String xml = writer.write("result", data);\n        List<String> raw = util.split(xml, "\\r\\n");\n        List<String> lines = new ArrayList<>();\n        raw.forEach(line -> lines.add(line.trim()));\n        Assert.assertTrue(lines.size() > 2);\n        Assert.assertEquals("<?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?>", lines.get(0));\n        Assert.assertEquals("<result>", lines.get(1));\n        Assert.assertTrue(lines.contains("<single>one</single>"));\n        Map<String, Object> result = parser.parse(xml);\n        Assert.assertEquals("one", result.get("single"));\n        Assert.assertTrue(result.get("lists") instanceof List);\n        List<Object> mixedList = (List<Object>) result.get("lists");\n        // the 7th element in the array is dropped\n        Assert.assertEquals(6, mixedList.size());\n        MultiLevelMap multi = new MultiLevelMap(result);\n        // empty array element is saved as null\n        Assert.assertNull(multi.getElement("lists[2]"));\n        Assert.assertEquals("internal", multi.getElement("lists[3].inner"));\n        Assert.assertEquals(util.date2str(now), multi.getElement("lists[3].time"));\n        Assert.assertEquals("3", multi.getElement("lists[4]"));\n        Assert.assertEquals("test", multi.getElement("lists[5]"));\n        // xml without array\n        try (InputStream in = this.getClass().getResourceAsStream("/log4j2.xml")) {{\n            MultiLevelMap mm = new MultiLevelMap(parser.parse(in));\n            Assert.assertEquals("console", mm.getElement("Appenders.name"));\n            Assert.assertEquals("false", mm.getElement("Loggers.additivity"));\n            Assert.assertEquals("console", mm.getElement("Loggers.Root.ref"));\n        }']
preds_chunk= [[-2.8032455  -3.0769823  -2.0142074  -0.40912527 -3.3253407  -2.818903  ]]
pred_class= [3]
test_x= ['@Test\n    public void adlsWithArrayTest() throws IOException {\n        try (InputStream in = this.getClass().getResourceAsStream("/sample_adls_response.xml")) {{\n            MultiLevelMap mm = new MultiLevelMap(parser.parse(in));\n            Assert.assertEquals("\\"0x8D90F50C8DD6E2A\\"",\n                    mm.getElement("Containers.Container[0].Properties.Etag"));\n            Assert.assertEquals("\\"0x8D9934CF1AD9D12\\"",\n                    mm.getElement("Containers.Container[1].Properties.Etag"));\n            Assert.assertEquals("hello", mm.getElement("Containers.Container[0].Name"));\n            Assert.assertEquals("test", mm.getElement("Containers.Container[1].Name"));\n        }']
preds_chunk= [[-3.4142752 -3.619543  -3.6871781 -0.1607002 -3.650497  -3.277122 ]]
pred_class= [3]
test_x= ['@Test\n    public void adlsWithoutArrayTest() throws IOException {\n        try (InputStream in = this.getClass().getResourceAsStream("/sample_adls_with_one_container.xml")) {{\n            MultiLevelMap mm = new MultiLevelMap(parser.parse(in));\n            // an array of one element will be rendered as a regular element instead of an array\n            Assert.assertEquals("\\"0x8D90F50C8DD6E2A\\"",\n                    mm.getElement("Containers.Container.Properties.Etag"));\n            Assert.assertEquals("hello", mm.getElement("Containers.Container.Name"));\n        }']
preds_chunk= [[-3.335399   -3.5409255  -3.6484382  -0.18159515 -3.4058044  -3.1638582 ]]
pred_class= [3]
test_x= ['@Test\n    public void featureTest() throws ParserConfigurationException {\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        for (String feature: FEATURES_TO_ENABLE) {{\n            Assert.assertTrue(setFeature(dbf, feature, true));\n        }']
preds_chunk= [[-3.6037176  -4.064256   -3.9586089  -3.9959557  -0.11976323 -3.4740293 ]]
pred_class= [4]
test_x= ['@Test\n    public void returnOriginalClassIfSameTargetClass() {{\n        PoJo pojo = new PoJo();\n        pojo.setName("hello");\n        pojo.setNumber(123);\n        Object o = SimpleMapper.getInstance().getMapper().readValue(pojo, PoJo.class);\n        Assert.assertEquals(pojo, o);\n    }']
preds_chunk= [[-3.4348032  -3.629224   -3.6811717  -0.15532513 -3.6954644  -3.350543  ]]
pred_class= [3]
test_x= ['@Test\n    public void typedNumberShouldMapDouble() {{\n        final JsonPrimitive number = new JsonPrimitive("1.12345678");\n        Object result = SimpleMapper.getInstance().typedNumber(number);\n        assertThat(result, is(1.12345678d));\n    }']
preds_chunk= [[-3.327411   -3.5465696  -3.605236   -0.17502406 -3.40365    -3.3404448 ]]
pred_class= [3]
test_x= ['@Test\n    public void typedNumberShouldMapFloat() {{\n        final JsonPrimitive number = new JsonPrimitive("1.12");\n        Object result = SimpleMapper.getInstance().typedNumber(number);\n        assertThat(result, is(1.12d));\n    }']
preds_chunk= [[-3.045636  -3.240148  -3.2782178 -0.2802296 -2.6041584 -3.0790079]]
pred_class= [3]
test_x= ['@Test\n    public void primitiveDataTest() {{\n        final boolean bol = true;\n        Object bolString = SimpleMapper.getInstance().getMapper().writeValueAsString(bol);\n        Assert.assertEquals("true", bolString);\n        final int n = 1;\n        Object intString = SimpleMapper.getInstance().getMapper().writeValueAsString(n);\n        Assert.assertEquals("1", intString);\n    }']
preds_chunk= [[-3.422525  -3.6351001 -3.6797383 -0.1551362 -3.6846833 -3.3709905]]
pred_class= [3]
test_x= ['@Test\n    @SuppressWarnings("unchecked")\n    public void mapperSerializationTest() {{\n        Utility util = Utility.getInstance();\n        SimpleObjectMapper mapper = SimpleMapper.getInstance().getMapper();\n        Date now = new Date();\n        LocalDateTime time = LocalDateTime.now();\n        String iso8601 = util.date2str(now);\n        String iso8601NoTimeZone = time.toString();\n        Map<String, Object> map = new HashMap<>();\n        map.put("integer", 100);\n        map.put("date", now);\n        map.put("time", time);\n        map.put("sql_date", new java.sql.Date(now.getTime()));\n        map.put("sql_timestamp", new java.sql.Timestamp(now.getTime()));\n        Map<String, Object> converted = mapper.readValue(mapper.writeValueAsString(map), Map.class);\n        // verify that java.util.Date, java.sql.Date and java.sql.Timestamp can be serialized to ISO-8601 string format\n        Assert.assertEquals(iso8601, converted.get("date"));\n        // LocalDateTime string will drop the "T" separator\n        Assert.assertEquals(iso8601NoTimeZone.replace(\'T\', \' \'), converted.get("time"));\n        // sql date is yyyy-mm-dd\n        Assert.assertEquals(new java.sql.Date(now.getTime()).toString(), converted.get("sql_date"));\n        Assert.assertEquals(iso8601, converted.get("sql_timestamp"));\n        Assert.assertEquals(Integer.class, converted.get("integer").getClass());\n        String name = "hello world";\n        Map<String, Object> input = new HashMap<>();\n        input.put("full_name", name);\n        input.put("date", iso8601);\n        input.put("time", iso8601NoTimeZone);\n        PoJo pojo = mapper.readValue(input, PoJo.class);\n        // verify that the time is restored correctly\n        Assert.assertEquals(now.getTime(), pojo.getDate().getTime());\n        Assert.assertEquals(time, pojo.getTime());\n        // verify that snake case is deserialized correctly\n        Assert.assertEquals(name, pojo.getFullName());\n        // verify input timestamp can be in milliseconds too\n        input.put("date", now.getTime());\n        pojo = mapper.readValue(input, PoJo.class);\n        Assert.assertEquals(now.getTime(), pojo.getDate().getTime());\n    }']
preds_chunk= [[-2.8712015 -3.0363889 -2.5341856 -0.7141503 -3.3821273 -1.2294552]]
pred_class= [3]
test_x= ['@Test\n    @SuppressWarnings("unchecked")\n    public void bigDecimalSerializationTests() {{\n        SimpleMapper mapper = SimpleMapper.getInstance();\n        String NUMBER = "number";\n        String ONE  = "0.00000001";\n        String ZERO = "0.00000000";\n        SimpleNumber one  = new SimpleNumber(ONE);\n        SimpleNumber zero = new SimpleNumber(ZERO);\n        // verify hash map result\n        Map<String, Object> mapOne = mapper.getMapper().readValue(one, Map.class);\n        // numeric value is preserved\n        Assert.assertEquals(ONE, mapOne.get(NUMBER));\n        // ensure that ZERO is converted to "0"\n        Map<String, Object> mapZero = mapper.getMapper().readValue(zero, Map.class);\n        Assert.assertEquals("0", mapZero.get(NUMBER));\n        // verify PoJo class conversion behavior - this will return the original object because the class is the same\n        SimpleNumber numberOne = mapper.getMapper().readValue(one, SimpleNumber.class);\n        Assert.assertEquals(numberOne.number, one.number);\n        // this will pass thru the serializer\n        String zeroValue = mapper.getMapper().writeValueAsString(zero);\n        SimpleNumber numberZero = mapper.getMapper().readValue(zeroValue, SimpleNumber.class);\n        // the original number has the zero number with many zeros after the decimal\n        Assert.assertEquals("0E-8", zero.number.toString());\n        Assert.assertEquals(ZERO, zero.number.toPlainString());\n        // the converted BigDecimal gets a zero number without zeros after the decimal\n        Assert.assertEquals("0", numberZero.number.toString());\n        // verify map to PoJo serialization behavior\n        SimpleNumber number0 = mapper.getMapper().readValue(mapZero, SimpleNumber.class);\n        Assert.assertTrue(mapper.isZero(number0.number));\n        Assert.assertTrue(mapper.isZero(zero.number));\n        // the two zero objects are different because of precision\n        Assert.assertNotEquals(number0.number, zero.number);\n        SimpleNumber number1 = mapper.getMapper().readValue(mapOne, SimpleNumber.class);\n        // non-zero numbers are exactly the same\n        Assert.assertEquals(number1.number, one.number);\n    }']
preds_chunk= [[-3.4229753  -3.641541   -3.6443646  -0.15819174 -3.701748   -3.3058405 ]]
pred_class= [3]
test_x= ['@Test\n    public void bigDecimalTests() {{\n        String ZERO = "0.00000000";\n        BigDecimal zero = new BigDecimal("0");\n        BigDecimal zeroes = new BigDecimal(ZERO);\n        BigDecimal result = zero.multiply(zeroes);\n        // precision is preserved after multiplication\n        Assert.assertEquals(zeroes, result);\n        Assert.assertEquals(ZERO, result.toPlainString());\n        // test zero values\n        Assert.assertTrue(SimpleMapper.getInstance().isZero(zero));\n        Assert.assertTrue(SimpleMapper.getInstance().isZero(zeroes));\n        Assert.assertTrue(SimpleMapper.getInstance().isZero(result));\n        Assert.assertTrue(SimpleMapper.getInstance().isZero(result.toPlainString()));\n        Assert.assertTrue(SimpleMapper.getInstance().isZero(result.toString()));\n    }']
preds_chunk= [[-3.4254072  -3.6182637  -3.6265874  -0.15636395 -3.6888244  -3.3879256 ]]
pred_class= [3]
test_x= ['@Test\n    public void caseMappingTest() {{\n        SimpleObjectMapper snakeMapper = SimpleMapper.getInstance().getSnakeCaseMapper();\n        SimpleObjectMapper camelMapper = SimpleMapper.getInstance().getCamelCaseMapper();\n        String NUMBER = "1.234567890";\n        CaseDemo sn = new CaseDemo(NUMBER);\n        Map<String, Object> snakeMap = snakeMapper.readValue(sn, Map.class);\n        Assert.assertEquals(NUMBER, snakeMap.get("case_demo"));\n        Map<String, Object> camelMap = camelMapper.readValue(sn, Map.class);\n        Assert.assertEquals(NUMBER, camelMap.get("caseDemo"));\n        CaseDemo restoredFromSnake = snakeMapper.readValue(snakeMap, CaseDemo.class);\n        Assert.assertEquals(NUMBER, restoredFromSnake.caseDemo.toPlainString());\n        CaseDemo restoredFromCamel = camelMapper.readValue(camelMap, CaseDemo.class);\n        Assert.assertEquals(NUMBER, restoredFromCamel.caseDemo.toPlainString());\n    }']
preds_chunk= [[-3.431625   -3.634797   -3.6647012  -0.15564574 -3.6852493  -3.3606915 ]]
pred_class= [3]
test_x= ['@Test\n    public void base64() {{\n        String base64 = util.bytesToBase64(INPUT.getBytes(), true, false);\n        // verify that it is a pretty-print output\n        Assert.assertTrue(base64.contains("\\r\\n"));\n        byte[] b = util.base64ToBytes(base64);\n        Assert.assertEquals(INPUT, new String(b));\n    }']
preds_chunk= [[-3.1724892  -3.4367857  -3.361673   -0.21526414 -3.0892928  -3.234163  ]]
pred_class= [3]
test_x= ['@Test\n    public void hex() throws IOException {\n        String hexString = util.bytes2hex(INPUT.getBytes());\n        byte[] b = util.hex2bytes(hexString);\n        Assert.assertEquals(INPUT, new String(b));\n    }\n\n    @Test\n    public void normalizeUtcTimestamp() {{\n        Utility util = Utility.getInstance();\n        String expected = "2020-07-09T01:02:03.123Z";\n        String timestamp = "2020-07-09T01:02:03.12345678Z";\n        Assert.assertEquals(expected, util.date2str(util.str2date(timestamp)));\n        expected = "2020-07-09T01:02:03.120Z";\n        timestamp = "2020-07-09T01:02:03.12Z";\n        Assert.assertEquals(expected, util.date2str(util.str2date(timestamp)));\n        expected = "2020-07-09T01:02:03.100Z";\n        timestamp = "2020-07-09T01:02:03.1Z";\n        Assert.assertEquals(expected, util.date2str(util.str2date(timestamp)));\n        expected = "2020-07-09T01:02:03Z";\n        timestamp = "2020-07-09T01:02:03.000Z";\n        Assert.assertEquals(expected, util.date2str(util.str2date(timestamp)));\n    }']
preds_chunk= [[-3.3360312  -3.6667902  -0.12771733 -3.9138882  -4.2955523  -3.6821067 ]]
pred_class= [2]
test_x= ['@Test\n    public void concurrentEventTest() throws InterruptedException {\n        final BlockingQueue<Boolean> wait = new ArrayBlockingQueue<>(1);\n        final AppConfigReader config = AppConfigReader.getInstance();\n        final Utility util = Utility.getInstance();\n        int poolSize = Math.max(32, util.str2int(config.getProperty("kernel.thread.pool", "100")));\n        final ExecutorService executor = Platform.getInstance().getEventExecutor();\n        final String RPC_FORWARDER = "rpc.forwarder";\n        final String SLOW_SERVICE = "artificial.delay";\n        final int CYCLES = poolSize / 2;\n        log.info("Test sync and blocking RPC with {} workers", CYCLES);\n        final long TIMEOUT = 10000;\n        PostOffice po = new PostOffice("unit.test", "12345", "/TEST");\n        // make nested RPC calls\n        long begin = System.currentTimeMillis();\n        AtomicInteger counter = new AtomicInteger(0);\n        AtomicInteger passes = new AtomicInteger(0);\n        for (int i=0; i < CYCLES; i++) {{\n            /*\n             * The blocking RPC will hold up a large number of worker threads = CYCLES\n             * Therefore, this test will break if CYCLES > poolSize.\n             */\n            executor.submit(() -> {\n                int count = counter.incrementAndGet();\n                try {\n                    final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n                    String message = "hello world "+count;\n                    EventEnvelope request = new EventEnvelope().setTo(RPC_FORWARDER)\n                            .setHeader("target", SLOW_SERVICE).setHeader("timeout", TIMEOUT).setBody(message);\n                    po.asyncRequest(request, TIMEOUT, true).onSuccess(bench::offer);\n                    EventEnvelope response = bench.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n                    assert response != null;\n                    if (message.equals(response.getBody())) {\n                        passes.incrementAndGet();\n                    }\n                    if (passes.get() >= CYCLES) {\n                        wait.offer(true);\n                    }\n                } catch (Exception e) {\n                    log.error("Exception - {}", e.getMessage());\n                }\n            });\n        }']
preds_chunk= [[-0.56660926 -1.2711862  -2.9948397  -3.6791234  -3.4432135  -3.1054683 ]]
pred_class= [0]
test_x= ['@Test\n    public void aliasRouteTest() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        final long TIMEOUT = 5000;\n        EventEmitter po = EventEmitter.getInstance();\n        final String MESSAGE = "test message";\n        po.asyncRequest(new EventEnvelope().setTo(HELLO_ALIAS).setBody(MESSAGE), TIMEOUT).onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> body = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(MESSAGE, body.get("body"));\n    }\n\n    @Test\n    public void nullRouteListTest() {{\n        EventEmitter po = EventEmitter.getInstance();\n        Assert.assertFalse(po.exists((String[]) null));\n        Assert.assertFalse(po.exists((String) null));\n    }']
preds_chunk= [[-0.10049308 -3.584296   -3.9252038  -4.508102   -3.8605506  -4.1327558 ]]
pred_class= [0]
test_x= ['@Test\n    public void rpcTagTest() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        final PostOffice po = new PostOffice("unit.test", "801", "TEST /rpc1/timeout/tag");\n        final long TIMEOUT = 5000;\n        final int BODY = 100;\n        final String RPC_TIMEOUT_CHECK = "rpc.timeout.check";\n        EventEnvelope request = new EventEnvelope().setTo(RPC_TIMEOUT_CHECK).setBody(BODY);\n        po.asyncRequest(request, TIMEOUT).onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(String.valueOf(TIMEOUT), result.get(EventEmitter.RPC));\n        Assert.assertEquals(BODY, result.get("body"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void parallelRpcTagTest() throws IOException, InterruptedException {\n        final BlockingQueue<List<EventEnvelope>> bench = new ArrayBlockingQueue<>(1);\n        final PostOffice po = new PostOffice("unit.test", "802", "TEST /rpc2/timeout/tag");\n        final int CYCLE = 3;\n        final long TIMEOUT = 5500;\n        final String BODY = "body";\n        final String RPC_TIMEOUT_CHECK = "rpc.timeout.check";\n        List<EventEnvelope> requests = new ArrayList<>();\n        for (int i=0; i < CYCLE; i++) {{\n            requests.add(new EventEnvelope().setTo(RPC_TIMEOUT_CHECK).setBody(i+1));\n        }']
preds_chunk= [[-0.09631041 -3.6930115  -3.928819   -4.5118284  -3.8764431  -4.163602  ]]
pred_class= [0]
test_x= ['@Test\n    public void wsTest() throws InterruptedException {\n        final Utility util = Utility.getInstance();\n        final AppConfigReader config = AppConfigReader.getInstance();\n        final int PORT = util.str2int(config.getProperty("websocket.server.port",\n                                        config.getProperty("server.port", "8085")));\n        final String WELCOME = "welcome";\n        final String MESSAGE = "hello world";\n        final String END = "end";\n        final BlockingQueue<Boolean> bench = new ArrayBlockingQueue<>(1);\n        final EventEmitter po = EventEmitter.getInstance();\n        List<String> welcome = new ArrayList<>();\n        List<String> txPaths = new ArrayList<>();\n        LambdaFunction connector = (headers, input, instance) -> {\n            if ("open".equals(headers.get("type"))) {{\n                String txPath = headers.get("tx_path");\n                if (txPaths.isEmpty()) {\n                    txPaths.add(txPath);\n                }\n                Assert.assertNotNull(txPath);\n                po.send(txPath, WELCOME.getBytes());\n                po.send(txPath, MESSAGE);\n                po.send(txPath, END);\n            }']
preds_chunk= [[-0.10291096 -3.5101042  -3.8995466  -4.4907875  -3.898556   -4.124918  ]]
pred_class= [0]
test_x= ['@Test\n    public void testExceptionTransport() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        final long TIMEOUT = 5000;\n        String EXCEPTION = "exception";\n        String MESSAGE = "just a test";\n        EventEmitter po = EventEmitter.getInstance();\n        EventEnvelope request = new EventEnvelope().setTo("hello.world").setBody("demo").setHeader(EXCEPTION, true);\n        po.asyncRequest(request, TIMEOUT).onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n        assert response != null;\n        Assert.assertEquals(400, response.getStatus());\n        Assert.assertEquals(MESSAGE, response.getBody());\n        Assert.assertEquals(AppException.class, response.getException().getClass());\n        log.info("Exception transported - {}", response.getException().toString());\n        log.info("Stack trace transported through the response event:");\n        StackTraceElement[] elements = response.getException().getStackTrace();\n        for (StackTraceElement e: elements) {{\n            if (e.getClassName().startsWith("org.platformlambda.")) {\n                log.info("Found - {}", e);\n            }\n        }']
preds_chunk= [[-0.09791122 -3.5926085  -3.9267063  -4.515593   -3.9012325  -4.207631  ]]
pred_class= [0]
test_x= ['@Test\n    public void testNestedExceptionTransport() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        final long TIMEOUT = 5000;\n        String NEST_EXCEPTION = "nested_exception";\n        String MESSAGE = "just a test";\n        String SQL_ERROR = "sql error";\n        EventEmitter po = EventEmitter.getInstance();\n        EventEnvelope request = new EventEnvelope().setTo("hello.world").setBody("hi").setHeader(NEST_EXCEPTION, true);\n        po.asyncRequest(request, TIMEOUT).onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n        assert response != null;\n        Assert.assertEquals(400, response.getStatus());\n        // event error is mapped to the root cause\n        Assert.assertEquals(SQL_ERROR, response.getError());\n        // nested exception is transported by the response event\n        Throwable ex = response.getException();\n        // immediate exception\n        Assert.assertEquals(AppException.class, ex.getClass());\n        AppException appEx = (AppException) ex;\n        Assert.assertEquals(400, appEx.getStatus());\n        Assert.assertEquals(MESSAGE, appEx.getMessage());\n        // nested exception\n        Throwable nested = ex.getCause();\n        Assert.assertNotNull(nested);\n        Assert.assertEquals(SQLException.class, nested.getClass());\n        Assert.assertEquals(SQL_ERROR, nested.getMessage());\n    }\n\n    @Test\n    public void findProviderThatExists() throws InterruptedException {\n        BlockingQueue<Boolean> bench = new ArrayBlockingQueue<>(1);\n        Platform platform = Platform.getInstance();\n        Future<Boolean> status = platform.waitForProvider("cloud.connector", 10);\n        status.onSuccess(bench::offer);\n        Boolean result = bench.poll(5, TimeUnit.SECONDS);\n        Assert.assertEquals(Boolean.TRUE, result);\n    }\n\n    @Test\n    public void findProviderThatDoesNotExists() throws InterruptedException {\n        BlockingQueue<Boolean> bench = new ArrayBlockingQueue<>(1);\n        Platform platform = Platform.getInstance();\n        Future<Boolean> status = platform.waitForProvider("no.such.service", 1);\n        status.onSuccess(bench::offer);\n        Boolean result = bench.poll(12, TimeUnit.SECONDS);\n        Assert.assertNotEquals(Boolean.TRUE, result);\n    }\n\n    @Test\n    public void findProviderThatIsPending() throws IOException, InterruptedException {\n        final BlockingQueue<Boolean> bench1 = new ArrayBlockingQueue<>(1);\n        final BlockingQueue<EventEnvelope> bench2 = new ArrayBlockingQueue<>(1);\n        String NO_OP = "no.op";\n        String PENDING_SERVICE = "pending.service";\n        Platform platform = Platform.getInstance();\n        LambdaFunction noOp = (headers, input, instance) -> true;\n        LambdaFunction f = (headers, input, instance) -> {\n            platform.register(NO_OP, noOp, 1);\n            return true;\n        };\n        platform.registerPrivate(PENDING_SERVICE, f, 1);\n        PostOffice po = new PostOffice("unit.test", "11", "CHECK /provider");\n        // start service two seconds later, so we can test the waitForProvider method\n        po.sendLater(new EventEnvelope().setTo(PENDING_SERVICE).setBody("hi"),\n                new Date(System.currentTimeMillis()+2100));\n        Future<Boolean> status = platform.waitForProvider(NO_OP, 5);\n        status.onSuccess(bench1::offer);\n        Boolean result = bench1.poll(12, TimeUnit.SECONDS);\n        Assert.assertEquals(Boolean.TRUE, result);\n        EventEnvelope request = new EventEnvelope().setTo(NO_OP).setBody("ok");\n        po.asyncRequest(request, 5000).onSuccess(bench2::offer);\n        EventEnvelope response = bench2.poll(12, TimeUnit.SECONDS);\n        assert response != null;\n        Assert.assertEquals(true, response.getBody());\n        platform.release(NO_OP);\n        platform.release(PENDING_SERVICE);\n    }\n\n    @Test\n    public void deriveOriginIdFromAppId() {{\n        /*\n         * Usually you do not need to set application-ID\n         * When you set it, the origin-ID will be generated from the app-ID\n         * so that you can correlate user specific information for tracking purpose.\n         *\n         * Since appId must be set before the "getOrigin" method, the setId is done in the BeforeClass\n         * for this unit test.\n         */\n        Platform platform = Platform.getInstance();\n        Assert.assertEquals(APP_ID, platform.getAppId());\n        Utility util = Utility.getInstance();\n        // validate the hashing algorithm\n        String id = util.getUuid();\n        byte[] hash = crypto.getSHA256(util.getUTF(platform.getAppId()));\n        id = util.bytes2hex(hash).substring(0, id.length());\n        String originId = util.getDateOnly(new Date()) + id;\n        Assert.assertEquals(platform.getOrigin(), originId);\n    }']
preds_chunk= [[-0.09590542 -3.659833   -3.9371247  -4.5060177  -3.9031768  -4.200441  ]]
pred_class= [0]
test_x= ['@Test\n    public void registerInvalidRoute() {{\n        Platform platform = Platform.getInstance();\n        LambdaFunction noOp = (headers, input, instance) -> true;\n        IllegalArgumentException ex = Assert.assertThrows(IllegalArgumentException.class, () ->\n                platform.register("invalidFormat", noOp, 1));\n        Assert.assertEquals("Invalid route name - use 0-9, a-z, period, hyphen or underscore characters",\n                ex.getMessage());\n    }']
preds_chunk= [[-1.5384517  -3.3365853  -2.9052591  -3.4195344  -0.49314517 -2.9649367 ]]
pred_class= [4]
test_x= ['@Test\n    public void registerNullRoute() {{\n        Platform platform = Platform.getInstance();\n        LambdaFunction noOp = (headers, input, instance) -> true;\n        IllegalArgumentException ex = Assert.assertThrows(IllegalArgumentException.class, () ->\n                platform.register(null, noOp, 1));\n        Assert.assertEquals("Missing service routing path", ex.getMessage());\n    }']
preds_chunk= [[-0.15558809 -3.5175476  -3.5599093  -4.135768   -3.0410376  -3.807697  ]]
pred_class= [0]
test_x= ['@Test\n    public void registerNullService() {{\n        Platform platform = Platform.getInstance();\n        IllegalArgumentException ex = Assert.assertThrows(IllegalArgumentException.class, () ->\n                platform.register("no.service", null, 1));\n        Assert.assertEquals("Missing LambdaFunction instance", ex.getMessage());\n    }']
preds_chunk= [[-0.10570372 -3.625478   -3.8931396  -4.4589043  -3.6987178  -4.0768423 ]]
pred_class= [0]
test_x= ['@Test\n    public void reservedExtensionNotAllowed() {{\n        Platform platform = Platform.getInstance();\n        LambdaFunction noOp = (headers, input, instance) -> true;\n        IllegalArgumentException ex = Assert.assertThrows(IllegalArgumentException.class, () ->\n                platform.register("nothing.com", noOp, 1));\n        Assert.assertEquals("Invalid route nothing.com which is use a reserved extension", ex.getMessage());\n    }']
preds_chunk= [[-1.8900218 -3.4953682 -3.226729  -3.6318061 -0.33512   -3.2918181]]
pred_class= [4]
test_x= ['@Test\n    public void reservedFilenameNotAllowed() {{\n        Platform platform = Platform.getInstance();\n        LambdaFunction noOp = (headers, input, instance) -> true;\n        IllegalArgumentException ex = Assert.assertThrows(IllegalArgumentException.class, () ->\n                platform.register("thumbs.db", noOp, 1));\n        Assert.assertEquals("Invalid route thumbs.db which is a reserved Windows filename", ex.getMessage());\n    }']
preds_chunk= [[-0.3716033 -3.2461545 -3.166485  -3.7068    -1.7728734 -3.3553574]]
pred_class= [0]
test_x= ['@Test\n    public void reloadPublicServiceAsPrivate() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        String SERVICE = "reloadable.service";\n        long TIMEOUT = 5000;\n        Platform platform = Platform.getInstance();\n        EventEmitter po = EventEmitter.getInstance();\n        LambdaFunction TRUE_FUNCTION = (headers, input, instance) -> true;\n        LambdaFunction FALSE_FUNCTION = (headers, input, instance) -> false;\n        platform.register(SERVICE, TRUE_FUNCTION, 1);\n        EventEnvelope request = new EventEnvelope().setTo(SERVICE).setBody("HELLO");\n        po.asyncRequest(request, TIMEOUT).onSuccess(bench::offer);\n        EventEnvelope result = bench.poll(10, TimeUnit.SECONDS);\n        assert result != null;\n        Assert.assertEquals(true, result.getBody());\n        // reload as private\n        platform.registerPrivate(SERVICE, FALSE_FUNCTION, 1);\n        po.asyncRequest(request, TIMEOUT).onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        Assert.assertEquals(false, response.getBody());\n        // convert to public\n        platform.makePublic(SERVICE);\n        platform.release(SERVICE);\n    }\n\n    @Test\n    public void emptyRouteNotAllowed() {{\n        Platform platform = Platform.getInstance();\n        LambdaFunction noOp = (headers, input, instance) -> true;\n        IllegalArgumentException ex = Assert.assertThrows(IllegalArgumentException.class, () ->\n                platform.register("", noOp, 1));\n        Assert.assertEquals("Invalid route name - use 0-9, a-z, period, hyphen or underscore characters",\n                ex.getMessage());\n    }']
preds_chunk= [[-0.09668991 -3.6311393  -3.9394424  -4.5184426  -3.8959157  -4.2005954 ]]
pred_class= [0]
test_x= ['@Test\n    public void checkLocalRouting() {{\n        Platform platform = Platform.getInstance();\n        ConcurrentMap<String, ServiceDef> routes = platform.getLocalRoutingTable();\n        Assert.assertFalse(routes.isEmpty());\n    }']
preds_chunk= [[-3.3317032 -3.927591  -3.8914735 -3.9278271 -0.1444127 -3.2456145]]
pred_class= [4]
test_x= ['@Test\n    public void testExists() throws InterruptedException {\n        BlockingQueue<List<String>> bench = new ArrayBlockingQueue<>(1);\n        Platform platform = Platform.getInstance();\n        EventEmitter po = EventEmitter.getInstance();\n        Assert.assertFalse(po.exists());\n        Assert.assertTrue(po.exists(HELLO_WORLD));\n        Assert.assertFalse(po.exists(HELLO_WORLD, "unknown.service"));\n        Assert.assertFalse(po.exists(HELLO_WORLD, "unknown.1", "unknown.2"));\n        Future<List<String>> asyncResponse1 = po.search(HELLO_WORLD);\n        asyncResponse1.onSuccess(bench::offer);\n        List<String> origins = bench.poll(5, TimeUnit.SECONDS);\n        assert origins != null;\n        Assert.assertTrue(origins.contains(platform.getOrigin()));\n        Future<List<String>> asyncResponse2 = po.search(HELLO_WORLD, true);\n        asyncResponse2.onSuccess(bench::offer);\n        List<String> remoteOrigins = bench.poll(5, TimeUnit.SECONDS);\n        assert remoteOrigins != null;\n        Assert.assertTrue(remoteOrigins.isEmpty());\n        Assert.assertTrue(po.exists(platform.getOrigin()));\n    }\n\n    @Test\n    public void testNonExistRoute() {{\n        EventEmitter po = EventEmitter.getInstance();\n        IOException ex = Assert.assertThrows(IOException.class, () ->\n                po.send("undefined.route", "OK"));\n        Assert.assertEquals("Route undefined.route not found", ex.getMessage());\n    }']
preds_chunk= [[-0.15850371 -2.869568   -3.6539013  -4.2403526  -3.7244575  -3.6715086 ]]
pred_class= [0]
test_x= ['@Test\n    public void cancelFutureEventTest() {{\n        long FIVE_SECONDS = 5000;\n        long now = System.currentTimeMillis();\n        String TRACE_ID = Utility.getInstance().getUuid();\n        EventEmitter po = EventEmitter.getInstance();\n        EventEnvelope event1 = new EventEnvelope().setTo(HELLO_WORLD)\n                .setTraceId(TRACE_ID).setTracePath("GET /1").setBody(1);\n        EventEnvelope event2 = new EventEnvelope().setTo(HELLO_WORLD)\n                .setTraceId(TRACE_ID).setTracePath("GET /2").setBody(2);\n        String id1 = po.sendLater(event1, new Date(now+(FIVE_SECONDS/10)));\n        String id2 = po.sendLater(event2, new Date(now+FIVE_SECONDS));\n        Assert.assertEquals(event1.getId(), id1);\n        Assert.assertEquals(event2.getId(), id2);\n        List<String> future1 = po.getFutureEvents(HELLO_WORLD);\n        Assert.assertEquals(2, future1.size());\n        Assert.assertTrue(future1.contains(id1));\n        Assert.assertTrue(future1.contains(id2));\n        List<String> futureRoutes = po.getAllFutureEvents();\n        Assert.assertTrue(futureRoutes.contains(HELLO_WORLD));\n        Date time = po.getFutureEventTime(id2);\n        long diff = time.getTime() - now;\n        Assert.assertEquals(FIVE_SECONDS, diff);\n        po.cancelFutureEvent(id2);\n        List<String> futureEvents = po.getFutureEvents(HELLO_WORLD);\n        Assert.assertTrue(futureEvents.contains(id1));\n        po.cancelFutureEvent(id1);\n    }']
preds_chunk= [[-3.2891338  -3.6716228  -0.12636027 -4.0239115  -4.2581325  -3.7317913 ]]
pred_class= [2]
test_x= ['@Test\n    public void journalYamlTest() {{\n        String MY_FUNCTION = "my.test.function";\n        String ANOTHER_FUNCTION = "another.function";\n        EventEmitter po = EventEmitter.getInstance();\n        List<String> routes = po.getJournaledRoutes();\n        Assert.assertEquals(2, routes.size());\n        Assert.assertTrue(routes.contains(ANOTHER_FUNCTION));\n        Assert.assertTrue(routes.contains(MY_FUNCTION));\n    }']
preds_chunk= [[-3.367773   -3.8789997  -3.567742   -3.4686644  -0.15307954 -3.5963874 ]]
pred_class= [4]
test_x= ['@Test\n    public void journalTest() throws IOException, InterruptedException {\n        String TRANSACTION_JOURNAL_RECORDER = "transaction.journal.recorder";\n        BlockingQueue<Map<String, Object>> bench = new ArrayBlockingQueue<>(1);\n        Platform platform = Platform.getInstance();\n        String FROM = "unit.test";\n        String HELLO = "hello";\n        String WORLD = "world";\n        String RETURN_VALUE = "some_value";\n        String MY_FUNCTION = "my.test.function";\n        String traceId = Utility.getInstance().getUuid();\n        LambdaFunction f = (headers, input, instance) -> {\n            // guarantee that this function has received the correct trace and journal\n            Map<String, Object> trace = (Map<String, Object>) input;\n            MultiLevelMap map = new MultiLevelMap(trace);\n            if (traceId.equals(map.getElement("trace.id"))) {{\n                bench.offer(trace);\n            }']
preds_chunk= [[-0.15807612 -3.5463884  -3.2033265  -4.052156   -3.4833527  -3.5518823 ]]
pred_class= [0]
test_x= ['@Test\n    public void rpcJournalTest() throws IOException, InterruptedException {\n        String TRANSACTION_JOURNAL_RECORDER = "transaction.journal.recorder";\n        BlockingQueue<Map<String, Object>> bench = new ArrayBlockingQueue<>(1);\n        Platform platform = Platform.getInstance();\n        String FROM = "unit.test";\n        String HELLO = "hello";\n        String WORLD = "world";\n        String RETURN_VALUE = "some_value";\n        String MY_FUNCTION = "my.test.function";\n        String traceId = Utility.getInstance().getUuid();\n        LambdaFunction f = (headers, input, instance) -> {\n            // guarantee that this function has received the correct trace and journal\n            Map<String, Object> trace = (Map<String, Object>) input;\n            MultiLevelMap map = new MultiLevelMap(trace);\n            if (traceId.equals(map.getElement("trace.id"))) {{\n                bench.offer(trace);\n            }']
preds_chunk= [[-0.11465327 -3.7301004  -3.6196656  -4.3271146  -3.6633425  -3.9797459 ]]
pred_class= [0]
test_x= ['@Test\n    public void telemetryTest() throws IOException, InterruptedException {\n        String DISTRIBUTED_TRACE_FORWARDER = "distributed.trace.forwarder";\n        BlockingQueue<Map<String, Object>> bench = new ArrayBlockingQueue<>(1);\n        Platform platform = Platform.getInstance();\n        String FROM = "unit.test";\n        String HELLO = "hello";\n        String WORLD = "world";\n        String RETURN_VALUE = "some_value";\n        String SIMPLE_FUNCTION = "another.simple.function";\n        String traceId = Utility.getInstance().getUuid();\n        LambdaFunction f = (headers, input, instance) -> {\n            // guarantee that this function has received the correct trace\n            Map<String, Object> trace = (Map<String, Object>) input;\n            MultiLevelMap map = new MultiLevelMap(trace);\n            if (traceId.equals(map.getElement("trace.id"))) {{\n                bench.offer(trace);\n            }']
preds_chunk= [[-0.10911547 -3.5633934  -3.7867048  -4.4029408  -3.8138013  -4.0143275 ]]
pred_class= [0]
test_x= ['@Test\n    public void rpcTelemetryTest() throws IOException, InterruptedException {\n        String DISTRIBUTED_TRACE_FORWARDER = "distributed.trace.forwarder";\n        BlockingQueue<Map<String, Object>> bench = new ArrayBlockingQueue<>(1);\n        Platform platform = Platform.getInstance();\n        String FROM = "unit.test";\n        String HELLO = "hello";\n        String WORLD = "world";\n        String RETURN_VALUE = "some_value";\n        String SIMPLE_FUNCTION = "another.simple.function";\n        String traceId = Utility.getInstance().getUuid();\n        LambdaFunction f = (headers, input, instance) -> {\n            // guarantee that this function has received the correct trace\n            Map<String, Object> trace = (Map<String, Object>) input;\n            MultiLevelMap map = new MultiLevelMap(trace);\n            if (traceId.equals(map.getElement("trace.id"))) {{\n                bench.offer(trace);\n            }']
preds_chunk= [[-0.10814147 -3.7081673  -3.7131991  -4.3811665  -3.7482498  -4.0451026 ]]
pred_class= [0]
test_x= ['@Test\n    public void traceHeaderTest() throws IOException, InterruptedException {\n        String TRACE_DETECTOR = "trace.detector";\n        String TRACE_ID = "101";\n        String TRACE_PATH = "GET /api/trace";\n        BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        Platform platform = Platform.getInstance();\n        PostOffice po = new PostOffice("unit.test", TRACE_ID, TRACE_PATH);\n        LambdaFunction f = (headers, input, instance) -> {\n            if (headers.containsKey("my_route") &&\n                    headers.containsKey("my_trace_id") && headers.containsKey("my_trace_path")) {{\n                log.info("Trace detector got {}", headers);\n                return true;\n            }']
preds_chunk= [[-0.10700833 -3.6366246  -3.8794997  -4.402758   -3.7616222  -3.9638429 ]]
pred_class= [0]
test_x= ['@Test\n    public void coroutineTraceHeaderTest() throws IOException, InterruptedException {\n        String COROUTINE_TRACE_DETECTOR = "coroutine.trace.detector";\n        String TRACE_ID = "102";\n        String TRACE_PATH = "GET /api/trace";\n        BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        PostOffice po = new PostOffice("unit.test", TRACE_ID, TRACE_PATH);\n        EventEnvelope request = new EventEnvelope().setTo(COROUTINE_TRACE_DETECTOR).setBody("ok");\n        Future<EventEnvelope> response = po.asyncRequest(request, 5000);\n        response.onSuccess(result -> bench.offer(result));\n        EventEnvelope result = bench.poll(5, TimeUnit.SECONDS);\n        assert result != null;\n        Assert.assertEquals(Boolean.TRUE, result.getBody());\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void broadcastTest() throws IOException, InterruptedException {\n        BlockingQueue<String> bench = new ArrayBlockingQueue<>(1);\n        String CALLBACK = "my.callback";\n        String MESSAGE = "test";\n        String DONE = "done";\n        Platform platform = Platform.getInstance();\n        LambdaFunction callback = (headers, input, instance) -> {\n            if (input instanceof Map) {{\n                if (MESSAGE.equals(((Map<String, Object>) input).get("body"))) {\n                    bench.offer(DONE);\n                }\n            }']
preds_chunk= [[-0.09452225 -3.6931088  -3.9554791  -4.5122294  -3.8963258  -4.2092032 ]]
pred_class= [0]
test_x= ['@Test\n    public void eventHasFromAddress() throws IOException, InterruptedException {\n        String FIRST = "hello.world.one";\n        String SECOND = "hello.world.two";\n        Platform platform = Platform.getInstance();\n        EventEmitter emitter = EventEmitter.getInstance();\n        LambdaFunction f1 = (headers, input, instance) -> {\n            PostOffice po = new PostOffice(headers, instance);\n            po.send(SECOND, true);\n            return Optional.empty();\n        };\n        platform.register(FIRST, f1, 1);\n        platform.register(SECOND, new SimpleInterceptor(), 1);\n        // without tracing\n        emitter.send(FIRST, Optional.empty());\n        String result = interceptorBench.poll(5, TimeUnit.SECONDS);\n        // validate the "from" address\n        Assert.assertEquals(FIRST, result);\n    }\n\n    @Test\n    public void singleRequestWithTimeout() throws IOException, InterruptedException {\n        BlockingQueue<Throwable> bench = new ArrayBlockingQueue<>(1);\n        EventEmitter po = EventEmitter.getInstance();\n        EventEnvelope request = new EventEnvelope().setTo("hello.world").setBody(2);\n        po.asyncRequest(request, 800).onFailure(bench::offer);\n        Throwable ex = bench.poll(10, TimeUnit.SECONDS);\n        assert ex != null;\n        Assert.assertEquals("Timeout for 800 ms", ex.getMessage());\n        Assert.assertEquals(TimeoutException.class, ex.getClass());\n    }\n\n    @Test\n    public void singleRequestWithException() throws IOException, InterruptedException {\n        BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        EventEmitter po = EventEmitter.getInstance();\n        EventEnvelope request = new EventEnvelope().setTo("hello.world").setFrom("unit.test")\n                                    .setTrace("100", "TEST /timeout/exception")\n                                    .setHeader("exception", true).setBody(1);\n        po.asyncRequest(request, 800).onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        Assert.assertEquals(400, response.getStatus());\n        Assert.assertEquals("just a test", response.getError());\n        Assert.assertEquals(AppException.class, response.getException().getClass());\n    }\n\n    @Test\n    @SuppressWarnings("unchecked")\n    public void singleRequest() throws IOException, InterruptedException {\n        BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        int input = 111;\n        EventEmitter po = EventEmitter.getInstance();\n        EventEnvelope request = new EventEnvelope().setTo("hello.world").setHeader("a", "b").setBody(input);\n        po.asyncRequest(request, 800).onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        Assert.assertEquals(HashMap.class, response.getBody().getClass());\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(input, result.get("body"));\n    }\n\n    @Test\n    public void asyncRequestTest() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> success = new ArrayBlockingQueue<>(1);\n        final String SERVICE = "hello.future.1";\n        final String TEXT = "hello world";\n        final Platform platform = Platform.getInstance();\n        final EventEmitter po = EventEmitter.getInstance();\n        final LambdaFunction f = (headers, input, instance) -> input;\n        platform.registerPrivate(SERVICE, f, 1);\n        EventEnvelope request = new EventEnvelope().setTo(SERVICE)\n                                    .setBody(TEXT).setTrace("1030", "TEST /api/async/request");\n        Future<EventEnvelope> future = po.asyncRequest(request, 1500);\n        future.onSuccess(event -> {\n            platform.release(SERVICE);\n            success.offer(event);\n        });\n        EventEnvelope result = success.poll(5, TimeUnit.SECONDS);\n        Assert.assertNotNull(result);\n        Assert.assertEquals(200, result.getStatus());\n        Assert.assertEquals(TEXT, result.getBody());\n    }\n\n    @Test\n    public void futureExceptionAsResult() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> completion = new ArrayBlockingQueue<>(1);\n        int STATUS = 400;\n        String ERROR = "some exception";\n        String SERVICE = "hello.future.3";\n        String TEXT = "hello world";\n        Platform platform = Platform.getInstance();\n        EventEmitter po = EventEmitter.getInstance();\n        LambdaFunction f = (headers, input, instance) -> {\n            throw new AppException(STATUS, ERROR);\n        };\n        platform.registerPrivate(SERVICE, f, 1);\n        Future<EventEnvelope> future = po.asyncRequest(new EventEnvelope().setTo(SERVICE).setBody(TEXT), 5000);\n        future.onSuccess(event -> {\n            platform.release(SERVICE);\n            completion.offer(event);\n        });\n        EventEnvelope result = completion.poll(5, TimeUnit.SECONDS);\n        Assert.assertNotNull(result);\n        Assert.assertEquals(STATUS, result.getStatus());\n        Assert.assertEquals(ERROR, result.getBody());\n    }\n\n    @Test\n    public void asyncForkJoinTest() throws IOException, InterruptedException {\n        final BlockingQueue<List<EventEnvelope>> success = new ArrayBlockingQueue<>(1);\n        final String from = "unit.test";\n        final String traceId = "1020";\n        final String tracePath = "TEST /async/fork-n-join";\n        final String SERVICE = "hello.future.3";\n        final String TEXT = "hello world";\n        final int PARALLEL_INSTANCES = 5;\n        final Platform platform = Platform.getInstance();\n        final EventEmitter po = EventEmitter.getInstance();\n        final LambdaFunction f1 = (headers, input, instance) -> input;\n        platform.registerPrivate(SERVICE, f1, PARALLEL_INSTANCES);\n        List<EventEnvelope> requests = new ArrayList<>();\n        for (int i=1; i < PARALLEL_INSTANCES + 1; i++) {{\n            EventEnvelope req = new EventEnvelope().setTo(SERVICE).setBody(TEXT + "." + i)\n                                    .setFrom(from).setTrace(traceId, tracePath);\n            requests.add(req);\n        }']
preds_chunk= [[-0.10340612 -3.4530287  -3.934851   -4.506312   -3.8984318  -4.1522913 ]]
pred_class= [0]
test_x= ['@Test\n    public void asyncForkJoinTimeoutTest() throws IOException, InterruptedException {\n        final long TIMEOUT = 500;\n        final BlockingQueue<Throwable> exception = new ArrayBlockingQueue<>(1);\n        final String SERVICE = "hello.future.4";\n        final String TEXT = "hello world";\n        final int PARALLEL_INSTANCES = 5;\n        final Platform platform = Platform.getInstance();\n        final EventEmitter po = EventEmitter.getInstance();\n        final LambdaFunction f1 = (headers, input, instance) -> {\n            log.info("Received event {}, {}", headers, input);\n            return input;\n        };\n        platform.registerPrivate(SERVICE, f1, PARALLEL_INSTANCES);\n        List<EventEnvelope> requests = new ArrayList<>();\n        for (int i=1; i <= PARALLEL_INSTANCES; i++) {{\n            requests.add(new EventEnvelope().setTo(SERVICE).setBody(TEXT + "." + i)\n                            .setHeader("timeout_exception", true)\n                            .setHeader("seq", i));\n        }']
preds_chunk= [[-0.19767833 -2.4527123  -3.5975764  -4.1508875  -3.6793373  -3.691837  ]]
pred_class= [0]
test_x= ['@Test\n    public void asyncForkJoinPartialResultTest() throws IOException, InterruptedException {\n        final long TIMEOUT = 800;\n        final BlockingQueue<List<EventEnvelope>> result = new ArrayBlockingQueue<>(1);\n        final String SERVICE = "hello.future.5";\n        final String TEXT = "hello world";\n        final int PARALLEL_INSTANCES = 5;\n        final Platform platform = Platform.getInstance();\n        final EventEmitter po = EventEmitter.getInstance();\n        final LambdaFunction f1 = (headers, input, instance) -> {\n            log.info("Received event {}, {}", headers, input);\n            return input;\n        };\n        platform.registerPrivate(SERVICE, f1, PARALLEL_INSTANCES);\n        List<EventEnvelope> requests = new ArrayList<>();\n        for (int i=1; i <= PARALLEL_INSTANCES; i++) {{\n            requests.add(new EventEnvelope().setTo(SERVICE).setBody(TEXT + "." + i)\n                    .setHeader("partial_result", true)\n                    .setHeader("seq", i));\n        }']
preds_chunk= [[-0.13862848 -2.968676   -3.7821727  -4.332213   -3.7943952  -3.928705  ]]
pred_class= [0]
test_x= ['@Test\n    public void nonBlockingRpcTest() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        final String HELLO_WORLD = "hello world";\n        EventEnvelope request = new EventEnvelope().setTo("long.running.rpc.alias").setBody(HELLO_WORLD)\n                        .setHeader("timeout", 2000)\n                        .setTrace("10000", "/api/non-blocking/rpc").setFrom("unit.test");\n        EventEmitter.getInstance().asyncRequest(request, 5000).onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        MultiLevelMap map = new MultiLevelMap((Map<String, Object>) response.getBody());\n        Assert.assertEquals(2, map.getElement("body"));\n        Assert.assertEquals(HELLO_WORLD, map.getElement("headers.body"));\n    }\n\n    @Test\n    public void nonBlockingRpcTimeoutTest() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        final String HELLO_WORLD = "hello world";\n        EventEnvelope request = new EventEnvelope().setTo("long.running.rpc.alias").setBody(HELLO_WORLD)\n                .setHeader("timeout", 500)\n                .setTrace("10001", "/api/non-blocking/rpc").setFrom("unit.test");\n        /*\n         * Since it is the nested service that throws TimeoutException,\n         * the exception is transported as a regular response event.\n         */\n        EventEmitter.getInstance().asyncRequest(request, 5000).onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        Assert.assertEquals(408, response.getStatus());\n        Assert.assertEquals("Timeout for 500 ms", response.getError());\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void nonBlockingForkAndJoinTest() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        final String FORK_N_JOIN = "fork-n-join";\n        final String HELLO_WORLD = "hello world";\n        EventEnvelope request = new EventEnvelope().setTo("long.running.rpc").setBody(HELLO_WORLD)\n                .setFrom("unit.test")\n                .setHeader(FORK_N_JOIN, true)\n                .setHeader("timeout", 2000)\n                .setTrace("20000", "/api/non-blocking/fork-n-join");\n        EventEmitter.getInstance().asyncRequest(request, 5000).onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        MultiLevelMap map = new MultiLevelMap((Map<String, Object>) response.getBody());\n        Assert.assertEquals(4, map.getMap().size());\n        Assert.assertEquals(0, map.getElement("cid-0.body"));\n        Assert.assertEquals(HELLO_WORLD, map.getElement("cid-0.headers.body"));\n        Assert.assertEquals("true", map.getElement("cid-0.headers." + FORK_N_JOIN));\n        Assert.assertEquals(1, map.getElement("cid-1.body"));\n        Assert.assertEquals(HELLO_WORLD, map.getElement("cid-1.headers.body"));\n        Assert.assertEquals("true", map.getElement("cid-1.headers." + FORK_N_JOIN));\n        Assert.assertEquals(2, map.getElement("cid-2.body"));\n        Assert.assertEquals(HELLO_WORLD, map.getElement("cid-2.headers.body"));\n        Assert.assertEquals("true", map.getElement("cid-2.headers." + FORK_N_JOIN));\n        Assert.assertEquals(3, map.getElement("cid-3.body"));\n        Assert.assertEquals(HELLO_WORLD, map.getElement("cid-3.headers.body"));\n        Assert.assertEquals("true", map.getElement("cid-3.headers." + FORK_N_JOIN));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void nonBlockingForkAndJoinTimeoutTest() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        final String FORK_N_JOIN = "fork-n-join";\n        final String HELLO_WORLD = "hello world";\n        EventEnvelope request = new EventEnvelope().setTo("long.running.rpc").setBody(HELLO_WORLD)\n                .setFrom("unit.test")\n                .setHeader(FORK_N_JOIN, true)\n                .setHeader("timeout", 500)\n                .setTrace("20000", "/api/non-blocking/fork-n-join");\n        EventEmitter.getInstance().asyncRequest(request, 5000).onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        MultiLevelMap map = new MultiLevelMap((Map<String, Object>) response.getBody());\n        // since 2 requests will time out with artificial delay of one second, there will only be 2 responses.\n        Assert.assertEquals(2, map.getMap().size());\n        Assert.assertEquals(1, map.getElement("cid-1.body"));\n        Assert.assertEquals(HELLO_WORLD, map.getElement("cid-1.headers.body"));\n        Assert.assertEquals("true", map.getElement("cid-1.headers." + FORK_N_JOIN));\n        Assert.assertEquals(3, map.getElement("cid-3.body"));\n        Assert.assertEquals(HELLO_WORLD, map.getElement("cid-3.headers.body"));\n        Assert.assertEquals("true", map.getElement("cid-3.headers." + FORK_N_JOIN));\n    }\n\n    @Test\n    @SuppressWarnings("unchecked")\n    public void multilevelTrace() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        final String ROUTE_ONE = "hello.level.1";\n        final String ROUTE_TWO = "hello.level.2";\n        final String TRACE_ID = "cid-123456";\n        final String TRACE_PATH = "GET /api/hello/world";\n        Platform platform = Platform.getInstance();\n        LambdaFunction tier2 = (headers, input, instance) -> {\n            PostOffice po = new PostOffice(headers, instance);\n            Assert.assertEquals(ROUTE_TWO, po.getRoute());\n            Assert.assertEquals(TRACE_ID, po.getTraceId());\n            // annotations are local to a service and should not be transported to the next service\n            Assert.assertTrue(po.getTrace().annotations.isEmpty());\n            return po.getTraceId();\n        };\n        platform.register(ROUTE_TWO, tier2, 1);\n        // test tracing to 2 levels\n        String testMessage = "some message";\n        EventEnvelope event = new EventEnvelope();\n        event.setTo(ROUTE_ONE).setHeader("hello", "world").setBody(testMessage);\n        event.setTrace(TRACE_ID, TRACE_PATH).setFrom("unit.test");\n        EventEmitter po = EventEmitter.getInstance();\n        po.asyncRequest(event, 5000).onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        Assert.assertEquals(HashMap.class, response.getBody().getClass());\n        MultiLevelMap map = new MultiLevelMap((Map<String, Object>) response.getBody());\n        Assert.assertEquals("world", map.getElement("headers.hello"));\n        Assert.assertEquals(testMessage, map.getElement("body"));\n        Assert.assertEquals(TRACE_ID, map.getElement("trace_id"));\n        Assert.assertEquals(TRACE_PATH, map.getElement("trace_path"));\n        Assert.assertEquals(ROUTE_ONE, map.getElement("route_one"));\n    }\n\n    @Test\n    @SuppressWarnings("unchecked")\n    public void routeSubstitution() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        int input = 111;\n        EventEmitter po = EventEmitter.getInstance();\n        // with route substitution in the application.properties, hello.test will route to hello.world\n        EventEnvelope request = new EventEnvelope().setTo("hello.test").setBody(input);\n        po.asyncRequest(request, 800).onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        Assert.assertEquals(HashMap.class, response.getBody().getClass());\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(input, result.get("body"));\n        Map<String, String> list = po.getRouteSubstitutionList();\n        Assert.assertTrue(list.containsKey("hello.test"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void healthTest() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        Platform platform = Platform.getInstance();\n        EventEmitter po = EventEmitter.getInstance();\n        EventEnvelope request = new EventEnvelope().setTo(EventEmitter.ACTUATOR_SERVICES).setHeader("type" ,"health");\n        po.asyncRequest(request, 5000).onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> map = (Map<String, Object>) response.getBody();\n        Assert.assertEquals("UP", map.get("status"));\n        Assert.assertEquals("platform-core", map.get("name"));\n        Assert.assertEquals(platform.getOrigin(), map.get("origin"));\n        Object upstream = map.get("upstream");\n        Assert.assertTrue(upstream instanceof List);\n        List<Map<String, Object>> upstreamList = (List<Map<String, Object>>) upstream;\n        Assert.assertEquals(1, upstreamList.size());\n        Map<String, Object> health = upstreamList.get(0);\n        Assert.assertEquals("mock.connector", health.get("service"));\n        Assert.assertEquals("mock.topic", health.get("topics"));\n        Assert.assertEquals("fine", health.get("message"));\n        Assert.assertEquals("true", health.get("required").toString());\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void infoTest() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        EventEmitter po = EventEmitter.getInstance();\n        EventEnvelope request = new EventEnvelope().setTo(EventEmitter.ACTUATOR_SERVICES).setHeader("type" ,"info");\n        po.asyncRequest(request, 5000).onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertTrue(result.containsKey("app"));\n        Assert.assertTrue(result.containsKey("memory"));\n        Assert.assertTrue(result.containsKey("personality"));\n        Assert.assertTrue(result.containsKey("vm"));\n        Assert.assertTrue(result.containsKey("streams"));\n        Assert.assertTrue(result.containsKey("origin"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void libTest() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        EventEmitter po = EventEmitter.getInstance();\n        EventEnvelope request = new EventEnvelope().setTo(EventEmitter.ACTUATOR_SERVICES).setHeader("type" ,"lib");\n        po.asyncRequest(request, 5000).onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertTrue(result.containsKey("app"));\n        Assert.assertTrue(result.containsKey("library"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void infoRouteTest() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        String MY_FUNCTION = "my.test.function";\n        String ANOTHER_FUNCTION = "another.function";\n        EventEmitter po = EventEmitter.getInstance();\n        EventEnvelope request = new EventEnvelope().setTo(EventEmitter.ACTUATOR_SERVICES).setHeader("type" ,"routes");\n        po.asyncRequest(request, 5000).onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        MultiLevelMap multi = new MultiLevelMap((Map<String, Object>) response.getBody());\n        Object journalRoutes = multi.getElement("journal");\n        Assert.assertTrue(journalRoutes instanceof List);\n        List<String> routes = (List<String>) journalRoutes;\n        Assert.assertTrue(routes.contains(MY_FUNCTION));\n        Assert.assertTrue(routes.contains(ANOTHER_FUNCTION));\n    }\n\n    @Test\n    public void livenessProbeTest() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        EventEmitter po = EventEmitter.getInstance();\n        EventEnvelope request = new EventEnvelope()\n                                    .setTo(EventEmitter.ACTUATOR_SERVICES).setHeader("type" ,"livenessprobe");\n        po.asyncRequest(request, 5000).onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        Assert.assertEquals("OK", response.getBody());\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void envTest() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        EventEmitter po = EventEmitter.getInstance();\n        EventEnvelope request = new EventEnvelope()\n                .setTo(EventEmitter.ACTUATOR_SERVICES).setHeader("type" ,"env");\n        po.asyncRequest(request, 5000).onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertTrue(result.containsKey("app"));\n        Assert.assertTrue(result.containsKey("routing"));\n        Assert.assertTrue(result.containsKey("env"));\n    }\n\n    @Test\n    public void resumeTest() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        final String USER = "user";\n        final String WHEN = "when";\n        EventEmitter po = EventEmitter.getInstance();\n        EventEnvelope request = new EventEnvelope()\n                .setTo(EventEmitter.ACTUATOR_SERVICES).setHeader("type" ,"resume")\n                .setHeader(USER, "someone").setHeader(WHEN, "now");\n        po.asyncRequest(request, 5000).onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        Assert.assertEquals(false, response.getBody());\n    }\n\n    @Test\n    public void envelopeAsResponseTest() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        String TARGET = "test.route.1";\n        String MESSAGE = "hello world";\n        EventEmitter po = EventEmitter.getInstance();\n        Platform.getInstance().register(TARGET, new EventEnvelopeReader(), 1);\n        EventEnvelope request = new EventEnvelope().setTo(TARGET).setBody(MESSAGE);\n        po.asyncRequest(request, 5000).onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        Assert.assertEquals(MESSAGE, response.getBody());\n    }\n\n    @Test\n    public void threadPoolTest() throws IOException, InterruptedException {\n        final int CYCLES = 200;\n        final int WORKER_POOL = 50;\n        final ConcurrentMap<Long, Boolean> threads = new ConcurrentHashMap<>();\n        final BlockingQueue<Boolean> bench = new ArrayBlockingQueue<>(1);\n        final AtomicInteger counter = new AtomicInteger(0);\n        final AtomicLong last = new AtomicLong(0);\n        String MULTI_CORES = "multi.cores";\n        LambdaFunction f= (headers, input, instance) -> {\n            int n = counter.incrementAndGet();\n            long id = Thread.currentThread().getId();\n            log.debug("Instance #{}, count={}, thread #{} {}", instance, n, id, input);\n            threads.put(id, true);\n            if (n == CYCLES) {{\n                last.set(System.currentTimeMillis());\n                bench.offer(true);\n            }']
preds_chunk= [[-0.09648362 -3.6697283  -3.9536788  -4.5168366  -3.866888   -4.1694446 ]]
pred_class= [0]
test_x= ['@Test\n    public void testCallBackEventHandler() throws IOException, InterruptedException {\n        final BlockingQueue<Object> bench = new ArrayBlockingQueue<>(1);\n        String TRACE_ID = "10000";\n        String HELLO = "hello";\n        String POJO_HAPPY_CASE = "pojo.happy.case.1";\n        String SIMPLE_CALLBACK = "simple.callback.1";\n        Platform platform = Platform.getInstance();\n        EventEmitter po = EventEmitter.getInstance();\n        LambdaFunction f = (headers, input, instance) -> {\n            PoJo pojo = new PoJo();\n            pojo.setName((String) input);\n            return pojo;\n        };\n        platform.registerPrivate(POJO_HAPPY_CASE, f, 1);\n        platform.registerPrivate(SIMPLE_CALLBACK, new SimpleCallback(bench, TRACE_ID), 1);\n        po.send(new EventEnvelope().setTo(POJO_HAPPY_CASE).setReplyTo(SIMPLE_CALLBACK).setBody(HELLO)\n                        .setFrom("unit.test").setTrace(TRACE_ID, "HAPPY /10000"));\n        Object result = bench.poll(10, TimeUnit.SECONDS);\n        Assert.assertNotNull(result);\n        Assert.assertEquals(PoJo.class, result.getClass());\n        Assert.assertEquals(HELLO, ((PoJo) result).getName());\n        platform.release(POJO_HAPPY_CASE);\n        platform.release(SIMPLE_CALLBACK);\n    }\n\n    @Test\n    public void testCallBackCastingException() throws IOException, InterruptedException {\n        final BlockingQueue<Object> bench = new ArrayBlockingQueue<>(1);\n        String TRACE_ID = "30000";\n        String HELLO = "hello";\n        String POJO_ERROR_CASE = "pojo.error.case.3";\n        String SIMPLE_CALLBACK = "simple.callback.3";\n        Platform platform = Platform.getInstance();\n        EventEmitter po = EventEmitter.getInstance();\n        LambdaFunction f = (headers, input, instance) -> HELLO;\n        platform.registerPrivate(POJO_ERROR_CASE, f, 1);\n        platform.registerPrivate(SIMPLE_CALLBACK, new SimpleCallback(bench, TRACE_ID), 1);\n        po.send(new EventEnvelope().setTo(POJO_ERROR_CASE).setReplyTo(SIMPLE_CALLBACK).setBody(HELLO)\n                .setTrace(TRACE_ID, "CAST /30000"));\n        Object result = bench.poll(10, TimeUnit.SECONDS);\n        Assert.assertNotNull(result);\n        Assert.assertEquals(AppException.class, result.getClass());\n        AppException ex = (AppException) result;\n        Assert.assertEquals(500, ex.getStatus());\n        Assert.assertTrue(ex.getMessage().contains("cannot be cast to"));\n        platform.release(POJO_ERROR_CASE);\n        platform.release(SIMPLE_CALLBACK);\n    }\n\n    @Test\n    public void testInputObjectMapping() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        String TRACE_ID = "101010";\n        String TRACE_PATH = "TEST /api/hello/input/mapping";\n        String AUTO_MAPPING = "hello.input.mapping";\n        String HELLO_WORLD = "hello world";\n        Date now = new Date();\n        LocalDateTime time = Instant.ofEpochMilli(now.getTime()).atZone(ZoneId.systemDefault()).toLocalDateTime();\n        EventEmitter po = EventEmitter.getInstance();\n        // prove that two PoJo are compatible when sending data fields that intersect\n        PoJoSubset minimalData = new PoJoSubset();\n        minimalData.setName(HELLO_WORLD);\n        minimalData.setDate(now);\n        minimalData.setTime(time);\n        EventEnvelope request = new EventEnvelope().setTo(AUTO_MAPPING).setBody(minimalData)\n                                .setTrace(TRACE_ID,TRACE_PATH).setFrom("unit.test");\n        po.asyncRequest(request, 5000).onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        Assert.assertEquals(PoJo.class, response.getBody().getClass());\n        PoJo pojo = (PoJo) response.getBody();\n        Assert.assertEquals(now, pojo.getDate());\n        Assert.assertEquals(time, pojo.getTime());\n        Assert.assertEquals(HELLO_WORLD, pojo.getName());\n        // default values in PoJo\n        Assert.assertEquals(0, pojo.getNumber());\n        Assert.assertEquals(0L, pojo.getLongNumber());\n        // the demo function is designed to return its function execution types\n        Assert.assertEquals("false", response.getHeader("coroutine"));\n        Assert.assertEquals("false", response.getHeader("suspend"));\n        Assert.assertEquals("false", response.getHeader("interceptor"));\n        Assert.assertEquals("true", response.getHeader("tracing"));\n        // the demo function will also echo the READ only route, trace ID and path\n        Assert.assertEquals(AUTO_MAPPING, response.getHeader("route"));\n        Assert.assertEquals(TRACE_ID, response.getHeader("trace_id"));\n        Assert.assertEquals(TRACE_PATH, response.getHeader("trace_path"));\n        // the system will filter out reserved metadata - my_route, my_trace_id, my_trace_path\n        Assert.assertNull(response.getHeader("my_route"));\n        Assert.assertNull(response.getHeader("my_trace_id"));\n        Assert.assertNull(response.getHeader("my_trace_path"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void testPrimitiveTransport() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        String HELLO_WORLD = "hello.world";\n        int number = 101;\n        EventEmitter po = EventEmitter.getInstance();\n        EventEnvelope request = new EventEnvelope().setTo(HELLO_WORLD).setBody(number);\n        po.asyncRequest(request, 5000).onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        Map<String, Object> map = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(number, map.get("body"));\n        Date now = new Date();\n        request = new EventEnvelope().setTo(HELLO_WORLD).setBody(now);\n        po.asyncRequest(request, 5000).onSuccess(bench::offer);\n        response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        map = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(Utility.getInstance().date2str(now), map.get("body"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void testCustomSerializer() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        PostOffice po = new PostOffice("custom.serializer.test",\n                "10108", "/custom/serializer", new JacksonSerializer());\n        SimplePoJo pojo = new SimplePoJo();\n        pojo.name = "hello";\n        pojo.address = "world";\n        pojo.telephone = 12345678;\n        // test java user function\n        EventEnvelope request1 = new EventEnvelope().setTo("custom.serializer.service.java").setBody(pojo);\n        po.asyncRequest(request1, 5000).onSuccess(bench::offer);\n        EventEnvelope result1 = bench.poll(5, TimeUnit.SECONDS);\n        assert result1 != null;\n        Assert.assertTrue(result1.getBody() instanceof Map);\n        Map<String, Object> data1 = (Map<String, Object>) result1.getBody();\n        Assert.assertEquals(pojo.name, data1.get("name"));\n        Assert.assertEquals(pojo.address, data1.get("address"));\n        Assert.assertEquals(pojo.telephone, data1.get("telephone"));\n        SimplePoJo responsePoJo1 = po.getResponseBodyAsPoJo(result1, SimplePoJo.class);\n        Assert.assertEquals(pojo.name, responsePoJo1.name);\n        Assert.assertEquals(pojo.address, responsePoJo1.address);\n        Assert.assertEquals(pojo.telephone, responsePoJo1.telephone);\n        // test kotlin user function\n        EventEnvelope request2 = new EventEnvelope().setTo("custom.serializer.service.kotlin").setBody(pojo);\n        po.asyncRequest(request2, 5000).onSuccess(bench::offer);\n        EventEnvelope result2 = bench.poll(5, TimeUnit.SECONDS);\n        assert result2 != null;\n        Assert.assertTrue(result2.getBody() instanceof Map);\n        Map<String, Object> data2 = (Map<String, Object>) result2.getBody();\n        Assert.assertEquals(pojo.name, data2.get("name"));\n        Assert.assertEquals(pojo.address, data2.get("address"));\n        Assert.assertEquals(pojo.telephone, data2.get("telephone"));\n        SimplePoJo responsePoJo2 = po.getResponseBodyAsPoJo(result2, SimplePoJo.class);\n        Assert.assertEquals(pojo.name, responsePoJo2.name);\n        Assert.assertEquals(pojo.address, responsePoJo2.address);\n        Assert.assertEquals(pojo.telephone, responsePoJo2.telephone);\n    }\n\n    private static class SimpleCallback implements TypedLambdaFunction<PoJo, Void>, PoJoMappingExceptionHandler {\n\n        private final BlockingQueue<Object> bench;\n        private final String traceId;\n\n        public SimpleCallback(BlockingQueue<Object> bench, String traceId) {{\n            this.bench = bench;\n            this.traceId = traceId;\n        }']
preds_chunk= [[-0.14825296 -2.8843794  -3.7351418  -4.3103104  -3.7794337  -3.8275528 ]]
pred_class= [0]
test_x= ['@Test\n    public void expiryTest() throws IOException, InterruptedException {\n        final BlockingQueue<Boolean> bench = new ArrayBlockingQueue<>(1);\n        Utility util = Utility.getInstance();\n        String TEXT = "hello world";\n        // The minimum timeout is one second if you set it to a smaller value\n        ObjectStreamIO unused = new ObjectStreamIO(0);\n        Assert.assertEquals(1, unused.getExpirySeconds());\n        String unusedStream = unused.getInputStreamId().substring(0, unused.getInputStreamId().indexOf(\'@\'));\n        // create a stream with 5 second expiry\n        ObjectStreamIO stream = new ObjectStreamIO(5);\n        ObjectStreamWriter out = new ObjectStreamWriter(stream.getOutputStreamId());\n        out.write(TEXT);\n        Map<String, Object> info = ObjectStreamIO.getStreamInfo();\n        Assert.assertNotNull(info.get("count"));\n        int count = util.str2int(info.get("count").toString());\n        Assert.assertTrue(count > 0);\n        String id = stream.getInputStreamId().substring(0, stream.getInputStreamId().indexOf(\'@\'));\n        Assert.assertTrue(info.containsKey(id));\n        AsyncObjectStreamReader in = new AsyncObjectStreamReader(stream.getInputStreamId(), 5000);\n        in.get().onSuccess(data -> {\n            Assert.assertEquals(TEXT, data);\n            bench.offer(true);\n        });\n        bench.poll(10, TimeUnit.SECONDS);\n        // The stream is intentionally left open\n        Thread.sleep(1100);\n        /*\n         * The system will check expired streams every 30 seconds\n         * To avoid waiting it in a unit test, we force it to remove expired streams\n         */\n        ObjectStreamIO.checkExpiredStreams();\n        Map<String, Object> allStreams = ObjectStreamIO.getStreamInfo();\n        // the unused stream has already expired\n        Assert.assertFalse(allStreams.containsKey(unusedStream));\n        log.info("{} has expired", unusedStream);\n        // The stream has not yet expired\n        Assert.assertTrue(allStreams.containsKey(id));\n        log.info("{} is still active", id);\n        // Sleep past the 5-second mark\n        Thread.sleep(4000);\n        ObjectStreamIO.checkExpiredStreams();\n        allStreams = ObjectStreamIO.getStreamInfo();\n        // It should be gone at this point\n        Assert.assertFalse(allStreams.containsKey(id));\n    }\n\n    @Test\n    public void asyncReadWrite() throws IOException, InterruptedException {\n        int CYCLES = 10;\n        String TEXT = "hello world";\n        /*\n         * Producer creates a new stream with 60 seconds inactivity expiry\n         */\n        ObjectStreamIO stream = new ObjectStreamIO(1);\n        log.info("Using {}", stream.getInputStreamId());\n        // Closing an output stream will send an EOF signal. The try auto-close will do this.\n        try (ObjectStreamWriter out = new ObjectStreamWriter(stream.getOutputStreamId())) {{\n            for (int i = 0; i < CYCLES; i++) {\n                out.write(TEXT + " " + i);\n            }\n        }']
preds_chunk= [[-0.29021963 -2.007647   -3.2818747  -3.9214964  -3.61156    -3.404676  ]]
pred_class= [0]
test_x= ['@Test\n    public void verifyThatJaxRsExampleIsThere() {{\n        AppConfigReader reader = AppConfigReader.getInstance();\n        String value = reader.getProperty("jaxrs.example.enabled");\n        Assert.assertEquals("true", value);\n        Object helloWorld = reader.get("hello.world.array");\n        Assert.assertTrue(helloWorld instanceof List);\n    }']
preds_chunk= [[-2.7091992  -2.9983299  -2.8519375  -1.3638731  -0.68212485 -2.7395885 ]]
pred_class= [4]
test_x= ['@Test\n    public void infoEndpointTest() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/info", headers);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        MultiLevelMap multi = new MultiLevelMap(result);\n        Assert.assertEquals("rest-spring", multi.getElement("app.name"));\n        Assert.assertEquals("APP", multi.getElement("personality"));\n        Assert.assertEquals(Platform.getInstance().getOrigin(), multi.getElement("origin"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void remoteInfoEndpointTest() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        headers.put("x-app-instance", "does-not-exist");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/info", headers);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(404, response.getStatus());\n        Assert.assertEquals(404, result.get("status"));\n        Assert.assertEquals("does-not-exist is not reachable", result.get("message"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void libEndpointTest() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/info/lib", headers);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        MultiLevelMap multi = new MultiLevelMap(result);\n        Assert.assertEquals("rest-spring", multi.getElement("app.name"));\n        Assert.assertTrue(result.containsKey("library"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void remoteLibEndpointTest() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        headers.put("x-app-instance", "does-not-exist");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/info/lib", headers);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(404, response.getStatus());\n        Assert.assertEquals(404, result.get("status"));\n        Assert.assertEquals("does-not-exist is not reachable", result.get("message"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void routeEndpointTest() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/info/routes", headers);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        MultiLevelMap multi = new MultiLevelMap(result);\n        Assert.assertEquals("rest-spring", multi.getElement("app.name"));\n        Object o = result.get("route_substitution");\n        Assert.assertTrue(o instanceof Map);\n        Map<String, Object> substitution = (Map<String, Object>) o;\n        Assert.assertEquals("hello.world", substitution.get("hello.test"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void remoteRouteEndpointTest() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        headers.put("x-app-instance", "does-not-exist");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/info/routes", headers);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(404, response.getStatus());\n        Assert.assertEquals(404, result.get("status"));\n        Assert.assertEquals("does-not-exist is not reachable", result.get("message"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void healthEndpointTest() throws IOException, InterruptedException {\n        String MESSAGE = "Did you forget to define mandatory.health.dependencies or optional.health.dependencies";\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/health", headers);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals("UP", result.get("status"));\n        Assert.assertEquals(MESSAGE, result.get("message"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void protectedEndpointTest() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        EventEnvelope response = httpGet("http://localhost:"+port, "/health", headers);\n        assert response != null;\n        Assert.assertEquals(404, response.getStatus());\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(404, result.get("status"));\n        Assert.assertEquals("Resource not found", result.get("message"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void remoteHealthEndpointTest() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        headers.put("x-app-instance", "does-not-exist");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/health", headers);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(404, response.getStatus());\n        Assert.assertEquals(404, result.get("status"));\n        Assert.assertEquals("does-not-exist is not reachable", result.get("message"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void uriPathSecurityTest() throws IOException, InterruptedException {\n        String url = "/api/hello/world moved to https://evil.site?hello world=abc";\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        EventEnvelope response = httpGet("http://localhost:"+port, url, headers);\n        assert response != null;\n        Assert.assertEquals(404, response.getStatus());\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> error = (Map<String, Object>) response.getBody();\n        Assert.assertEquals("/api/hello/world moved to https", error.get("path"));\n    }\n\n    @Test\n    public void livenessEndpointTest() throws IOException, InterruptedException {\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/livenessprobe", null);\n        Assert.assertEquals("OK", response.getBody());\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void remoteLivenessEndpointTest() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        headers.put("x-app-instance", "does-not-exist");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/livenessprobe", headers);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(404, response.getStatus());\n        Assert.assertEquals(404, result.get("status"));\n        Assert.assertEquals("does-not-exist is not reachable", result.get("message"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void envEndpointTest() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/env", headers);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        MultiLevelMap multi = new MultiLevelMap(result);\n        Assert.assertEquals("rest-spring", multi.getElement("app.name"));\n        Assert.assertTrue(result.get("env") instanceof Map);\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void remoteEnvEndpointTest() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        headers.put("x-app-instance", "does-not-exist");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/env", headers);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(404, response.getStatus());\n        Assert.assertEquals(404, result.get("status"));\n        Assert.assertEquals("does-not-exist is not reachable", result.get("message"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void shutdownUsingGetWillFail() throws IOException, InterruptedException {\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/shutdown", null);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(404, response.getStatus());\n        Assert.assertEquals(404, result.get("status"));\n        Assert.assertEquals("Not Found", result.get("message"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void suspendUsingGetWillFail() throws IOException, InterruptedException {\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/suspend", null);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(404, response.getStatus());\n        Assert.assertEquals(404, result.get("status"));\n        Assert.assertEquals("Not Found", result.get("message"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void resumeUsingGetWillFail() throws IOException, InterruptedException {\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/resume", null);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(404, response.getStatus());\n        Assert.assertEquals(404, result.get("status"));\n        Assert.assertEquals("Not Found", result.get("message"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void shutdownWithoutAppInstanceWillFail() throws IOException, InterruptedException {\n        EventEnvelope response = httpPost("http://127.0.0.1:"+port, "/shutdown", null, new HashMap<>());\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(400, response.getStatus());\n        Assert.assertEquals(400, result.get("status"));\n        Assert.assertEquals("Missing X-App-Instance in request header", result.get("message"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void shutdownWithIncorrectAppInstanceWillFail() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        headers.put("x-app-instance", "does-not-exist");\n        EventEnvelope response = httpPost("http://127.0.0.1:"+port, "/shutdown", headers, new HashMap<>());\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(404, response.getStatus());\n        Assert.assertEquals(404, result.get("status"));\n        Assert.assertEquals("does-not-exist is not reachable", result.get("message"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void suspendWithoutAppInstanceWillFail() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        EventEnvelope response = httpPost("http://127.0.0.1:"+port, "/suspend", headers, new HashMap<>());\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(400, response.getStatus());\n        Assert.assertEquals(400, result.get("status"));\n        Assert.assertEquals("Missing X-App-Instance in request header", result.get("message"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void suspendWithIncorrectAppInstanceWillFail() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        headers.put("x-app-instance", "does-not-exist");\n        EventEnvelope response = httpPost("http://127.0.0.1:"+port, "/suspend", headers, new HashMap<>());\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(404, response.getStatus());\n        Assert.assertEquals(404, result.get("status"));\n        Assert.assertEquals("does-not-exist is not reachable", result.get("message"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void resumeWithoutAppInstanceWillFail() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        EventEnvelope response = httpPost("http://127.0.0.1:"+port, "/resume", headers, new HashMap<>());\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(400, response.getStatus());\n        Assert.assertEquals(400, result.get("status"));\n        Assert.assertEquals("Missing X-App-Instance in request header", result.get("message"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void resumeWithIncorrectAppInstanceWillFail() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        headers.put("x-app-instance", "does-not-exist");\n        EventEnvelope response = httpPost("http://127.0.0.1:"+port, "/resume", headers, new HashMap<>());\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(404, response.getStatus());\n        Assert.assertEquals(404, result.get("status"));\n        Assert.assertEquals("does-not-exist is not reachable", result.get("message"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void suspendAppInstanceOK() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("X-App-Instance", Platform.getInstance().getOrigin());\n        EventEnvelope response = httpPost("http://127.0.0.1:"+port, "/suspend", headers, new HashMap<>());\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(200, result.get("status"));\n        Assert.assertEquals("ok", result.get("type"));\n        Assert.assertEquals("/suspend", result.get("path"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void resumeAppInstanceOK() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("X-App-Instance", Platform.getInstance().getOrigin());\n        EventEnvelope response = httpPost("http://127.0.0.1:"+port, "/resume", headers, new HashMap<>());\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(200, result.get("status"));\n        Assert.assertEquals("ok", result.get("type"));\n        Assert.assertEquals("/resume", result.get("path"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void getPoJoFromSpringRest() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/pojo?name=test", headers);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(101, result.get("number"));\n        Assert.assertEquals("test", result.get("name"));\n    }\n\n    @Test\n    public void getPoJoFromSpringRestHtml() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "text/html");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/hello/html", headers);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof String);\n        Assert.assertEquals("<html><body><div>hello</div></body></html>", response.getBody());\n    }\n\n    @Test\n    public void getListFromSpringRest() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/xml");\n        headers.put("x-raw-xml", "true");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/hello/list", headers);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof String);\n        String text = (String) response.getBody();\n        Assert.assertTrue(text.startsWith("<?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?>"));\n        Assert.assertTrue(text.contains("<item>three</item>"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void springRestExceptionHandling() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/pojo?name=exception", headers);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(400, response.getStatus());\n        Assert.assertEquals(400, result.get("status"));\n        Assert.assertEquals("IllegalArgumentException", result.get("message"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void springRestNullHandling() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/pojo?name=null", headers);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(500, response.getStatus());\n        Assert.assertEquals(500, result.get("status"));\n        Assert.assertEquals("Null pointer exception", result.get("message"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void springRestIOExceptionHandling() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/pojo?name=io_exception", headers);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(500, response.getStatus());\n        Assert.assertEquals(500, result.get("status"));\n        Assert.assertEquals("IOException", result.get("message"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void springRestAppExceptionHandling() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/pojo?name=app_exception", headers);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(401, response.getStatus());\n        Assert.assertEquals(401, result.get("status"));\n        Assert.assertEquals("AppException", result.get("message"));\n    }\n\n    @Test\n    public void springRestAppExceptionHandlingHtml() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "text/html");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/pojo?name=app_exception", headers);\n        assert response != null;\n        Assert.assertEquals(401, response.getStatus());\n        Assert.assertTrue(response.getBody() instanceof String);\n        String result = (String) response.getBody();\n        Assert.assertTrue(result.startsWith("<!DOCTYPE html>"));\n        Assert.assertTrue(result.contains("HTTP-401"));\n    }\n\n    @Test\n    public void springRestAppExceptionHandlingXml() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/xml");\n        headers.put("x-raw-xml", "true");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/pojo?name=app_exception", headers);\n        assert response != null;\n        Assert.assertEquals(401, response.getStatus());\n        Assert.assertTrue(response.getBody() instanceof String);\n        String result = (String) response.getBody();\n        Assert.assertTrue(result.startsWith("<?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?>"));\n        Assert.assertTrue(result.contains("<status>401</status>"));\n    }\n\n    @Test\n    public void getTextResponseFromServlet() throws IOException, InterruptedException {\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/mock_servlet", null);\n        assert response != null;\n        Assert.assertEquals(200, response.getStatus());\n        Assert.assertNotNull(response.getHeader("content-type"));\n        String contentType = response.getHeader("content-type");\n        Assert.assertTrue(contentType.startsWith("text/plain"));\n        Assert.assertTrue(response.getBody() instanceof String);\n        Assert.assertEquals("hello world from servlet", response.getBody());\n    }\n\n    @Test\n    public void getIndexPage() throws IOException, InterruptedException {\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/", null);\n        assert response != null;\n        Assert.assertEquals(200, response.getStatus());\n        Assert.assertNotNull(response.getHeader("content-type"));\n        String contentType = response.getHeader("content-type");\n        Assert.assertTrue(contentType.startsWith("text/html"));\n        Assert.assertTrue(response.getBody() instanceof String);\n        String text = (String) response.getBody();\n        Assert.assertTrue(text.startsWith("<!DOCTYPE html>"));\n        Assert.assertTrue(text.contains("Your application is running"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void pageNotExists() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/no_such_page", headers);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(404, response.getStatus());\n        Assert.assertEquals(404, result.get("status"));\n        Assert.assertEquals("Not Found", result.get("message"));\n    }\n\n    @Test\n    public void pageNotExistsXml() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/xml");\n        headers.put("x-raw-xml", "true");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/no_such_page", headers);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof String);\n        Assert.assertEquals(404, response.getStatus());\n        String result = (String) response.getBody();\n        Assert.assertTrue(result.startsWith("<?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?>"));\n        Assert.assertTrue(result.contains("<status>404</status>"));\n    }\n\n    @Test\n    public void pageNotExistsHtml() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "text/html");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/no_such_page", headers);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof String);\n        Assert.assertEquals(404, response.getStatus());\n        String result = (String) response.getBody();\n        Assert.assertTrue(result.startsWith("<!DOCTYPE html>"));\n        Assert.assertTrue(result.contains("HTTP-404"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void getHelloJson() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/hello/map", headers);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals("hello", result.get("name"));\n    }\n\n    @Test\n    public void getHelloXml() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/xml");\n        headers.put("x-raw-xml", "true");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/hello/map", headers);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof String);\n        Assert.assertEquals(200, response.getStatus());\n        String result = (String) response.getBody();\n        Assert.assertTrue(result.startsWith("<?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?>"));\n        Assert.assertTrue(result.contains("<name>hello</name>"));\n    }\n\n    @Test\n    public void getHelloHtml() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "text/html");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/hello/map", headers);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof String);\n        String result = (String) response.getBody();\n        Assert.assertTrue(result.startsWith("<html>") && result.endsWith("</html>"));\n    }\n\n    @SuppressWarnings("unchecked")\n    @Test\n    public void sendJson() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("Content-Type", "application/json");\n        headers.put("accept", "application/json");\n        Map<String, Object> body = new HashMap<>();\n        body.put("hello", "world");\n        EventEnvelope response = httpPost("http://127.0.0.1:"+port, "/hello/map", headers, body);\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        MultiLevelMap multi = new MultiLevelMap(result);\n        Assert.assertEquals("world", multi.getElement("data.hello"));\n    }\n\n    @Test\n    public void sendXml() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("Accept", "application/xml");\n        headers.put("Content-Type", "application/xml");\n        headers.put("x-raw-xml", "true");\n        Map<String, Object> body = new HashMap<>();\n        body.put("hello", "world");\n        EventEnvelope response = httpPost("http://127.0.0.1:"+port, "/hello/map", headers, xml.write(body));\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof String);\n        String text = (String) response.getBody();\n        Assert.assertTrue(text.startsWith("<?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?>"));\n        Assert.assertTrue(text.contains("<hello>world</hello>"));\n    }\n\n    @Test\n    public void sendXmlReceiveHtml() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("Accept", "text/html");\n        headers.put("Content-Type", "application/xml");\n        headers.put("x-raw-xml", "true");\n        Map<String, Object> body = new HashMap<>();\n        body.put("hello", "world");\n        EventEnvelope response = httpPost("http://127.0.0.1:"+port, "/hello/map", headers, xml.write(body));\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof String);\n        String text = (String) response.getBody();\n        Assert.assertTrue(text.startsWith("<html>") && text.endsWith("</html>"));\n    }\n\n    @Test\n    public void sendText() throws IOException, InterruptedException {\n        Map<String, String> headers = new HashMap<>();\n        headers.put("Accept", "text/plain");\n        headers.put("Content-Type", "text/plain");\n        EventEnvelope response = httpPost("http://127.0.0.1:"+port, "/hello/text", headers, "hello world");\n        assert response != null;\n        Assert.assertTrue(response.getBody() instanceof String);\n        String text = (String) response.getBody();\n        Assert.assertTrue(text.contains("\\"data\\": \\"hello world\\""));\n    }\n\n    @Test\n    public void websocketConnectionTest() throws InterruptedException {\n        final BlockingQueue<Boolean> textBench = new ArrayBlockingQueue<>(1);\n        final BlockingQueue<Boolean> bytesBench = new ArrayBlockingQueue<>(1);\n        String MESSAGE = "hello world";\n        EventEmitter po = EventEmitter.getInstance();\n        Utility util = Utility.getInstance();\n        LambdaFunction connector = (headers, input, instance) -> {\n            if ("open".equals(headers.get("type"))) {{\n                String txPath = headers.get("tx_path");\n                Assert.assertNotNull(txPath);\n                po.send(txPath, MESSAGE);\n                // also test sending bytes\n                po.send(txPath, util.getUTF(MESSAGE));\n            }']
preds_chunk= [[-2.878724  -3.6386817 -3.3847315 -3.3450983 -2.7851071 -0.2399838]]
pred_class= [5]
test_x= ['@Test" to do simple confirmation test\n     *\n     * @throws SchedulerException in case of error\n     * @throws InterruptedException in case of job creation error\n     */\n//    @Test\n    public void cronTest() throws SchedulerException, InterruptedException {\n\n        String MY_JOB = "my_job";\n\n        SchedulerFactory schedulerFactory = new StdSchedulerFactory();\n        Scheduler scheduler = schedulerFactory.getScheduler();\n\n        JobDetail job  =  JobBuilder.newJob(SimpleJob.class).storeDurably(true)\n                                    .usingJobData(JOB_ID, MY_JOB)\n                                    .withIdentity(MY_JOB, GLOBAL_GROUP).build();\n        scheduler.addJob(job, true);\n\n        CronTrigger trigger = TriggerBuilder.newTrigger()\n                .withSchedule(CronScheduleBuilder.cronSchedule("0 0/1 * 1/1 * ? *"))\n                .forJob(MY_JOB, GLOBAL_GROUP)\n                .build();\n\n        scheduler.scheduleJob(trigger);\n        scheduler.start();\n\n        for (int i=1; i < 240; i++) {{\n            System.out.println("waiting..."+i);\n            Thread.sleep(10000);\n        }']
preds_chunk= [[-0.11692797 -3.210981   -3.9199839  -4.466029   -3.8193643  -4.088897  ]]
pred_class= [0]
test_x= ['@Test\n    public void rpcTest() throws IOException, InterruptedException {\n        Utility util = Utility.getInstance();\n        BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        String NAME = "hello";\n        String ADDRESS = "world";\n        String TELEPHONE = "123-456-7890";\n        DemoPoJo pojo = new DemoPoJo(NAME, ADDRESS, TELEPHONE);\n        PostOffice po = new PostOffice("unit.test", "12345", "POST /api/hello/world");\n        EventEnvelope request = new EventEnvelope().setTo("hello.world").setBody(pojo.toMap());\n        po.asyncRequest(request, 800).onSuccess(bench::offer);\n        EventEnvelope response = bench.poll(10, TimeUnit.SECONDS);\n        assert response != null;\n        Assert.assertEquals(HashMap.class, response.getBody().getClass());\n        MultiLevelMap map = new MultiLevelMap((Map<String, Object>) response.getBody());\n        Assert.assertEquals(NAME, map.getElement("body.name"));\n        Assert.assertEquals(ADDRESS, map.getElement("body.address"));\n        Assert.assertEquals(TELEPHONE, map.getElement("body.telephone"));\n        Assert.assertEquals(util.date2str(pojo.time), map.getElement("body.time"));\n    }\n\n    private class DemoPoJo {\n        String name;\n        String address;\n        String telephone;\n        Date time;\n\n        private DemoPoJo(String name, String address, String telephone) {{\n            this.name = name;\n            this.address = address;\n            this.telephone = telephone;\n            this.time = new Date();\n        }']
preds_chunk= [[-0.10555152 -3.7597258  -3.6326451  -4.3966303  -3.8170266  -4.127462  ]]
pred_class= [0]
test_x= ['@Test\n    public void uploadTest() throws IOException, InterruptedException {\n        String FILENAME = "unit-test-data.txt";\n        BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        Utility util = Utility.getInstance();\n        String traceId = Utility.getInstance().getUuid();\n        PostOffice po = new PostOffice("unit.test", traceId, "/stream/upload/test");\n        int len = 0;\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        ObjectStreamIO stream = new ObjectStreamIO();\n        ObjectStreamWriter out = new ObjectStreamWriter(stream.getOutputStreamId());\n        for (int i=0; i < 10; i++) {{\n            String line = "hello world "+i+"\\n";\n            byte[] d = util.getUTF(line);\n            out.write(d);\n            bytes.write(d);\n            len += d.length;\n        }']
preds_chunk= [[-1.5512488  -0.62766445 -2.857161   -3.1096163  -3.283218   -2.1661096 ]]
pred_class= [1]
test_x= ['@Test\n    public void filterName() {{\n        String valid = "hello.world";\n        String invalid = "hello.wor?ld";\n        String dotted = "..."+invalid;\n        String filtered1 = util.filteredServiceName(invalid);\n        Assert.assertEquals(valid, filtered1);\n        String filtered2 = util.filteredServiceName(dotted);\n        Assert.assertEquals(valid, filtered2);\n    }']
preds_chunk= [[-3.3969214  -3.6267881  -3.6301963  -0.15846148 -3.642978   -3.3878505 ]]
pred_class= [3]
test_x= ['@Test\n    public void validName() {{\n        String windowsMetafile = "thumbs.db";\n        String windowsExt = "hello.com";\n        String valid = "com.hello";\n        Assert.assertTrue(util.reservedFilename(windowsMetafile));\n        Assert.assertTrue(util.reservedExtension(windowsExt));\n        Assert.assertFalse(util.reservedExtension(valid));\n\n    }']
preds_chunk= [[-3.0509224  -3.581469   -2.9250798  -2.9689984  -0.26451886 -2.9515305 ]]
pred_class= [4]
test_x= ['@Test\n    public void aesEncryptionTest() throws IOException, GeneralSecurityException {\n        String input = "hello world";\n        byte[] key = crypto.generateAesKey(strongCrypto? 256 : 128);\n        byte[] encrypted = crypto.aesEncrypt(input.getBytes(), key);\n        byte[] decrypted = crypto.aesDecrypt(encrypted, key);\n        Assert.assertEquals(input, new String(decrypted));\n    }\n\n    @Test\n    public void rsaEncryptionTest() throws GeneralSecurityException {\n        // RSA encryption is usually used to transport symmetric encryption key\n        byte[] input = crypto.generateAesKey(256);\n        KeyPair kp = crypto.generateRsaKey();\n        byte[] pub = kp.getPublic().getEncoded();\n        byte[] pri = kp.getPrivate().getEncoded();\n        // encrypt\n        byte[] encrypted = crypto.rsaEncrypt(input, pub);\n        // decrypt\n        byte[] decrypted = crypto.rsaDecrypt(encrypted, pri);\n        // cannot use Assert.assertEquals because we are comparing byte-by-byte\n        Assert.assertTrue(Arrays.equals(input, decrypted));\n    }\n\n    @Test\n    public void dsaSignatureTest() throws GeneralSecurityException {\n        KeyPair kp = crypto.generateDsaKey();\n        byte[] pub = kp.getPublic().getEncoded();\n        byte[] pri = kp.getPrivate().getEncoded();\n        byte[] data = "hello world".getBytes();\n        byte[] signature = crypto.dsaSign(data, pri);\n        boolean result = crypto.dsaVerify(data, signature, pub);\n        Assert.assertTrue(result);\n    }\n\n    @Test\n    public void rsaSignatureTest() throws GeneralSecurityException {\n        KeyPair kp = crypto.generateRsaKey();\n        byte[] pub = kp.getPublic().getEncoded();\n        byte[] pri = kp.getPrivate().getEncoded();\n        byte[] data = "hello world".getBytes();\n        byte[] signature = crypto.rsaSign(data, pri);\n        boolean result = crypto.rsaVerify(data, signature, pub);\n        Assert.assertTrue(result);\n    }\n\n    @Test\n    public void hashTest() {{\n        String input = "hello world";\n        byte[] hashed = crypto.getSHA256(input.getBytes());\n        Assert.assertEquals(32, hashed.length);\n        hashed = crypto.getSHA1(input.getBytes());\n        Assert.assertEquals(20, hashed.length);\n        hashed = crypto.getMd5(input.getBytes());\n        Assert.assertEquals(16, hashed.length);\n    }']
preds_chunk= [[-0.11458205 -3.66187    -3.7407517  -4.343166   -3.618891   -3.961586  ]]
pred_class= [0]
test_x= ['@Test\n    public void hmac1Test() {{\n        String expected = "8a3a84bcd0d0065e97f175d370447c7d02e00973";\n        byte[] key = "hello".getBytes();\n        byte[] message = "world".getBytes();\n        byte[] b = crypto.getHmacSha1(key, message);\n        Assert.assertEquals(expected, Utility.getInstance().bytes2hex(b));\n    }']
preds_chunk= [[-3.3448014  -3.5674984  -3.549143   -0.17273447 -3.4783602  -3.3371475 ]]
pred_class= [3]
test_x= ['@Test\n    public void hmac256Test() {{\n        String expected = "f1ac9702eb5faf23ca291a4dc46deddeee2a78ccdaf0a412bed7714cfffb1cc4";\n        byte[] key = "hello".getBytes();\n        byte[] message = "world".getBytes();\n        byte[] b = crypto.getHmacSha256(key, message);\n        Assert.assertEquals(expected, Utility.getInstance().bytes2hex(b));\n    }']
preds_chunk= [[-3.3946412  -3.612005   -3.5982726  -0.16128871 -3.6144063  -3.3784711 ]]
pred_class= [3]
test_x= ['@Test\n    public void base64() {{\n        String input = "hello world";\n        String base64 = util.bytesToBase64(input.getBytes());\n        byte[] b = util.base64ToBytes(base64);\n        Assert.assertEquals(input, new String(b));\n    }']
preds_chunk= [[-3.3499641 -3.566905  -3.597633  -0.1726757 -3.4603126 -3.3117487]]
pred_class= [3]
test_x= ['@Test\n    public void filterName() {{\n        String valid = "hello.world";\n        String invalid = "hello.wor?ld";\n        String dotted = "..."+invalid;\n        String filtered1 = util.filteredServiceName(invalid);\n        Assert.assertEquals(valid, filtered1);\n        String filtered2 = util.filteredServiceName(dotted);\n        Assert.assertEquals(valid, filtered2);\n    }']
preds_chunk= [[-3.3969214  -3.6267881  -3.6301963  -0.15846148 -3.642978   -3.3878505 ]]
pred_class= [3]
test_x= ['@Test\n    public void validName() {{\n        String windowsMetafile = "thumbs.db";\n        String windowsExt = "hello.com";\n        String valid = "com.hello";\n        Assert.assertTrue(util.reservedFilename(windowsMetafile));\n        Assert.assertTrue(util.reservedExtension(windowsExt));\n        Assert.assertFalse(util.reservedExtension(valid));\n    }']
preds_chunk= [[-3.0897315  -3.645718   -3.0005488  -3.0823495  -0.23678151 -3.1325078 ]]
pred_class= [4]
test_x= ['@Test\n    public void filterName() {{\n        String valid = "hello.world";\n        String invalid = "hello.wor?ld";\n        String dotted = "..."+invalid;\n        String filtered1 = util.filteredServiceName(invalid);\n        Assert.assertEquals(valid, filtered1);\n        String filtered2 = util.filteredServiceName(dotted);\n        Assert.assertEquals(valid, filtered2);\n    }']
preds_chunk= [[-3.3969214  -3.6267881  -3.6301963  -0.15846148 -3.642978   -3.3878505 ]]
pred_class= [3]
test_x= ['@Test\n    public void validName() {{\n        String windowsMetafile = "thumbs.db";\n        String windowsExt = "hello.com";\n        String valid = "com.hello";\n        Assert.assertTrue(util.reservedFilename(windowsMetafile));\n        Assert.assertTrue(util.reservedExtension(windowsExt));\n        Assert.assertFalse(util.reservedExtension(valid));\n    }']
preds_chunk= [[-3.0897315  -3.645718   -3.0005488  -3.0823495  -0.23678151 -3.1325078 ]]
pred_class= [4]
test_x= ['@Test\n    public void filterName() {{\n        String valid = "hello.world";\n        String invalid = "hello.wor?ld";\n        String dotted = "..."+invalid;\n        String filtered1 = util.filteredServiceName(invalid);\n        Assert.assertEquals(valid, filtered1);\n        String filtered2 = util.filteredServiceName(dotted);\n        Assert.assertEquals(valid, filtered2);\n    }']
preds_chunk= [[-3.3969214  -3.6267881  -3.6301963  -0.15846148 -3.642978   -3.3878505 ]]
pred_class= [3]
test_x= ['@Test\n    public void validName() {{\n        String windowsMetafile = "thumbs.db";\n        String windowsExt = "hello.com";\n        String valid = "com.hello";\n        Assert.assertTrue(util.reservedFilename(windowsMetafile));\n        Assert.assertTrue(util.reservedExtension(windowsExt));\n        Assert.assertFalse(util.reservedExtension(valid));\n    }']
preds_chunk= [[-3.0897315  -3.645718   -3.0005488  -3.0823495  -0.23678151 -3.1325078 ]]
pred_class= [4]
test_x= ['@Test\n    public void filterName() {{\n        String valid = "hello.world";\n        String invalid = "hello.wor?ld";\n        String dotted = "..."+invalid;\n        String filtered1 = util.filteredServiceName(invalid);\n        Assert.assertEquals(valid, filtered1);\n        String filtered2 = util.filteredServiceName(dotted);\n        Assert.assertEquals(valid, filtered2);\n    }']
preds_chunk= [[-3.3969214  -3.6267881  -3.6301963  -0.15846148 -3.642978   -3.3878505 ]]
pred_class= [3]
test_x= ['@Test\n    public void validName() {{\n        String windowsMetafile = "thumbs.db";\n        String windowsExt = "hello.com";\n        String valid = "com.hello";\n        Assert.assertTrue(util.reservedFilename(windowsMetafile));\n        Assert.assertTrue(util.reservedExtension(windowsExt));\n        Assert.assertFalse(util.reservedExtension(valid));\n    }']
preds_chunk= [[-3.0897315  -3.645718   -3.0005488  -3.0823495  -0.23678151 -3.1325078 ]]
pred_class= [4]
test_x= ['@Test\n    public void connectivityTest() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        EventEmitter po = EventEmitter.getInstance();\n        int n = 0;\n        while (!PresenceHandler.isReady() || MonitorService.getConnections().isEmpty() && ++n < 20) {{\n            log.info("Waiting for member connection... {}", n);\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                // ok to ignore\n            }\n        }']
preds_chunk= [[-2.6052284 -0.2264921 -3.2269826 -3.600692  -3.8255227 -3.2188952]]
pred_class= [1]
test_x= ['@Test\n    public void connectivityTest() throws IOException, InterruptedException {\n        final BlockingQueue<EventEnvelope> bench = new ArrayBlockingQueue<>(1);\n        String origin = "unit-test";\n        Platform platform = Platform.getInstance();\n        platform.waitForProvider("cloud.connector.health", 10);\n        EventEmitter po = EventEmitter.getInstance();\n        String URL = "https://127.0.0.1";\n        String SERVICE_NAME = "CloudConnector";\n        ConnectorConfig.setDisplayUrl(URL);\n        ConnectorConfig.setServiceName(SERVICE_NAME);\n        String url = ConnectorConfig.getDisplayUrl();\n        String name = ConnectorConfig.getServiceName();\n        Map<String, String> topicSubstitution = ConnectorConfig.getTopicSubstitution();\n        Assert.assertEquals(URL, url);\n        Assert.assertEquals(SERVICE_NAME, name);\n        Assert.assertEquals("user.topic.one", topicSubstitution.get("multiplex.0001.0"));\n        EventEnvelope req = new EventEnvelope().setTo(ServiceDiscovery.SERVICE_REGISTRY)\n                                    .setHeader("type", "join").setHeader("origin", origin)\n                                    .setHeader("topic", "multiplex.0001-001");\n        po.asyncRequest(req, 5000).onSuccess(bench::offer);\n        bench.poll(10, TimeUnit.SECONDS);\n        req = new EventEnvelope().setTo(ServiceDiscovery.SERVICE_REGISTRY)\n                .setHeader("type", "join").setHeader("origin", platform.getOrigin())\n                .setHeader("topic", "multiplex.0001-000");\n        po.asyncRequest(req, 5000).onSuccess(bench::offer);\n        bench.poll(10, TimeUnit.SECONDS);\n        req.setHeader("type", "add").setHeader("topic", "multiplex.0001-001");\n        req = new EventEnvelope().setTo(ServiceDiscovery.SERVICE_REGISTRY)\n                    .setHeader("type", "add").setHeader("origin", origin).setHeader("route", "hello.world")\n                    .setHeader("personality", "WEB");\n        po.asyncRequest(req, 5000).onSuccess(bench::offer);\n        bench.poll(10, TimeUnit.SECONDS);\n        Map<String, Object> routes = new HashMap<>();\n        routes.put("hello.test", "WEB");\n        routes.put("hello.demo", "WEB");\n        routes.put("to.be.removed", "WEB");\n        req = new EventEnvelope().setTo(ServiceDiscovery.SERVICE_REGISTRY).setBody(routes)\n                    .setHeader("type", "add").setHeader("origin", origin)\n                    .setHeader("personality", "WEB");\n        po.asyncRequest(req, 5000).onSuccess(bench::offer);\n        bench.poll(10, TimeUnit.SECONDS);\n        po.broadcast("hello.world", "something");\n        po.send("hello.demo@"+origin, "something else");\n        req = new EventEnvelope().setTo(ServiceDiscovery.SERVICE_REGISTRY).setBody(routes)\n                .setHeader("type", "unregister").setHeader("origin", origin)\n                .setHeader("route", "to.be.removed");\n        po.asyncRequest(req, 5000).onSuccess(bench::offer);\n        bench.poll(10, TimeUnit.SECONDS);\n        req = new EventEnvelope().setTo(ServiceDiscovery.SERVICE_QUERY)\n                .setHeader("type", "search")\n                .setHeader("origin", origin).setHeader("route", "hello.world");\n        po.asyncRequest(req, 5000).onSuccess(bench::offer);\n        EventEnvelope queryResult = bench.poll(10, TimeUnit.SECONDS);\n        assert queryResult != null;\n        Assert.assertTrue(queryResult.getBody() instanceof List);\n        List<String> list = (List<String>) queryResult.getBody();\n        Assert.assertFalse(list.isEmpty());\n        List<String> instances = (List<String>) queryResult.getBody();\n        Assert.assertTrue(instances.contains("unit-test"));\n        Assert.assertTrue(instances.contains(platform.getOrigin()));\n        Map<String, String> headers = new HashMap<>();\n        headers.put("accept", "application/json");\n        EventEnvelope response = httpGet("http://127.0.0.1:"+port, "/info/routes", headers);\n        Map<String, Object> info = (Map<String, Object>) response.getBody();\n        MultiLevelMap multi = new MultiLevelMap(info);\n        Object nodes = multi.getElement("routing.nodes");\n        Assert.assertTrue(nodes instanceof List);\n        String nodeList = nodes.toString();\n        Assert.assertTrue(nodeList.contains("unit-test"));\n        Assert.assertTrue(po.exists("hello.demo"));\n        req = new EventEnvelope().setTo(ServiceDiscovery.SERVICE_QUERY)\n                .setBody(Collections.singletonList("hello.world")).setHeader("type", "find")\n                .setHeader("route", "*");\n        po.asyncRequest(req, 5000).onSuccess(bench::offer);\n        queryResult = bench.poll(10, TimeUnit.SECONDS);\n        assert queryResult != null;\n        Assert.assertEquals(true, queryResult.getBody());\n        headers.put("X-App-Instance", Platform.getInstance().getOrigin());\n        response = httpPost("http://127.0.0.1:"+port, "/suspend/now", headers, new HashMap<>());\n        Assert.assertTrue(response.getBody() instanceof Map);\n        Map<String, Object> result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(200, result.get("status"));\n        Assert.assertEquals("suspend", result.get("type"));\n        Assert.assertEquals("/suspend/now", result.get("path"));\n        response = httpPost("http://127.0.0.1:"+port, "/resume/now", headers, new HashMap<>());\n        Assert.assertTrue(response.getBody() instanceof Map);\n        result = (Map<String, Object>) response.getBody();\n        Assert.assertEquals(200, result.get("status"));\n        Assert.assertEquals("resume", result.get("type"));\n        Assert.assertEquals("/resume/now", result.get("path"));\n        po.send(ServiceDiscovery.SERVICE_REGISTRY, new Kv("type", "leave"), new Kv("origin", origin));\n    }\n\n    @Test\n    public void checkTopicNameWithoutDot() throws IOException {\n        String name = "hello.world";\n        ConnectorConfig.validateTopicName(name);\n        String invalid = "helloworld";\n        IOException ex = Assert.assertThrows(IOException.class, () -> ConnectorConfig.validateTopicName(invalid));\n        Assert.assertEquals("Invalid route helloworld because it is missing dot separator(s). e.g. hello.world",\n                ex.getMessage());\n    }\n\n    @Test\n    public void checkEmptyTopic() {{\n        IOException ex = Assert.assertThrows(IOException.class, () -> ConnectorConfig.validateTopicName(""));\n        Assert.assertEquals("Invalid route name - use 0-9, a-z, A-Z, period, hyphen or underscore characters",\n                ex.getMessage());\n    }']
preds_chunk= [[-0.10235735 -3.5277843  -3.932679   -4.497495   -3.8775918  -4.1047254 ]]
pred_class= [0]
test_x= ['@Test\n    public void reservedExtension() {{\n        IOException ex = Assert.assertThrows(IOException.class, () ->\n                ConnectorConfig.validateTopicName("hello.com"));\n        Assert.assertEquals("Invalid route hello.com which is a reserved extension",\n                ex.getMessage());\n    }']
preds_chunk= [[-3.688971   -4.16897    -3.9521227  -4.074308   -0.10455246 -3.7903066 ]]
pred_class= [4]
test_x= ['@Test\n    public void reservedName() {{\n        IOException ex = Assert.assertThrows(IOException.class, () ->\n                ConnectorConfig.validateTopicName("Thumbs.db"));\n        Assert.assertEquals("Invalid route Thumbs.db which is a reserved Windows filename",\n                ex.getMessage());\n    }']
preds_chunk= [[-3.684387   -4.1825533  -3.9665852  -4.0951123  -0.10361281 -3.79594   ]]
pred_class= [4]
SHANTO preds= [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
***************=========********
